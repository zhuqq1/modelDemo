"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Glodon = window.Glodon || {};
Glodon.Version = new Date().toLocaleDateString();

var CLOUD = window.CLOUD || {};

(function () {
    function ensureNamespace(namespace, namespaceString) {

        var subNamespaces = namespaceString.split(".");
        var parent = namespace;
        var subNamespaceLength = subNamespaces.length;

        for (var i = 0; i < subNamespaceLength; i++) {
            // create missed namespace
            if (typeof parent[subNamespaces[i]] === "undefined") {
                parent[subNamespaces[i]] = {};
            }

            parent = parent[subNamespaces[i]];
        }

        return parent;
    }

    // namespace
    var NamespaceNS = ensureNamespace(Glodon, "Web.Lang.Utility.Namespace");
    NamespaceNS.ensureNamespace = ensureNamespace;
})();

(function () {
    var CommonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Common");

    var Error = function Error(data) {
        if (typeof data === "string") {
            data = JSON.parse(res);
        }
        this.code = data.code;
        this.message = data.message;
    };

    Error.prototype = {

        getErrorCode: function getErrorCode() {
            return this.code;
        },

        getErrorMessage: function getErrorMessage() {
            return this.message;
        }
    };

    CommonNS.Error = Error;
})();

(function () {

    function createObject(obj) {
        function LocalType() {}

        LocalType.prototype = obj;
        return new LocalType();
    }

    function inheritPrototype(subType, superType) {
        var prototype = createObject(superType.prototype);
        prototype.constructor = subType;
        subType.prototype = prototype;
    }

    var TypeNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Type");
    TypeNS.inheritPrototype = inheritPrototype;
})();

(function () {
    var HttpRequestNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.HttpRequest");
    // ajax
    var ajax = function ajax(options) {
        var defaults = {
            type: 'get',
            cache: true,
            headers: {
                'Content-type': 'application/x-www-form-urlencoded'
            },
            data: null,
            async: true,
            success: null,
            failure: null
        };
        var _opt = Object.assign(defaults, options);
        var xmlhttp;
        //创建xmlhttp对象
        if (window.XMLHttpRequest) {
            xmlhttp = new XMLHttpRequest();
        } else {
            xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
        }
        xmlhttp.onreadystatechange = function () {
            if (xmlhttp.readyState == 4) {
                var status = xmlhttp.status;
                if (status >= 200 && status < 300) {
                    _opt.success && _opt.success(xmlhttp.responseText, xmlhttp.responseXML);
                } else {
                    _opt.failure && _opt.failure(status);
                }
            }
        };
        xmlhttp.open(_opt.type, _opt.url, _opt.async);
        for (var key in _opt.headers) {
            xmlhttp.setRequestHeader(key, _opt.headers[key]);
        }
        xmlhttp.send(_opt.data);
    };
    // get script
    var getScript = function getScript(url, callback) {
        var isCache = {};
        if (!isCache[url]) {
            var script = document.createElement("script");
            script.type = "text/javascript";
            script.src = url;
            document.head.appendChild(script);
            isCache[url] = true;
            if (script.readyState) {
                //IE
                script.onreadystatechange = function () {
                    if (script.readyState == "loaded" || script.readyState == "complete") {
                        script.onreadystatechange = null;
                        callback && callback();
                    }
                };
            } else {
                //Others: Firefox, Safari, Chrome, and Opera
                script.onload = function () {
                    callback && callback();
                };
            }
        } else {
            callback && callback();
        }
    };
    HttpRequestNS.ajax = ajax;
    HttpRequestNS.getScript = getScript;
})();

(function () {
    var FullScreenNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.FullScreen");

    var fullScreen = function fullScreen(element) {
        if (!element) return false;
        if (element.requestFullscreen) {
            element.requestFullscreen();
        } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        } else if (element.webkitRequestFullScreen) {
            element.webkitRequestFullScreen();
        } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
        }
    };

    var exitFullScreen = function exitFullScreen() {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.webkitCancelFullScreen) {
            document.webkitCancelFullScreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    };

    var onFullScreenChanged = function onFullScreenChanged(callback) {
        var fullScreenChanged = function fullScreenChanged() {
            callback && callback();
        };
        document.documentElement.onwebkitfullscreenchange = fullScreenChanged;
        document.onmozfullscreenchange = fullScreenChanged;
        document.onmsfullscreenchange = fullScreenChanged;
    };
    FullScreenNS.fullScreen = fullScreen;
    FullScreenNS.exitFullScreen = exitFullScreen;
    FullScreenNS.onFullScreenChanged = onFullScreenChanged;
})();

(function () {
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");

    var create = function create(nodeType, className) {
        var temp = document.createElement(nodeType);
        temp.setAttribute('class', className);
        return temp;
    };

    DomNS.create = create;
})();

(function () {
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");

    var createNS = function createNS(nodeType, className) {
        var temp = document.createElementNS("http://www.w3.org/2000/svg", nodeType);
        temp.setAttribute('class', className);
        return temp;
    };

    DomNS.createNS = createNS;
})();

(function () {
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");

    var select = function select(nodeType) {
        if (nodeType.indexof("#")) {
            return document.getElementById(nodeType.replace("#", ""));
        } else if (nodeType.indexof(".")) {
            return document.getElementsByClassName(nodeType.replace(".", ""));
        } else {
            return document.getElementsByTagName(nodeType);
        }
    };

    DomNS.select = select;
})();

(function () {
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");

    var drag = function drag(options) {
        var defaults = {
            element: null,
            handle: null,
            axis: 'all',
            cursor: 'move',
            distance: 0,
            start: null,
            move: null,
            stop: null
        };
        var _opt = Object.assign(defaults, options);
        var element = _opt.element;
        if (!element) return false;
        var handle = _opt.handle || element,
            startPosition = void 0,
            enableMove = false;
        var getMoveState = function getMoveState(distance) {
            if (Math.pow(distance.x, 2) + Math.pow(distance.y, 2) > Math.pow(_opt.distance, 2)) {
                _opt.start && _opt.start(startPosition);
                return true;
            } else {
                return false;
            }
        };
        var enableDrag = function enableDrag(btn) {
            // 左键拖动，右键不能拖动
            var userAgent = navigator.userAgent;
            var isIE = userAgent.indexOf("compatible") > -1 && userAgent.indexOf("MSIE") > -1 && !isOpera;
            if (isIE) {
                if (btn == 1) {
                    return true;
                } else {
                    return false;
                }
            } else {
                if (btn == 0) {
                    return true;
                } else {
                    return false;
                }
            }
        };

        var setPosition = function setPosition(ev) {
            // 设置拖动后的位置
            var left = element.offsetLeft;
            var top = element.offsetTop;
            var x = left + ev.x < 0 ? 0 : left + ev.x;
            var y = top + ev.y < 0 ? 0 : top + ev.y;
            switch (_opt.axis) {
                case 'x':
                    element.style.left = x + "px";
                    break;
                case 'y':
                    element.style.top = y + "px";
                    break;
                case 'all':
                default:
                    element.style.left = x + "px";
                    element.style.top = y + "px";
                    break;
            }
        };
        var start = function start(event) {
            var ev = event;

            if (!enableDrag(ev.button)) return;
            startPosition = {
                x: ev.clientX,
                y: ev.clientY
            };
            _opt.start && _opt.start(startPosition);
            document.addEventListener('mousemove', move);
            document.addEventListener('touchmove', move);
        };

        var move = function move(event) {
            var ev = event;
            var endPosition = {
                x: ev.clientX,
                y: ev.clientY
            };
            var distance = {
                x: endPosition.x - startPosition.x,
                y: endPosition.y - startPosition.y
            };
            if (enableMove) {
                _opt.move && _opt.move(startPosition, endPosition, distance);
                startPosition = endPosition;
                setPosition(distance);
            } else {
                enableMove = getMoveState(distance);
            }
        };

        var end = function end() {
            enableMove && _opt.end && _opt.end(startPosition);
            enableMove = false;
            document.removeEventListener('mousemove', move);
            document.removeEventListener('touchmove', move);
        };

        handle.style.cursor = _opt.cursor;
        handle.style.userSelect = 'none';
        handle.addEventListener('mousedown', start);
        handle.addEventListener('touchstart', start);

        document.addEventListener('mouseup', end);
        document.addEventListener('touchend ', end);
    };

    DomNS.drag = drag;
})();

(function () {
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");

    var sizable = function sizable(options) {
        var defaults = {
            element: null,
            axis: 'all',
            minWidth: 100,
            minHeight: 100,
            distance: 0,
            start: null,
            sizable: null,
            stop: null
        };
        var _opt = Object.assign(defaults, options);
        var element = _opt.element;
        if (!element) return false;
        var startPosition = void 0,
            enableResize = false,
            handle = DomNS.create('div', 'bf-resize');
        var getResizeState = function getResizeState(distance) {
            if (Math.pow(distance.x, 2) + Math.pow(distance.y, 2) > Math.pow(_opt.distance, 2)) {
                _opt.start && _opt.start(startPosition);
                return true;
            } else {
                return false;
            }
        };
        var enableDrag = function enableDrag(btn) {
            // 左键拖动，右键不能拖动
            var userAgent = navigator.userAgent;
            var isIE = userAgent.indexOf("compatible") > -1 && userAgent.indexOf("MSIE") > -1 && !isOpera;
            if (isIE) {
                if (btn == 1) {
                    return true;
                } else {
                    return false;
                }
            } else {
                if (btn == 0) {
                    return true;
                } else {
                    return false;
                }
            }
        };

        var setState = function setState(ev) {
            // 设置拖动后的位置
            var _left = element.offsetLeft;
            var _top = element.offsetTop;
            var _width = element.clientWidth;
            var _height = element.clientHeight;
            var width = _width + ev.x < _opt.minWidth ? _opt.minWidth : _width + ev.x;
            var height = _height + ev.y < _opt.minHeight ? _opt.minHeight : _height + ev.y;
            _opt.resize && _opt.resize(width, height);
            element.style.left = _left + "px";
            element.style.top = _top + "px";
            switch (_opt.axis) {
                case 'x':
                    element.style.width = width + "px";
                    break;
                case 'y':
                    element.style.height = height + "px";
                    break;
                case 'all':
                default:
                    element.style.width = width + "px";
                    element.style.height = height + "px";
                    break;
            }
        };
        var start = function start(event) {
            var ev = event;
            if (!enableDrag(ev.button)) return;
            startPosition = {
                x: ev.clientX,
                y: ev.clientY
            };
            document.addEventListener('mousemove', resize);
            document.addEventListener('touchmove', resize);
        };
        var resize = function resize(event) {
            var ev = event;
            var endPosition = {
                x: ev.clientX,
                y: ev.clientY
            };
            var distance = {
                x: endPosition.x - startPosition.x,
                y: endPosition.y - startPosition.y
            };
            if (enableResize) {
                _opt.sizable && _opt.sizable(startPosition, endPosition, distance);
                startPosition = endPosition;
                setState(distance);
            } else {
                enableResize = getResizeState(distance);
            }
        };
        var end = function end() {
            enableResize && _opt.end && _opt.end(startPosition);
            enableResize = false;
            document.removeEventListener('mousemove', resize);
            document.removeEventListener('touchmove', resize);
        };
        element.addClass('bf-sizable');
        element.appendChild(handle);

        handle.addEventListener('mousedown', start);
        handle.addEventListener('touchstart', start);

        document.addEventListener('mouseup', end);
        document.addEventListener('touchend', end);
    };

    DomNS.sizable = sizable;
})();

(function () {
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");

    var range = function range(options) {
        var self = this;
        var defaults = {
            element: null,
            min: 0,
            max: 100,
            cur: 50,
            step: 1,
            input: null,
            change: null
        };
        var _opt = Object.assign(defaults, options);
        this._opt = _opt;
        var range = DomNS.create('div', 'bf-range');
        var input = DomNS.create('input', 'bf-input-range');
        self.input = input;
        input.setAttribute('type', 'range');
        input.setAttribute('step', _opt.step);
        input.setAttribute('min', _opt.min);
        input.setAttribute('max', _opt.max);
        input.setAttribute('value', _opt.cur);
        var min = DomNS.create('span', 'bf-range-min');
        min.innerText = _opt.min;
        var cur = DomNS.create('span', 'bf-range-cur');
        self.cur = cur;
        cur.innerText = _opt.cur;
        var max = DomNS.create('span', 'bf-range-max');
        max.innerText = _opt.max;
        var progress = DomNS.create('span', 'bf-range-progress');
        range.appendChild(input);
        range.appendChild(min);
        range.appendChild(cur);
        range.appendChild(max);
        range.appendChild(progress);
        _opt.element.appendChild(range);

        self.setProgress();
        input.addEventListener('input', function () {
            self.setProgress();
            _opt.input && _opt.input(this.value);
        });
        input.addEventListener('change', function () {
            self.setProgress();
            _opt.change && _opt.change(this.value);
        });
    };
    range.prototype.setProgress = function () {
        var _opt = this._opt;
        var total = _opt.max - _opt.min;
        var input = this.input;
        var value = input.value;
        var cur = this.cur;
        var progress = (value - _opt.min) / total * 100;
        input.style.background = 'linear-gradient(to right,#11dab7 0%,#11dab7 ' + progress + '%,#999 ' + progress + '%, #999 100%)';
        cur.innerText = value;
    };
    range.prototype.reset = function () {
        this.setProgress(this.input.value);
    };
    DomNS.range = range;
})();

(function () {
    var ClientHelperNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.ClientHelper");

    var getIsDesktop = function getIsDesktop() {
        var ua = navigator.userAgent,
            isWindowsPhone = /(?:Windows Phone)/.test(ua),
            isSymbian = /(?:SymbianOS)/.test(ua) || isWindowsPhone,
            isAndroid = /(?:Android)/.test(ua),
            isFireFox = /(?:Firefox)/.test(ua),
            isChrome = /(?:Chrome|CriOS)/.test(ua),
            isTablet = /(?:iPad|PlayBook)/.test(ua) || isAndroid && !/(?:Mobile)/.test(ua) || isFireFox && /(?:Tablet)/.test(ua),
            isPhone = /(?:iPhone)/.test(ua) && !isTablet,
            isPc = !isPhone && !isAndroid && !isSymbian;
        return isPc;
    };

    ClientHelperNS.getIsDesktop = getIsDesktop;
})();

(function () {
    var UUIDNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.UUID");
    var createUUID = function createUUID() {
        var s = [];
        var hexDigits = "0123456789abcdef";
        for (var i = 0; i < 36; i++) {
            s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
        }
        s[14] = "4"; // bits 12-15 of the time_hi_and_version field to 0010
        s[19] = hexDigits.substr(s[19] & 0x3 | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01
        s[8] = s[13] = s[18] = s[23] = "-";

        var uuid = s.join("");
        return uuid;
    };

    UUIDNS.createUUID = createUUID;
})();

(function () {
    var LangNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang");

    var EventManager = function EventManager() {
        this.container = {};
    };

    EventManager.prototype.addEvent = function (type, fn) {
        if (typeof type === "string" && typeof fn === "function") {
            if (typeof this.container[type] === "undefined") {
                this.container[type] = [fn];
            } else {
                this.container[type].push(fn);
            }
        }

        return this;
    };

    EventManager.prototype.fireEvent = function (type) {
        if (type && this.container[type]) {
            var args = Array.prototype.slice.call(arguments);
            args.shift();

            var length = this.container[type].length;
            for (var index = 0; index < length; index++) {
                var delegatedFunction = this.container[type][index];
                delegatedFunction.apply(null, args);
            }
        }

        return this;
    };

    EventManager.prototype.removeEvent = function (type, key) {
        if (typeof key !== "function" || typeof type !== "string") {
            return;
        }

        var listeners = this.container[type];
        if (listeners instanceof Array) {
            for (var i = 0, length = listeners.length; i < length; i += 1) {
                if (listeners[i] === key) {
                    listeners.splice(i, 1);
                    break;
                }
            }

            if (listeners.length == 0) {
                delete this.container[type];
            }
        }

        return this;
    };

    LangNS.EventManager = EventManager;
})();

(function () {
    var GeometryNSNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Geometry");

    var Point3d = function Point3d(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    };

    Point3d.prototype = {

        get: function get() {
            return {
                x: this.x,
                y: this.y,
                z: this.z
            };
        },

        set: function set(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }

    };

    GeometryNSNS.Point3d = Point3d;
})();

(function () {
    var GeometryNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Geometry");

    var BoundingBox = function BoundingBox(min, max) {
        var boundingBox = {};
        var minPoint3d = new GeometryNS.Point3d();
        var maxPoint3d = new GeometryNS.Point3d();
        minPoint3d.set(min.x, min.y, min.z);
        maxPoint3d.set(max.x, max.y, max.z);
        boundingBox.min = minPoint3d;
        boundingBox.max = maxPoint3d;
        return boundingBox;
    };

    GeometryNS.BoundingBox = BoundingBox;
})();

(function () {
    var UtilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Graphics.Utility");

    var RGBToHex = function RGBToHex(color) {
        var hex = color.toString(16);
        if (hex.length == 1) {
            hex = '0' + hex;
        }
        return hex;
    };

    UtilityNS.RGBToHex = RGBToHex;
})();

(function () {
    var RelationNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Graphics.Utility.Relation");

    var getViews = function getViews(databagId, callback) {
        Glodon.Web.Lang.Utility.HttpRequest.ajax({
            url: "https://m.bimface.com/" + databagId + "/metadata/views.json",
            success: function success(data) {
                var viewes = JSON.parse(data).viewList;
                var data = [];
                for (var viewId in viewes) {
                    var view = viewes[viewId];
                    if (view.viewType == "FloorPlan") {
                        view.preview.path = "https://m.bimface.com/" + databagId + "/" + view.preview.path;
                        data.push(view);
                    }
                }
                callback && callback(data);
            }
        });
    };

    var point2DToPoint3D = function point2DToPoint3D(point2d, viewInfo) {
        if (viewInfo.viewType != "FloorPlan") {
            console.warn("Not support yet!");
            return null;
        }

        var w = viewInfo.preview.width;
        var h = viewInfo.preview.height;

        var minX = viewInfo.outline[0];
        var maxX = viewInfo.outline[2];
        var minY = viewInfo.outline[1];
        var maxY = viewInfo.outline[3];

        var outlineWdith = maxX - minX;
        var outlineHeight = maxY - minY;

        var xRatio = (0 - minX) / outlineWdith;
        var yRation = maxY / outlineHeight;

        var x = (point2d.x - w * xRatio) / w;
        var y = (h * yRation - point2d.y) / h;

        x = x * outlineWdith * viewInfo.viewPoint.scale;
        y = y * outlineHeight * viewInfo.viewPoint.scale;

        var result = new Glodon.Web.Geometry.Point3d(x, y, viewInfo.elevation);
        return result;
    };

    var point3DToPoint2D = function point3DToPoint2D(point3d, viewInfo) {
        if (viewInfo.viewType != "FloorPlan") {
            console.warn("Not support yet!");
            return null;
        }

        var w = viewInfo.preview.width;
        var h = viewInfo.preview.height;

        var minX = viewInfo.outline[0];
        var maxX = viewInfo.outline[2];
        var minY = viewInfo.outline[1];
        var maxY = viewInfo.outline[3];

        var outlineWdith = maxX - minX;
        var outlineHeight = maxY - minY;

        var xRatio = (0 - minX) / (maxX - minX);
        var yRation = maxY / (maxY - minY);

        var x = point3d.x / (outlineWdith * viewInfo.viewPoint.scale);
        var y = point3d.y / (outlineHeight * viewInfo.viewPoint.scale);

        x = x * w + w * xRatio;
        y = h * yRation - y * h;

        return {
            x: x,
            y: y,
            z: 0
        };
    };

    RelationNS.getViews = getViews;
    RelationNS.point2DToPoint3D = point2DToPoint3D;
    RelationNS.point3DToPoint2D = point3DToPoint2D;
})();

(function () {
    var UtilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Graphics.Utility");

    var ImageContainer = function ImageContainer(src) {
        var image = new Image();
        var promise = new Promise(function (resolve, reject) {
            image.onload = function () {
                resolve(image);
            };
            image.onerror = function (error) {
                reject(error);
            };
            image.crossOrigin = "anonymous";
            image.src = src;
            if (image.complete === true) {
                resolve(image);
            }
        });
        return promise;
    };

    UtilityNS.ImageContainer = ImageContainer;
})();

(function () {
    var GraphicsNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Graphics");
    var RGBToHex = Glodon.Web.Graphics.Utility.RGBToHex;

    var Color = function Color(red, green, blue, alpha) {
        this.red = red;
        this.green = green;
        this.blue = blue;
        this.alpha = alpha;
    };

    Color.prototype = {

        getRGB: function getRGB() {
            return "rgba(" + this.red + "," + this.green + "," + this.blue + ")";
        },
        getRGBA: function getRGBA() {
            return "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")";
        },
        getHEX: function getHEX() {
            return "" + RGBToHex(this.red) + RGBToHex(this.green) + RGBToHex(this.blue);
        },
        getAlpha: function getAlpha() {
            return this.alpha;
        }
    };

    GraphicsNS.Color = Color;
})();

(function () {
    HTMLElement.prototype.getClass = function (className) {
        return this.getAttribute('class');
    };

    HTMLElement.prototype.hasClass = function (className) {
        var currentClassName = this.getClass();
        if (!currentClassName) return false;
        var arr = currentClassName && currentClassName.split(' ');
        if (arr.indexOf(className) > -1) {
            return true;
        } else {
            return false;
        }
    };

    HTMLElement.prototype.addClass = function (className) {
        var currentClassName = this.getClass();
        var arr = currentClassName && currentClassName.split(' ');
        if (!currentClassName) {
            this.setAttribute('class', "" + className);
        } else {
            if (arr.indexOf(className) == -1) {
                arr.push(className);
                currentClassName = arr.join(' ');
                this.setAttribute('class', "" + currentClassName);
            }
        }
        return this;
    };

    HTMLElement.prototype.removeClass = function (className) {
        var hasClass = this.hasClass(className);
        if (!hasClass) {
            return this;
        }
        var currentClassName = this.getClass().replace(className, '').trim();
        if (currentClassName) {
            this.setAttribute('class', "" + currentClassName);
        } else {
            this.removeAttribute('class');
        }
        return this;
    };

    HTMLElement.prototype.toggleClass = function (className, enable) {
        var currentClassName = this.getClass(),
            hasClassName = this.hasClass(className);
        if (enable != undefined) {
            if (enable && !hasClassName) {
                this.addClass(className);
            }
            if (!enable) {
                this.removeClass(className);
            }
        } else {
            if (hasClassName) {
                this.removeClass(className);
            } else {
                this.addClass(className);
            }
        }
        return !hasClassName;
    };
})();

(function () {
    Array.prototype.getObjectByAttribute = function (key, value) {
        var arr = this;
        var len = arr.length;
        var i = 0;
        for (; i < len; i++) {
            if (arr[i][key] == value) {
                return arr[i];
            }
        }
        return false;
    };
    Array.prototype.removeObjectByAttribute = function (key, value) {
        var arr = this;
        var len = arr.length;
        var i = 0;
        for (; i < len; i++) {
            if (arr[i][key] == value) {
                arr = arr.splice(i, 1);
                return arr;
            }
        }
        return false;
    };
    Array.prototype.getAllObjectByAttribute = function (key, value) {
        var arr = this;
        var len = arr.length;
        var i = 0;
        var temp = [];
        for (; i < len; i++) {
            if (arr[i][key] == value) {
                temp.push(arr[i]);
            }
        }
        return temp;
    };
    Array.prototype.removeByValue = function (value) {
        var arr = this;
        var len = arr.length;
        var i = len - 1;
        for (; i >= 0; i--) {
            if (arr[i] == value) {
                arr.splice(i, 1);
            }
        }
        return arr;
    };
    Array.prototype.insert = function (index, item) {
        this.splice(index, 0, item);
        return this;
    };
})();

(function () {
    HTMLElement.prototype.setCss = function (css) {
        if (css) {
            for (var i in css) {
                this.style[i] = css[i];
            }
        }
    };

    HTMLElement.prototype.getCss = function () {
        return this.style;
    };
})();

/**
 * core-js 2.4.1
 * https://github.com/zloirock/core-js
 * License: http://rock.mit-license.org
 * © 2016 Denis Pushkarev
 */
!function (a, b, c) {
    "use strict";
    !function (a) {
        function __webpack_require__(c) {
            if (b[c]) return b[c].exports;var d = b[c] = { exports: {}, id: c, loaded: !1 };return a[c].call(d.exports, d, d.exports, __webpack_require__), d.loaded = !0, d.exports;
        }var b = {};return __webpack_require__.m = a, __webpack_require__.c = b, __webpack_require__.p = "", __webpack_require__(0);
    }([function (a, b, c) {
        c(1), c(50), c(51), c(52), c(54), c(55), c(58), c(59), c(60), c(61), c(62), c(63), c(64), c(65), c(66), c(68), c(70), c(72), c(74), c(77), c(78), c(79), c(83), c(86), c(87), c(88), c(89), c(91), c(92), c(93), c(94), c(95), c(97), c(99), c(100), c(101), c(103), c(104), c(105), c(107), c(108), c(109), c(111), c(112), c(113), c(114), c(115), c(116), c(117), c(118), c(119), c(120), c(121), c(122), c(123), c(124), c(126), c(130), c(131), c(132), c(133), c(137), c(139), c(140), c(141), c(142), c(143), c(144), c(145), c(146), c(147), c(148), c(149), c(150), c(151), c(152), c(158), c(159), c(161), c(162), c(163), c(167), c(168), c(169), c(170), c(171), c(173), c(174), c(175), c(176), c(179), c(181), c(182), c(183), c(185), c(187), c(189), c(190), c(191), c(193), c(194), c(195), c(196), c(203), c(206), c(207), c(209), c(210), c(211), c(212), c(213), c(214), c(215), c(216), c(217), c(218), c(219), c(220), c(222), c(223), c(224), c(225), c(226), c(227), c(228), c(229), c(231), c(234), c(235), c(237), c(238), c(239), c(240), c(241), c(242), c(243), c(244), c(245), c(246), c(247), c(249), c(250), c(251), c(252), c(253), c(254), c(255), c(256), c(258), c(259), c(261), c(262), c(263), c(264), c(267), c(268), c(269), c(270), c(271), c(272), c(273), c(274), c(276), c(277), c(278), c(279), c(280), c(281), c(282), c(283), c(284), c(285), c(286), c(287), c(288), c(291), c(156), c(293), c(292), c(294), c(295), c(296), c(297), c(298), c(300), c(301), c(302), c(304), a.exports = c(305);
    }, function (a, b, d) {
        var e = d(2),
            f = d(3),
            g = d(4),
            h = d(6),
            i = d(16),
            j = d(20).KEY,
            k = d(5),
            l = d(21),
            m = d(22),
            n = d(17),
            o = d(23),
            p = d(24),
            q = d(25),
            r = d(27),
            s = d(40),
            t = d(43),
            u = d(10),
            v = d(30),
            w = d(14),
            x = d(15),
            y = d(44),
            z = d(47),
            A = d(49),
            B = d(9),
            C = d(28),
            D = A.f,
            E = B.f,
            F = z.f,
            G = e.Symbol,
            H = e.JSON,
            I = H && H.stringify,
            J = "prototype",
            K = o("_hidden"),
            L = o("toPrimitive"),
            M = {}.propertyIsEnumerable,
            N = l("symbol-registry"),
            O = l("symbols"),
            P = l("op-symbols"),
            Q = Object[J],
            R = "function" == typeof G,
            S = e.QObject,
            T = !S || !S[J] || !S[J].findChild,
            U = g && k(function () {
            return 7 != y(E({}, "a", { get: function get() {
                    return E(this, "a", { value: 7 }).a;
                } })).a;
        }) ? function (a, b, c) {
            var d = D(Q, b);d && delete Q[b], E(a, b, c), d && a !== Q && E(Q, b, d);
        } : E,
            V = function V(a) {
            var b = O[a] = y(G[J]);return b._k = a, b;
        },
            W = R && "symbol" == _typeof(G.iterator) ? function (a) {
            return "symbol" == (typeof a === "undefined" ? "undefined" : _typeof(a));
        } : function (a) {
            return a instanceof G;
        },
            X = function defineProperty(a, b, c) {
            return a === Q && X(P, b, c), u(a), b = w(b, !0), u(c), f(O, b) ? (c.enumerable ? (f(a, K) && a[K][b] && (a[K][b] = !1), c = y(c, { enumerable: x(0, !1) })) : (f(a, K) || E(a, K, x(1, {})), a[K][b] = !0), U(a, b, c)) : E(a, b, c);
        },
            Y = function defineProperties(a, b) {
            u(a);for (var c, d = s(b = v(b)), e = 0, f = d.length; f > e;) {
                X(a, c = d[e++], b[c]);
            }return a;
        },
            Z = function create(a, b) {
            return b === c ? y(a) : Y(y(a), b);
        },
            $ = function propertyIsEnumerable(a) {
            var b = M.call(this, a = w(a, !0));return !(this === Q && f(O, a) && !f(P, a)) && (!(b || !f(this, a) || !f(O, a) || f(this, K) && this[K][a]) || b);
        },
            _ = function getOwnPropertyDescriptor(a, b) {
            if (a = v(a), b = w(b, !0), a !== Q || !f(O, b) || f(P, b)) {
                var c = D(a, b);return !c || !f(O, b) || f(a, K) && a[K][b] || (c.enumerable = !0), c;
            }
        },
            aa = function getOwnPropertyNames(a) {
            for (var b, c = F(v(a)), d = [], e = 0; c.length > e;) {
                f(O, b = c[e++]) || b == K || b == j || d.push(b);
            }return d;
        },
            ba = function getOwnPropertySymbols(a) {
            for (var b, c = a === Q, d = F(c ? P : v(a)), e = [], g = 0; d.length > g;) {
                !f(O, b = d[g++]) || c && !f(Q, b) || e.push(O[b]);
            }return e;
        };R || (G = function _Symbol() {
            if (this instanceof G) throw TypeError("Symbol is not a constructor!");var a = n(arguments.length > 0 ? arguments[0] : c),
                b = function b(c) {
                this === Q && b.call(P, c), f(this, K) && f(this[K], a) && (this[K][a] = !1), U(this, a, x(1, c));
            };return g && T && U(Q, a, { configurable: !0, set: b }), V(a);
        }, i(G[J], "toString", function toString() {
            return this._k;
        }), A.f = _, B.f = X, d(48).f = z.f = aa, d(42).f = $, d(41).f = ba, g && !d(26) && i(Q, "propertyIsEnumerable", $, !0), p.f = function (a) {
            return V(o(a));
        }), h(h.G + h.W + h.F * !R, { Symbol: G });for (var ca = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), da = 0; ca.length > da;) {
            o(ca[da++]);
        }for (var ca = C(o.store), da = 0; ca.length > da;) {
            q(ca[da++]);
        }h(h.S + h.F * !R, "Symbol", { "for": function _for(a) {
                return f(N, a += "") ? N[a] : N[a] = G(a);
            }, keyFor: function keyFor(a) {
                if (W(a)) return r(N, a);throw TypeError(a + " is not a symbol!");
            }, useSetter: function useSetter() {
                T = !0;
            }, useSimple: function useSimple() {
                T = !1;
            } }), h(h.S + h.F * !R, "Object", { create: Z, defineProperty: X, defineProperties: Y, getOwnPropertyDescriptor: _, getOwnPropertyNames: aa, getOwnPropertySymbols: ba }), H && h(h.S + h.F * (!R || k(function () {
            var a = G();return "[null]" != I([a]) || "{}" != I({ a: a }) || "{}" != I(Object(a));
        })), "JSON", { stringify: function stringify(a) {
                if (a !== c && !W(a)) {
                    for (var b, d, e = [a], f = 1; arguments.length > f;) {
                        e.push(arguments[f++]);
                    }return b = e[1], "function" == typeof b && (d = b), !d && t(b) || (b = function b(a, _b) {
                        if (d && (_b = d.call(this, a, _b)), !W(_b)) return _b;
                    }), e[1] = b, I.apply(H, e);
                }
            } }), G[J][L] || d(8)(G[J], L, G[J].valueOf), m(G, "Symbol"), m(Math, "Math", !0), m(e.JSON, "JSON", !0);
    }, function (a, c) {
        var d = a.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();"number" == typeof b && (b = d);
    }, function (a, b) {
        var c = {}.hasOwnProperty;a.exports = function (a, b) {
            return c.call(a, b);
        };
    }, function (a, b, c) {
        a.exports = !c(5)(function () {
            return 7 != Object.defineProperty({}, "a", { get: function get() {
                    return 7;
                } }).a;
        });
    }, function (a, b) {
        a.exports = function (a) {
            try {
                return !!a();
            } catch (b) {
                return !0;
            }
        };
    }, function (a, b, d) {
        var e = d(2),
            f = d(7),
            g = d(8),
            h = d(16),
            i = d(18),
            j = "prototype",
            k = function k(a, b, d) {
            var l,
                m,
                n,
                o,
                p = a & k.F,
                q = a & k.G,
                r = a & k.S,
                s = a & k.P,
                t = a & k.B,
                u = q ? e : r ? e[b] || (e[b] = {}) : (e[b] || {})[j],
                v = q ? f : f[b] || (f[b] = {}),
                w = v[j] || (v[j] = {});q && (d = b);for (l in d) {
                m = !p && u && u[l] !== c, n = (m ? u : d)[l], o = t && m ? i(n, e) : s && "function" == typeof n ? i(Function.call, n) : n, u && h(u, l, n, a & k.U), v[l] != n && g(v, l, o), s && w[l] != n && (w[l] = n);
            }
        };e.core = f, k.F = 1, k.G = 2, k.S = 4, k.P = 8, k.B = 16, k.W = 32, k.U = 64, k.R = 128, a.exports = k;
    }, function (b, c) {
        var d = b.exports = { version: "2.4.0" };"number" == typeof a && (a = d);
    }, function (a, b, c) {
        var d = c(9),
            e = c(15);a.exports = c(4) ? function (a, b, c) {
            return d.f(a, b, e(1, c));
        } : function (a, b, c) {
            return a[b] = c, a;
        };
    }, function (a, b, c) {
        var d = c(10),
            e = c(12),
            f = c(14),
            g = Object.defineProperty;b.f = c(4) ? Object.defineProperty : function defineProperty(a, b, c) {
            if (d(a), b = f(b, !0), d(c), e) try {
                return g(a, b, c);
            } catch (h) {}if ("get" in c || "set" in c) throw TypeError("Accessors not supported!");return "value" in c && (a[b] = c.value), a;
        };
    }, function (a, b, c) {
        var d = c(11);a.exports = function (a) {
            if (!d(a)) throw TypeError(a + " is not an object!");return a;
        };
    }, function (a, b) {
        a.exports = function (a) {
            return "object" == (typeof a === "undefined" ? "undefined" : _typeof(a)) ? null !== a : "function" == typeof a;
        };
    }, function (a, b, c) {
        a.exports = !c(4) && !c(5)(function () {
            return 7 != Object.defineProperty(c(13)("div"), "a", { get: function get() {
                    return 7;
                } }).a;
        });
    }, function (a, b, c) {
        var d = c(11),
            e = c(2).document,
            f = d(e) && d(e.createElement);a.exports = function (a) {
            return f ? e.createElement(a) : {};
        };
    }, function (a, b, c) {
        var d = c(11);a.exports = function (a, b) {
            if (!d(a)) return a;var c, e;if (b && "function" == typeof (c = a.toString) && !d(e = c.call(a))) return e;if ("function" == typeof (c = a.valueOf) && !d(e = c.call(a))) return e;if (!b && "function" == typeof (c = a.toString) && !d(e = c.call(a))) return e;throw TypeError("Can't convert object to primitive value");
        };
    }, function (a, b) {
        a.exports = function (a, b) {
            return { enumerable: !(1 & a), configurable: !(2 & a), writable: !(4 & a), value: b };
        };
    }, function (a, b, c) {
        var d = c(2),
            e = c(8),
            f = c(3),
            g = c(17)("src"),
            h = "toString",
            i = Function[h],
            j = ("" + i).split(h);c(7).inspectSource = function (a) {
            return i.call(a);
        }, (a.exports = function (a, b, c, h) {
            var i = "function" == typeof c;i && (f(c, "name") || e(c, "name", b)), a[b] !== c && (i && (f(c, g) || e(c, g, a[b] ? "" + a[b] : j.join(String(b)))), a === d ? a[b] = c : h ? a[b] ? a[b] = c : e(a, b, c) : (delete a[b], e(a, b, c)));
        })(Function.prototype, h, function toString() {
            return "function" == typeof this && this[g] || i.call(this);
        });
    }, function (a, b) {
        var d = 0,
            e = Math.random();a.exports = function (a) {
            return "Symbol(".concat(a === c ? "" : a, ")_", (++d + e).toString(36));
        };
    }, function (a, b, d) {
        var e = d(19);a.exports = function (a, b, d) {
            if (e(a), b === c) return a;switch (d) {case 1:
                    return function (c) {
                        return a.call(b, c);
                    };case 2:
                    return function (c, d) {
                        return a.call(b, c, d);
                    };case 3:
                    return function (c, d, e) {
                        return a.call(b, c, d, e);
                    };}return function () {
                return a.apply(b, arguments);
            };
        };
    }, function (a, b) {
        a.exports = function (a) {
            if ("function" != typeof a) throw TypeError(a + " is not a function!");return a;
        };
    }, function (a, b, c) {
        var d = c(17)("meta"),
            e = c(11),
            f = c(3),
            g = c(9).f,
            h = 0,
            i = Object.isExtensible || function () {
            return !0;
        },
            j = !c(5)(function () {
            return i(Object.preventExtensions({}));
        }),
            k = function k(a) {
            g(a, d, { value: { i: "O" + ++h, w: {} } });
        },
            l = function l(a, b) {
            if (!e(a)) return "symbol" == (typeof a === "undefined" ? "undefined" : _typeof(a)) ? a : ("string" == typeof a ? "S" : "P") + a;if (!f(a, d)) {
                if (!i(a)) return "F";if (!b) return "E";k(a);
            }return a[d].i;
        },
            m = function m(a, b) {
            if (!f(a, d)) {
                if (!i(a)) return !0;if (!b) return !1;k(a);
            }return a[d].w;
        },
            n = function n(a) {
            return j && o.NEED && i(a) && !f(a, d) && k(a), a;
        },
            o = a.exports = { KEY: d, NEED: !1, fastKey: l, getWeak: m, onFreeze: n };
    }, function (a, b, c) {
        var d = c(2),
            e = "__core-js_shared__",
            f = d[e] || (d[e] = {});a.exports = function (a) {
            return f[a] || (f[a] = {});
        };
    }, function (a, b, c) {
        var d = c(9).f,
            e = c(3),
            f = c(23)("toStringTag");a.exports = function (a, b, c) {
            a && !e(a = c ? a : a.prototype, f) && d(a, f, { configurable: !0, value: b });
        };
    }, function (a, b, c) {
        var d = c(21)("wks"),
            e = c(17),
            f = c(2).Symbol,
            g = "function" == typeof f,
            h = a.exports = function (a) {
            return d[a] || (d[a] = g && f[a] || (g ? f : e)("Symbol." + a));
        };h.store = d;
    }, function (a, b, c) {
        b.f = c(23);
    }, function (a, b, c) {
        var d = c(2),
            e = c(7),
            f = c(26),
            g = c(24),
            h = c(9).f;a.exports = function (a) {
            var b = e.Symbol || (e.Symbol = f ? {} : d.Symbol || {});"_" == a.charAt(0) || a in b || h(b, a, { value: g.f(a) });
        };
    }, function (a, b) {
        a.exports = !1;
    }, function (a, b, c) {
        var d = c(28),
            e = c(30);a.exports = function (a, b) {
            for (var c, f = e(a), g = d(f), h = g.length, i = 0; h > i;) {
                if (f[c = g[i++]] === b) return c;
            }
        };
    }, function (a, b, c) {
        var d = c(29),
            e = c(39);a.exports = Object.keys || function keys(a) {
            return d(a, e);
        };
    }, function (a, b, c) {
        var d = c(3),
            e = c(30),
            f = c(34)(!1),
            g = c(38)("IE_PROTO");a.exports = function (a, b) {
            var c,
                h = e(a),
                i = 0,
                j = [];for (c in h) {
                c != g && d(h, c) && j.push(c);
            }for (; b.length > i;) {
                d(h, c = b[i++]) && (~f(j, c) || j.push(c));
            }return j;
        };
    }, function (a, b, c) {
        var d = c(31),
            e = c(33);a.exports = function (a) {
            return d(e(a));
        };
    }, function (a, b, c) {
        var d = c(32);a.exports = Object("z").propertyIsEnumerable(0) ? Object : function (a) {
            return "String" == d(a) ? a.split("") : Object(a);
        };
    }, function (a, b) {
        var c = {}.toString;a.exports = function (a) {
            return c.call(a).slice(8, -1);
        };
    }, function (a, b) {
        a.exports = function (a) {
            if (a == c) throw TypeError("Can't call method on  " + a);return a;
        };
    }, function (a, b, c) {
        var d = c(30),
            e = c(35),
            f = c(37);a.exports = function (a) {
            return function (b, c, g) {
                var h,
                    i = d(b),
                    j = e(i.length),
                    k = f(g, j);if (a && c != c) {
                    for (; j > k;) {
                        if (h = i[k++], h != h) return !0;
                    }
                } else for (; j > k; k++) {
                    if ((a || k in i) && i[k] === c) return a || k || 0;
                }return !a && -1;
            };
        };
    }, function (a, b, c) {
        var d = c(36),
            e = Math.min;a.exports = function (a) {
            return a > 0 ? e(d(a), 9007199254740991) : 0;
        };
    }, function (a, b) {
        var c = Math.ceil,
            d = Math.floor;a.exports = function (a) {
            return isNaN(a = +a) ? 0 : (a > 0 ? d : c)(a);
        };
    }, function (a, b, c) {
        var d = c(36),
            e = Math.max,
            f = Math.min;a.exports = function (a, b) {
            return a = d(a), a < 0 ? e(a + b, 0) : f(a, b);
        };
    }, function (a, b, c) {
        var d = c(21)("keys"),
            e = c(17);a.exports = function (a) {
            return d[a] || (d[a] = e(a));
        };
    }, function (a, b) {
        a.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    }, function (a, b, c) {
        var d = c(28),
            e = c(41),
            f = c(42);a.exports = function (a) {
            var b = d(a),
                c = e.f;if (c) for (var g, h = c(a), i = f.f, j = 0; h.length > j;) {
                i.call(a, g = h[j++]) && b.push(g);
            }return b;
        };
    }, function (a, b) {
        b.f = Object.getOwnPropertySymbols;
    }, function (a, b) {
        b.f = {}.propertyIsEnumerable;
    }, function (a, b, c) {
        var d = c(32);a.exports = Array.isArray || function isArray(a) {
            return "Array" == d(a);
        };
    }, function (a, b, d) {
        var e = d(10),
            f = d(45),
            g = d(39),
            h = d(38)("IE_PROTO"),
            i = function i() {},
            j = "prototype",
            _k = function k() {
            var a,
                b = d(13)("iframe"),
                c = g.length,
                e = "<",
                f = ">";for (b.style.display = "none", d(46).appendChild(b), b.src = "javascript:", a = b.contentWindow.document, a.open(), a.write(e + "script" + f + "document.F=Object" + e + "/script" + f), a.close(), _k = a.F; c--;) {
                delete _k[j][g[c]];
            }return _k();
        };a.exports = Object.create || function create(a, b) {
            var d;return null !== a ? (i[j] = e(a), d = new i(), i[j] = null, d[h] = a) : d = _k(), b === c ? d : f(d, b);
        };
    }, function (a, b, c) {
        var d = c(9),
            e = c(10),
            f = c(28);a.exports = c(4) ? Object.defineProperties : function defineProperties(a, b) {
            e(a);for (var c, g = f(b), h = g.length, i = 0; h > i;) {
                d.f(a, c = g[i++], b[c]);
            }return a;
        };
    }, function (a, b, c) {
        a.exports = c(2).document && document.documentElement;
    }, function (a, b, c) {
        var d = c(30),
            e = c(48).f,
            f = {}.toString,
            g = "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
            h = function h(a) {
            try {
                return e(a);
            } catch (b) {
                return g.slice();
            }
        };a.exports.f = function getOwnPropertyNames(a) {
            return g && "[object Window]" == f.call(a) ? h(a) : e(d(a));
        };
    }, function (a, b, c) {
        var d = c(29),
            e = c(39).concat("length", "prototype");b.f = Object.getOwnPropertyNames || function getOwnPropertyNames(a) {
            return d(a, e);
        };
    }, function (a, b, c) {
        var d = c(42),
            e = c(15),
            f = c(30),
            g = c(14),
            h = c(3),
            i = c(12),
            j = Object.getOwnPropertyDescriptor;b.f = c(4) ? j : function getOwnPropertyDescriptor(a, b) {
            if (a = f(a), b = g(b, !0), i) try {
                return j(a, b);
            } catch (c) {}if (h(a, b)) return e(!d.f.call(a, b), a[b]);
        };
    }, function (a, b, c) {
        var d = c(6);d(d.S + d.F * !c(4), "Object", { defineProperty: c(9).f });
    }, function (a, b, c) {
        var d = c(6);d(d.S + d.F * !c(4), "Object", { defineProperties: c(45) });
    }, function (a, b, c) {
        var d = c(30),
            e = c(49).f;c(53)("getOwnPropertyDescriptor", function () {
            return function getOwnPropertyDescriptor(a, b) {
                return e(d(a), b);
            };
        });
    }, function (a, b, c) {
        var d = c(6),
            e = c(7),
            f = c(5);a.exports = function (a, b) {
            var c = (e.Object || {})[a] || Object[a],
                g = {};g[a] = b(c), d(d.S + d.F * f(function () {
                c(1);
            }), "Object", g);
        };
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Object", { create: c(44) });
    }, function (a, b, c) {
        var d = c(56),
            e = c(57);c(53)("getPrototypeOf", function () {
            return function getPrototypeOf(a) {
                return e(d(a));
            };
        });
    }, function (a, b, c) {
        var d = c(33);a.exports = function (a) {
            return Object(d(a));
        };
    }, function (a, b, c) {
        var d = c(3),
            e = c(56),
            f = c(38)("IE_PROTO"),
            g = Object.prototype;a.exports = Object.getPrototypeOf || function (a) {
            return a = e(a), d(a, f) ? a[f] : "function" == typeof a.constructor && a instanceof a.constructor ? a.constructor.prototype : a instanceof Object ? g : null;
        };
    }, function (a, b, c) {
        var d = c(56),
            e = c(28);c(53)("keys", function () {
            return function keys(a) {
                return e(d(a));
            };
        });
    }, function (a, b, c) {
        c(53)("getOwnPropertyNames", function () {
            return c(47).f;
        });
    }, function (a, b, c) {
        var d = c(11),
            e = c(20).onFreeze;c(53)("freeze", function (a) {
            return function freeze(b) {
                return a && d(b) ? a(e(b)) : b;
            };
        });
    }, function (a, b, c) {
        var d = c(11),
            e = c(20).onFreeze;c(53)("seal", function (a) {
            return function seal(b) {
                return a && d(b) ? a(e(b)) : b;
            };
        });
    }, function (a, b, c) {
        var d = c(11),
            e = c(20).onFreeze;c(53)("preventExtensions", function (a) {
            return function preventExtensions(b) {
                return a && d(b) ? a(e(b)) : b;
            };
        });
    }, function (a, b, c) {
        var d = c(11);c(53)("isFrozen", function (a) {
            return function isFrozen(b) {
                return !d(b) || !!a && a(b);
            };
        });
    }, function (a, b, c) {
        var d = c(11);c(53)("isSealed", function (a) {
            return function isSealed(b) {
                return !d(b) || !!a && a(b);
            };
        });
    }, function (a, b, c) {
        var d = c(11);c(53)("isExtensible", function (a) {
            return function isExtensible(b) {
                return !!d(b) && (!a || a(b));
            };
        });
    }, function (a, b, c) {
        var d = c(6);d(d.S + d.F, "Object", { assign: c(67) });
    }, function (a, b, c) {
        var d = c(28),
            e = c(41),
            f = c(42),
            g = c(56),
            h = c(31),
            i = Object.assign;a.exports = !i || c(5)(function () {
            var a = {},
                b = {},
                c = Symbol(),
                d = "abcdefghijklmnopqrst";return a[c] = 7, d.split("").forEach(function (a) {
                b[a] = a;
            }), 7 != i({}, a)[c] || Object.keys(i({}, b)).join("") != d;
        }) ? function assign(a, b) {
            for (var c = g(a), i = arguments.length, j = 1, k = e.f, l = f.f; i > j;) {
                for (var m, n = h(arguments[j++]), o = k ? d(n).concat(k(n)) : d(n), p = o.length, q = 0; p > q;) {
                    l.call(n, m = o[q++]) && (c[m] = n[m]);
                }
            }return c;
        } : i;
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Object", { is: c(69) });
    }, function (a, b) {
        a.exports = Object.is || function is(a, b) {
            return a === b ? 0 !== a || 1 / a === 1 / b : a != a && b != b;
        };
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Object", { setPrototypeOf: c(71).set });
    }, function (a, b, d) {
        var e = d(11),
            f = d(10),
            g = function g(a, b) {
            if (f(a), !e(b) && null !== b) throw TypeError(b + ": can't set as prototype!");
        };a.exports = { set: Object.setPrototypeOf || ("__proto__" in {} ? function (a, b, c) {
                try {
                    c = d(18)(Function.call, d(49).f(Object.prototype, "__proto__").set, 2), c(a, []), b = !(a instanceof Array);
                } catch (e) {
                    b = !0;
                }return function setPrototypeOf(a, d) {
                    return g(a, d), b ? a.__proto__ = d : c(a, d), a;
                };
            }({}, !1) : c), check: g };
    }, function (a, b, c) {
        var d = c(73),
            e = {};e[c(23)("toStringTag")] = "z", e + "" != "[object z]" && c(16)(Object.prototype, "toString", function toString() {
            return "[object " + d(this) + "]";
        }, !0);
    }, function (a, b, d) {
        var e = d(32),
            f = d(23)("toStringTag"),
            g = "Arguments" == e(function () {
            return arguments;
        }()),
            h = function h(a, b) {
            try {
                return a[b];
            } catch (c) {}
        };a.exports = function (a) {
            var b, d, i;return a === c ? "Undefined" : null === a ? "Null" : "string" == typeof (d = h(b = Object(a), f)) ? d : g ? e(b) : "Object" == (i = e(b)) && "function" == typeof b.callee ? "Arguments" : i;
        };
    }, function (a, b, c) {
        var d = c(6);d(d.P, "Function", { bind: c(75) });
    }, function (a, b, c) {
        var d = c(19),
            e = c(11),
            f = c(76),
            g = [].slice,
            h = {},
            i = function i(a, b, c) {
            if (!(b in h)) {
                for (var d = [], e = 0; e < b; e++) {
                    d[e] = "a[" + e + "]";
                }h[b] = Function("F,a", "return new F(" + d.join(",") + ")");
            }return h[b](a, c);
        };a.exports = Function.bind || function bind(a) {
            var b = d(this),
                c = g.call(arguments, 1),
                h = function h() {
                var d = c.concat(g.call(arguments));return this instanceof h ? i(b, d.length, d) : f(b, d, a);
            };return e(b.prototype) && (h.prototype = b.prototype), h;
        };
    }, function (a, b) {
        a.exports = function (a, b, d) {
            var e = d === c;switch (b.length) {case 0:
                    return e ? a() : a.call(d);case 1:
                    return e ? a(b[0]) : a.call(d, b[0]);case 2:
                    return e ? a(b[0], b[1]) : a.call(d, b[0], b[1]);case 3:
                    return e ? a(b[0], b[1], b[2]) : a.call(d, b[0], b[1], b[2]);case 4:
                    return e ? a(b[0], b[1], b[2], b[3]) : a.call(d, b[0], b[1], b[2], b[3]);}return a.apply(d, b);
        };
    }, function (a, b, c) {
        var d = c(9).f,
            e = c(15),
            f = c(3),
            g = Function.prototype,
            h = /^\s*function ([^ (]*)/,
            i = "name",
            j = Object.isExtensible || function () {
            return !0;
        };i in g || c(4) && d(g, i, { configurable: !0, get: function get() {
                try {
                    var a = this,
                        b = ("" + a).match(h)[1];return f(a, i) || !j(a) || d(a, i, e(5, b)), b;
                } catch (c) {
                    return "";
                }
            } });
    }, function (a, b, c) {
        var d = c(11),
            e = c(57),
            f = c(23)("hasInstance"),
            g = Function.prototype;f in g || c(9).f(g, f, { value: function value(a) {
                if ("function" != typeof this || !d(a)) return !1;if (!d(this.prototype)) return a instanceof this;for (; a = e(a);) {
                    if (this.prototype === a) return !0;
                }return !1;
            } });
    }, function (a, b, c) {
        var d = c(2),
            e = c(3),
            f = c(32),
            g = c(80),
            h = c(14),
            i = c(5),
            j = c(48).f,
            k = c(49).f,
            l = c(9).f,
            m = c(81).trim,
            n = "Number",
            o = d[n],
            p = o,
            q = o.prototype,
            r = f(c(44)(q)) == n,
            s = "trim" in String.prototype,
            t = function t(a) {
            var b = h(a, !1);if ("string" == typeof b && b.length > 2) {
                b = s ? b.trim() : m(b, 3);var c,
                    d,
                    e,
                    f = b.charCodeAt(0);if (43 === f || 45 === f) {
                    if (c = b.charCodeAt(2), 88 === c || 120 === c) return NaN;
                } else if (48 === f) {
                    switch (b.charCodeAt(1)) {case 66:case 98:
                            d = 2, e = 49;break;case 79:case 111:
                            d = 8, e = 55;break;default:
                            return +b;}for (var g, i = b.slice(2), j = 0, k = i.length; j < k; j++) {
                        if (g = i.charCodeAt(j), g < 48 || g > e) return NaN;
                    }return parseInt(i, d);
                }
            }return +b;
        };if (!o(" 0o1") || !o("0b1") || o("+0x1")) {
            o = function Number(a) {
                var b = arguments.length < 1 ? 0 : a,
                    c = this;return c instanceof o && (r ? i(function () {
                    q.valueOf.call(c);
                }) : f(c) != n) ? g(new p(t(b)), c, o) : t(b);
            };for (var u, v = c(4) ? j(p) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), w = 0; v.length > w; w++) {
                e(p, u = v[w]) && !e(o, u) && l(o, u, k(p, u));
            }o.prototype = q, q.constructor = o, c(16)(d, n, o);
        }
    }, function (a, b, c) {
        var d = c(11),
            e = c(71).set;a.exports = function (a, b, c) {
            var f,
                g = b.constructor;return g !== c && "function" == typeof g && (f = g.prototype) !== c.prototype && d(f) && e && e(a, f), a;
        };
    }, function (a, b, c) {
        var d = c(6),
            e = c(33),
            f = c(5),
            g = c(82),
            h = "[" + g + "]",
            i = "​",
            j = RegExp("^" + h + h + "*"),
            k = RegExp(h + h + "*$"),
            l = function l(a, b, c) {
            var e = {},
                h = f(function () {
                return !!g[a]() || i[a]() != i;
            }),
                j = e[a] = h ? b(m) : g[a];c && (e[c] = j), d(d.P + d.F * h, "String", e);
        },
            m = l.trim = function (a, b) {
            return a = String(e(a)), 1 & b && (a = a.replace(j, "")), 2 & b && (a = a.replace(k, "")), a;
        };a.exports = l;
    }, function (a, b) {
        a.exports = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
    }, function (a, b, c) {
        var d = c(6),
            e = c(36),
            f = c(84),
            g = c(85),
            h = 1..toFixed,
            i = Math.floor,
            j = [0, 0, 0, 0, 0, 0],
            k = "Number.toFixed: incorrect invocation!",
            l = "0",
            m = function m(a, b) {
            for (var c = -1, d = b; ++c < 6;) {
                d += a * j[c], j[c] = d % 1e7, d = i(d / 1e7);
            }
        },
            n = function n(a) {
            for (var b = 6, c = 0; --b >= 0;) {
                c += j[b], j[b] = i(c / a), c = c % a * 1e7;
            }
        },
            o = function o() {
            for (var a = 6, b = ""; --a >= 0;) {
                if ("" !== b || 0 === a || 0 !== j[a]) {
                    var c = String(j[a]);b = "" === b ? c : b + g.call(l, 7 - c.length) + c;
                }
            }return b;
        },
            p = function p(a, b, c) {
            return 0 === b ? c : b % 2 === 1 ? p(a, b - 1, c * a) : p(a * a, b / 2, c);
        },
            q = function q(a) {
            for (var b = 0, c = a; c >= 4096;) {
                b += 12, c /= 4096;
            }for (; c >= 2;) {
                b += 1, c /= 2;
            }return b;
        };d(d.P + d.F * (!!h && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== 0xde0b6b3a7640080.toFixed(0)) || !c(5)(function () {
            h.call({});
        })), "Number", { toFixed: function toFixed(a) {
                var b,
                    c,
                    d,
                    h,
                    i = f(this, k),
                    j = e(a),
                    r = "",
                    s = l;if (j < 0 || j > 20) throw RangeError(k);if (i != i) return "NaN";if (i <= -1e21 || i >= 1e21) return String(i);if (i < 0 && (r = "-", i = -i), i > 1e-21) if (b = q(i * p(2, 69, 1)) - 69, c = b < 0 ? i * p(2, -b, 1) : i / p(2, b, 1), c *= 4503599627370496, b = 52 - b, b > 0) {
                    for (m(0, c), d = j; d >= 7;) {
                        m(1e7, 0), d -= 7;
                    }for (m(p(10, d, 1), 0), d = b - 1; d >= 23;) {
                        n(1 << 23), d -= 23;
                    }n(1 << d), m(1, 1), n(2), s = o();
                } else m(0, c), m(1 << -b, 0), s = o() + g.call(l, j);return j > 0 ? (h = s.length, s = r + (h <= j ? "0." + g.call(l, j - h) + s : s.slice(0, h - j) + "." + s.slice(h - j))) : s = r + s, s;
            } });
    }, function (a, b, c) {
        var d = c(32);a.exports = function (a, b) {
            if ("number" != typeof a && "Number" != d(a)) throw TypeError(b);return +a;
        };
    }, function (a, b, c) {
        var d = c(36),
            e = c(33);a.exports = function repeat(a) {
            var b = String(e(this)),
                c = "",
                f = d(a);if (f < 0 || f == 1 / 0) throw RangeError("Count can't be negative");for (; f > 0; (f >>>= 1) && (b += b)) {
                1 & f && (c += b);
            }return c;
        };
    }, function (a, b, d) {
        var e = d(6),
            f = d(5),
            g = d(84),
            h = 1..toPrecision;e(e.P + e.F * (f(function () {
            return "1" !== h.call(1, c);
        }) || !f(function () {
            h.call({});
        })), "Number", { toPrecision: function toPrecision(a) {
                var b = g(this, "Number#toPrecision: incorrect invocation!");return a === c ? h.call(b) : h.call(b, a);
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Number", { EPSILON: Math.pow(2, -52) });
    }, function (a, b, c) {
        var d = c(6),
            e = c(2).isFinite;d(d.S, "Number", { isFinite: function isFinite(a) {
                return "number" == typeof a && e(a);
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Number", { isInteger: c(90) });
    }, function (a, b, c) {
        var d = c(11),
            e = Math.floor;a.exports = function isInteger(a) {
            return !d(a) && isFinite(a) && e(a) === a;
        };
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Number", { isNaN: function isNaN(a) {
                return a != a;
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(90),
            f = Math.abs;d(d.S, "Number", { isSafeInteger: function isSafeInteger(a) {
                return e(a) && f(a) <= 9007199254740991;
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Number", { MAX_SAFE_INTEGER: 9007199254740991 });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Number", { MIN_SAFE_INTEGER: -9007199254740991 });
    }, function (a, b, c) {
        var d = c(6),
            e = c(96);d(d.S + d.F * (Number.parseFloat != e), "Number", { parseFloat: e });
    }, function (a, b, c) {
        var d = c(2).parseFloat,
            e = c(81).trim;a.exports = 1 / d(c(82) + "-0") !== -(1 / 0) ? function parseFloat(a) {
            var b = e(String(a), 3),
                c = d(b);return 0 === c && "-" == b.charAt(0) ? -0 : c;
        } : d;
    }, function (a, b, c) {
        var d = c(6),
            e = c(98);d(d.S + d.F * (Number.parseInt != e), "Number", { parseInt: e });
    }, function (a, b, c) {
        var d = c(2).parseInt,
            e = c(81).trim,
            f = c(82),
            g = /^[\-+]?0[xX]/;a.exports = 8 !== d(f + "08") || 22 !== d(f + "0x16") ? function parseInt(a, b) {
            var c = e(String(a), 3);return d(c, b >>> 0 || (g.test(c) ? 16 : 10));
        } : d;
    }, function (a, b, c) {
        var d = c(6),
            e = c(98);d(d.G + d.F * (parseInt != e), { parseInt: e });
    }, function (a, b, c) {
        var d = c(6),
            e = c(96);d(d.G + d.F * (parseFloat != e), { parseFloat: e });
    }, function (a, b, c) {
        var d = c(6),
            e = c(102),
            f = Math.sqrt,
            g = Math.acosh;d(d.S + d.F * !(g && 710 == Math.floor(g(Number.MAX_VALUE)) && g(1 / 0) == 1 / 0), "Math", { acosh: function acosh(a) {
                return (a = +a) < 1 ? NaN : a > 94906265.62425156 ? Math.log(a) + Math.LN2 : e(a - 1 + f(a - 1) * f(a + 1));
            } });
    }, function (a, b) {
        a.exports = Math.log1p || function log1p(a) {
            return (a = +a) > -1e-8 && a < 1e-8 ? a - a * a / 2 : Math.log(1 + a);
        };
    }, function (a, b, c) {
        function asinh(a) {
            return isFinite(a = +a) && 0 != a ? a < 0 ? -asinh(-a) : Math.log(a + Math.sqrt(a * a + 1)) : a;
        }var d = c(6),
            e = Math.asinh;d(d.S + d.F * !(e && 1 / e(0) > 0), "Math", { asinh: asinh });
    }, function (a, b, c) {
        var d = c(6),
            e = Math.atanh;d(d.S + d.F * !(e && 1 / e(-0) < 0), "Math", { atanh: function atanh(a) {
                return 0 == (a = +a) ? a : Math.log((1 + a) / (1 - a)) / 2;
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(106);d(d.S, "Math", { cbrt: function cbrt(a) {
                return e(a = +a) * Math.pow(Math.abs(a), 1 / 3);
            } });
    }, function (a, b) {
        a.exports = Math.sign || function sign(a) {
            return 0 == (a = +a) || a != a ? a : a < 0 ? -1 : 1;
        };
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Math", { clz32: function clz32(a) {
                return (a >>>= 0) ? 31 - Math.floor(Math.log(a + .5) * Math.LOG2E) : 32;
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = Math.exp;d(d.S, "Math", { cosh: function cosh(a) {
                return (e(a = +a) + e(-a)) / 2;
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(110);d(d.S + d.F * (e != Math.expm1), "Math", { expm1: e });
    }, function (a, b) {
        var c = Math.expm1;a.exports = !c || c(10) > 22025.465794806718 || c(10) < 22025.465794806718 || c(-2e-17) != -2e-17 ? function expm1(a) {
            return 0 == (a = +a) ? a : a > -1e-6 && a < 1e-6 ? a + a * a / 2 : Math.exp(a) - 1;
        } : c;
    }, function (a, b, c) {
        var d = c(6),
            e = c(106),
            f = Math.pow,
            g = f(2, -52),
            h = f(2, -23),
            i = f(2, 127) * (2 - h),
            j = f(2, -126),
            k = function k(a) {
            return a + 1 / g - 1 / g;
        };d(d.S, "Math", { fround: function fround(a) {
                var b,
                    c,
                    d = Math.abs(a),
                    f = e(a);return d < j ? f * k(d / j / h) * j * h : (b = (1 + h / g) * d, c = b - (b - d), c > i || c != c ? f * (1 / 0) : f * c);
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = Math.abs;d(d.S, "Math", { hypot: function hypot(a, b) {
                for (var c, d, f = 0, g = 0, h = arguments.length, i = 0; g < h;) {
                    c = e(arguments[g++]), i < c ? (d = i / c, f = f * d * d + 1, i = c) : c > 0 ? (d = c / i, f += d * d) : f += c;
                }return i === 1 / 0 ? 1 / 0 : i * Math.sqrt(f);
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = Math.imul;d(d.S + d.F * c(5)(function () {
            return e(4294967295, 5) != -5 || 2 != e.length;
        }), "Math", { imul: function imul(a, b) {
                var c = 65535,
                    d = +a,
                    e = +b,
                    f = c & d,
                    g = c & e;return 0 | f * g + ((c & d >>> 16) * g + f * (c & e >>> 16) << 16 >>> 0);
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Math", { log10: function log10(a) {
                return Math.log(a) / Math.LN10;
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Math", { log1p: c(102) });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Math", { log2: function log2(a) {
                return Math.log(a) / Math.LN2;
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Math", { sign: c(106) });
    }, function (a, b, c) {
        var d = c(6),
            e = c(110),
            f = Math.exp;d(d.S + d.F * c(5)(function () {
            return !Math.sinh(-2e-17) != -2e-17;
        }), "Math", { sinh: function sinh(a) {
                return Math.abs(a = +a) < 1 ? (e(a) - e(-a)) / 2 : (f(a - 1) - f(-a - 1)) * (Math.E / 2);
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(110),
            f = Math.exp;d(d.S, "Math", { tanh: function tanh(a) {
                var b = e(a = +a),
                    c = e(-a);return b == 1 / 0 ? 1 : c == 1 / 0 ? -1 : (b - c) / (f(a) + f(-a));
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Math", { trunc: function trunc(a) {
                return (a > 0 ? Math.floor : Math.ceil)(a);
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(37),
            f = String.fromCharCode,
            g = String.fromCodePoint;d(d.S + d.F * (!!g && 1 != g.length), "String", { fromCodePoint: function fromCodePoint(a) {
                for (var b, c = [], d = arguments.length, g = 0; d > g;) {
                    if (b = +arguments[g++], e(b, 1114111) !== b) throw RangeError(b + " is not a valid code point");c.push(b < 65536 ? f(b) : f(((b -= 65536) >> 10) + 55296, b % 1024 + 56320));
                }return c.join("");
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(30),
            f = c(35);d(d.S, "String", { raw: function raw(a) {
                for (var b = e(a.raw), c = f(b.length), d = arguments.length, g = [], h = 0; c > h;) {
                    g.push(String(b[h++])), h < d && g.push(String(arguments[h]));
                }return g.join("");
            } });
    }, function (a, b, c) {
        c(81)("trim", function (a) {
            return function trim() {
                return a(this, 3);
            };
        });
    }, function (a, b, c) {
        var d = c(6),
            e = c(125)(!1);d(d.P, "String", { codePointAt: function codePointAt(a) {
                return e(this, a);
            } });
    }, function (a, b, d) {
        var e = d(36),
            f = d(33);a.exports = function (a) {
            return function (b, d) {
                var g,
                    h,
                    i = String(f(b)),
                    j = e(d),
                    k = i.length;return j < 0 || j >= k ? a ? "" : c : (g = i.charCodeAt(j), g < 55296 || g > 56319 || j + 1 === k || (h = i.charCodeAt(j + 1)) < 56320 || h > 57343 ? a ? i.charAt(j) : g : a ? i.slice(j, j + 2) : (g - 55296 << 10) + (h - 56320) + 65536);
            };
        };
    }, function (a, b, d) {
        var e = d(6),
            f = d(35),
            g = d(127),
            h = "endsWith",
            i = ""[h];e(e.P + e.F * d(129)(h), "String", { endsWith: function endsWith(a) {
                var b = g(this, a, h),
                    d = arguments.length > 1 ? arguments[1] : c,
                    e = f(b.length),
                    j = d === c ? e : Math.min(f(d), e),
                    k = String(a);return i ? i.call(b, k, j) : b.slice(j - k.length, j) === k;
            } });
    }, function (a, b, c) {
        var d = c(128),
            e = c(33);a.exports = function (a, b, c) {
            if (d(b)) throw TypeError("String#" + c + " doesn't accept regex!");return String(e(a));
        };
    }, function (a, b, d) {
        var e = d(11),
            f = d(32),
            g = d(23)("match");a.exports = function (a) {
            var b;return e(a) && ((b = a[g]) !== c ? !!b : "RegExp" == f(a));
        };
    }, function (a, b, c) {
        var d = c(23)("match");a.exports = function (a) {
            var b = /./;try {
                "/./"[a](b);
            } catch (c) {
                try {
                    return b[d] = !1, !"/./"[a](b);
                } catch (e) {}
            }return !0;
        };
    }, function (a, b, d) {
        var e = d(6),
            f = d(127),
            g = "includes";e(e.P + e.F * d(129)(g), "String", { includes: function includes(a) {
                return !!~f(this, a, g).indexOf(a, arguments.length > 1 ? arguments[1] : c);
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.P, "String", { repeat: c(85) });
    }, function (a, b, d) {
        var e = d(6),
            f = d(35),
            g = d(127),
            h = "startsWith",
            i = ""[h];e(e.P + e.F * d(129)(h), "String", { startsWith: function startsWith(a) {
                var b = g(this, a, h),
                    d = f(Math.min(arguments.length > 1 ? arguments[1] : c, b.length)),
                    e = String(a);return i ? i.call(b, e, d) : b.slice(d, d + e.length) === e;
            } });
    }, function (a, b, d) {
        var e = d(125)(!0);d(134)(String, "String", function (a) {
            this._t = String(a), this._i = 0;
        }, function () {
            var a,
                b = this._t,
                d = this._i;return d >= b.length ? { value: c, done: !0 } : (a = e(b, d), this._i += a.length, { value: a, done: !1 });
        });
    }, function (a, b, d) {
        var e = d(26),
            f = d(6),
            g = d(16),
            h = d(8),
            i = d(3),
            j = d(135),
            k = d(136),
            l = d(22),
            m = d(57),
            n = d(23)("iterator"),
            o = !([].keys && "next" in [].keys()),
            p = "@@iterator",
            q = "keys",
            r = "values",
            s = function s() {
            return this;
        };a.exports = function (a, b, d, t, u, v, w) {
            k(d, b, t);var x,
                y,
                z,
                A = function A(a) {
                if (!o && a in E) return E[a];switch (a) {case q:
                        return function keys() {
                            return new d(this, a);
                        };case r:
                        return function values() {
                            return new d(this, a);
                        };}return function entries() {
                    return new d(this, a);
                };
            },
                B = b + " Iterator",
                C = u == r,
                D = !1,
                E = a.prototype,
                F = E[n] || E[p] || u && E[u],
                G = F || A(u),
                H = u ? C ? A("entries") : G : c,
                I = "Array" == b ? E.entries || F : F;if (I && (z = m(I.call(new a())), z !== Object.prototype && (l(z, B, !0), e || i(z, n) || h(z, n, s))), C && F && F.name !== r && (D = !0, G = function values() {
                return F.call(this);
            }), e && !w || !o && !D && E[n] || h(E, n, G), j[b] = G, j[B] = s, u) if (x = { values: C ? G : A(r), keys: v ? G : A(q), entries: H }, w) for (y in x) {
                y in E || g(E, y, x[y]);
            } else f(f.P + f.F * (o || D), b, x);return x;
        };
    }, function (a, b) {
        a.exports = {};
    }, function (a, b, c) {
        var d = c(44),
            e = c(15),
            f = c(22),
            g = {};c(8)(g, c(23)("iterator"), function () {
            return this;
        }), a.exports = function (a, b, c) {
            a.prototype = d(g, { next: e(1, c) }), f(a, b + " Iterator");
        };
    }, function (a, b, c) {
        c(138)("anchor", function (a) {
            return function anchor(b) {
                return a(this, "a", "name", b);
            };
        });
    }, function (a, b, c) {
        var d = c(6),
            e = c(5),
            f = c(33),
            g = /"/g,
            h = function h(a, b, c, d) {
            var e = String(f(a)),
                h = "<" + b;return "" !== c && (h += " " + c + '="' + String(d).replace(g, "&quot;") + '"'), h + ">" + e + "</" + b + ">";
        };a.exports = function (a, b) {
            var c = {};c[a] = b(h), d(d.P + d.F * e(function () {
                var b = ""[a]('"');return b !== b.toLowerCase() || b.split('"').length > 3;
            }), "String", c);
        };
    }, function (a, b, c) {
        c(138)("big", function (a) {
            return function big() {
                return a(this, "big", "", "");
            };
        });
    }, function (a, b, c) {
        c(138)("blink", function (a) {
            return function blink() {
                return a(this, "blink", "", "");
            };
        });
    }, function (a, b, c) {
        c(138)("bold", function (a) {
            return function bold() {
                return a(this, "b", "", "");
            };
        });
    }, function (a, b, c) {
        c(138)("fixed", function (a) {
            return function fixed() {
                return a(this, "tt", "", "");
            };
        });
    }, function (a, b, c) {
        c(138)("fontcolor", function (a) {
            return function fontcolor(b) {
                return a(this, "font", "color", b);
            };
        });
    }, function (a, b, c) {
        c(138)("fontsize", function (a) {
            return function fontsize(b) {
                return a(this, "font", "size", b);
            };
        });
    }, function (a, b, c) {
        c(138)("italics", function (a) {
            return function italics() {
                return a(this, "i", "", "");
            };
        });
    }, function (a, b, c) {
        c(138)("link", function (a) {
            return function link(b) {
                return a(this, "a", "href", b);
            };
        });
    }, function (a, b, c) {
        c(138)("small", function (a) {
            return function small() {
                return a(this, "small", "", "");
            };
        });
    }, function (a, b, c) {
        c(138)("strike", function (a) {
            return function strike() {
                return a(this, "strike", "", "");
            };
        });
    }, function (a, b, c) {
        c(138)("sub", function (a) {
            return function sub() {
                return a(this, "sub", "", "");
            };
        });
    }, function (a, b, c) {
        c(138)("sup", function (a) {
            return function sup() {
                return a(this, "sup", "", "");
            };
        });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Array", { isArray: c(43) });
    }, function (a, b, d) {
        var e = d(18),
            f = d(6),
            g = d(56),
            h = d(153),
            i = d(154),
            j = d(35),
            k = d(155),
            l = d(156);f(f.S + f.F * !d(157)(function (a) {
            Array.from(a);
        }), "Array", { from: function from(a) {
                var b,
                    d,
                    f,
                    m,
                    n = g(a),
                    o = "function" == typeof this ? this : Array,
                    p = arguments.length,
                    q = p > 1 ? arguments[1] : c,
                    r = q !== c,
                    s = 0,
                    t = l(n);if (r && (q = e(q, p > 2 ? arguments[2] : c, 2)), t == c || o == Array && i(t)) for (b = j(n.length), d = new o(b); b > s; s++) {
                    k(d, s, r ? q(n[s], s) : n[s]);
                } else for (m = t.call(n), d = new o(); !(f = m.next()).done; s++) {
                    k(d, s, r ? h(m, q, [f.value, s], !0) : f.value);
                }return d.length = s, d;
            } });
    }, function (a, b, d) {
        var e = d(10);a.exports = function (a, b, d, f) {
            try {
                return f ? b(e(d)[0], d[1]) : b(d);
            } catch (g) {
                var h = a["return"];throw h !== c && e(h.call(a)), g;
            }
        };
    }, function (a, b, d) {
        var e = d(135),
            f = d(23)("iterator"),
            g = Array.prototype;a.exports = function (a) {
            return a !== c && (e.Array === a || g[f] === a);
        };
    }, function (a, b, c) {
        var d = c(9),
            e = c(15);a.exports = function (a, b, c) {
            b in a ? d.f(a, b, e(0, c)) : a[b] = c;
        };
    }, function (a, b, d) {
        var e = d(73),
            f = d(23)("iterator"),
            g = d(135);a.exports = d(7).getIteratorMethod = function (a) {
            if (a != c) return a[f] || a["@@iterator"] || g[e(a)];
        };
    }, function (a, b, c) {
        var d = c(23)("iterator"),
            e = !1;try {
            var f = [7][d]();f["return"] = function () {
                e = !0;
            }, Array.from(f, function () {
                throw 2;
            });
        } catch (g) {}a.exports = function (a, b) {
            if (!b && !e) return !1;var c = !1;try {
                var f = [7],
                    g = f[d]();g.next = function () {
                    return { done: c = !0 };
                }, f[d] = function () {
                    return g;
                }, a(f);
            } catch (h) {}return c;
        };
    }, function (a, b, c) {
        var d = c(6),
            e = c(155);d(d.S + d.F * c(5)(function () {
            function F() {}return !(Array.of.call(F) instanceof F);
        }), "Array", { of: function of() {
                for (var a = 0, b = arguments.length, c = new ("function" == typeof this ? this : Array)(b); b > a;) {
                    e(c, a, arguments[a++]);
                }return c.length = b, c;
            } });
    }, function (a, b, d) {
        var e = d(6),
            f = d(30),
            g = [].join;e(e.P + e.F * (d(31) != Object || !d(160)(g)), "Array", { join: function join(a) {
                return g.call(f(this), a === c ? "," : a);
            } });
    }, function (a, b, c) {
        var d = c(5);a.exports = function (a, b) {
            return !!a && d(function () {
                b ? a.call(null, function () {}, 1) : a.call(null);
            });
        };
    }, function (a, b, d) {
        var e = d(6),
            f = d(46),
            g = d(32),
            h = d(37),
            i = d(35),
            j = [].slice;e(e.P + e.F * d(5)(function () {
            f && j.call(f);
        }), "Array", { slice: function slice(a, b) {
                var d = i(this.length),
                    e = g(this);if (b = b === c ? d : b, "Array" == e) return j.call(this, a, b);for (var f = h(a, d), k = h(b, d), l = i(k - f), m = Array(l), n = 0; n < l; n++) {
                    m[n] = "String" == e ? this.charAt(f + n) : this[f + n];
                }return m;
            } });
    }, function (a, b, d) {
        var e = d(6),
            f = d(19),
            g = d(56),
            h = d(5),
            i = [].sort,
            j = [1, 2, 3];e(e.P + e.F * (h(function () {
            j.sort(c);
        }) || !h(function () {
            j.sort(null);
        }) || !d(160)(i)), "Array", { sort: function sort(a) {
                return a === c ? i.call(g(this)) : i.call(g(this), f(a));
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(164)(0),
            f = c(160)([].forEach, !0);d(d.P + d.F * !f, "Array", { forEach: function forEach(a) {
                return e(this, a, arguments[1]);
            } });
    }, function (a, b, d) {
        var e = d(18),
            f = d(31),
            g = d(56),
            h = d(35),
            i = d(165);a.exports = function (a, b) {
            var d = 1 == a,
                j = 2 == a,
                k = 3 == a,
                l = 4 == a,
                m = 6 == a,
                n = 5 == a || m,
                o = b || i;return function (b, i, p) {
                for (var q, r, s = g(b), t = f(s), u = e(i, p, 3), v = h(t.length), w = 0, x = d ? o(b, v) : j ? o(b, 0) : c; v > w; w++) {
                    if ((n || w in t) && (q = t[w], r = u(q, w, s), a)) if (d) x[w] = r;else if (r) switch (a) {case 3:
                            return !0;case 5:
                            return q;case 6:
                            return w;case 2:
                            x.push(q);} else if (l) return !1;
                }return m ? -1 : k || l ? l : x;
            };
        };
    }, function (a, b, c) {
        var d = c(166);a.exports = function (a, b) {
            return new (d(a))(b);
        };
    }, function (a, b, d) {
        var e = d(11),
            f = d(43),
            g = d(23)("species");a.exports = function (a) {
            var b;return f(a) && (b = a.constructor, "function" != typeof b || b !== Array && !f(b.prototype) || (b = c), e(b) && (b = b[g], null === b && (b = c))), b === c ? Array : b;
        };
    }, function (a, b, c) {
        var d = c(6),
            e = c(164)(1);d(d.P + d.F * !c(160)([].map, !0), "Array", { map: function map(a) {
                return e(this, a, arguments[1]);
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(164)(2);d(d.P + d.F * !c(160)([].filter, !0), "Array", { filter: function filter(a) {
                return e(this, a, arguments[1]);
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(164)(3);d(d.P + d.F * !c(160)([].some, !0), "Array", { some: function some(a) {
                return e(this, a, arguments[1]);
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(164)(4);d(d.P + d.F * !c(160)([].every, !0), "Array", { every: function every(a) {
                return e(this, a, arguments[1]);
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(172);d(d.P + d.F * !c(160)([].reduce, !0), "Array", { reduce: function reduce(a) {
                return e(this, a, arguments.length, arguments[1], !1);
            } });
    }, function (a, b, c) {
        var d = c(19),
            e = c(56),
            f = c(31),
            g = c(35);a.exports = function (a, b, c, h, i) {
            d(b);var j = e(a),
                k = f(j),
                l = g(j.length),
                m = i ? l - 1 : 0,
                n = i ? -1 : 1;if (c < 2) for (;;) {
                if (m in k) {
                    h = k[m], m += n;break;
                }if (m += n, i ? m < 0 : l <= m) throw TypeError("Reduce of empty array with no initial value");
            }for (; i ? m >= 0 : l > m; m += n) {
                m in k && (h = b(h, k[m], m, j));
            }return h;
        };
    }, function (a, b, c) {
        var d = c(6),
            e = c(172);d(d.P + d.F * !c(160)([].reduceRight, !0), "Array", { reduceRight: function reduceRight(a) {
                return e(this, a, arguments.length, arguments[1], !0);
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(34)(!1),
            f = [].indexOf,
            g = !!f && 1 / [1].indexOf(1, -0) < 0;d(d.P + d.F * (g || !c(160)(f)), "Array", { indexOf: function indexOf(a) {
                return g ? f.apply(this, arguments) || 0 : e(this, a, arguments[1]);
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(30),
            f = c(36),
            g = c(35),
            h = [].lastIndexOf,
            i = !!h && 1 / [1].lastIndexOf(1, -0) < 0;d(d.P + d.F * (i || !c(160)(h)), "Array", { lastIndexOf: function lastIndexOf(a) {
                if (i) return h.apply(this, arguments) || 0;var b = e(this),
                    c = g(b.length),
                    d = c - 1;for (arguments.length > 1 && (d = Math.min(d, f(arguments[1]))), d < 0 && (d = c + d); d >= 0; d--) {
                    if (d in b && b[d] === a) return d || 0;
                }return -1;
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.P, "Array", { copyWithin: c(177) }), c(178)("copyWithin");
    }, function (a, b, d) {
        var e = d(56),
            f = d(37),
            g = d(35);a.exports = [].copyWithin || function copyWithin(a, b) {
            var d = e(this),
                h = g(d.length),
                i = f(a, h),
                j = f(b, h),
                k = arguments.length > 2 ? arguments[2] : c,
                l = Math.min((k === c ? h : f(k, h)) - j, h - i),
                m = 1;for (j < i && i < j + l && (m = -1, j += l - 1, i += l - 1); l-- > 0;) {
                j in d ? d[i] = d[j] : delete d[i], i += m, j += m;
            }return d;
        };
    }, function (a, b, d) {
        var e = d(23)("unscopables"),
            f = Array.prototype;f[e] == c && d(8)(f, e, {}), a.exports = function (a) {
            f[e][a] = !0;
        };
    }, function (a, b, c) {
        var d = c(6);d(d.P, "Array", { fill: c(180) }), c(178)("fill");
    }, function (a, b, d) {
        var e = d(56),
            f = d(37),
            g = d(35);a.exports = function fill(a) {
            for (var b = e(this), d = g(b.length), h = arguments.length, i = f(h > 1 ? arguments[1] : c, d), j = h > 2 ? arguments[2] : c, k = j === c ? d : f(j, d); k > i;) {
                b[i++] = a;
            }return b;
        };
    }, function (a, b, d) {
        var e = d(6),
            f = d(164)(5),
            g = "find",
            h = !0;g in [] && Array(1)[g](function () {
            h = !1;
        }), e(e.P + e.F * h, "Array", { find: function find(a) {
                return f(this, a, arguments.length > 1 ? arguments[1] : c);
            } }), d(178)(g);
    }, function (a, b, d) {
        var e = d(6),
            f = d(164)(6),
            g = "findIndex",
            h = !0;g in [] && Array(1)[g](function () {
            h = !1;
        }), e(e.P + e.F * h, "Array", { findIndex: function findIndex(a) {
                return f(this, a, arguments.length > 1 ? arguments[1] : c);
            } }), d(178)(g);
    }, function (a, b, d) {
        var e = d(178),
            f = d(184),
            g = d(135),
            h = d(30);a.exports = d(134)(Array, "Array", function (a, b) {
            this._t = h(a), this._i = 0, this._k = b;
        }, function () {
            var a = this._t,
                b = this._k,
                d = this._i++;return !a || d >= a.length ? (this._t = c, f(1)) : "keys" == b ? f(0, d) : "values" == b ? f(0, a[d]) : f(0, [d, a[d]]);
        }, "values"), g.Arguments = g.Array, e("keys"), e("values"), e("entries");
    }, function (a, b) {
        a.exports = function (a, b) {
            return { value: b, done: !!a };
        };
    }, function (a, b, c) {
        c(186)("Array");
    }, function (a, b, c) {
        var d = c(2),
            e = c(9),
            f = c(4),
            g = c(23)("species");a.exports = function (a) {
            var b = d[a];f && b && !b[g] && e.f(b, g, { configurable: !0, get: function get() {
                    return this;
                } });
        };
    }, function (a, b, d) {
        var e = d(2),
            f = d(80),
            g = d(9).f,
            h = d(48).f,
            i = d(128),
            j = d(188),
            k = e.RegExp,
            l = k,
            m = k.prototype,
            n = /a/g,
            o = /a/g,
            p = new k(n) !== n;if (d(4) && (!p || d(5)(function () {
            return o[d(23)("match")] = !1, k(n) != n || k(o) == o || "/a/i" != k(n, "i");
        }))) {
            k = function RegExp(a, b) {
                var d = this instanceof k,
                    e = i(a),
                    g = b === c;return !d && e && a.constructor === k && g ? a : f(p ? new l(e && !g ? a.source : a, b) : l((e = a instanceof k) ? a.source : a, e && g ? j.call(a) : b), d ? this : m, k);
            };for (var q = function q(a) {
                (a in k) || g(k, a, { configurable: !0, get: function get() {
                        return l[a];
                    }, set: function set(b) {
                        l[a] = b;
                    } });
            }, r = h(l), s = 0; r.length > s;) {
                q(r[s++]);
            }m.constructor = k, k.prototype = m, d(16)(e, "RegExp", k);
        }d(186)("RegExp");
    }, function (a, b, c) {
        var d = c(10);a.exports = function () {
            var a = d(this),
                b = "";return a.global && (b += "g"), a.ignoreCase && (b += "i"), a.multiline && (b += "m"), a.unicode && (b += "u"), a.sticky && (b += "y"), b;
        };
    }, function (a, b, d) {
        d(190);var e = d(10),
            f = d(188),
            g = d(4),
            h = "toString",
            i = /./[h],
            j = function j(a) {
            d(16)(RegExp.prototype, h, a, !0);
        };d(5)(function () {
            return "/a/b" != i.call({ source: "a", flags: "b" });
        }) ? j(function toString() {
            var a = e(this);return "/".concat(a.source, "/", "flags" in a ? a.flags : !g && a instanceof RegExp ? f.call(a) : c);
        }) : i.name != h && j(function toString() {
            return i.call(this);
        });
    }, function (a, b, c) {
        c(4) && "g" != /./g.flags && c(9).f(RegExp.prototype, "flags", { configurable: !0, get: c(188) });
    }, function (a, b, d) {
        d(192)("match", 1, function (a, b, d) {
            return [function match(d) {
                var e = a(this),
                    f = d == c ? c : d[b];return f !== c ? f.call(d, e) : new RegExp(d)[b](String(e));
            }, d];
        });
    }, function (a, b, c) {
        var d = c(8),
            e = c(16),
            f = c(5),
            g = c(33),
            h = c(23);a.exports = function (a, b, c) {
            var i = h(a),
                j = c(g, i, ""[a]),
                k = j[0],
                l = j[1];f(function () {
                var b = {};return b[i] = function () {
                    return 7;
                }, 7 != ""[a](b);
            }) && (e(String.prototype, a, k), d(RegExp.prototype, i, 2 == b ? function (a, b) {
                return l.call(a, this, b);
            } : function (a) {
                return l.call(a, this);
            }));
        };
    }, function (a, b, d) {
        d(192)("replace", 2, function (a, b, d) {
            return [function replace(e, f) {
                var g = a(this),
                    h = e == c ? c : e[b];return h !== c ? h.call(e, g, f) : d.call(String(g), e, f);
            }, d];
        });
    }, function (a, b, d) {
        d(192)("search", 1, function (a, b, d) {
            return [function search(d) {
                var e = a(this),
                    f = d == c ? c : d[b];return f !== c ? f.call(d, e) : new RegExp(d)[b](String(e));
            }, d];
        });
    }, function (a, b, d) {
        d(192)("split", 2, function (a, b, e) {
            var f = d(128),
                g = e,
                h = [].push,
                i = "split",
                j = "length",
                k = "lastIndex";if ("c" == "abbc"[i](/(b)*/)[1] || 4 != "test"[i](/(?:)/, -1)[j] || 2 != "ab"[i](/(?:ab)*/)[j] || 4 != "."[i](/(.?)(.?)/)[j] || "."[i](/()()/)[j] > 1 || ""[i](/.?/)[j]) {
                var l = /()??/.exec("")[1] === c;e = function e(a, b) {
                    var d = String(this);if (a === c && 0 === b) return [];if (!f(a)) return g.call(d, a, b);var e,
                        i,
                        m,
                        n,
                        o,
                        p = [],
                        q = (a.ignoreCase ? "i" : "") + (a.multiline ? "m" : "") + (a.unicode ? "u" : "") + (a.sticky ? "y" : ""),
                        r = 0,
                        s = b === c ? 4294967295 : b >>> 0,
                        t = new RegExp(a.source, q + "g");for (l || (e = new RegExp("^" + t.source + "$(?!\\s)", q)); (i = t.exec(d)) && (m = i.index + i[0][j], !(m > r && (p.push(d.slice(r, i.index)), !l && i[j] > 1 && i[0].replace(e, function () {
                        for (o = 1; o < arguments[j] - 2; o++) {
                            arguments[o] === c && (i[o] = c);
                        }
                    }), i[j] > 1 && i.index < d[j] && h.apply(p, i.slice(1)), n = i[0][j], r = m, p[j] >= s)));) {
                        t[k] === i.index && t[k]++;
                    }return r === d[j] ? !n && t.test("") || p.push("") : p.push(d.slice(r)), p[j] > s ? p.slice(0, s) : p;
                };
            } else "0"[i](c, 0)[j] && (e = function e(a, b) {
                return a === c && 0 === b ? [] : g.call(this, a, b);
            });return [function split(d, f) {
                var g = a(this),
                    h = d == c ? c : d[b];return h !== c ? h.call(d, g, f) : e.call(String(g), d, f);
            }, e];
        });
    }, function (a, b, d) {
        var e,
            f,
            g,
            h = d(26),
            i = d(2),
            j = d(18),
            k = d(73),
            l = d(6),
            m = d(11),
            n = d(19),
            o = d(197),
            p = d(198),
            q = d(199),
            r = d(200).set,
            s = d(201)(),
            t = "Promise",
            u = i.TypeError,
            v = i.process,
            w = i[t],
            v = i.process,
            x = "process" == k(v),
            y = function y() {},
            z = !!function () {
            try {
                var a = w.resolve(1),
                    b = (a.constructor = {})[d(23)("species")] = function (a) {
                    a(y, y);
                };return (x || "function" == typeof PromiseRejectionEvent) && a.then(y) instanceof b;
            } catch (c) {}
        }(),
            A = function A(a, b) {
            return a === b || a === w && b === g;
        },
            B = function B(a) {
            var b;return !(!m(a) || "function" != typeof (b = a.then)) && b;
        },
            C = function C(a) {
            return A(w, a) ? new D(a) : new f(a);
        },
            D = f = function f(a) {
            var b, d;this.promise = new a(function (a, e) {
                if (b !== c || d !== c) throw u("Bad Promise constructor");b = a, d = e;
            }), this.resolve = n(b), this.reject = n(d);
        },
            E = function E(a) {
            try {
                a();
            } catch (b) {
                return { error: b };
            }
        },
            F = function F(a, b) {
            if (!a._n) {
                a._n = !0;var c = a._c;s(function () {
                    for (var d = a._v, e = 1 == a._s, f = 0, g = function g(b) {
                        var c,
                            f,
                            g = e ? b.ok : b.fail,
                            h = b.resolve,
                            i = b.reject,
                            j = b.domain;try {
                            g ? (e || (2 == a._h && I(a), a._h = 1), g === !0 ? c = d : (j && j.enter(), c = g(d), j && j.exit()), c === b.promise ? i(u("Promise-chain cycle")) : (f = B(c)) ? f.call(c, h, i) : h(c)) : i(d);
                        } catch (k) {
                            i(k);
                        }
                    }; c.length > f;) {
                        g(c[f++]);
                    }a._c = [], a._n = !1, b && !a._h && G(a);
                });
            }
        },
            G = function G(a) {
            r.call(i, function () {
                var b,
                    d,
                    e,
                    f = a._v;if (H(a) && (b = E(function () {
                    x ? v.emit("unhandledRejection", f, a) : (d = i.onunhandledrejection) ? d({ promise: a, reason: f }) : (e = i.console) && e.error && e.error("Unhandled promise rejection", f);
                }), a._h = x || H(a) ? 2 : 1), a._a = c, b) throw b.error;
            });
        },
            H = function H(a) {
            if (1 == a._h) return !1;for (var b, c = a._a || a._c, d = 0; c.length > d;) {
                if (b = c[d++], b.fail || !H(b.promise)) return !1;
            }return !0;
        },
            I = function I(a) {
            r.call(i, function () {
                var b;x ? v.emit("rejectionHandled", a) : (b = i.onrejectionhandled) && b({ promise: a, reason: a._v });
            });
        },
            J = function J(a) {
            var b = this;b._d || (b._d = !0, b = b._w || b, b._v = a, b._s = 2, b._a || (b._a = b._c.slice()), F(b, !0));
        },
            K = function K(a) {
            var b,
                c = this;if (!c._d) {
                c._d = !0, c = c._w || c;try {
                    if (c === a) throw u("Promise can't be resolved itself");(b = B(a)) ? s(function () {
                        var d = { _w: c, _d: !1 };try {
                            b.call(a, j(K, d, 1), j(J, d, 1));
                        } catch (e) {
                            J.call(d, e);
                        }
                    }) : (c._v = a, c._s = 1, F(c, !1));
                } catch (d) {
                    J.call({ _w: c, _d: !1 }, d);
                }
            }
        };z || (w = function Promise(a) {
            o(this, w, t, "_h"), n(a), e.call(this);try {
                a(j(K, this, 1), j(J, this, 1));
            } catch (b) {
                J.call(this, b);
            }
        }, e = function Promise(a) {
            this._c = [], this._a = c, this._s = 0, this._d = !1, this._v = c, this._h = 0, this._n = !1;
        }, e.prototype = d(202)(w.prototype, { then: function then(a, b) {
                var d = C(q(this, w));return d.ok = "function" != typeof a || a, d.fail = "function" == typeof b && b, d.domain = x ? v.domain : c, this._c.push(d), this._a && this._a.push(d), this._s && F(this, !1), d.promise;
            }, "catch": function _catch(a) {
                return this.then(c, a);
            } }), D = function D() {
            var a = new e();this.promise = a, this.resolve = j(K, a, 1), this.reject = j(J, a, 1);
        }), l(l.G + l.W + l.F * !z, { Promise: w }), d(22)(w, t), d(186)(t), g = d(7)[t], l(l.S + l.F * !z, t, { reject: function reject(a) {
                var b = C(this),
                    c = b.reject;return c(a), b.promise;
            } }), l(l.S + l.F * (h || !z), t, { resolve: function resolve(a) {
                if (a instanceof w && A(a.constructor, this)) return a;var b = C(this),
                    c = b.resolve;return c(a), b.promise;
            } }), l(l.S + l.F * !(z && d(157)(function (a) {
            w.all(a)["catch"](y);
        })), t, { all: function all(a) {
                var b = this,
                    d = C(b),
                    e = d.resolve,
                    f = d.reject,
                    g = E(function () {
                    var d = [],
                        g = 0,
                        h = 1;p(a, !1, function (a) {
                        var i = g++,
                            j = !1;d.push(c), h++, b.resolve(a).then(function (a) {
                            j || (j = !0, d[i] = a, --h || e(d));
                        }, f);
                    }), --h || e(d);
                });return g && f(g.error), d.promise;
            }, race: function race(a) {
                var b = this,
                    c = C(b),
                    d = c.reject,
                    e = E(function () {
                    p(a, !1, function (a) {
                        b.resolve(a).then(c.resolve, d);
                    });
                });return e && d(e.error), c.promise;
            } });
    }, function (a, b) {
        a.exports = function (a, b, d, e) {
            if (!(a instanceof b) || e !== c && e in a) throw TypeError(d + ": incorrect invocation!");return a;
        };
    }, function (a, b, c) {
        var d = c(18),
            e = c(153),
            f = c(154),
            g = c(10),
            h = c(35),
            i = c(156),
            j = {},
            k = {},
            b = a.exports = function (a, b, c, l, m) {
            var n,
                o,
                p,
                q,
                r = m ? function () {
                return a;
            } : i(a),
                s = d(c, l, b ? 2 : 1),
                t = 0;if ("function" != typeof r) throw TypeError(a + " is not iterable!");if (f(r)) {
                for (n = h(a.length); n > t; t++) {
                    if (q = b ? s(g(o = a[t])[0], o[1]) : s(a[t]), q === j || q === k) return q;
                }
            } else for (p = r.call(a); !(o = p.next()).done;) {
                if (q = e(p, s, o.value, b), q === j || q === k) return q;
            }
        };b.BREAK = j, b.RETURN = k;
    }, function (a, b, d) {
        var e = d(10),
            f = d(19),
            g = d(23)("species");a.exports = function (a, b) {
            var d,
                h = e(a).constructor;return h === c || (d = e(h)[g]) == c ? b : f(d);
        };
    }, function (a, b, c) {
        var d,
            e,
            f,
            g = c(18),
            h = c(76),
            i = c(46),
            j = c(13),
            k = c(2),
            l = k.process,
            m = k.setImmediate,
            n = k.clearImmediate,
            o = k.MessageChannel,
            p = 0,
            q = {},
            r = "onreadystatechange",
            s = function s() {
            var a = +this;if (q.hasOwnProperty(a)) {
                var b = q[a];delete q[a], b();
            }
        },
            t = function t(a) {
            s.call(a.data);
        };m && n || (m = function setImmediate(a) {
            for (var b = [], c = 1; arguments.length > c;) {
                b.push(arguments[c++]);
            }return q[++p] = function () {
                h("function" == typeof a ? a : Function(a), b);
            }, d(p), p;
        }, n = function clearImmediate(a) {
            delete q[a];
        }, "process" == c(32)(l) ? d = function d(a) {
            l.nextTick(g(s, a, 1));
        } : o ? (e = new o(), f = e.port2, e.port1.onmessage = t, d = g(f.postMessage, f, 1)) : k.addEventListener && "function" == typeof postMessage && !k.importScripts ? (d = function d(a) {
            k.postMessage(a + "", "*");
        }, k.addEventListener("message", t, !1)) : d = r in j("script") ? function (a) {
            i.appendChild(j("script"))[r] = function () {
                i.removeChild(this), s.call(a);
            };
        } : function (a) {
            setTimeout(g(s, a, 1), 0);
        }), a.exports = { set: m, clear: n };
    }, function (a, b, d) {
        var e = d(2),
            f = d(200).set,
            g = e.MutationObserver || e.WebKitMutationObserver,
            h = e.process,
            i = e.Promise,
            j = "process" == d(32)(h);a.exports = function () {
            var a,
                b,
                d,
                k = function k() {
                var e, f;for (j && (e = h.domain) && e.exit(); a;) {
                    f = a.fn, a = a.next;try {
                        f();
                    } catch (g) {
                        throw a ? d() : b = c, g;
                    }
                }b = c, e && e.enter();
            };if (j) d = function d() {
                h.nextTick(k);
            };else if (g) {
                var l = !0,
                    m = document.createTextNode("");new g(k).observe(m, { characterData: !0 }), d = function d() {
                    m.data = l = !l;
                };
            } else if (i && i.resolve) {
                var n = i.resolve();d = function d() {
                    n.then(k);
                };
            } else d = function d() {
                f.call(e, k);
            };return function (e) {
                var f = { fn: e, next: c };b && (b.next = f), a || (a = f, d()), b = f;
            };
        };
    }, function (a, b, c) {
        var d = c(16);a.exports = function (a, b, c) {
            for (var e in b) {
                d(a, e, b[e], c);
            }return a;
        };
    }, function (a, b, d) {
        var e = d(204);a.exports = d(205)("Map", function (a) {
            return function Map() {
                return a(this, arguments.length > 0 ? arguments[0] : c);
            };
        }, { get: function get(a) {
                var b = e.getEntry(this, a);return b && b.v;
            }, set: function set(a, b) {
                return e.def(this, 0 === a ? 0 : a, b);
            } }, e, !0);
    }, function (a, b, d) {
        var e = d(9).f,
            f = d(44),
            g = d(202),
            h = d(18),
            i = d(197),
            j = d(33),
            k = d(198),
            l = d(134),
            m = d(184),
            n = d(186),
            o = d(4),
            p = d(20).fastKey,
            q = o ? "_s" : "size",
            r = function r(a, b) {
            var c,
                d = p(b);if ("F" !== d) return a._i[d];for (c = a._f; c; c = c.n) {
                if (c.k == b) return c;
            }
        };a.exports = { getConstructor: function getConstructor(a, b, d, l) {
                var m = a(function (a, e) {
                    i(a, m, b, "_i"), a._i = f(null), a._f = c, a._l = c, a[q] = 0, e != c && k(e, d, a[l], a);
                });return g(m.prototype, { clear: function clear() {
                        for (var a = this, b = a._i, d = a._f; d; d = d.n) {
                            d.r = !0, d.p && (d.p = d.p.n = c), delete b[d.i];
                        }a._f = a._l = c, a[q] = 0;
                    }, "delete": function _delete(a) {
                        var b = this,
                            c = r(b, a);if (c) {
                            var d = c.n,
                                e = c.p;delete b._i[c.i], c.r = !0, e && (e.n = d), d && (d.p = e), b._f == c && (b._f = d), b._l == c && (b._l = e), b[q]--;
                        }return !!c;
                    }, forEach: function forEach(a) {
                        i(this, m, "forEach");for (var b, d = h(a, arguments.length > 1 ? arguments[1] : c, 3); b = b ? b.n : this._f;) {
                            for (d(b.v, b.k, this); b && b.r;) {
                                b = b.p;
                            }
                        }
                    }, has: function has(a) {
                        return !!r(this, a);
                    } }), o && e(m.prototype, "size", { get: function get() {
                        return j(this[q]);
                    } }), m;
            }, def: function def(a, b, d) {
                var e,
                    f,
                    g = r(a, b);return g ? g.v = d : (a._l = g = { i: f = p(b, !0), k: b, v: d, p: e = a._l, n: c, r: !1 }, a._f || (a._f = g), e && (e.n = g), a[q]++, "F" !== f && (a._i[f] = g)), a;
            }, getEntry: r, setStrong: function setStrong(a, b, d) {
                l(a, b, function (a, b) {
                    this._t = a, this._k = b, this._l = c;
                }, function () {
                    for (var a = this, b = a._k, d = a._l; d && d.r;) {
                        d = d.p;
                    }return a._t && (a._l = d = d ? d.n : a._t._f) ? "keys" == b ? m(0, d.k) : "values" == b ? m(0, d.v) : m(0, [d.k, d.v]) : (a._t = c, m(1));
                }, d ? "entries" : "values", !d, !0), n(b);
            } };
    }, function (a, b, d) {
        var e = d(2),
            f = d(6),
            g = d(16),
            h = d(202),
            i = d(20),
            j = d(198),
            k = d(197),
            l = d(11),
            m = d(5),
            n = d(157),
            o = d(22),
            p = d(80);a.exports = function (a, b, d, q, r, s) {
            var t = e[a],
                u = t,
                v = r ? "set" : "add",
                w = u && u.prototype,
                x = {},
                y = function y(a) {
                var b = w[a];g(w, a, "delete" == a ? function (a) {
                    return !(s && !l(a)) && b.call(this, 0 === a ? 0 : a);
                } : "has" == a ? function has(a) {
                    return !(s && !l(a)) && b.call(this, 0 === a ? 0 : a);
                } : "get" == a ? function get(a) {
                    return s && !l(a) ? c : b.call(this, 0 === a ? 0 : a);
                } : "add" == a ? function add(a) {
                    return b.call(this, 0 === a ? 0 : a), this;
                } : function set(a, c) {
                    return b.call(this, 0 === a ? 0 : a, c), this;
                });
            };if ("function" == typeof u && (s || w.forEach && !m(function () {
                new u().entries().next();
            }))) {
                var z = new u(),
                    A = z[v](s ? {} : -0, 1) != z,
                    B = m(function () {
                    z.has(1);
                }),
                    C = n(function (a) {
                    new u(a);
                }),
                    D = !s && m(function () {
                    for (var a = new u(), b = 5; b--;) {
                        a[v](b, b);
                    }return !a.has(-0);
                });C || (u = b(function (b, d) {
                    k(b, u, a);var e = p(new t(), b, u);return d != c && j(d, r, e[v], e), e;
                }), u.prototype = w, w.constructor = u), (B || D) && (y("delete"), y("has"), r && y("get")), (D || A) && y(v), s && w.clear && delete w.clear;
            } else u = q.getConstructor(b, a, r, v), h(u.prototype, d), i.NEED = !0;return o(u, a), x[a] = u, f(f.G + f.W + f.F * (u != t), x), s || q.setStrong(u, a, r), u;
        };
    }, function (a, b, d) {
        var e = d(204);a.exports = d(205)("Set", function (a) {
            return function Set() {
                return a(this, arguments.length > 0 ? arguments[0] : c);
            };
        }, { add: function add(a) {
                return e.def(this, a = 0 === a ? 0 : a, a);
            } }, e);
    }, function (a, b, d) {
        var e,
            f = d(164)(0),
            g = d(16),
            h = d(20),
            i = d(67),
            j = d(208),
            k = d(11),
            l = h.getWeak,
            m = Object.isExtensible,
            n = j.ufstore,
            o = {},
            p = function p(a) {
            return function WeakMap() {
                return a(this, arguments.length > 0 ? arguments[0] : c);
            };
        },
            q = { get: function get(a) {
                if (k(a)) {
                    var b = l(a);return b === !0 ? n(this).get(a) : b ? b[this._i] : c;
                }
            }, set: function set(a, b) {
                return j.def(this, a, b);
            } },
            r = a.exports = d(205)("WeakMap", p, q, j, !0, !0);7 != new r().set((Object.freeze || Object)(o), 7).get(o) && (e = j.getConstructor(p), i(e.prototype, q), h.NEED = !0, f(["delete", "has", "get", "set"], function (a) {
            var b = r.prototype,
                c = b[a];g(b, a, function (b, d) {
                if (k(b) && !m(b)) {
                    this._f || (this._f = new e());var f = this._f[a](b, d);return "set" == a ? this : f;
                }return c.call(this, b, d);
            });
        }));
    }, function (a, b, d) {
        var e = d(202),
            f = d(20).getWeak,
            g = d(10),
            h = d(11),
            i = d(197),
            j = d(198),
            k = d(164),
            l = d(3),
            m = k(5),
            n = k(6),
            o = 0,
            p = function p(a) {
            return a._l || (a._l = new q());
        },
            q = function q() {
            this.a = [];
        },
            r = function r(a, b) {
            return m(a.a, function (a) {
                return a[0] === b;
            });
        };q.prototype = { get: function get(a) {
                var b = r(this, a);if (b) return b[1];
            }, has: function has(a) {
                return !!r(this, a);
            }, set: function set(a, b) {
                var c = r(this, a);c ? c[1] = b : this.a.push([a, b]);
            }, "delete": function _delete(a) {
                var b = n(this.a, function (b) {
                    return b[0] === a;
                });return ~b && this.a.splice(b, 1), !!~b;
            } }, a.exports = { getConstructor: function getConstructor(a, b, d, g) {
                var k = a(function (a, e) {
                    i(a, k, b, "_i"), a._i = o++, a._l = c, e != c && j(e, d, a[g], a);
                });return e(k.prototype, { "delete": function _delete(a) {
                        if (!h(a)) return !1;var b = f(a);return b === !0 ? p(this)["delete"](a) : b && l(b, this._i) && delete b[this._i];
                    }, has: function has(a) {
                        if (!h(a)) return !1;var b = f(a);return b === !0 ? p(this).has(a) : b && l(b, this._i);
                    } }), k;
            }, def: function def(a, b, c) {
                var d = f(g(b), !0);return d === !0 ? p(a).set(b, c) : d[a._i] = c, a;
            }, ufstore: p };
    }, function (a, b, d) {
        var e = d(208);d(205)("WeakSet", function (a) {
            return function WeakSet() {
                return a(this, arguments.length > 0 ? arguments[0] : c);
            };
        }, { add: function add(a) {
                return e.def(this, a, !0);
            } }, e, !1, !0);
    }, function (a, b, c) {
        var d = c(6),
            e = c(19),
            f = c(10),
            g = (c(2).Reflect || {}).apply,
            h = Function.apply;d(d.S + d.F * !c(5)(function () {
            g(function () {});
        }), "Reflect", { apply: function apply(a, b, c) {
                var d = e(a),
                    i = f(c);return g ? g(d, b, i) : h.call(d, b, i);
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(44),
            f = c(19),
            g = c(10),
            h = c(11),
            i = c(5),
            j = c(75),
            k = (c(2).Reflect || {}).construct,
            l = i(function () {
            function F() {}return !(k(function () {}, [], F) instanceof F);
        }),
            m = !i(function () {
            k(function () {});
        });d(d.S + d.F * (l || m), "Reflect", { construct: function construct(a, b) {
                f(a), g(b);var c = arguments.length < 3 ? a : f(arguments[2]);if (m && !l) return k(a, b, c);if (a == c) {
                    switch (b.length) {case 0:
                            return new a();case 1:
                            return new a(b[0]);case 2:
                            return new a(b[0], b[1]);case 3:
                            return new a(b[0], b[1], b[2]);case 4:
                            return new a(b[0], b[1], b[2], b[3]);}var d = [null];return d.push.apply(d, b), new (j.apply(a, d))();
                }var i = c.prototype,
                    n = e(h(i) ? i : Object.prototype),
                    o = Function.apply.call(a, n, b);return h(o) ? o : n;
            } });
    }, function (a, b, c) {
        var d = c(9),
            e = c(6),
            f = c(10),
            g = c(14);e(e.S + e.F * c(5)(function () {
            Reflect.defineProperty(d.f({}, 1, { value: 1 }), 1, { value: 2 });
        }), "Reflect", { defineProperty: function defineProperty(a, b, c) {
                f(a), b = g(b, !0), f(c);try {
                    return d.f(a, b, c), !0;
                } catch (e) {
                    return !1;
                }
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(49).f,
            f = c(10);d(d.S, "Reflect", { deleteProperty: function deleteProperty(a, b) {
                var c = e(f(a), b);return !(c && !c.configurable) && delete a[b];
            } });
    }, function (a, b, d) {
        var e = d(6),
            f = d(10),
            g = function g(a) {
            this._t = f(a), this._i = 0;var b,
                c = this._k = [];for (b in a) {
                c.push(b);
            }
        };d(136)(g, "Object", function () {
            var a,
                b = this,
                d = b._k;do {
                if (b._i >= d.length) return { value: c, done: !0 };
            } while (!((a = d[b._i++]) in b._t));return { value: a, done: !1 };
        }), e(e.S, "Reflect", { enumerate: function enumerate(a) {
                return new g(a);
            } });
    }, function (a, b, d) {
        function get(a, b) {
            var d,
                h,
                k = arguments.length < 3 ? a : arguments[2];return j(a) === k ? a[b] : (d = e.f(a, b)) ? g(d, "value") ? d.value : d.get !== c ? d.get.call(k) : c : i(h = f(a)) ? get(h, b, k) : void 0;
        }var e = d(49),
            f = d(57),
            g = d(3),
            h = d(6),
            i = d(11),
            j = d(10);h(h.S, "Reflect", { get: get });
    }, function (a, b, c) {
        var d = c(49),
            e = c(6),
            f = c(10);e(e.S, "Reflect", { getOwnPropertyDescriptor: function getOwnPropertyDescriptor(a, b) {
                return d.f(f(a), b);
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(57),
            f = c(10);d(d.S, "Reflect", { getPrototypeOf: function getPrototypeOf(a) {
                return e(f(a));
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Reflect", { has: function has(a, b) {
                return b in a;
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(10),
            f = Object.isExtensible;d(d.S, "Reflect", { isExtensible: function isExtensible(a) {
                return e(a), !f || f(a);
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Reflect", { ownKeys: c(221) });
    }, function (a, b, c) {
        var d = c(48),
            e = c(41),
            f = c(10),
            g = c(2).Reflect;a.exports = g && g.ownKeys || function ownKeys(a) {
            var b = d.f(f(a)),
                c = e.f;return c ? b.concat(c(a)) : b;
        };
    }, function (a, b, c) {
        var d = c(6),
            e = c(10),
            f = Object.preventExtensions;d(d.S, "Reflect", { preventExtensions: function preventExtensions(a) {
                e(a);try {
                    return f && f(a), !0;
                } catch (b) {
                    return !1;
                }
            } });
    }, function (a, b, d) {
        function set(a, b, d) {
            var i,
                m,
                n = arguments.length < 4 ? a : arguments[3],
                o = f.f(k(a), b);if (!o) {
                if (l(m = g(a))) return set(m, b, d, n);o = j(0);
            }return h(o, "value") ? !(o.writable === !1 || !l(n)) && (i = f.f(n, b) || j(0), i.value = d, e.f(n, b, i), !0) : o.set !== c && (o.set.call(n, d), !0);
        }var e = d(9),
            f = d(49),
            g = d(57),
            h = d(3),
            i = d(6),
            j = d(15),
            k = d(10),
            l = d(11);i(i.S, "Reflect", { set: set });
    }, function (a, b, c) {
        var d = c(6),
            e = c(71);e && d(d.S, "Reflect", { setPrototypeOf: function setPrototypeOf(a, b) {
                e.check(a, b);try {
                    return e.set(a, b), !0;
                } catch (c) {
                    return !1;
                }
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Date", { now: function now() {
                return new Date().getTime();
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(56),
            f = c(14);d(d.P + d.F * c(5)(function () {
            return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({ toISOString: function toISOString() {
                    return 1;
                } });
        }), "Date", { toJSON: function toJSON(a) {
                var b = e(this),
                    c = f(b);return "number" != typeof c || isFinite(c) ? b.toISOString() : null;
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(5),
            f = Date.prototype.getTime,
            g = function g(a) {
            return a > 9 ? a : "0" + a;
        };d(d.P + d.F * (e(function () {
            return "0385-07-25T07:06:39.999Z" != new Date(-5e13 - 1).toISOString();
        }) || !e(function () {
            new Date(NaN).toISOString();
        })), "Date", { toISOString: function toISOString() {
                if (!isFinite(f.call(this))) throw RangeError("Invalid time value");var a = this,
                    b = a.getUTCFullYear(),
                    c = a.getUTCMilliseconds(),
                    d = b < 0 ? "-" : b > 9999 ? "+" : "";return d + ("00000" + Math.abs(b)).slice(d ? -6 : -4) + "-" + g(a.getUTCMonth() + 1) + "-" + g(a.getUTCDate()) + "T" + g(a.getUTCHours()) + ":" + g(a.getUTCMinutes()) + ":" + g(a.getUTCSeconds()) + "." + (c > 99 ? c : "0" + g(c)) + "Z";
            } });
    }, function (a, b, c) {
        var d = Date.prototype,
            e = "Invalid Date",
            f = "toString",
            g = d[f],
            h = d.getTime;new Date(NaN) + "" != e && c(16)(d, f, function toString() {
            var a = h.call(this);return a === a ? g.call(this) : e;
        });
    }, function (a, b, c) {
        var d = c(23)("toPrimitive"),
            e = Date.prototype;d in e || c(8)(e, d, c(230));
    }, function (a, b, c) {
        var d = c(10),
            e = c(14),
            f = "number";a.exports = function (a) {
            if ("string" !== a && a !== f && "default" !== a) throw TypeError("Incorrect hint");return e(d(this), a != f);
        };
    }, function (a, b, d) {
        var e = d(6),
            f = d(232),
            g = d(233),
            h = d(10),
            i = d(37),
            j = d(35),
            k = d(11),
            l = d(2).ArrayBuffer,
            m = d(199),
            n = g.ArrayBuffer,
            o = g.DataView,
            p = f.ABV && l.isView,
            q = n.prototype.slice,
            r = f.VIEW,
            s = "ArrayBuffer";e(e.G + e.W + e.F * (l !== n), { ArrayBuffer: n }), e(e.S + e.F * !f.CONSTR, s, { isView: function isView(a) {
                return p && p(a) || k(a) && r in a;
            } }), e(e.P + e.U + e.F * d(5)(function () {
            return !new n(2).slice(1, c).byteLength;
        }), s, { slice: function slice(a, b) {
                if (q !== c && b === c) return q.call(h(this), a);for (var d = h(this).byteLength, e = i(a, d), f = i(b === c ? d : b, d), g = new (m(this, n))(j(f - e)), k = new o(this), l = new o(g), p = 0; e < f;) {
                    l.setUint8(p++, k.getUint8(e++));
                }return g;
            } }), d(186)(s);
    }, function (a, b, c) {
        for (var d, e = c(2), f = c(8), g = c(17), h = g("typed_array"), i = g("view"), j = !(!e.ArrayBuffer || !e.DataView), k = j, l = 0, m = 9, n = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); l < m;) {
            (d = e[n[l++]]) ? (f(d.prototype, h, !0), f(d.prototype, i, !0)) : k = !1;
        }a.exports = { ABV: j, CONSTR: k, TYPED: h, VIEW: i };
    }, function (a, b, d) {
        var e = d(2),
            f = d(4),
            g = d(26),
            h = d(232),
            i = d(8),
            j = d(202),
            k = d(5),
            l = d(197),
            m = d(36),
            n = d(35),
            o = d(48).f,
            p = d(9).f,
            q = d(180),
            r = d(22),
            s = "ArrayBuffer",
            t = "DataView",
            u = "prototype",
            v = "Wrong length!",
            w = "Wrong index!",
            x = e[s],
            y = e[t],
            z = e.Math,
            A = e.RangeError,
            B = e.Infinity,
            C = x,
            D = z.abs,
            E = z.pow,
            F = z.floor,
            G = z.log,
            H = z.LN2,
            I = "buffer",
            J = "byteLength",
            K = "byteOffset",
            L = f ? "_b" : I,
            M = f ? "_l" : J,
            N = f ? "_o" : K,
            O = function O(a, b, c) {
            var d,
                e,
                f,
                g = Array(c),
                h = 8 * c - b - 1,
                i = (1 << h) - 1,
                j = i >> 1,
                k = 23 === b ? E(2, -24) - E(2, -77) : 0,
                l = 0,
                m = a < 0 || 0 === a && 1 / a < 0 ? 1 : 0;for (a = D(a), a != a || a === B ? (e = a != a ? 1 : 0, d = i) : (d = F(G(a) / H), a * (f = E(2, -d)) < 1 && (d--, f *= 2), a += d + j >= 1 ? k / f : k * E(2, 1 - j), a * f >= 2 && (d++, f /= 2), d + j >= i ? (e = 0, d = i) : d + j >= 1 ? (e = (a * f - 1) * E(2, b), d += j) : (e = a * E(2, j - 1) * E(2, b), d = 0)); b >= 8; g[l++] = 255 & e, e /= 256, b -= 8) {}for (d = d << b | e, h += b; h > 0; g[l++] = 255 & d, d /= 256, h -= 8) {}return g[--l] |= 128 * m, g;
        },
            P = function P(a, b, c) {
            var d,
                e = 8 * c - b - 1,
                f = (1 << e) - 1,
                g = f >> 1,
                h = e - 7,
                i = c - 1,
                j = a[i--],
                k = 127 & j;for (j >>= 7; h > 0; k = 256 * k + a[i], i--, h -= 8) {}for (d = k & (1 << -h) - 1, k >>= -h, h += b; h > 0; d = 256 * d + a[i], i--, h -= 8) {}if (0 === k) k = 1 - g;else {
                if (k === f) return d ? NaN : j ? -B : B;d += E(2, b), k -= g;
            }return (j ? -1 : 1) * d * E(2, k - b);
        },
            Q = function Q(a) {
            return a[3] << 24 | a[2] << 16 | a[1] << 8 | a[0];
        },
            R = function R(a) {
            return [255 & a];
        },
            S = function S(a) {
            return [255 & a, a >> 8 & 255];
        },
            T = function T(a) {
            return [255 & a, a >> 8 & 255, a >> 16 & 255, a >> 24 & 255];
        },
            U = function U(a) {
            return O(a, 52, 8);
        },
            V = function V(a) {
            return O(a, 23, 4);
        },
            W = function W(a, b, c) {
            p(a[u], b, { get: function get() {
                    return this[c];
                } });
        },
            X = function X(a, b, c, d) {
            var e = +c,
                f = m(e);if (e != f || f < 0 || f + b > a[M]) throw A(w);var g = a[L]._b,
                h = f + a[N],
                i = g.slice(h, h + b);return d ? i : i.reverse();
        },
            Y = function Y(a, b, c, d, e, f) {
            var g = +c,
                h = m(g);if (g != h || h < 0 || h + b > a[M]) throw A(w);for (var i = a[L]._b, j = h + a[N], k = d(+e), l = 0; l < b; l++) {
                i[j + l] = k[f ? l : b - l - 1];
            }
        },
            Z = function Z(a, b) {
            l(a, x, s);var c = +b,
                d = n(c);if (c != d) throw A(v);return d;
        };if (h.ABV) {
            if (!k(function () {
                new x();
            }) || !k(function () {
                new x(.5);
            })) {
                x = function ArrayBuffer(a) {
                    return new C(Z(this, a));
                };for (var $, _ = x[u] = C[u], aa = o(C), ba = 0; aa.length > ba;) {
                    ($ = aa[ba++]) in x || i(x, $, C[$]);
                }g || (_.constructor = x);
            }var ca = new y(new x(2)),
                da = y[u].setInt8;ca.setInt8(0, 2147483648), ca.setInt8(1, 2147483649), !ca.getInt8(0) && ca.getInt8(1) || j(y[u], { setInt8: function setInt8(a, b) {
                    da.call(this, a, b << 24 >> 24);
                }, setUint8: function setUint8(a, b) {
                    da.call(this, a, b << 24 >> 24);
                } }, !0);
        } else x = function ArrayBuffer(a) {
            var b = Z(this, a);this._b = q.call(Array(b), 0), this[M] = b;
        }, y = function DataView(a, b, d) {
            l(this, y, t), l(a, x, t);var e = a[M],
                f = m(b);if (f < 0 || f > e) throw A("Wrong offset!");if (d = d === c ? e - f : n(d), f + d > e) throw A(v);this[L] = a, this[N] = f, this[M] = d;
        }, f && (W(x, J, "_l"), W(y, I, "_b"), W(y, J, "_l"), W(y, K, "_o")), j(y[u], { getInt8: function getInt8(a) {
                return X(this, 1, a)[0] << 24 >> 24;
            }, getUint8: function getUint8(a) {
                return X(this, 1, a)[0];
            }, getInt16: function getInt16(a) {
                var b = X(this, 2, a, arguments[1]);return (b[1] << 8 | b[0]) << 16 >> 16;
            }, getUint16: function getUint16(a) {
                var b = X(this, 2, a, arguments[1]);return b[1] << 8 | b[0];
            }, getInt32: function getInt32(a) {
                return Q(X(this, 4, a, arguments[1]));
            }, getUint32: function getUint32(a) {
                return Q(X(this, 4, a, arguments[1])) >>> 0;
            }, getFloat32: function getFloat32(a) {
                return P(X(this, 4, a, arguments[1]), 23, 4);
            }, getFloat64: function getFloat64(a) {
                return P(X(this, 8, a, arguments[1]), 52, 8);
            }, setInt8: function setInt8(a, b) {
                Y(this, 1, a, R, b);
            }, setUint8: function setUint8(a, b) {
                Y(this, 1, a, R, b);
            }, setInt16: function setInt16(a, b) {
                Y(this, 2, a, S, b, arguments[2]);
            }, setUint16: function setUint16(a, b) {
                Y(this, 2, a, S, b, arguments[2]);
            }, setInt32: function setInt32(a, b) {
                Y(this, 4, a, T, b, arguments[2]);
            }, setUint32: function setUint32(a, b) {
                Y(this, 4, a, T, b, arguments[2]);
            }, setFloat32: function setFloat32(a, b) {
                Y(this, 4, a, V, b, arguments[2]);
            }, setFloat64: function setFloat64(a, b) {
                Y(this, 8, a, U, b, arguments[2]);
            } });r(x, s), r(y, t), i(y[u], h.VIEW, !0), b[s] = x, b[t] = y;
    }, function (a, b, c) {
        var d = c(6);d(d.G + d.W + d.F * !c(232).ABV, { DataView: c(233).DataView });
    }, function (a, b, c) {
        c(236)("Int8", 1, function (a) {
            return function Int8Array(b, c, d) {
                return a(this, b, c, d);
            };
        });
    }, function (a, b, d) {
        if (d(4)) {
            var e = d(26),
                f = d(2),
                g = d(5),
                h = d(6),
                i = d(232),
                j = d(233),
                k = d(18),
                l = d(197),
                m = d(15),
                n = d(8),
                o = d(202),
                p = d(36),
                q = d(35),
                r = d(37),
                s = d(14),
                t = d(3),
                u = d(69),
                v = d(73),
                w = d(11),
                x = d(56),
                y = d(154),
                z = d(44),
                A = d(57),
                B = d(48).f,
                C = d(156),
                D = d(17),
                E = d(23),
                F = d(164),
                G = d(34),
                H = d(199),
                I = d(183),
                J = d(135),
                K = d(157),
                L = d(186),
                M = d(180),
                N = d(177),
                O = d(9),
                P = d(49),
                Q = O.f,
                R = P.f,
                S = f.RangeError,
                T = f.TypeError,
                U = f.Uint8Array,
                V = "ArrayBuffer",
                W = "Shared" + V,
                X = "BYTES_PER_ELEMENT",
                Y = "prototype",
                Z = Array[Y],
                $ = j.ArrayBuffer,
                _ = j.DataView,
                aa = F(0),
                ba = F(2),
                ca = F(3),
                da = F(4),
                ea = F(5),
                fa = F(6),
                ga = G(!0),
                ha = G(!1),
                ia = I.values,
                ja = I.keys,
                ka = I.entries,
                la = Z.lastIndexOf,
                ma = Z.reduce,
                na = Z.reduceRight,
                oa = Z.join,
                pa = Z.sort,
                qa = Z.slice,
                ra = Z.toString,
                sa = Z.toLocaleString,
                ta = E("iterator"),
                ua = E("toStringTag"),
                va = D("typed_constructor"),
                wa = D("def_constructor"),
                xa = i.CONSTR,
                ya = i.TYPED,
                za = i.VIEW,
                Aa = "Wrong length!",
                Ba = F(1, function (a, b) {
                return Ha(H(a, a[wa]), b);
            }),
                Ca = g(function () {
                return 1 === new U(new Uint16Array([1]).buffer)[0];
            }),
                Da = !!U && !!U[Y].set && g(function () {
                new U(1).set({});
            }),
                Ea = function Ea(a, b) {
                if (a === c) throw T(Aa);var d = +a,
                    e = q(a);if (b && !u(d, e)) throw S(Aa);return e;
            },
                Fa = function Fa(a, b) {
                var c = p(a);if (c < 0 || c % b) throw S("Wrong offset!");return c;
            },
                Ga = function Ga(a) {
                if (w(a) && ya in a) return a;throw T(a + " is not a typed array!");
            },
                Ha = function Ha(a, b) {
                if (!(w(a) && va in a)) throw T("It is not a typed array constructor!");return new a(b);
            },
                Ia = function Ia(a, b) {
                return Ja(H(a, a[wa]), b);
            },
                Ja = function Ja(a, b) {
                for (var c = 0, d = b.length, e = Ha(a, d); d > c;) {
                    e[c] = b[c++];
                }return e;
            },
                Ka = function Ka(a, b, c) {
                Q(a, b, { get: function get() {
                        return this._d[c];
                    } });
            },
                La = function from(a) {
                var b,
                    d,
                    e,
                    f,
                    g,
                    h,
                    i = x(a),
                    j = arguments.length,
                    l = j > 1 ? arguments[1] : c,
                    m = l !== c,
                    n = C(i);if (n != c && !y(n)) {
                    for (h = n.call(i), e = [], b = 0; !(g = h.next()).done; b++) {
                        e.push(g.value);
                    }i = e;
                }for (m && j > 2 && (l = k(l, arguments[2], 2)), b = 0, d = q(i.length), f = Ha(this, d); d > b; b++) {
                    f[b] = m ? l(i[b], b) : i[b];
                }return f;
            },
                Ma = function of() {
                for (var a = 0, b = arguments.length, c = Ha(this, b); b > a;) {
                    c[a] = arguments[a++];
                }return c;
            },
                Na = !!U && g(function () {
                sa.call(new U(1));
            }),
                Oa = function toLocaleString() {
                return sa.apply(Na ? qa.call(Ga(this)) : Ga(this), arguments);
            },
                Pa = { copyWithin: function copyWithin(a, b) {
                    return N.call(Ga(this), a, b, arguments.length > 2 ? arguments[2] : c);
                }, every: function every(a) {
                    return da(Ga(this), a, arguments.length > 1 ? arguments[1] : c);
                }, fill: function fill(a) {
                    return M.apply(Ga(this), arguments);
                }, filter: function filter(a) {
                    return Ia(this, ba(Ga(this), a, arguments.length > 1 ? arguments[1] : c));
                }, find: function find(a) {
                    return ea(Ga(this), a, arguments.length > 1 ? arguments[1] : c);
                }, findIndex: function findIndex(a) {
                    return fa(Ga(this), a, arguments.length > 1 ? arguments[1] : c);
                }, forEach: function forEach(a) {
                    aa(Ga(this), a, arguments.length > 1 ? arguments[1] : c);
                }, indexOf: function indexOf(a) {
                    return ha(Ga(this), a, arguments.length > 1 ? arguments[1] : c);
                }, includes: function includes(a) {
                    return ga(Ga(this), a, arguments.length > 1 ? arguments[1] : c);
                }, join: function join(a) {
                    return oa.apply(Ga(this), arguments);
                }, lastIndexOf: function lastIndexOf(a) {
                    return la.apply(Ga(this), arguments);
                }, map: function map(a) {
                    return Ba(Ga(this), a, arguments.length > 1 ? arguments[1] : c);
                }, reduce: function reduce(a) {
                    return ma.apply(Ga(this), arguments);
                }, reduceRight: function reduceRight(a) {
                    return na.apply(Ga(this), arguments);
                }, reverse: function reverse() {
                    for (var a, b = this, c = Ga(b).length, d = Math.floor(c / 2), e = 0; e < d;) {
                        a = b[e], b[e++] = b[--c], b[c] = a;
                    }return b;
                }, some: function some(a) {
                    return ca(Ga(this), a, arguments.length > 1 ? arguments[1] : c);
                }, sort: function sort(a) {
                    return pa.call(Ga(this), a);
                }, subarray: function subarray(a, b) {
                    var d = Ga(this),
                        e = d.length,
                        f = r(a, e);return new (H(d, d[wa]))(d.buffer, d.byteOffset + f * d.BYTES_PER_ELEMENT, q((b === c ? e : r(b, e)) - f));
                } },
                Qa = function slice(a, b) {
                return Ia(this, qa.call(Ga(this), a, b));
            },
                Ra = function set(a) {
                Ga(this);var b = Fa(arguments[1], 1),
                    c = this.length,
                    d = x(a),
                    e = q(d.length),
                    f = 0;if (e + b > c) throw S(Aa);for (; f < e;) {
                    this[b + f] = d[f++];
                }
            },
                Sa = { entries: function entries() {
                    return ka.call(Ga(this));
                }, keys: function keys() {
                    return ja.call(Ga(this));
                }, values: function values() {
                    return ia.call(Ga(this));
                } },
                Ta = function Ta(a, b) {
                return w(a) && a[ya] && "symbol" != (typeof b === "undefined" ? "undefined" : _typeof(b)) && b in a && String(+b) == String(b);
            },
                Ua = function getOwnPropertyDescriptor(a, b) {
                return Ta(a, b = s(b, !0)) ? m(2, a[b]) : R(a, b);
            },
                Va = function defineProperty(a, b, c) {
                return !(Ta(a, b = s(b, !0)) && w(c) && t(c, "value")) || t(c, "get") || t(c, "set") || c.configurable || t(c, "writable") && !c.writable || t(c, "enumerable") && !c.enumerable ? Q(a, b, c) : (a[b] = c.value, a);
            };xa || (P.f = Ua, O.f = Va), h(h.S + h.F * !xa, "Object", { getOwnPropertyDescriptor: Ua, defineProperty: Va }), g(function () {
                ra.call({});
            }) && (ra = sa = function toString() {
                return oa.call(this);
            });var Wa = o({}, Pa);o(Wa, Sa), n(Wa, ta, Sa.values), o(Wa, { slice: Qa, set: Ra, constructor: function constructor() {}, toString: ra, toLocaleString: Oa }), Ka(Wa, "buffer", "b"), Ka(Wa, "byteOffset", "o"), Ka(Wa, "byteLength", "l"), Ka(Wa, "length", "e"), Q(Wa, ua, { get: function get() {
                    return this[ya];
                } }), a.exports = function (a, b, d, j) {
                j = !!j;var k = a + (j ? "Clamped" : "") + "Array",
                    m = "Uint8Array" != k,
                    o = "get" + a,
                    p = "set" + a,
                    r = f[k],
                    s = r || {},
                    t = r && A(r),
                    u = !r || !i.ABV,
                    x = {},
                    y = r && r[Y],
                    C = function C(a, c) {
                    var d = a._d;return d.v[o](c * b + d.o, Ca);
                },
                    D = function D(a, c, d) {
                    var e = a._d;j && (d = (d = Math.round(d)) < 0 ? 0 : d > 255 ? 255 : 255 & d), e.v[p](c * b + e.o, d, Ca);
                },
                    E = function E(a, b) {
                    Q(a, b, { get: function get() {
                            return C(this, b);
                        }, set: function set(a) {
                            return D(this, b, a);
                        }, enumerable: !0 });
                };u ? (r = d(function (a, d, e, f) {
                    l(a, r, k, "_d");var g,
                        h,
                        i,
                        j,
                        m = 0,
                        o = 0;if (w(d)) {
                        if (!(d instanceof $ || (j = v(d)) == V || j == W)) return ya in d ? Ja(r, d) : La.call(r, d);g = d, o = Fa(e, b);var p = d.byteLength;if (f === c) {
                            if (p % b) throw S(Aa);if (h = p - o, h < 0) throw S(Aa);
                        } else if (h = q(f) * b, h + o > p) throw S(Aa);i = h / b;
                    } else i = Ea(d, !0), h = i * b, g = new $(h);for (n(a, "_d", { b: g, o: o, l: h, e: i, v: new _(g) }); m < i;) {
                        E(a, m++);
                    }
                }), y = r[Y] = z(Wa), n(y, "constructor", r)) : K(function (a) {
                    new r(null), new r(a);
                }, !0) || (r = d(function (a, d, e, f) {
                    l(a, r, k);var g;return w(d) ? d instanceof $ || (g = v(d)) == V || g == W ? f !== c ? new s(d, Fa(e, b), f) : e !== c ? new s(d, Fa(e, b)) : new s(d) : ya in d ? Ja(r, d) : La.call(r, d) : new s(Ea(d, m));
                }), aa(t !== Function.prototype ? B(s).concat(B(t)) : B(s), function (a) {
                    a in r || n(r, a, s[a]);
                }), r[Y] = y, e || (y.constructor = r));var F = y[ta],
                    G = !!F && ("values" == F.name || F.name == c),
                    H = Sa.values;n(r, va, !0), n(y, ya, k), n(y, za, !0), n(y, wa, r), (j ? new r(1)[ua] == k : ua in y) || Q(y, ua, { get: function get() {
                        return k;
                    } }), x[k] = r, h(h.G + h.W + h.F * (r != s), x), h(h.S, k, { BYTES_PER_ELEMENT: b, from: La, of: Ma }), X in y || n(y, X, b), h(h.P, k, Pa), L(k), h(h.P + h.F * Da, k, { set: Ra }), h(h.P + h.F * !G, k, Sa), h(h.P + h.F * (y.toString != ra), k, { toString: ra }), h(h.P + h.F * g(function () {
                    new r(1).slice();
                }), k, { slice: Qa }), h(h.P + h.F * (g(function () {
                    return [1, 2].toLocaleString() != new r([1, 2]).toLocaleString();
                }) || !g(function () {
                    y.toLocaleString.call([1, 2]);
                })), k, { toLocaleString: Oa }), J[k] = G ? F : H, e || G || n(y, ta, H);
            };
        } else a.exports = function () {};
    }, function (a, b, c) {
        c(236)("Uint8", 1, function (a) {
            return function Uint8Array(b, c, d) {
                return a(this, b, c, d);
            };
        });
    }, function (a, b, c) {
        c(236)("Uint8", 1, function (a) {
            return function Uint8ClampedArray(b, c, d) {
                return a(this, b, c, d);
            };
        }, !0);
    }, function (a, b, c) {
        c(236)("Int16", 2, function (a) {
            return function Int16Array(b, c, d) {
                return a(this, b, c, d);
            };
        });
    }, function (a, b, c) {
        c(236)("Uint16", 2, function (a) {
            return function Uint16Array(b, c, d) {
                return a(this, b, c, d);
            };
        });
    }, function (a, b, c) {
        c(236)("Int32", 4, function (a) {
            return function Int32Array(b, c, d) {
                return a(this, b, c, d);
            };
        });
    }, function (a, b, c) {
        c(236)("Uint32", 4, function (a) {
            return function Uint32Array(b, c, d) {
                return a(this, b, c, d);
            };
        });
    }, function (a, b, c) {
        c(236)("Float32", 4, function (a) {
            return function Float32Array(b, c, d) {
                return a(this, b, c, d);
            };
        });
    }, function (a, b, c) {
        c(236)("Float64", 8, function (a) {
            return function Float64Array(b, c, d) {
                return a(this, b, c, d);
            };
        });
    }, function (a, b, d) {
        var e = d(6),
            f = d(34)(!0);e(e.P, "Array", { includes: function includes(a) {
                return f(this, a, arguments.length > 1 ? arguments[1] : c);
            } }), d(178)("includes");
    }, function (a, b, c) {
        var d = c(6),
            e = c(125)(!0);d(d.P, "String", { at: function at(a) {
                return e(this, a);
            } });
    }, function (a, b, d) {
        var e = d(6),
            f = d(248);e(e.P, "String", { padStart: function padStart(a) {
                return f(this, a, arguments.length > 1 ? arguments[1] : c, !0);
            } });
    }, function (a, b, d) {
        var e = d(35),
            f = d(85),
            g = d(33);a.exports = function (a, b, d, h) {
            var i = String(g(a)),
                j = i.length,
                k = d === c ? " " : String(d),
                l = e(b);if (l <= j || "" == k) return i;var m = l - j,
                n = f.call(k, Math.ceil(m / k.length));return n.length > m && (n = n.slice(0, m)), h ? n + i : i + n;
        };
    }, function (a, b, d) {
        var e = d(6),
            f = d(248);e(e.P, "String", { padEnd: function padEnd(a) {
                return f(this, a, arguments.length > 1 ? arguments[1] : c, !1);
            } });
    }, function (a, b, c) {
        c(81)("trimLeft", function (a) {
            return function trimLeft() {
                return a(this, 1);
            };
        }, "trimStart");
    }, function (a, b, c) {
        c(81)("trimRight", function (a) {
            return function trimRight() {
                return a(this, 2);
            };
        }, "trimEnd");
    }, function (a, b, c) {
        var d = c(6),
            e = c(33),
            f = c(35),
            g = c(128),
            h = c(188),
            i = RegExp.prototype,
            j = function j(a, b) {
            this._r = a, this._s = b;
        };c(136)(j, "RegExp String", function next() {
            var a = this._r.exec(this._s);return { value: a, done: null === a };
        }), d(d.P, "String", { matchAll: function matchAll(a) {
                if (e(this), !g(a)) throw TypeError(a + " is not a regexp!");var b = String(this),
                    c = "flags" in i ? String(a.flags) : h.call(a),
                    d = new RegExp(a.source, ~c.indexOf("g") ? c : "g" + c);return d.lastIndex = f(a.lastIndex), new j(d, b);
            } });
    }, function (a, b, c) {
        c(25)("asyncIterator");
    }, function (a, b, c) {
        c(25)("observable");
    }, function (a, b, c) {
        var d = c(6),
            e = c(221),
            f = c(30),
            g = c(49),
            h = c(155);d(d.S, "Object", { getOwnPropertyDescriptors: function getOwnPropertyDescriptors(a) {
                for (var b, c = f(a), d = g.f, i = e(c), j = {}, k = 0; i.length > k;) {
                    h(j, b = i[k++], d(c, b));
                }return j;
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(257)(!1);d(d.S, "Object", { values: function values(a) {
                return e(a);
            } });
    }, function (a, b, c) {
        var d = c(28),
            e = c(30),
            f = c(42).f;a.exports = function (a) {
            return function (b) {
                for (var c, g = e(b), h = d(g), i = h.length, j = 0, k = []; i > j;) {
                    f.call(g, c = h[j++]) && k.push(a ? [c, g[c]] : g[c]);
                }return k;
            };
        };
    }, function (a, b, c) {
        var d = c(6),
            e = c(257)(!0);d(d.S, "Object", { entries: function entries(a) {
                return e(a);
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(56),
            f = c(19),
            g = c(9);c(4) && d(d.P + c(260), "Object", { __defineGetter__: function __defineGetter__(a, b) {
                g.f(e(this), a, { get: f(b), enumerable: !0, configurable: !0 });
            } });
    }, function (a, b, c) {
        a.exports = c(26) || !c(5)(function () {
            var a = Math.random();__defineSetter__.call(null, a, function () {}), delete c(2)[a];
        });
    }, function (a, b, c) {
        var d = c(6),
            e = c(56),
            f = c(19),
            g = c(9);c(4) && d(d.P + c(260), "Object", { __defineSetter__: function __defineSetter__(a, b) {
                g.f(e(this), a, { set: f(b), enumerable: !0, configurable: !0 });
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(56),
            f = c(14),
            g = c(57),
            h = c(49).f;c(4) && d(d.P + c(260), "Object", { __lookupGetter__: function __lookupGetter__(a) {
                var b,
                    c = e(this),
                    d = f(a, !0);do {
                    if (b = h(c, d)) return b.get;
                } while (c = g(c));
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(56),
            f = c(14),
            g = c(57),
            h = c(49).f;c(4) && d(d.P + c(260), "Object", { __lookupSetter__: function __lookupSetter__(a) {
                var b,
                    c = e(this),
                    d = f(a, !0);do {
                    if (b = h(c, d)) return b.set;
                } while (c = g(c));
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.P + d.R, "Map", { toJSON: c(265)("Map") });
    }, function (a, b, c) {
        var d = c(73),
            e = c(266);a.exports = function (a) {
            return function toJSON() {
                if (d(this) != a) throw TypeError(a + "#toJSON isn't generic");return e(this);
            };
        };
    }, function (a, b, c) {
        var d = c(198);a.exports = function (a, b) {
            var c = [];return d(a, !1, c.push, c, b), c;
        };
    }, function (a, b, c) {
        var d = c(6);d(d.P + d.R, "Set", { toJSON: c(265)("Set") });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "System", { global: c(2) });
    }, function (a, b, c) {
        var d = c(6),
            e = c(32);d(d.S, "Error", { isError: function isError(a) {
                return "Error" === e(a);
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Math", { iaddh: function iaddh(a, b, c, d) {
                var e = a >>> 0,
                    f = b >>> 0,
                    g = c >>> 0;return f + (d >>> 0) + ((e & g | (e | g) & ~(e + g >>> 0)) >>> 31) | 0;
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Math", { isubh: function isubh(a, b, c, d) {
                var e = a >>> 0,
                    f = b >>> 0,
                    g = c >>> 0;return f - (d >>> 0) - ((~e & g | ~(e ^ g) & e - g >>> 0) >>> 31) | 0;
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Math", { imulh: function imulh(a, b) {
                var c = 65535,
                    d = +a,
                    e = +b,
                    f = d & c,
                    g = e & c,
                    h = d >> 16,
                    i = e >> 16,
                    j = (h * g >>> 0) + (f * g >>> 16);return h * i + (j >> 16) + ((f * i >>> 0) + (j & c) >> 16);
            } });
    }, function (a, b, c) {
        var d = c(6);d(d.S, "Math", { umulh: function umulh(a, b) {
                var c = 65535,
                    d = +a,
                    e = +b,
                    f = d & c,
                    g = e & c,
                    h = d >>> 16,
                    i = e >>> 16,
                    j = (h * g >>> 0) + (f * g >>> 16);return h * i + (j >>> 16) + ((f * i >>> 0) + (j & c) >>> 16);
            } });
    }, function (a, b, c) {
        var d = c(275),
            e = c(10),
            f = d.key,
            g = d.set;d.exp({ defineMetadata: function defineMetadata(a, b, c, d) {
                g(a, b, e(c), f(d));
            } });
    }, function (a, b, d) {
        var e = d(203),
            f = d(6),
            g = d(21)("metadata"),
            h = g.store || (g.store = new (d(207))()),
            i = function i(a, b, d) {
            var f = h.get(a);if (!f) {
                if (!d) return c;h.set(a, f = new e());
            }var g = f.get(b);if (!g) {
                if (!d) return c;f.set(b, g = new e());
            }return g;
        },
            j = function j(a, b, d) {
            var e = i(b, d, !1);return e !== c && e.has(a);
        },
            k = function k(a, b, d) {
            var e = i(b, d, !1);return e === c ? c : e.get(a);
        },
            l = function l(a, b, c, d) {
            i(c, d, !0).set(a, b);
        },
            m = function m(a, b) {
            var c = i(a, b, !1),
                d = [];return c && c.forEach(function (a, b) {
                d.push(b);
            }), d;
        },
            n = function n(a) {
            return a === c || "symbol" == (typeof a === "undefined" ? "undefined" : _typeof(a)) ? a : String(a);
        },
            o = function o(a) {
            f(f.S, "Reflect", a);
        };a.exports = { store: h, map: i, has: j, get: k, set: l, keys: m, key: n, exp: o };
    }, function (a, b, d) {
        var e = d(275),
            f = d(10),
            g = e.key,
            h = e.map,
            i = e.store;e.exp({ deleteMetadata: function deleteMetadata(a, b) {
                var d = arguments.length < 3 ? c : g(arguments[2]),
                    e = h(f(b), d, !1);if (e === c || !e["delete"](a)) return !1;if (e.size) return !0;var j = i.get(b);return j["delete"](d), !!j.size || i["delete"](b);
            } });
    }, function (a, b, d) {
        var e = d(275),
            f = d(10),
            g = d(57),
            h = e.has,
            i = e.get,
            j = e.key,
            k = function k(a, b, d) {
            var e = h(a, b, d);if (e) return i(a, b, d);var f = g(b);return null !== f ? k(a, f, d) : c;
        };e.exp({ getMetadata: function getMetadata(a, b) {
                return k(a, f(b), arguments.length < 3 ? c : j(arguments[2]));
            } });
    }, function (a, b, d) {
        var e = d(206),
            f = d(266),
            g = d(275),
            h = d(10),
            i = d(57),
            j = g.keys,
            k = g.key,
            l = function l(a, b) {
            var c = j(a, b),
                d = i(a);if (null === d) return c;var g = l(d, b);return g.length ? c.length ? f(new e(c.concat(g))) : g : c;
        };g.exp({ getMetadataKeys: function getMetadataKeys(a) {
                return l(h(a), arguments.length < 2 ? c : k(arguments[1]));
            } });
    }, function (a, b, d) {
        var e = d(275),
            f = d(10),
            g = e.get,
            h = e.key;e.exp({ getOwnMetadata: function getOwnMetadata(a, b) {
                return g(a, f(b), arguments.length < 3 ? c : h(arguments[2]));
            } });
    }, function (a, b, d) {
        var e = d(275),
            f = d(10),
            g = e.keys,
            h = e.key;e.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(a) {
                return g(f(a), arguments.length < 2 ? c : h(arguments[1]));
            } });
    }, function (a, b, d) {
        var e = d(275),
            f = d(10),
            g = d(57),
            h = e.has,
            i = e.key,
            j = function j(a, b, c) {
            var d = h(a, b, c);if (d) return !0;var e = g(b);return null !== e && j(a, e, c);
        };e.exp({ hasMetadata: function hasMetadata(a, b) {
                return j(a, f(b), arguments.length < 3 ? c : i(arguments[2]));
            } });
    }, function (a, b, d) {
        var e = d(275),
            f = d(10),
            g = e.has,
            h = e.key;e.exp({ hasOwnMetadata: function hasOwnMetadata(a, b) {
                return g(a, f(b), arguments.length < 3 ? c : h(arguments[2]));
            } });
    }, function (a, b, d) {
        var e = d(275),
            f = d(10),
            g = d(19),
            h = e.key,
            i = e.set;e.exp({ metadata: function metadata(a, b) {
                return function decorator(d, e) {
                    i(a, b, (e !== c ? f : g)(d), h(e));
                };
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(201)(),
            f = c(2).process,
            g = "process" == c(32)(f);d(d.G, { asap: function asap(a) {
                var b = g && f.domain;e(b ? b.bind(a) : a);
            } });
    }, function (a, b, d) {
        var e = d(6),
            f = d(2),
            g = d(7),
            h = d(201)(),
            i = d(23)("observable"),
            j = d(19),
            k = d(10),
            l = d(197),
            m = d(202),
            n = d(8),
            o = d(198),
            p = o.RETURN,
            q = function q(a) {
            return null == a ? c : j(a);
        },
            r = function r(a) {
            var b = a._c;b && (a._c = c, b());
        },
            s = function s(a) {
            return a._o === c;
        },
            t = function t(a) {
            s(a) || (a._o = c, r(a));
        },
            u = function u(a, b) {
            k(a), this._c = c, this._o = a, a = new v(this);try {
                var d = b(a),
                    e = d;null != d && ("function" == typeof d.unsubscribe ? d = function d() {
                    e.unsubscribe();
                } : j(d), this._c = d);
            } catch (f) {
                return void a.error(f);
            }s(this) && r(this);
        };u.prototype = m({}, { unsubscribe: function unsubscribe() {
                t(this);
            } });var v = function v(a) {
            this._s = a;
        };v.prototype = m({}, { next: function next(a) {
                var b = this._s;if (!s(b)) {
                    var c = b._o;try {
                        var d = q(c.next);if (d) return d.call(c, a);
                    } catch (e) {
                        try {
                            t(b);
                        } finally {
                            throw e;
                        }
                    }
                }
            }, error: function error(a) {
                var b = this._s;if (s(b)) throw a;var d = b._o;b._o = c;try {
                    var e = q(d.error);if (!e) throw a;a = e.call(d, a);
                } catch (f) {
                    try {
                        r(b);
                    } finally {
                        throw f;
                    }
                }return r(b), a;
            }, complete: function complete(a) {
                var b = this._s;if (!s(b)) {
                    var d = b._o;b._o = c;try {
                        var e = q(d.complete);a = e ? e.call(d, a) : c;
                    } catch (f) {
                        try {
                            r(b);
                        } finally {
                            throw f;
                        }
                    }return r(b), a;
                }
            } });var w = function Observable(a) {
            l(this, w, "Observable", "_f")._f = j(a);
        };m(w.prototype, { subscribe: function subscribe(a) {
                return new u(a, this._f);
            }, forEach: function forEach(a) {
                var b = this;return new (g.Promise || f.Promise)(function (c, d) {
                    j(a);var e = b.subscribe({ next: function next(b) {
                            try {
                                return a(b);
                            } catch (c) {
                                d(c), e.unsubscribe();
                            }
                        }, error: d, complete: c });
                });
            } }), m(w, { from: function from(a) {
                var b = "function" == typeof this ? this : w,
                    c = q(k(a)[i]);if (c) {
                    var d = k(c.call(a));return d.constructor === b ? d : new b(function (a) {
                        return d.subscribe(a);
                    });
                }return new b(function (b) {
                    var c = !1;return h(function () {
                        if (!c) {
                            try {
                                if (o(a, !1, function (a) {
                                    if (b.next(a), c) return p;
                                }) === p) return;
                            } catch (d) {
                                if (c) throw d;return void b.error(d);
                            }b.complete();
                        }
                    }), function () {
                        c = !0;
                    };
                });
            }, of: function of() {
                for (var a = 0, b = arguments.length, c = Array(b); a < b;) {
                    c[a] = arguments[a++];
                }return new ("function" == typeof this ? this : w)(function (a) {
                    var b = !1;return h(function () {
                        if (!b) {
                            for (var d = 0; d < c.length; ++d) {
                                if (a.next(c[d]), b) return;
                            }a.complete();
                        }
                    }), function () {
                        b = !0;
                    };
                });
            } }), n(w.prototype, i, function () {
            return this;
        }), e(e.G, { Observable: w }), d(186)("Observable");
    }, function (a, b, c) {
        var d = c(6),
            e = c(200);d(d.G + d.B, { setImmediate: e.set, clearImmediate: e.clear });
    }, function (a, b, c) {
        for (var d = c(183), e = c(16), f = c(2), g = c(8), h = c(135), i = c(23), j = i("iterator"), k = i("toStringTag"), l = h.Array, m = ["NodeList", "DOMTokenList", "MediaList", "StyleSheetList", "CSSRuleList"], n = 0; n < 5; n++) {
            var o,
                p = m[n],
                q = f[p],
                r = q && q.prototype;if (r) {
                r[j] || g(r, j, l), r[k] || g(r, k, p), h[p] = l;for (o in d) {
                    r[o] || e(r, o, d[o], !0);
                }
            }
        }
    }, function (a, b, c) {
        var d = c(2),
            e = c(6),
            f = c(76),
            g = c(289),
            h = d.navigator,
            i = !!h && /MSIE .\./.test(h.userAgent),
            j = function j(a) {
            return i ? function (b, c) {
                return a(f(g, [].slice.call(arguments, 2), "function" == typeof b ? b : Function(b)), c);
            } : a;
        };e(e.G + e.B + e.F * i, { setTimeout: j(d.setTimeout), setInterval: j(d.setInterval) });
    }, function (a, b, c) {
        var d = c(290),
            e = c(76),
            f = c(19);a.exports = function () {
            for (var a = f(this), b = arguments.length, c = Array(b), g = 0, h = d._, i = !1; b > g;) {
                (c[g] = arguments[g++]) === h && (i = !0);
            }return function () {
                var d,
                    f = this,
                    g = arguments.length,
                    j = 0,
                    k = 0;if (!i && !g) return e(a, c, f);if (d = c.slice(), i) for (; b > j; j++) {
                    d[j] === h && (d[j] = arguments[k++]);
                }for (; g > k;) {
                    d.push(arguments[k++]);
                }return e(a, d, f);
            };
        };
    }, function (a, b, c) {
        a.exports = c(2);
    }, function (a, b, d) {
        function Dict(a) {
            var b = i(null);return a != c && (p(a) ? o(a, !0, function (a, c) {
                b[a] = c;
            }) : h(b, a)), b;
        }function reduce(a, b, c) {
            n(b);var d,
                e,
                f = t(a),
                g = k(f),
                h = g.length,
                i = 0;if (arguments.length < 3) {
                if (!h) throw TypeError("Reduce of empty object with no initial value");d = f[g[i++]];
            } else d = Object(c);for (; h > i;) {
                v(f, e = g[i++]) && (d = b(d, f[e], e, a));
            }return d;
        }function includes(a, b) {
            return (b == b ? m(a, b) : x(a, function (a) {
                return a != a;
            })) !== c;
        }function get(a, b) {
            if (v(a, b)) return a[b];
        }function set(a, b, c) {
            return u && b in Object ? l.f(a, b, g(0, c)) : a[b] = c, a;
        }function isDict(a) {
            return s(a) && j(a) === Dict.prototype;
        }var e = d(18),
            f = d(6),
            g = d(15),
            h = d(67),
            i = d(44),
            j = d(57),
            k = d(28),
            l = d(9),
            m = d(27),
            n = d(19),
            o = d(198),
            p = d(292),
            q = d(136),
            r = d(184),
            s = d(11),
            t = d(30),
            u = d(4),
            v = d(3),
            w = function w(a) {
            var b = 1 == a,
                d = 4 == a;return function (f, g, h) {
                var i,
                    j,
                    k,
                    l = e(g, h, 3),
                    m = t(f),
                    n = b || 7 == a || 2 == a ? new ("function" == typeof this ? this : Dict)() : c;for (i in m) {
                    if (v(m, i) && (j = m[i], k = l(j, i, f), a)) if (b) n[i] = k;else if (k) switch (a) {case 2:
                            n[i] = j;break;case 3:
                            return !0;case 5:
                            return j;case 6:
                            return i;case 7:
                            n[k[0]] = k[1];} else if (d) return !1;
                }return 3 == a || d ? d : n;
            };
        },
            x = w(6),
            y = function y(a) {
            return function (b) {
                return new z(b, a);
            };
        },
            z = function z(a, b) {
            this._t = t(a), this._a = k(a), this._i = 0, this._k = b;
        };q(z, "Dict", function () {
            var a,
                b = this,
                d = b._t,
                e = b._a,
                f = b._k;do {
                if (b._i >= e.length) return b._t = c, r(1);
            } while (!v(d, a = e[b._i++]));return "keys" == f ? r(0, a) : "values" == f ? r(0, d[a]) : r(0, [a, d[a]]);
        }), Dict.prototype = null, f(f.G + f.F, { Dict: Dict }), f(f.S, "Dict", { keys: y("keys"), values: y("values"), entries: y("entries"), forEach: w(0), map: w(1), filter: w(2), some: w(3), every: w(4), find: w(5), findKey: x, mapPairs: w(7), reduce: reduce, keyOf: m, includes: includes, has: v, get: get, set: set, isDict: isDict });
    }, function (a, b, d) {
        var e = d(73),
            f = d(23)("iterator"),
            g = d(135);a.exports = d(7).isIterable = function (a) {
            var b = Object(a);return b[f] !== c || "@@iterator" in b || g.hasOwnProperty(e(b));
        };
    }, function (a, b, c) {
        var d = c(10),
            e = c(156);a.exports = c(7).getIterator = function (a) {
            var b = e(a);if ("function" != typeof b) throw TypeError(a + " is not iterable!");return d(b.call(a));
        };
    }, function (a, b, c) {
        var d = c(2),
            e = c(7),
            f = c(6),
            g = c(289);f(f.G + f.F, { delay: function delay(a) {
                return new (e.Promise || d.Promise)(function (b) {
                    setTimeout(g.call(b, !0), a);
                });
            } });
    }, function (a, b, c) {
        var d = c(290),
            e = c(6);c(7)._ = d._ = d._ || {}, e(e.P + e.F, "Function", { part: c(289) });
    }, function (a, b, c) {
        var d = c(6);d(d.S + d.F, "Object", { isObject: c(11) });
    }, function (a, b, c) {
        var d = c(6);d(d.S + d.F, "Object", { classof: c(73) });
    }, function (a, b, c) {
        var d = c(6),
            e = c(299);d(d.S + d.F, "Object", { define: e });
    }, function (a, b, c) {
        var d = c(9),
            e = c(49),
            f = c(221),
            g = c(30);a.exports = function define(a, b) {
            for (var c, h = f(g(b)), i = h.length, j = 0; i > j;) {
                d.f(a, c = h[j++], e.f(b, c));
            }return a;
        };
    }, function (a, b, c) {
        var d = c(6),
            e = c(299),
            f = c(44);d(d.S + d.F, "Object", { make: function make(a, b) {
                return e(f(a), b);
            } });
    }, function (a, b, d) {
        d(134)(Number, "Number", function (a) {
            this._l = +a, this._i = 0;
        }, function () {
            var a = this._i++,
                b = !(a < this._l);return { done: b, value: b ? c : a };
        });
    }, function (a, b, c) {
        var d = c(6),
            e = c(303)(/[\\^$*+?.()|[\]{}]/g, "\\$&");d(d.S, "RegExp", { escape: function escape(a) {
                return e(a);
            } });
    }, function (a, b) {
        a.exports = function (a, b) {
            var c = b === Object(b) ? function (a) {
                return b[a];
            } : b;return function (b) {
                return String(b).replace(a, c);
            };
        };
    }, function (a, b, c) {
        var d = c(6),
            e = c(303)(/[&<>"']/g, { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&apos;" });d(d.P + d.F, "String", { escapeHTML: function escapeHTML() {
                return e(this);
            } });
    }, function (a, b, c) {
        var d = c(6),
            e = c(303)(/&(?:amp|lt|gt|quot|apos);/g, { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&apos;": "'" });d(d.P + d.F, "String", { unescapeHTML: function unescapeHTML() {
                return e(this);
            } });
    }]), "undefined" != typeof module && module.exports ? module.exports = a : "function" == typeof define && define.amd ? define(function () {
        return a;
    }) : b.core = a;
}(1, 1);

(function (global, factory) {
    (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.THREE = global.THREE || {});
})(window, function (exports) {
    'use strict';

    // Polyfills

    if (Number.EPSILON === undefined) {

        Number.EPSILON = Math.pow(2, -52);
    }

    if (Number.isInteger === undefined) {

        // Missing in IE
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

        Number.isInteger = function (value) {

            return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
        };
    }

    //

    if (Math.sign === undefined) {

        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

        Math.sign = function (x) {

            return x < 0 ? -1 : x > 0 ? 1 : +x;
        };
    }

    if (Function.prototype.name === undefined) {

        // Missing in IE
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

        Object.defineProperty(Function.prototype, 'name', {

            get: function get() {

                return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
            }

        });
    }

    if (Object.assign === undefined) {

        // Missing in IE
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

        (function () {

            Object.assign = function (target) {

                'use strict';

                if (target === undefined || target === null) {

                    throw new TypeError('Cannot convert undefined or null to object');
                }

                var output = Object(target);

                for (var index = 1; index < arguments.length; index++) {

                    var source = arguments[index];

                    if (source !== undefined && source !== null) {

                        for (var nextKey in source) {

                            if (Object.prototype.hasOwnProperty.call(source, nextKey)) {

                                output[nextKey] = source[nextKey];
                            }
                        }
                    }
                }

                return output;
            };
        })();
    }

    /**
     * https://github.com/mrdoob/eventdispatcher.js/
     */

    function EventDispatcher() {}

    Object.assign(EventDispatcher.prototype, {

        addEventListener: function addEventListener(type, listener) {

            if (this._listeners === undefined) this._listeners = {};

            var listeners = this._listeners;

            if (listeners[type] === undefined) {

                listeners[type] = [];
            }

            if (listeners[type].indexOf(listener) === -1) {

                listeners[type].push(listener);
            }
        },

        hasEventListener: function hasEventListener(type, listener) {

            if (this._listeners === undefined) return false;

            var listeners = this._listeners;

            return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
        },

        removeEventListener: function removeEventListener(type, listener) {

            if (this._listeners === undefined) return;

            var listeners = this._listeners;
            var listenerArray = listeners[type];

            if (listenerArray !== undefined) {

                var index = listenerArray.indexOf(listener);

                if (index !== -1) {

                    listenerArray.splice(index, 1);
                }
            }
        },

        dispatchEvent: function dispatchEvent(event) {

            if (this._listeners === undefined) return;

            var listeners = this._listeners;
            var listenerArray = listeners[event.type];

            if (listenerArray !== undefined) {

                event.target = this;

                var array = [],
                    i = 0;
                var length = listenerArray.length;

                for (i = 0; i < length; i++) {

                    array[i] = listenerArray[i];
                }

                for (i = 0; i < length; i++) {

                    array[i].call(this, event);
                }
            }
        }

    });

    var REVISION = '85';
    var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
    var CullFaceNone = 0;
    var CullFaceBack = 1;
    var CullFaceFront = 2;
    var CullFaceFrontBack = 3;
    var FrontFaceDirectionCW = 0;
    var FrontFaceDirectionCCW = 1;
    var BasicShadowMap = 0;
    var PCFShadowMap = 1;
    var PCFSoftShadowMap = 2;
    var FrontSide = 0;
    var BackSide = 1;
    var DoubleSide = 2;
    var FlatShading = 1;
    var SmoothShading = 2;
    var NoColors = 0;
    var FaceColors = 1;
    var VertexColors = 2;
    var NoBlending = 0;
    var NormalBlending = 1;
    var AdditiveBlending = 2;
    var SubtractiveBlending = 3;
    var MultiplyBlending = 4;
    var CustomBlending = 5;
    var AddEquation = 100;
    var SubtractEquation = 101;
    var ReverseSubtractEquation = 102;
    var MinEquation = 103;
    var MaxEquation = 104;
    var ZeroFactor = 200;
    var OneFactor = 201;
    var SrcColorFactor = 202;
    var OneMinusSrcColorFactor = 203;
    var SrcAlphaFactor = 204;
    var OneMinusSrcAlphaFactor = 205;
    var DstAlphaFactor = 206;
    var OneMinusDstAlphaFactor = 207;
    var DstColorFactor = 208;
    var OneMinusDstColorFactor = 209;
    var SrcAlphaSaturateFactor = 210;
    var NeverDepth = 0;
    var AlwaysDepth = 1;
    var LessDepth = 2;
    var LessEqualDepth = 3;
    var EqualDepth = 4;
    var GreaterEqualDepth = 5;
    var GreaterDepth = 6;
    var NotEqualDepth = 7;
    var MultiplyOperation = 0;
    var MixOperation = 1;
    var AddOperation = 2;
    var NoToneMapping = 0;
    var LinearToneMapping = 1;
    var ReinhardToneMapping = 2;
    var Uncharted2ToneMapping = 3;
    var CineonToneMapping = 4;
    var UVMapping = 300;
    var CubeReflectionMapping = 301;
    var CubeRefractionMapping = 302;
    var EquirectangularReflectionMapping = 303;
    var EquirectangularRefractionMapping = 304;
    var SphericalReflectionMapping = 305;
    var CubeUVReflectionMapping = 306;
    var CubeUVRefractionMapping = 307;
    var RepeatWrapping = 1000;
    var ClampToEdgeWrapping = 1001;
    var MirroredRepeatWrapping = 1002;
    var NearestFilter = 1003;
    var NearestMipMapNearestFilter = 1004;
    var NearestMipMapLinearFilter = 1005;
    var LinearFilter = 1006;
    var LinearMipMapNearestFilter = 1007;
    var LinearMipMapLinearFilter = 1008;
    var UnsignedByteType = 1009;
    var ByteType = 1010;
    var ShortType = 1011;
    var UnsignedShortType = 1012;
    var IntType = 1013;
    var UnsignedIntType = 1014;
    var FloatType = 1015;
    var HalfFloatType = 1016;
    var UnsignedShort4444Type = 1017;
    var UnsignedShort5551Type = 1018;
    var UnsignedShort565Type = 1019;
    var UnsignedInt248Type = 1020;
    var AlphaFormat = 1021;
    var RGBFormat = 1022;
    var RGBAFormat = 1023;
    var LuminanceFormat = 1024;
    var LuminanceAlphaFormat = 1025;
    var RGBEFormat = RGBAFormat;
    var DepthFormat = 1026;
    var DepthStencilFormat = 1027;
    var RGB_S3TC_DXT1_Format = 2001;
    var RGBA_S3TC_DXT1_Format = 2002;
    var RGBA_S3TC_DXT3_Format = 2003;
    var RGBA_S3TC_DXT5_Format = 2004;
    var RGB_PVRTC_4BPPV1_Format = 2100;
    var RGB_PVRTC_2BPPV1_Format = 2101;
    var RGBA_PVRTC_4BPPV1_Format = 2102;
    var RGBA_PVRTC_2BPPV1_Format = 2103;
    var RGB_ETC1_Format = 2151;
    var LoopOnce = 2200;
    var LoopRepeat = 2201;
    var LoopPingPong = 2202;
    var InterpolateDiscrete = 2300;
    var InterpolateLinear = 2301;
    var InterpolateSmooth = 2302;
    var ZeroCurvatureEnding = 2400;
    var ZeroSlopeEnding = 2401;
    var WrapAroundEnding = 2402;
    var TrianglesDrawMode = 0;
    var TriangleStripDrawMode = 1;
    var TriangleFanDrawMode = 2;
    var LinearEncoding = 3000;
    var sRGBEncoding = 3001;
    var GammaEncoding = 3007;
    var RGBEEncoding = 3002;
    var LogLuvEncoding = 3003;
    var RGBM7Encoding = 3004;
    var RGBM16Encoding = 3005;
    var RGBDEncoding = 3006;
    var BasicDepthPacking = 3200;
    var RGBADepthPacking = 3201;

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    var _Math = {

        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,

        generateUUID: function () {

            // http://www.broofa.com/Tools/Math.uuid.htm

            var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
            var uuid = new Array(36);
            var rnd = 0,
                r;

            return function generateUUID() {

                for (var i = 0; i < 36; i++) {

                    if (i === 8 || i === 13 || i === 18 || i === 23) {

                        uuid[i] = '-';
                    } else if (i === 14) {

                        uuid[i] = '4';
                    } else {

                        if (rnd <= 0x02) rnd = 0x2000000 + Math.random() * 0x1000000 | 0;
                        r = rnd & 0xf;
                        rnd = rnd >> 4;
                        uuid[i] = chars[i === 19 ? r & 0x3 | 0x8 : r];
                    }
                }

                return uuid.join('');
            };
        }(),

        clamp: function clamp(value, min, max) {

            return Math.max(min, Math.min(max, value));
        },

        // compute euclidian modulo of m % n
        // https://en.wikipedia.org/wiki/Modulo_operation

        euclideanModulo: function euclideanModulo(n, m) {

            return (n % m + m) % m;
        },

        // Linear mapping from range <a1, a2> to range <b1, b2>

        mapLinear: function mapLinear(x, a1, a2, b1, b2) {

            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
        },

        // https://en.wikipedia.org/wiki/Linear_interpolation

        lerp: function lerp(x, y, t) {

            return (1 - t) * x + t * y;
        },

        // http://en.wikipedia.org/wiki/Smoothstep

        smoothstep: function smoothstep(x, min, max) {

            if (x <= min) return 0;
            if (x >= max) return 1;

            x = (x - min) / (max - min);

            return x * x * (3 - 2 * x);
        },

        smootherstep: function smootherstep(x, min, max) {

            if (x <= min) return 0;
            if (x >= max) return 1;

            x = (x - min) / (max - min);

            return x * x * x * (x * (x * 6 - 15) + 10);
        },

        // Random integer from <low, high> interval

        randInt: function randInt(low, high) {

            return low + Math.floor(Math.random() * (high - low + 1));
        },

        // Random float from <low, high> interval

        randFloat: function randFloat(low, high) {

            return low + Math.random() * (high - low);
        },

        // Random float from <-range/2, range/2> interval

        randFloatSpread: function randFloatSpread(range) {

            return range * (0.5 - Math.random());
        },

        degToRad: function degToRad(degrees) {

            return degrees * _Math.DEG2RAD;
        },

        radToDeg: function radToDeg(radians) {

            return radians * _Math.RAD2DEG;
        },

        isPowerOfTwo: function isPowerOfTwo(value) {

            return (value & value - 1) === 0 && value !== 0;
        },

        nearestPowerOfTwo: function nearestPowerOfTwo(value) {

            return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
        },

        nextPowerOfTwo: function nextPowerOfTwo(value) {

            value--;
            value |= value >> 1;
            value |= value >> 2;
            value |= value >> 4;
            value |= value >> 8;
            value |= value >> 16;
            value++;

            return value;
        }

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author philogb / http://blog.thejit.org/
     * @author egraether / http://egraether.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */

    function Vector2(x, y) {

        this.x = x || 0;
        this.y = y || 0;
    }

    Object.defineProperties(Vector2.prototype, {

        "width": {

            get: function get() {

                return this.x;
            },

            set: function set(value) {

                this.x = value;
            }

        },

        "height": {

            get: function get() {

                return this.y;
            },

            set: function set(value) {

                this.y = value;
            }

        }

    });

    Object.assign(Vector2.prototype, {

        isVector2: true,

        set: function set(x, y) {

            this.x = x;
            this.y = y;

            return this;
        },

        setScalar: function setScalar(scalar) {

            this.x = scalar;
            this.y = scalar;

            return this;
        },

        setX: function setX(x) {

            this.x = x;

            return this;
        },

        setY: function setY(y) {

            this.y = y;

            return this;
        },

        setComponent: function setComponent(index, value) {

            switch (index) {

                case 0:
                    this.x = value;break;
                case 1:
                    this.y = value;break;
                default:
                    throw new Error('index is out of range: ' + index);

            }

            return this;
        },

        getComponent: function getComponent(index) {

            switch (index) {

                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error('index is out of range: ' + index);

            }
        },

        clone: function clone() {

            return new this.constructor(this.x, this.y);
        },

        copy: function copy(v) {

            this.x = v.x;
            this.y = v.y;

            return this;
        },

        add: function add(v, w) {

            if (w !== undefined) {

                console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                return this.addVectors(v, w);
            }

            this.x += v.x;
            this.y += v.y;

            return this;
        },

        addScalar: function addScalar(s) {

            this.x += s;
            this.y += s;

            return this;
        },

        addVectors: function addVectors(a, b) {

            this.x = a.x + b.x;
            this.y = a.y + b.y;

            return this;
        },

        addScaledVector: function addScaledVector(v, s) {

            this.x += v.x * s;
            this.y += v.y * s;

            return this;
        },

        sub: function sub(v, w) {

            if (w !== undefined) {

                console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                return this.subVectors(v, w);
            }

            this.x -= v.x;
            this.y -= v.y;

            return this;
        },

        subScalar: function subScalar(s) {

            this.x -= s;
            this.y -= s;

            return this;
        },

        subVectors: function subVectors(a, b) {

            this.x = a.x - b.x;
            this.y = a.y - b.y;

            return this;
        },

        multiply: function multiply(v) {

            this.x *= v.x;
            this.y *= v.y;

            return this;
        },

        multiplyScalar: function multiplyScalar(scalar) {

            this.x *= scalar;
            this.y *= scalar;

            return this;
        },

        divide: function divide(v) {

            this.x /= v.x;
            this.y /= v.y;

            return this;
        },

        divideScalar: function divideScalar(scalar) {

            return this.multiplyScalar(1 / scalar);
        },

        min: function min(v) {

            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);

            return this;
        },

        max: function max(v) {

            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);

            return this;
        },

        clamp: function clamp(min, max) {

            // This function assumes min < max, if this assumption isn't true it will not operate correctly

            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));

            return this;
        },

        clampScalar: function () {

            var min = new Vector2();
            var max = new Vector2();

            return function clampScalar(minVal, maxVal) {

                min.set(minVal, minVal);
                max.set(maxVal, maxVal);

                return this.clamp(min, max);
            };
        }(),

        clampLength: function clampLength(min, max) {

            var length = this.length();

            return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
        },

        floor: function floor() {

            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);

            return this;
        },

        ceil: function ceil() {

            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);

            return this;
        },

        round: function round() {

            this.x = Math.round(this.x);
            this.y = Math.round(this.y);

            return this;
        },

        roundToZero: function roundToZero() {

            this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);

            return this;
        },

        negate: function negate() {

            this.x = -this.x;
            this.y = -this.y;

            return this;
        },

        dot: function dot(v) {

            return this.x * v.x + this.y * v.y;
        },

        lengthSq: function lengthSq() {

            return this.x * this.x + this.y * this.y;
        },

        length: function length() {

            return Math.sqrt(this.x * this.x + this.y * this.y);
        },

        lengthManhattan: function lengthManhattan() {

            return Math.abs(this.x) + Math.abs(this.y);
        },

        normalize: function normalize() {

            return this.divideScalar(this.length());
        },

        angle: function angle() {

            // computes the angle in radians with respect to the positive x-axis

            var angle = Math.atan2(this.y, this.x);

            if (angle < 0) angle += 2 * Math.PI;

            return angle;
        },

        distanceTo: function distanceTo(v) {

            return Math.sqrt(this.distanceToSquared(v));
        },

        distanceToSquared: function distanceToSquared(v) {

            var dx = this.x - v.x,
                dy = this.y - v.y;
            return dx * dx + dy * dy;
        },

        distanceToManhattan: function distanceToManhattan(v) {

            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        },

        setLength: function setLength(length) {

            return this.multiplyScalar(length / this.length());
        },

        lerp: function lerp(v, alpha) {

            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;

            return this;
        },

        lerpVectors: function lerpVectors(v1, v2, alpha) {

            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },

        equals: function equals(v) {

            return v.x === this.x && v.y === this.y;
        },

        fromArray: function fromArray(array, offset) {

            if (offset === undefined) offset = 0;

            this.x = array[offset];
            this.y = array[offset + 1];

            return this;
        },

        toArray: function toArray(array, offset) {

            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;

            array[offset] = this.x;
            array[offset + 1] = this.y;

            return array;
        },

        fromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {

            if (offset !== undefined) {

                console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
            }

            this.x = attribute.getX(index);
            this.y = attribute.getY(index);

            return this;
        },

        rotateAround: function rotateAround(center, angle) {

            var c = Math.cos(angle),
                s = Math.sin(angle);

            var x = this.x - center.x;
            var y = this.y - center.y;

            this.x = x * c - y * s + center.x;
            this.y = x * s + y * c + center.y;

            return this;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     */

    var textureId = 0;

    function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {

        Object.defineProperty(this, 'id', { value: textureId++ });

        this.uuid = _Math.generateUUID();

        this.name = '';

        this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
        this.mipmaps = [];

        this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

        this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
        this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

        this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
        this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

        this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

        this.format = format !== undefined ? format : RGBAFormat;
        this.type = type !== undefined ? type : UnsignedByteType;

        this.offset = new Vector2(0, 0);
        this.repeat = new Vector2(1, 1);
        this.rotateMatrix = new Matrix3(); // xmh add

        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

        // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
        //
        // Also changing the encoding after already used by a Material will not automatically make the Material
        // update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
        this.encoding = encoding !== undefined ? encoding : LinearEncoding;

        this.version = 0;
        this.onUpdate = null;
    }

    Texture.DEFAULT_IMAGE = undefined;
    Texture.DEFAULT_MAPPING = UVMapping;

    Object.defineProperty(Texture.prototype, "needsUpdate", {

        set: function set(value) {

            if (value === true) this.version++;
        }

    });

    Object.assign(Texture.prototype, EventDispatcher.prototype, {

        constructor: Texture,

        isTexture: true,

        clone: function clone() {

            return new this.constructor().copy(this);
        },

        copy: function copy(source) {

            this.name = source.name;

            this.image = source.image;
            this.mipmaps = source.mipmaps.slice(0);

            this.mapping = source.mapping;

            this.wrapS = source.wrapS;
            this.wrapT = source.wrapT;

            this.magFilter = source.magFilter;
            this.minFilter = source.minFilter;

            this.anisotropy = source.anisotropy;

            this.format = source.format;
            this.type = source.type;

            this.offset.copy(source.offset);
            this.repeat.copy(source.repeat);

            this.rotateMatrix.copy(source.rotateMatrix); // xmh add

            this.generateMipmaps = source.generateMipmaps;
            this.premultiplyAlpha = source.premultiplyAlpha;
            this.flipY = source.flipY;
            this.unpackAlignment = source.unpackAlignment;
            this.encoding = source.encoding;

            return this;
        },

        toJSON: function toJSON(meta) {

            if (meta.textures[this.uuid] !== undefined) {

                return meta.textures[this.uuid];
            }

            function getDataURL(image) {

                var canvas;

                if (image.toDataURL !== undefined) {

                    canvas = image;
                } else {

                    canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                    canvas.width = image.width;
                    canvas.height = image.height;

                    canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height);
                }

                if (canvas.width > 2048 || canvas.height > 2048) {

                    return canvas.toDataURL('image/jpeg', 0.6);
                } else {

                    return canvas.toDataURL('image/png');
                }
            }

            var output = {
                metadata: {
                    version: 4.5,
                    type: 'Texture',
                    generator: 'Texture.toJSON'
                },

                uuid: this.uuid,
                name: this.name,

                mapping: this.mapping,

                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                wrap: [this.wrapS, this.wrapT],

                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,

                flipY: this.flipY
            };

            if (this.image !== undefined) {

                // TODO: Move to THREE.Image

                var image = this.image;

                if (image.uuid === undefined) {

                    image.uuid = _Math.generateUUID(); // UGH
                }

                if (meta.images[image.uuid] === undefined) {

                    meta.images[image.uuid] = {
                        uuid: image.uuid,
                        url: getDataURL(image)
                    };
                }

                output.image = image.uuid;
            }

            meta.textures[this.uuid] = output;

            return output;
        },

        dispose: function dispose() {

            this.dispatchEvent({ type: 'dispose' });
        },

        transformUv: function transformUv(uv) {

            if (this.mapping !== UVMapping) return;

            uv.multiply(this.repeat);
            uv.add(this.offset);

            if (uv.x < 0 || uv.x > 1) {

                switch (this.wrapS) {

                    case RepeatWrapping:

                        uv.x = uv.x - Math.floor(uv.x);
                        break;

                    case ClampToEdgeWrapping:

                        uv.x = uv.x < 0 ? 0 : 1;
                        break;

                    case MirroredRepeatWrapping:

                        if (Math.abs(Math.floor(uv.x) % 2) === 1) {

                            uv.x = Math.ceil(uv.x) - uv.x;
                        } else {

                            uv.x = uv.x - Math.floor(uv.x);
                        }
                        break;

                }
            }

            if (uv.y < 0 || uv.y > 1) {

                switch (this.wrapT) {

                    case RepeatWrapping:

                        uv.y = uv.y - Math.floor(uv.y);
                        break;

                    case ClampToEdgeWrapping:

                        uv.y = uv.y < 0 ? 0 : 1;
                        break;

                    case MirroredRepeatWrapping:

                        if (Math.abs(Math.floor(uv.y) % 2) === 1) {

                            uv.y = Math.ceil(uv.y) - uv.y;
                        } else {

                            uv.y = uv.y - Math.floor(uv.y);
                        }
                        break;

                }
            }

            if (this.flipY) {

                uv.y = 1 - uv.y;
            }
        },

        // xmh add
        setRotateAngle: function setRotateAngle(angle) {

            var radAngle = THREE.Math.degToRad(angle);
            var s = Math.sin(radAngle);
            var c = Math.cos(radAngle);

            this.rotateMatrix.elements[0] = c;
            this.rotateMatrix.elements[1] = s;
            this.rotateMatrix.elements[3] = -s;
            this.rotateMatrix.elements[4] = c;
        }

    });

    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     */

    function Vector4(x, y, z, w) {

        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.w = w !== undefined ? w : 1;
    }

    Object.assign(Vector4.prototype, {

        isVector4: true,

        set: function set(x, y, z, w) {

            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;

            return this;
        },

        setScalar: function setScalar(scalar) {

            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
            this.w = scalar;

            return this;
        },

        setX: function setX(x) {

            this.x = x;

            return this;
        },

        setY: function setY(y) {

            this.y = y;

            return this;
        },

        setZ: function setZ(z) {

            this.z = z;

            return this;
        },

        setW: function setW(w) {

            this.w = w;

            return this;
        },

        setComponent: function setComponent(index, value) {

            switch (index) {

                case 0:
                    this.x = value;break;
                case 1:
                    this.y = value;break;
                case 2:
                    this.z = value;break;
                case 3:
                    this.w = value;break;
                default:
                    throw new Error('index is out of range: ' + index);

            }

            return this;
        },

        getComponent: function getComponent(index) {

            switch (index) {

                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error('index is out of range: ' + index);

            }
        },

        clone: function clone() {

            return new this.constructor(this.x, this.y, this.z, this.w);
        },

        copy: function copy(v) {

            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = v.w !== undefined ? v.w : 1;

            return this;
        },

        add: function add(v, w) {

            if (w !== undefined) {

                console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                return this.addVectors(v, w);
            }

            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            this.w += v.w;

            return this;
        },

        addScalar: function addScalar(s) {

            this.x += s;
            this.y += s;
            this.z += s;
            this.w += s;

            return this;
        },

        addVectors: function addVectors(a, b) {

            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;

            return this;
        },

        addScaledVector: function addScaledVector(v, s) {

            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            this.w += v.w * s;

            return this;
        },

        sub: function sub(v, w) {

            if (w !== undefined) {

                console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                return this.subVectors(v, w);
            }

            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            this.w -= v.w;

            return this;
        },

        subScalar: function subScalar(s) {

            this.x -= s;
            this.y -= s;
            this.z -= s;
            this.w -= s;

            return this;
        },

        subVectors: function subVectors(a, b) {

            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;

            return this;
        },

        multiplyScalar: function multiplyScalar(scalar) {

            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            this.w *= scalar;

            return this;
        },

        applyMatrix4: function applyMatrix4(m) {

            var x = this.x,
                y = this.y,
                z = this.z,
                w = this.w;
            var e = m.elements;

            this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
            this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
            this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;

            return this;
        },

        divideScalar: function divideScalar(scalar) {

            return this.multiplyScalar(1 / scalar);
        },

        setAxisAngleFromQuaternion: function setAxisAngleFromQuaternion(q) {

            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

            // q is assumed to be normalized

            this.w = 2 * Math.acos(q.w);

            var s = Math.sqrt(1 - q.w * q.w);

            if (s < 0.0001) {

                this.x = 1;
                this.y = 0;
                this.z = 0;
            } else {

                this.x = q.x / s;
                this.y = q.y / s;
                this.z = q.z / s;
            }

            return this;
        },

        setAxisAngleFromRotationMatrix: function setAxisAngleFromRotationMatrix(m) {

            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

            var angle,
                x,
                y,
                z,
                // variables for result
            epsilon = 0.01,
                // margin to allow for rounding errors
            epsilon2 = 0.1,
                // margin to distinguish between 0 and 180 degrees

            te = m.elements,
                m11 = te[0],
                m12 = te[4],
                m13 = te[8],
                m21 = te[1],
                m22 = te[5],
                m23 = te[9],
                m31 = te[2],
                m32 = te[6],
                m33 = te[10];

            if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {

                // singularity found
                // first check for identity matrix which must have +1 for all terms
                // in leading diagonal and zero in other terms

                if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {

                    // this singularity is identity matrix so angle = 0

                    this.set(1, 0, 0, 0);

                    return this; // zero angle, arbitrary axis
                }

                // otherwise this singularity is angle = 180

                angle = Math.PI;

                var xx = (m11 + 1) / 2;
                var yy = (m22 + 1) / 2;
                var zz = (m33 + 1) / 2;
                var xy = (m12 + m21) / 4;
                var xz = (m13 + m31) / 4;
                var yz = (m23 + m32) / 4;

                if (xx > yy && xx > zz) {

                    // m11 is the largest diagonal term

                    if (xx < epsilon) {

                        x = 0;
                        y = 0.707106781;
                        z = 0.707106781;
                    } else {

                        x = Math.sqrt(xx);
                        y = xy / x;
                        z = xz / x;
                    }
                } else if (yy > zz) {

                    // m22 is the largest diagonal term

                    if (yy < epsilon) {

                        x = 0.707106781;
                        y = 0;
                        z = 0.707106781;
                    } else {

                        y = Math.sqrt(yy);
                        x = xy / y;
                        z = yz / y;
                    }
                } else {

                    // m33 is the largest diagonal term so base result on this

                    if (zz < epsilon) {

                        x = 0.707106781;
                        y = 0.707106781;
                        z = 0;
                    } else {

                        z = Math.sqrt(zz);
                        x = xz / z;
                        y = yz / z;
                    }
                }

                this.set(x, y, z, angle);

                return this; // return 180 deg rotation
            }

            // as we have reached here there are no singularities so we can handle normally

            var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

            if (Math.abs(s) < 0.001) s = 1;

            // prevent divide by zero, should not happen if matrix is orthogonal and should be
            // caught by singularity test above, but I've left it in just in case

            this.x = (m32 - m23) / s;
            this.y = (m13 - m31) / s;
            this.z = (m21 - m12) / s;
            this.w = Math.acos((m11 + m22 + m33 - 1) / 2);

            return this;
        },

        min: function min(v) {

            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
            this.w = Math.min(this.w, v.w);

            return this;
        },

        max: function max(v) {

            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
            this.w = Math.max(this.w, v.w);

            return this;
        },

        clamp: function clamp(min, max) {

            // This function assumes min < max, if this assumption isn't true it will not operate correctly

            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));
            this.z = Math.max(min.z, Math.min(max.z, this.z));
            this.w = Math.max(min.w, Math.min(max.w, this.w));

            return this;
        },

        clampScalar: function () {

            var min = new Vector4();
            var max = new Vector4();

            return function clampScalar(minVal, maxVal) {

                min.set(minVal, minVal, minVal, minVal);
                max.set(maxVal, maxVal, maxVal, maxVal);

                return this.clamp(min, max);
            };
        }(),

        floor: function floor() {

            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            this.w = Math.floor(this.w);

            return this;
        },

        ceil: function ceil() {

            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            this.w = Math.ceil(this.w);

            return this;
        },

        round: function round() {

            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            this.w = Math.round(this.w);

            return this;
        },

        roundToZero: function roundToZero() {

            this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);

            return this;
        },

        negate: function negate() {

            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;

            return this;
        },

        dot: function dot(v) {

            return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        },

        lengthSq: function lengthSq() {

            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        },

        length: function length() {

            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        },

        lengthManhattan: function lengthManhattan() {

            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        },

        normalize: function normalize() {

            return this.divideScalar(this.length());
        },

        setLength: function setLength(length) {

            return this.multiplyScalar(length / this.length());
        },

        lerp: function lerp(v, alpha) {

            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            this.w += (v.w - this.w) * alpha;

            return this;
        },

        lerpVectors: function lerpVectors(v1, v2, alpha) {

            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },

        equals: function equals(v) {

            return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
        },

        fromArray: function fromArray(array, offset) {

            if (offset === undefined) offset = 0;

            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            this.w = array[offset + 3];

            return this;
        },

        toArray: function toArray(array, offset) {

            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;

            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            array[offset + 3] = this.w;

            return array;
        },

        fromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {

            if (offset !== undefined) {

                console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
            }

            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            this.z = attribute.getZ(index);
            this.w = attribute.getW(index);

            return this;
        }

    });

    /**
     * @author szimek / https://github.com/szimek/
     * @author alteredq / http://alteredqualia.com/
     * @author Marius Kintel / https://github.com/kintel
     */

    /*
     In options, we can specify:
     * Texture parameters for an auto-generated target texture
     * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
    */
    function WebGLRenderTarget(width, height, options) {

        this.uuid = _Math.generateUUID();

        this.width = width;
        this.height = height;

        this.scissor = new Vector4(0, 0, width, height);
        this.scissorTest = false;

        this.viewport = new Vector4(0, 0, width, height);

        options = options || {};

        if (options.minFilter === undefined) options.minFilter = LinearFilter;

        this.texture = new Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);

        this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
        this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
        this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
    }

    Object.assign(WebGLRenderTarget.prototype, EventDispatcher.prototype, {

        isWebGLRenderTarget: true,

        setSize: function setSize(width, height) {

            if (this.width !== width || this.height !== height) {

                this.width = width;
                this.height = height;

                this.dispose();
            }

            this.viewport.set(0, 0, width, height);
            this.scissor.set(0, 0, width, height);
        },

        clone: function clone() {

            return new this.constructor().copy(this);
        },

        copy: function copy(source) {

            this.width = source.width;
            this.height = source.height;

            this.viewport.copy(source.viewport);

            this.texture = source.texture.clone();

            this.depthBuffer = source.depthBuffer;
            this.stencilBuffer = source.stencilBuffer;
            this.depthTexture = source.depthTexture;

            return this;
        },

        dispose: function dispose() {

            this.dispatchEvent({ type: 'dispose' });
        }

    });

    /**
     * @author alteredq / http://alteredqualia.com
     */

    function WebGLRenderTargetCube(width, height, options) {

        WebGLRenderTarget.call(this, width, height, options);

        this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
        this.activeMipMapLevel = 0;
    }

    WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);
    WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

    WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */

    function Quaternion(x, y, z, w) {

        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._w = w !== undefined ? w : 1;
    }

    Object.assign(Quaternion, {

        slerp: function slerp(qa, qb, qm, t) {

            return qm.copy(qa).slerp(qb, t);
        },

        slerpFlat: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {

            // fuzz-free, array-based Quaternion SLERP operation

            var x0 = src0[srcOffset0 + 0],
                y0 = src0[srcOffset0 + 1],
                z0 = src0[srcOffset0 + 2],
                w0 = src0[srcOffset0 + 3],
                x1 = src1[srcOffset1 + 0],
                y1 = src1[srcOffset1 + 1],
                z1 = src1[srcOffset1 + 2],
                w1 = src1[srcOffset1 + 3];

            if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {

                var s = 1 - t,
                    cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
                    dir = cos >= 0 ? 1 : -1,
                    sqrSin = 1 - cos * cos;

                // Skip the Slerp for tiny steps to avoid numeric problems:
                if (sqrSin > Number.EPSILON) {

                    var sin = Math.sqrt(sqrSin),
                        len = Math.atan2(sin, cos * dir);

                    s = Math.sin(s * len) / sin;
                    t = Math.sin(t * len) / sin;
                }

                var tDir = t * dir;

                x0 = x0 * s + x1 * tDir;
                y0 = y0 * s + y1 * tDir;
                z0 = z0 * s + z1 * tDir;
                w0 = w0 * s + w1 * tDir;

                // Normalize in case we just did a lerp:
                if (s === 1 - t) {

                    var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);

                    x0 *= f;
                    y0 *= f;
                    z0 *= f;
                    w0 *= f;
                }
            }

            dst[dstOffset] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
        }

    });

    Object.defineProperties(Quaternion.prototype, {

        x: {

            get: function get() {

                return this._x;
            },

            set: function set(value) {

                this._x = value;
                this.onChangeCallback();
            }

        },

        y: {

            get: function get() {

                return this._y;
            },

            set: function set(value) {

                this._y = value;
                this.onChangeCallback();
            }

        },

        z: {

            get: function get() {

                return this._z;
            },

            set: function set(value) {

                this._z = value;
                this.onChangeCallback();
            }

        },

        w: {

            get: function get() {

                return this._w;
            },

            set: function set(value) {

                this._w = value;
                this.onChangeCallback();
            }

        }

    });

    Object.assign(Quaternion.prototype, {

        set: function set(x, y, z, w) {

            this._x = x;
            this._y = y;
            this._z = z;
            this._w = w;

            this.onChangeCallback();

            return this;
        },

        clone: function clone() {

            return new this.constructor(this._x, this._y, this._z, this._w);
        },

        copy: function copy(quaternion) {

            this._x = quaternion.x;
            this._y = quaternion.y;
            this._z = quaternion.z;
            this._w = quaternion.w;

            this.onChangeCallback();

            return this;
        },

        setFromEuler: function setFromEuler(euler, update) {

            if ((euler && euler.isEuler) === false) {

                throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
            }

            var x = euler._x,
                y = euler._y,
                z = euler._z,
                order = euler.order;

            // http://www.mathworks.com/matlabcentral/fileexchange/
            // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
            //	content/SpinCalc.m

            var cos = Math.cos;
            var sin = Math.sin;

            var c1 = cos(x / 2);
            var c2 = cos(y / 2);
            var c3 = cos(z / 2);

            var s1 = sin(x / 2);
            var s2 = sin(y / 2);
            var s3 = sin(z / 2);

            if (order === 'XYZ') {

                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            } else if (order === 'YXZ') {

                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            } else if (order === 'ZXY') {

                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            } else if (order === 'ZYX') {

                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            } else if (order === 'YZX') {

                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            } else if (order === 'XZY') {

                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            }

            if (update !== false) this.onChangeCallback();

            return this;
        },

        setFromAxisAngle: function setFromAxisAngle(axis, angle) {

            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

            // assumes axis is normalized

            var halfAngle = angle / 2,
                s = Math.sin(halfAngle);

            this._x = axis.x * s;
            this._y = axis.y * s;
            this._z = axis.z * s;
            this._w = Math.cos(halfAngle);

            this.onChangeCallback();

            return this;
        },

        setFromRotationMatrix: function setFromRotationMatrix(m) {

            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

            var te = m.elements,
                m11 = te[0],
                m12 = te[4],
                m13 = te[8],
                m21 = te[1],
                m22 = te[5],
                m23 = te[9],
                m31 = te[2],
                m32 = te[6],
                m33 = te[10],
                trace = m11 + m22 + m33,
                s;

            if (trace > 0) {

                s = 0.5 / Math.sqrt(trace + 1.0);

                this._w = 0.25 / s;
                this._x = (m32 - m23) * s;
                this._y = (m13 - m31) * s;
                this._z = (m21 - m12) * s;
            } else if (m11 > m22 && m11 > m33) {

                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);

                this._w = (m32 - m23) / s;
                this._x = 0.25 * s;
                this._y = (m12 + m21) / s;
                this._z = (m13 + m31) / s;
            } else if (m22 > m33) {

                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);

                this._w = (m13 - m31) / s;
                this._x = (m12 + m21) / s;
                this._y = 0.25 * s;
                this._z = (m23 + m32) / s;
            } else {

                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);

                this._w = (m21 - m12) / s;
                this._x = (m13 + m31) / s;
                this._y = (m23 + m32) / s;
                this._z = 0.25 * s;
            }

            this.onChangeCallback();

            return this;
        },

        setFromUnitVectors: function () {

            // assumes direction vectors vFrom and vTo are normalized

            var v1 = new Vector3();
            var r;

            var EPS = 0.000001;

            return function setFromUnitVectors(vFrom, vTo) {

                if (v1 === undefined) v1 = new Vector3();

                r = vFrom.dot(vTo) + 1;

                if (r < EPS) {

                    r = 0;

                    if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {

                        v1.set(-vFrom.y, vFrom.x, 0);
                    } else {

                        v1.set(0, -vFrom.z, vFrom.y);
                    }
                } else {

                    v1.crossVectors(vFrom, vTo);
                }

                this._x = v1.x;
                this._y = v1.y;
                this._z = v1.z;
                this._w = r;

                return this.normalize();
            };
        }(),

        inverse: function inverse() {

            return this.conjugate().normalize();
        },

        conjugate: function conjugate() {

            this._x *= -1;
            this._y *= -1;
            this._z *= -1;

            this.onChangeCallback();

            return this;
        },

        dot: function dot(v) {

            return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
        },

        lengthSq: function lengthSq() {

            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        },

        length: function length() {

            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        },

        normalize: function normalize() {

            var l = this.length();

            if (l === 0) {

                this._x = 0;
                this._y = 0;
                this._z = 0;
                this._w = 1;
            } else {

                l = 1 / l;

                this._x = this._x * l;
                this._y = this._y * l;
                this._z = this._z * l;
                this._w = this._w * l;
            }

            this.onChangeCallback();

            return this;
        },

        multiply: function multiply(q, p) {

            if (p !== undefined) {

                console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
                return this.multiplyQuaternions(q, p);
            }

            return this.multiplyQuaternions(this, q);
        },

        premultiply: function premultiply(q) {

            return this.multiplyQuaternions(q, this);
        },

        multiplyQuaternions: function multiplyQuaternions(a, b) {

            // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

            var qax = a._x,
                qay = a._y,
                qaz = a._z,
                qaw = a._w;
            var qbx = b._x,
                qby = b._y,
                qbz = b._z,
                qbw = b._w;

            this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
            this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
            this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
            this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

            this.onChangeCallback();

            return this;
        },

        slerp: function slerp(qb, t) {

            if (t === 0) return this;
            if (t === 1) return this.copy(qb);

            var x = this._x,
                y = this._y,
                z = this._z,
                w = this._w;

            // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

            var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

            if (cosHalfTheta < 0) {

                this._w = -qb._w;
                this._x = -qb._x;
                this._y = -qb._y;
                this._z = -qb._z;

                cosHalfTheta = -cosHalfTheta;
            } else {

                this.copy(qb);
            }

            if (cosHalfTheta >= 1.0) {

                this._w = w;
                this._x = x;
                this._y = y;
                this._z = z;

                return this;
            }

            var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

            if (Math.abs(sinHalfTheta) < 0.001) {

                this._w = 0.5 * (w + this._w);
                this._x = 0.5 * (x + this._x);
                this._y = 0.5 * (y + this._y);
                this._z = 0.5 * (z + this._z);

                return this;
            }

            var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
            var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
                ratioB = Math.sin(t * halfTheta) / sinHalfTheta;

            this._w = w * ratioA + this._w * ratioB;
            this._x = x * ratioA + this._x * ratioB;
            this._y = y * ratioA + this._y * ratioB;
            this._z = z * ratioA + this._z * ratioB;

            this.onChangeCallback();

            return this;
        },

        equals: function equals(quaternion) {

            return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
        },

        fromArray: function fromArray(array, offset) {

            if (offset === undefined) offset = 0;

            this._x = array[offset];
            this._y = array[offset + 1];
            this._z = array[offset + 2];
            this._w = array[offset + 3];

            this.onChangeCallback();

            return this;
        },

        toArray: function toArray(array, offset) {

            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;

            array[offset] = this._x;
            array[offset + 1] = this._y;
            array[offset + 2] = this._z;
            array[offset + 3] = this._w;

            return array;
        },

        onChange: function onChange(callback) {

            this.onChangeCallback = callback;

            return this;
        },

        onChangeCallback: function onChangeCallback() {}

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author *kile / http://kile.stravaganza.org/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     */

    function Vector3(x, y, z) {

        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
    }

    Object.assign(Vector3.prototype, {

        isVector3: true,

        set: function set(x, y, z) {

            this.x = x;
            this.y = y;
            this.z = z;

            return this;
        },

        setScalar: function setScalar(scalar) {

            this.x = scalar;
            this.y = scalar;
            this.z = scalar;

            return this;
        },

        setX: function setX(x) {

            this.x = x;

            return this;
        },

        setY: function setY(y) {

            this.y = y;

            return this;
        },

        setZ: function setZ(z) {

            this.z = z;

            return this;
        },

        setComponent: function setComponent(index, value) {

            switch (index) {

                case 0:
                    this.x = value;break;
                case 1:
                    this.y = value;break;
                case 2:
                    this.z = value;break;
                default:
                    throw new Error('index is out of range: ' + index);

            }

            return this;
        },

        getComponent: function getComponent(index) {

            switch (index) {

                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error('index is out of range: ' + index);

            }
        },

        clone: function clone() {

            return new this.constructor(this.x, this.y, this.z);
        },

        copy: function copy(v) {

            this.x = v.x;
            this.y = v.y;
            this.z = v.z;

            return this;
        },

        add: function add(v, w) {

            if (w !== undefined) {

                console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                return this.addVectors(v, w);
            }

            this.x += v.x;
            this.y += v.y;
            this.z += v.z;

            return this;
        },

        addScalar: function addScalar(s) {

            this.x += s;
            this.y += s;
            this.z += s;

            return this;
        },

        addVectors: function addVectors(a, b) {

            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;

            return this;
        },

        addScaledVector: function addScaledVector(v, s) {

            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;

            return this;
        },

        sub: function sub(v, w) {

            if (w !== undefined) {

                console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                return this.subVectors(v, w);
            }

            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;

            return this;
        },

        subScalar: function subScalar(s) {

            this.x -= s;
            this.y -= s;
            this.z -= s;

            return this;
        },

        subVectors: function subVectors(a, b) {

            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;

            return this;
        },

        multiply: function multiply(v, w) {

            if (w !== undefined) {

                console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
                return this.multiplyVectors(v, w);
            }

            this.x *= v.x;
            this.y *= v.y;
            this.z *= v.z;

            return this;
        },

        multiplyScalar: function multiplyScalar(scalar) {

            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;

            return this;
        },

        multiplyVectors: function multiplyVectors(a, b) {

            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;

            return this;
        },

        applyEuler: function () {

            var quaternion = new Quaternion();

            return function applyEuler(euler) {

                if ((euler && euler.isEuler) === false) {

                    console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
                }

                return this.applyQuaternion(quaternion.setFromEuler(euler));
            };
        }(),

        applyAxisAngle: function () {

            var quaternion = new Quaternion();

            return function applyAxisAngle(axis, angle) {

                return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
            };
        }(),

        applyMatrix3: function applyMatrix3(m) {

            var x = this.x,
                y = this.y,
                z = this.z;
            var e = m.elements;

            this.x = e[0] * x + e[3] * y + e[6] * z;
            this.y = e[1] * x + e[4] * y + e[7] * z;
            this.z = e[2] * x + e[5] * y + e[8] * z;

            return this;
        },

        applyMatrix4: function applyMatrix4(m) {

            var x = this.x,
                y = this.y,
                z = this.z;
            var e = m.elements;

            this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
            this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
            var w = e[3] * x + e[7] * y + e[11] * z + e[15];

            return this.divideScalar(w);
        },

        applyQuaternion: function applyQuaternion(q) {

            var x = this.x,
                y = this.y,
                z = this.z;
            var qx = q.x,
                qy = q.y,
                qz = q.z,
                qw = q.w;

            // calculate quat * vector

            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;

            // calculate result * inverse quat

            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

            return this;
        },

        project: function () {

            var matrix = new Matrix4();

            return function project(camera) {

                matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
                return this.applyMatrix4(matrix);
            };
        }(),

        unproject: function () {

            var matrix = new Matrix4();

            return function unproject(camera) {

                matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
                return this.applyMatrix4(matrix);
            };
        }(),

        transformDirection: function transformDirection(m) {

            // input: THREE.Matrix4 affine matrix
            // vector interpreted as a direction

            var x = this.x,
                y = this.y,
                z = this.z;
            var e = m.elements;

            this.x = e[0] * x + e[4] * y + e[8] * z;
            this.y = e[1] * x + e[5] * y + e[9] * z;
            this.z = e[2] * x + e[6] * y + e[10] * z;

            return this.normalize();
        },

        divide: function divide(v) {

            this.x /= v.x;
            this.y /= v.y;
            this.z /= v.z;

            return this;
        },

        divideScalar: function divideScalar(scalar) {

            return this.multiplyScalar(1 / scalar);
        },

        min: function min(v) {

            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);

            return this;
        },

        max: function max(v) {

            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);

            return this;
        },

        clamp: function clamp(min, max) {

            // This function assumes min < max, if this assumption isn't true it will not operate correctly

            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));
            this.z = Math.max(min.z, Math.min(max.z, this.z));

            return this;
        },

        clampScalar: function () {

            var min = new Vector3();
            var max = new Vector3();

            return function clampScalar(minVal, maxVal) {

                min.set(minVal, minVal, minVal);
                max.set(maxVal, maxVal, maxVal);

                return this.clamp(min, max);
            };
        }(),

        clampLength: function clampLength(min, max) {

            var length = this.length();

            return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
        },

        floor: function floor() {

            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);

            return this;
        },

        ceil: function ceil() {

            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);

            return this;
        },

        round: function round() {

            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);

            return this;
        },

        roundToZero: function roundToZero() {

            this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);

            return this;
        },

        negate: function negate() {

            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;

            return this;
        },

        dot: function dot(v) {

            return this.x * v.x + this.y * v.y + this.z * v.z;
        },

        // TODO lengthSquared?

        lengthSq: function lengthSq() {

            return this.x * this.x + this.y * this.y + this.z * this.z;
        },

        length: function length() {

            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        },

        lengthManhattan: function lengthManhattan() {

            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        },

        normalize: function normalize() {

            return this.divideScalar(this.length());
        },

        setLength: function setLength(length) {

            return this.multiplyScalar(length / this.length());
        },

        lerp: function lerp(v, alpha) {

            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;

            return this;
        },

        lerpVectors: function lerpVectors(v1, v2, alpha) {

            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },

        cross: function cross(v, w) {

            if (w !== undefined) {

                console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
                return this.crossVectors(v, w);
            }

            var x = this.x,
                y = this.y,
                z = this.z;

            this.x = y * v.z - z * v.y;
            this.y = z * v.x - x * v.z;
            this.z = x * v.y - y * v.x;

            return this;
        },

        crossVectors: function crossVectors(a, b) {

            var ax = a.x,
                ay = a.y,
                az = a.z;
            var bx = b.x,
                by = b.y,
                bz = b.z;

            this.x = ay * bz - az * by;
            this.y = az * bx - ax * bz;
            this.z = ax * by - ay * bx;

            return this;
        },

        projectOnVector: function projectOnVector(vector) {

            var scalar = vector.dot(this) / vector.lengthSq();

            return this.copy(vector).multiplyScalar(scalar);
        },

        projectOnPlane: function () {

            var v1 = new Vector3();

            return function projectOnPlane(planeNormal) {

                v1.copy(this).projectOnVector(planeNormal);

                return this.sub(v1);
            };
        }(),

        reflect: function () {

            // reflect incident vector off plane orthogonal to normal
            // normal is assumed to have unit length

            var v1 = new Vector3();

            return function reflect(normal) {

                return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
            };
        }(),

        angleTo: function angleTo(v) {

            var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());

            // clamp, to handle numerical problems

            return Math.acos(_Math.clamp(theta, -1, 1));
        },

        distanceTo: function distanceTo(v) {

            return Math.sqrt(this.distanceToSquared(v));
        },

        distanceToSquared: function distanceToSquared(v) {

            var dx = this.x - v.x,
                dy = this.y - v.y,
                dz = this.z - v.z;

            return dx * dx + dy * dy + dz * dz;
        },

        distanceToManhattan: function distanceToManhattan(v) {

            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
        },

        setFromSpherical: function setFromSpherical(s) {

            var sinPhiRadius = Math.sin(s.phi) * s.radius;

            this.x = sinPhiRadius * Math.sin(s.theta);
            this.y = Math.cos(s.phi) * s.radius;
            this.z = sinPhiRadius * Math.cos(s.theta);

            return this;
        },

        setFromCylindrical: function setFromCylindrical(c) {

            this.x = c.radius * Math.sin(c.theta);
            this.y = c.y;
            this.z = c.radius * Math.cos(c.theta);

            return this;
        },

        setFromMatrixPosition: function setFromMatrixPosition(m) {

            return this.setFromMatrixColumn(m, 3);
        },

        setFromMatrixScale: function setFromMatrixScale(m) {

            var sx = this.setFromMatrixColumn(m, 0).length();
            var sy = this.setFromMatrixColumn(m, 1).length();
            var sz = this.setFromMatrixColumn(m, 2).length();

            this.x = sx;
            this.y = sy;
            this.z = sz;

            return this;
        },

        setFromMatrixColumn: function setFromMatrixColumn(m, index) {

            return this.fromArray(m.elements, index * 4);
        },

        equals: function equals(v) {

            return v.x === this.x && v.y === this.y && v.z === this.z;
        },

        fromArray: function fromArray(array, offset) {

            if (offset === undefined) offset = 0;

            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];

            return this;
        },

        toArray: function toArray(array, offset) {

            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;

            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;

            return array;
        },

        fromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {

            if (offset !== undefined) {

                console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
            }

            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            this.z = attribute.getZ(index);

            return this;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author jordi_ros / http://plattsoft.com
     * @author D1plo1d / http://github.com/D1plo1d
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author timknip / http://www.floorplanner.com/
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */

    function Matrix4() {

        // this.elements = [

        // 	1, 0, 0, 0,
        // 	0, 1, 0, 0,
        // 	0, 0, 1, 0,
        // 	0, 0, 0, 1

        // ];

        this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);

        if (arguments.length > 0) {

            console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
        }
    }

    Object.assign(Matrix4.prototype, {

        isMatrix4: true,

        set: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {

            var te = this.elements;

            te[0] = n11;te[4] = n12;te[8] = n13;te[12] = n14;
            te[1] = n21;te[5] = n22;te[9] = n23;te[13] = n24;
            te[2] = n31;te[6] = n32;te[10] = n33;te[14] = n34;
            te[3] = n41;te[7] = n42;te[11] = n43;te[15] = n44;

            return this;
        },

        identity: function identity() {

            this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

            return this;
        },

        clone: function clone() {

            return new Matrix4().fromArray(this.elements);
        },

        copy: function copy(m) {

            var te = this.elements;
            var me = m.elements;

            te[0] = me[0];te[1] = me[1];te[2] = me[2];te[3] = me[3];
            te[4] = me[4];te[5] = me[5];te[6] = me[6];te[7] = me[7];
            te[8] = me[8];te[9] = me[9];te[10] = me[10];te[11] = me[11];
            te[12] = me[12];te[13] = me[13];te[14] = me[14];te[15] = me[15];

            return this;
        },

        copyPosition: function copyPosition(m) {

            var te = this.elements,
                me = m.elements;

            te[12] = me[12];
            te[13] = me[13];
            te[14] = me[14];

            return this;
        },

        extractBasis: function extractBasis(xAxis, yAxis, zAxis) {

            xAxis.setFromMatrixColumn(this, 0);
            yAxis.setFromMatrixColumn(this, 1);
            zAxis.setFromMatrixColumn(this, 2);

            return this;
        },

        makeBasis: function makeBasis(xAxis, yAxis, zAxis) {

            this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);

            return this;
        },

        extractRotation: function () {

            var v1 = new Vector3();

            return function extractRotation(m) {

                var te = this.elements;
                var me = m.elements;

                var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
                var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
                var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();

                te[0] = me[0] * scaleX;
                te[1] = me[1] * scaleX;
                te[2] = me[2] * scaleX;

                te[4] = me[4] * scaleY;
                te[5] = me[5] * scaleY;
                te[6] = me[6] * scaleY;

                te[8] = me[8] * scaleZ;
                te[9] = me[9] * scaleZ;
                te[10] = me[10] * scaleZ;

                return this;
            };
        }(),

        makeRotationFromEuler: function makeRotationFromEuler(euler) {

            if ((euler && euler.isEuler) === false) {

                console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
            }

            var te = this.elements;

            var x = euler.x,
                y = euler.y,
                z = euler.z;
            var a = Math.cos(x),
                b = Math.sin(x);
            var c = Math.cos(y),
                d = Math.sin(y);
            var e = Math.cos(z),
                f = Math.sin(z);

            if (euler.order === 'XYZ') {

                var ae = a * e,
                    af = a * f,
                    be = b * e,
                    bf = b * f;

                te[0] = c * e;
                te[4] = -c * f;
                te[8] = d;

                te[1] = af + be * d;
                te[5] = ae - bf * d;
                te[9] = -b * c;

                te[2] = bf - ae * d;
                te[6] = be + af * d;
                te[10] = a * c;
            } else if (euler.order === 'YXZ') {

                var ce = c * e,
                    cf = c * f,
                    de = d * e,
                    df = d * f;

                te[0] = ce + df * b;
                te[4] = de * b - cf;
                te[8] = a * d;

                te[1] = a * f;
                te[5] = a * e;
                te[9] = -b;

                te[2] = cf * b - de;
                te[6] = df + ce * b;
                te[10] = a * c;
            } else if (euler.order === 'ZXY') {

                var ce = c * e,
                    cf = c * f,
                    de = d * e,
                    df = d * f;

                te[0] = ce - df * b;
                te[4] = -a * f;
                te[8] = de + cf * b;

                te[1] = cf + de * b;
                te[5] = a * e;
                te[9] = df - ce * b;

                te[2] = -a * d;
                te[6] = b;
                te[10] = a * c;
            } else if (euler.order === 'ZYX') {

                var ae = a * e,
                    af = a * f,
                    be = b * e,
                    bf = b * f;

                te[0] = c * e;
                te[4] = be * d - af;
                te[8] = ae * d + bf;

                te[1] = c * f;
                te[5] = bf * d + ae;
                te[9] = af * d - be;

                te[2] = -d;
                te[6] = b * c;
                te[10] = a * c;
            } else if (euler.order === 'YZX') {

                var ac = a * c,
                    ad = a * d,
                    bc = b * c,
                    bd = b * d;

                te[0] = c * e;
                te[4] = bd - ac * f;
                te[8] = bc * f + ad;

                te[1] = f;
                te[5] = a * e;
                te[9] = -b * e;

                te[2] = -d * e;
                te[6] = ad * f + bc;
                te[10] = ac - bd * f;
            } else if (euler.order === 'XZY') {

                var ac = a * c,
                    ad = a * d,
                    bc = b * c,
                    bd = b * d;

                te[0] = c * e;
                te[4] = -f;
                te[8] = d * e;

                te[1] = ac * f + bd;
                te[5] = a * e;
                te[9] = ad * f - bc;

                te[2] = bc * f - ad;
                te[6] = b * e;
                te[10] = bd * f + ac;
            }

            // last column
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;

            // bottom row
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;

            return this;
        },

        makeRotationFromQuaternion: function makeRotationFromQuaternion(q) {

            var te = this.elements;

            var x = q._x,
                y = q._y,
                z = q._z,
                w = q._w;
            var x2 = x + x,
                y2 = y + y,
                z2 = z + z;
            var xx = x * x2,
                xy = x * y2,
                xz = x * z2;
            var yy = y * y2,
                yz = y * z2,
                zz = z * z2;
            var wx = w * x2,
                wy = w * y2,
                wz = w * z2;

            te[0] = 1 - (yy + zz);
            te[4] = xy - wz;
            te[8] = xz + wy;

            te[1] = xy + wz;
            te[5] = 1 - (xx + zz);
            te[9] = yz - wx;

            te[2] = xz - wy;
            te[6] = yz + wx;
            te[10] = 1 - (xx + yy);

            // last column
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;

            // bottom row
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;

            return this;
        },

        lookAt: function () {

            var x = new Vector3();
            var y = new Vector3();
            var z = new Vector3();

            return function lookAt(eye, target, up) {

                var te = this.elements;

                z.subVectors(eye, target);

                if (z.lengthSq() === 0) {

                    // eye and target are in the same position

                    z.z = 1;
                }

                z.normalize();
                x.crossVectors(up, z);

                if (x.lengthSq() === 0) {

                    // eye and target are in the same vertical

                    z.z += 0.0001;
                    x.crossVectors(up, z);
                }

                x.normalize();
                y.crossVectors(z, x);

                te[0] = x.x;te[4] = y.x;te[8] = z.x;
                te[1] = x.y;te[5] = y.y;te[9] = z.y;
                te[2] = x.z;te[6] = y.z;te[10] = z.z;

                return this;
            };
        }(),

        multiply: function multiply(m, n) {

            if (n !== undefined) {

                console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
                return this.multiplyMatrices(m, n);
            }

            return this.multiplyMatrices(this, m);
        },

        premultiply: function premultiply(m) {

            return this.multiplyMatrices(m, this);
        },

        multiplyMatrices: function multiplyMatrices(a, b) {

            var ae = a.elements;
            var be = b.elements;
            var te = this.elements;

            var a11 = ae[0],
                a12 = ae[4],
                a13 = ae[8],
                a14 = ae[12];
            var a21 = ae[1],
                a22 = ae[5],
                a23 = ae[9],
                a24 = ae[13];
            var a31 = ae[2],
                a32 = ae[6],
                a33 = ae[10],
                a34 = ae[14];
            var a41 = ae[3],
                a42 = ae[7],
                a43 = ae[11],
                a44 = ae[15];

            var b11 = be[0],
                b12 = be[4],
                b13 = be[8],
                b14 = be[12];
            var b21 = be[1],
                b22 = be[5],
                b23 = be[9],
                b24 = be[13];
            var b31 = be[2],
                b32 = be[6],
                b33 = be[10],
                b34 = be[14];
            var b41 = be[3],
                b42 = be[7],
                b43 = be[11],
                b44 = be[15];

            te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

            te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

            te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

            te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

            return this;
        },

        multiplyScalar: function multiplyScalar(s) {

            var te = this.elements;

            te[0] *= s;te[4] *= s;te[8] *= s;te[12] *= s;
            te[1] *= s;te[5] *= s;te[9] *= s;te[13] *= s;
            te[2] *= s;te[6] *= s;te[10] *= s;te[14] *= s;
            te[3] *= s;te[7] *= s;te[11] *= s;te[15] *= s;

            return this;
        },

        applyToBufferAttribute: function () {

            var v1 = new Vector3();

            return function applyToBufferAttribute(attribute) {

                for (var i = 0, l = attribute.count; i < l; i++) {

                    v1.x = attribute.getX(i);
                    v1.y = attribute.getY(i);
                    v1.z = attribute.getZ(i);

                    v1.applyMatrix4(this);

                    attribute.setXYZ(i, v1.x, v1.y, v1.z);
                }

                return attribute;
            };
        }(),

        determinant: function determinant() {

            var te = this.elements;

            var n11 = te[0],
                n12 = te[4],
                n13 = te[8],
                n14 = te[12];
            var n21 = te[1],
                n22 = te[5],
                n23 = te[9],
                n24 = te[13];
            var n31 = te[2],
                n32 = te[6],
                n33 = te[10],
                n34 = te[14];
            var n41 = te[3],
                n42 = te[7],
                n43 = te[11],
                n44 = te[15];

            //TODO: make this more efficient
            //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

            return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
        },

        transpose: function transpose() {

            var te = this.elements;
            var tmp;

            tmp = te[1];te[1] = te[4];te[4] = tmp;
            tmp = te[2];te[2] = te[8];te[8] = tmp;
            tmp = te[6];te[6] = te[9];te[9] = tmp;

            tmp = te[3];te[3] = te[12];te[12] = tmp;
            tmp = te[7];te[7] = te[13];te[13] = tmp;
            tmp = te[11];te[11] = te[14];te[14] = tmp;

            return this;
        },

        setPosition: function setPosition(v) {

            var te = this.elements;

            te[12] = v.x;
            te[13] = v.y;
            te[14] = v.z;

            return this;
        },

        getInverse: function getInverse(m, throwOnDegenerate) {

            // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
            var te = this.elements,
                me = m.elements,
                n11 = me[0],
                n21 = me[1],
                n31 = me[2],
                n41 = me[3],
                n12 = me[4],
                n22 = me[5],
                n32 = me[6],
                n42 = me[7],
                n13 = me[8],
                n23 = me[9],
                n33 = me[10],
                n43 = me[11],
                n14 = me[12],
                n24 = me[13],
                n34 = me[14],
                n44 = me[15],
                t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
                t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
                t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
                t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

            var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

            if (det === 0) {

                var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

                if (throwOnDegenerate === true) {

                    throw new Error(msg);
                } else {

                    console.warn(msg);
                }

                return this.identity();
            }

            var detInv = 1 / det;

            te[0] = t11 * detInv;
            te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
            te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
            te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;

            te[4] = t12 * detInv;
            te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
            te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
            te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;

            te[8] = t13 * detInv;
            te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
            te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
            te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;

            te[12] = t14 * detInv;
            te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
            te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
            te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;

            return this;
        },

        scale: function scale(v) {

            var te = this.elements;
            var x = v.x,
                y = v.y,
                z = v.z;

            te[0] *= x;te[4] *= y;te[8] *= z;
            te[1] *= x;te[5] *= y;te[9] *= z;
            te[2] *= x;te[6] *= y;te[10] *= z;
            te[3] *= x;te[7] *= y;te[11] *= z;

            return this;
        },

        getMaxScaleOnAxis: function getMaxScaleOnAxis() {

            var te = this.elements;

            var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
            var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
            var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];

            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        },

        makeTranslation: function makeTranslation(x, y, z) {

            this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);

            return this;
        },

        makeRotationX: function makeRotationX(theta) {

            var c = Math.cos(theta),
                s = Math.sin(theta);

            this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);

            return this;
        },

        makeRotationY: function makeRotationY(theta) {

            var c = Math.cos(theta),
                s = Math.sin(theta);

            this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);

            return this;
        },

        makeRotationZ: function makeRotationZ(theta) {

            var c = Math.cos(theta),
                s = Math.sin(theta);

            this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

            return this;
        },

        makeRotationAxis: function makeRotationAxis(axis, angle) {

            // Based on http://www.gamedev.net/reference/articles/article1199.asp

            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var t = 1 - c;
            var x = axis.x,
                y = axis.y,
                z = axis.z;
            var tx = t * x,
                ty = t * y;

            this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);

            return this;
        },

        makeScale: function makeScale(x, y, z) {

            this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);

            return this;
        },

        makeShear: function makeShear(x, y, z) {

            this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);

            return this;
        },

        compose: function compose(position, quaternion, scale) {

            this.makeRotationFromQuaternion(quaternion);
            this.scale(scale);
            this.setPosition(position);

            return this;
        },

        decompose: function () {

            var vector = new Vector3();
            var matrix = new Matrix4();

            return function decompose(position, quaternion, scale) {

                var te = this.elements;

                var sx = vector.set(te[0], te[1], te[2]).length();
                var sy = vector.set(te[4], te[5], te[6]).length();
                var sz = vector.set(te[8], te[9], te[10]).length();

                // if determine is negative, we need to invert one scale
                var det = this.determinant();
                if (det < 0) sx = -sx;

                position.x = te[12];
                position.y = te[13];
                position.z = te[14];

                // scale the rotation part
                matrix.copy(this);

                var invSX = 1 / sx;
                var invSY = 1 / sy;
                var invSZ = 1 / sz;

                matrix.elements[0] *= invSX;
                matrix.elements[1] *= invSX;
                matrix.elements[2] *= invSX;

                matrix.elements[4] *= invSY;
                matrix.elements[5] *= invSY;
                matrix.elements[6] *= invSY;

                matrix.elements[8] *= invSZ;
                matrix.elements[9] *= invSZ;
                matrix.elements[10] *= invSZ;

                quaternion.setFromRotationMatrix(matrix);

                scale.x = sx;
                scale.y = sy;
                scale.z = sz;

                return this;
            };
        }(),

        makePerspective: function makePerspective(left, right, top, bottom, near, far) {

            if (far === undefined) {

                console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
            }

            var te = this.elements;
            var x = 2 * near / (right - left);
            var y = 2 * near / (top - bottom);

            var a = (right + left) / (right - left);
            var b = (top + bottom) / (top - bottom);
            var c = -(far + near) / (far - near);
            var d = -2 * far * near / (far - near);

            te[0] = x;te[4] = 0;te[8] = a;te[12] = 0;
            te[1] = 0;te[5] = y;te[9] = b;te[13] = 0;
            te[2] = 0;te[6] = 0;te[10] = c;te[14] = d;
            te[3] = 0;te[7] = 0;te[11] = -1;te[15] = 0;

            return this;
        },

        makeOrthographic: function makeOrthographic(left, right, top, bottom, near, far) {

            var te = this.elements;
            var w = 1.0 / (right - left);
            var h = 1.0 / (top - bottom);
            var p = 1.0 / (far - near);

            var x = (right + left) * w;
            var y = (top + bottom) * h;
            var z = (far + near) * p;

            te[0] = 2 * w;te[4] = 0;te[8] = 0;te[12] = -x;
            te[1] = 0;te[5] = 2 * h;te[9] = 0;te[13] = -y;
            te[2] = 0;te[6] = 0;te[10] = -2 * p;te[14] = -z;
            te[3] = 0;te[7] = 0;te[11] = 0;te[15] = 1;

            return this;
        },

        equals: function equals(matrix) {

            var te = this.elements;
            var me = matrix.elements;

            for (var i = 0; i < 16; i++) {

                if (te[i] !== me[i]) return false;
            }

            return true;
        },

        fromArray: function fromArray(array, offset) {

            if (offset === undefined) offset = 0;

            for (var i = 0; i < 16; i++) {

                this.elements[i] = array[i + offset];
            }

            return this;
        },

        toArray: function toArray(array, offset) {

            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;

            var te = this.elements;

            array[offset] = te[0];
            array[offset + 1] = te[1];
            array[offset + 2] = te[2];
            array[offset + 3] = te[3];

            array[offset + 4] = te[4];
            array[offset + 5] = te[5];
            array[offset + 6] = te[6];
            array[offset + 7] = te[7];

            array[offset + 8] = te[8];
            array[offset + 9] = te[9];
            array[offset + 10] = te[10];
            array[offset + 11] = te[11];

            array[offset + 12] = te[12];
            array[offset + 13] = te[13];
            array[offset + 14] = te[14];
            array[offset + 15] = te[15];

            return array;
        }

    });

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {

        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

        this.image = { data: data, width: width, height: height };

        this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
        this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
    }

    DataTexture.prototype = Object.create(Texture.prototype);
    DataTexture.prototype.constructor = DataTexture;

    DataTexture.prototype.isDataTexture = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {

        images = images !== undefined ? images : [];
        mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

        Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

        this.flipY = false;
    }

    CubeTexture.prototype = Object.create(Texture.prototype);
    CubeTexture.prototype.constructor = CubeTexture;

    CubeTexture.prototype.isCubeTexture = true;

    Object.defineProperty(CubeTexture.prototype, 'images', {

        get: function get() {

            return this.image;
        },

        set: function set(value) {

            this.image = value;
        }

    });

    /**
     * @author tschw
     *
     * Uniforms of a program.
     * Those form a tree structure with a special top-level container for the root,
     * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
     *
     *
     * Properties of inner nodes including the top-level container:
     *
     * .seq - array of nested uniforms
     * .map - nested uniforms by name
     *
     *
     * Methods of all nodes except the top-level container:
     *
     * .setValue( gl, value, [renderer] )
     *
     * 		uploads a uniform value(s)
     *  	the 'renderer' parameter is needed for sampler uniforms
     *
     *
     * Static methods of the top-level container (renderer factorizations):
     *
     * .upload( gl, seq, values, renderer )
     *
     * 		sets uniforms in 'seq' to 'values[id].value'
     *
     * .seqWithValue( seq, values ) : filteredSeq
     *
     * 		filters 'seq' entries with corresponding entry in values
     *
     *
     * Methods of the top-level container (renderer factorizations):
     *
     * .setValue( gl, name, value )
     *
     * 		sets uniform with  name 'name' to 'value'
     *
     * .set( gl, obj, prop )
     *
     * 		sets uniform from object and property with same name than uniform
     *
     * .setOptional( gl, obj, prop )
     *
     * 		like .set for an optional property of the object
     *
     */

    var emptyTexture = new Texture();
    var emptyCubeTexture = new CubeTexture();

    // --- Base for inner nodes (including the root) ---

    function UniformContainer() {

        this.seq = [];
        this.map = {};
    }

    // --- Utilities ---

    // Array Caches (provide typed arrays for temporary by size)

    var arrayCacheF32 = [];
    var arrayCacheI32 = [];

    // Float32Array caches used for uploading Matrix uniforms

    var mat4array = new Float32Array(16);
    var mat3array = new Float32Array(9);

    // Flattening for arrays of vectors and matrices

    function flatten(array, nBlocks, blockSize) {

        var firstElem = array[0];

        if (firstElem <= 0 || firstElem > 0) return array;
        // unoptimized: ! isNaN( firstElem )
        // see http://jacksondunstan.com/articles/983

        var n = nBlocks * blockSize,
            r = arrayCacheF32[n];

        if (r === undefined) {

            r = new Float32Array(n);
            arrayCacheF32[n] = r;
        }

        if (nBlocks !== 0) {

            firstElem.toArray(r, 0);

            for (var i = 1, offset = 0; i !== nBlocks; ++i) {

                offset += blockSize;
                array[i].toArray(r, offset);
            }
        }

        return r;
    }

    // Texture unit allocation

    function allocTexUnits(renderer, n) {

        var r = arrayCacheI32[n];

        if (r === undefined) {

            r = new Int32Array(n);
            arrayCacheI32[n] = r;
        }

        for (var i = 0; i !== n; ++i) {
            r[i] = renderer.allocTextureUnit();
        }return r;
    }

    // --- Setters ---

    // Note: Defining these methods externally, because they come in a bunch
    // and this way their names minify.

    // Single scalar

    function setValue1f(gl, v) {
        gl.uniform1f(this.addr, v);
    }
    function setValue1i(gl, v) {
        gl.uniform1i(this.addr, v);
    }

    // Single float vector (from flat array or THREE.VectorN)

    function setValue2fv(gl, v) {

        if (v.x === undefined) gl.uniform2fv(this.addr, v);else gl.uniform2f(this.addr, v.x, v.y);
    }

    function setValue3fv(gl, v) {

        if (v.x !== undefined) gl.uniform3f(this.addr, v.x, v.y, v.z);else if (v.r !== undefined) gl.uniform3f(this.addr, v.r, v.g, v.b);else gl.uniform3fv(this.addr, v);
    }

    function setValue4fv(gl, v) {

        if (v.x === undefined) gl.uniform4fv(this.addr, v);else gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
    }

    // Single matrix (from flat array or MatrixN)

    function setValue2fm(gl, v) {

        gl.uniformMatrix2fv(this.addr, false, v.elements || v);
    }

    function setValue3fm(gl, v) {

        if (v.elements === undefined) {

            gl.uniformMatrix3fv(this.addr, false, v);
        } else {

            mat3array.set(v.elements);
            gl.uniformMatrix3fv(this.addr, false, mat3array);
        }
    }

    function setValue4fm(gl, v) {

        if (v.elements === undefined) {

            gl.uniformMatrix4fv(this.addr, false, v);
        } else {

            mat4array.set(v.elements);
            gl.uniformMatrix4fv(this.addr, false, mat4array);
        }
    }

    // Single texture (2D / Cube)

    function setValueT1(gl, v, renderer) {

        var unit = renderer.allocTextureUnit();
        gl.uniform1i(this.addr, unit);
        renderer.setTexture2D(v || emptyTexture, unit);
    }

    function setValueT6(gl, v, renderer) {

        var unit = renderer.allocTextureUnit();
        gl.uniform1i(this.addr, unit);
        renderer.setTextureCube(v || emptyCubeTexture, unit);
    }

    // Integer / Boolean vectors or arrays thereof (always flat arrays)

    function setValue2iv(gl, v) {
        gl.uniform2iv(this.addr, v);
    }
    function setValue3iv(gl, v) {
        gl.uniform3iv(this.addr, v);
    }
    function setValue4iv(gl, v) {
        gl.uniform4iv(this.addr, v);
    }

    // Helper to pick the right setter for the singular case

    function getSingularSetter(type) {

        switch (type) {

            case 0x1406:
                return setValue1f; // FLOAT
            case 0x8b50:
                return setValue2fv; // _VEC2
            case 0x8b51:
                return setValue3fv; // _VEC3
            case 0x8b52:
                return setValue4fv; // _VEC4

            case 0x8b5a:
                return setValue2fm; // _MAT2
            case 0x8b5b:
                return setValue3fm; // _MAT3
            case 0x8b5c:
                return setValue4fm; // _MAT4

            case 0x8b5e:
                return setValueT1; // SAMPLER_2D
            case 0x8b60:
                return setValueT6; // SAMPLER_CUBE

            case 0x1404:case 0x8b56:
                return setValue1i; // INT, BOOL
            case 0x8b53:case 0x8b57:
                return setValue2iv; // _VEC2
            case 0x8b54:case 0x8b58:
                return setValue3iv; // _VEC3
            case 0x8b55:case 0x8b59:
                return setValue4iv; // _VEC4

        }
    }

    // Array of scalars

    function setValue1fv(gl, v) {
        gl.uniform1fv(this.addr, v);
    }
    function setValue1iv(gl, v) {
        gl.uniform1iv(this.addr, v);
    }

    // Array of vectors (flat or from THREE classes)

    function setValueV2a(gl, v) {

        gl.uniform2fv(this.addr, flatten(v, this.size, 2));
    }

    function setValueV3a(gl, v) {

        gl.uniform3fv(this.addr, flatten(v, this.size, 3));
    }

    function setValueV4a(gl, v) {

        gl.uniform4fv(this.addr, flatten(v, this.size, 4));
    }

    // Array of matrices (flat or from THREE clases)

    function setValueM2a(gl, v) {

        gl.uniformMatrix2fv(this.addr, false, flatten(v, this.size, 4));
    }

    function setValueM3a(gl, v) {

        gl.uniformMatrix3fv(this.addr, false, flatten(v, this.size, 9));
    }

    function setValueM4a(gl, v) {

        gl.uniformMatrix4fv(this.addr, false, flatten(v, this.size, 16));
    }

    // Array of textures (2D / Cube)

    function setValueT1a(gl, v, renderer) {

        var n = v.length,
            units = allocTexUnits(renderer, n);

        gl.uniform1iv(this.addr, units);

        for (var i = 0; i !== n; ++i) {

            renderer.setTexture2D(v[i] || emptyTexture, units[i]);
        }
    }

    function setValueT6a(gl, v, renderer) {

        var n = v.length,
            units = allocTexUnits(renderer, n);

        gl.uniform1iv(this.addr, units);

        for (var i = 0; i !== n; ++i) {

            renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
        }
    }

    // Helper to pick the right setter for a pure (bottom-level) array

    function getPureArraySetter(type) {

        switch (type) {

            case 0x1406:
                return setValue1fv; // FLOAT
            case 0x8b50:
                return setValueV2a; // _VEC2
            case 0x8b51:
                return setValueV3a; // _VEC3
            case 0x8b52:
                return setValueV4a; // _VEC4

            case 0x8b5a:
                return setValueM2a; // _MAT2
            case 0x8b5b:
                return setValueM3a; // _MAT3
            case 0x8b5c:
                return setValueM4a; // _MAT4

            case 0x8b5e:
                return setValueT1a; // SAMPLER_2D
            case 0x8b60:
                return setValueT6a; // SAMPLER_CUBE

            case 0x1404:case 0x8b56:
                return setValue1iv; // INT, BOOL
            case 0x8b53:case 0x8b57:
                return setValue2iv; // _VEC2
            case 0x8b54:case 0x8b58:
                return setValue3iv; // _VEC3
            case 0x8b55:case 0x8b59:
                return setValue4iv; // _VEC4

        }
    }

    // --- Uniform Classes ---

    function SingleUniform(id, activeInfo, addr) {

        this.id = id;
        this.addr = addr;
        this.setValue = getSingularSetter(activeInfo.type);

        // this.path = activeInfo.name; // DEBUG
    }

    function PureArrayUniform(id, activeInfo, addr) {

        this.id = id;
        this.addr = addr;
        this.size = activeInfo.size;
        this.setValue = getPureArraySetter(activeInfo.type);

        // this.path = activeInfo.name; // DEBUG
    }

    function StructuredUniform(id) {

        this.id = id;

        UniformContainer.call(this); // mix-in
    }

    StructuredUniform.prototype.setValue = function (gl, value) {

        // Note: Don't need an extra 'renderer' parameter, since samplers
        // are not allowed in structured uniforms.

        var seq = this.seq;

        for (var i = 0, n = seq.length; i !== n; ++i) {

            var u = seq[i];
            u.setValue(gl, value[u.id]);
        }
    };

    // --- Top-level ---

    // Parser - builds up the property tree from the path strings

    var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

    // extracts
    // 	- the identifier (member name or array index)
    //  - followed by an optional right bracket (found when array index)
    //  - followed by an optional left bracket or dot (type of subscript)
    //
    // Note: These portions can be read in a non-overlapping fashion and
    // allow straightforward parsing of the hierarchy that WebGL encodes
    // in the uniform names.

    function addUniform(container, uniformObject) {

        container.seq.push(uniformObject);
        container.map[uniformObject.id] = uniformObject;
    }

    function parseUniform(activeInfo, addr, container) {

        var path = activeInfo.name,
            pathLength = path.length;

        // reset RegExp object, because of the early exit of a previous run
        RePathPart.lastIndex = 0;

        for (;;) {

            var match = RePathPart.exec(path),
                matchEnd = RePathPart.lastIndex,
                id = match[1],
                idIsIndex = match[2] === ']',
                subscript = match[3];

            if (idIsIndex) id = id | 0; // convert to integer

            if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {

                // bare name or "pure" bottom-level array "[0]" suffix

                addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));

                break;
            } else {

                // step into inner node / create it in case it doesn't exist

                var map = container.map,
                    next = map[id];

                if (next === undefined) {

                    next = new StructuredUniform(id);
                    addUniform(container, next);
                }

                container = next;
            }
        }
    }

    // Root Container

    function WebGLUniforms(gl, program, renderer) {

        UniformContainer.call(this);

        this.renderer = renderer;

        var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

        for (var i = 0; i < n; ++i) {

            var info = gl.getActiveUniform(program, i),
                path = info.name,
                addr = gl.getUniformLocation(program, path);

            parseUniform(info, addr, this);
        }
    }

    WebGLUniforms.prototype.setValue = function (gl, name, value) {

        var u = this.map[name];

        if (u !== undefined) u.setValue(gl, value, this.renderer);
    };

    WebGLUniforms.prototype.setOptional = function (gl, object, name) {

        var v = object[name];

        if (v !== undefined) this.setValue(gl, name, v);
    };

    // Static interface

    WebGLUniforms.upload = function (gl, seq, values, renderer) {

        for (var i = 0, n = seq.length; i !== n; ++i) {

            var u = seq[i],
                v = values[u.id];

            if (v.needsUpdate !== false) {

                // note: always updating when .needsUpdate is undefined
                u.setValue(gl, v.value, renderer);
            }
        }
    };

    WebGLUniforms.seqWithValue = function (seq, values) {

        var r = [];

        for (var i = 0, n = seq.length; i !== n; ++i) {

            var u = seq[i];
            if (u.id in values) r.push(u);
        }

        return r;
    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
        'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
        'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
        'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
        'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
        'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
        'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
        'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
        'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
        'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
        'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
        'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
        'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
        'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
        'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
        'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
        'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
        'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
        'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
        'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
        'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
        'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
        'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
        'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

    function Color(r, g, b) {

        if (g === undefined && b === undefined) {

            // r is THREE.Color, hex or string
            return this.set(r);
        }

        return this.setRGB(r, g, b);
    }

    Object.assign(Color.prototype, {

        isColor: true,

        r: 1, g: 1, b: 1,

        set: function set(value) {

            if (value && value.isColor) {

                this.copy(value);
            } else if (typeof value === 'number') {

                this.setHex(value);
            } else if (typeof value === 'string') {

                this.setStyle(value);
            }

            return this;
        },

        setScalar: function setScalar(scalar) {

            this.r = scalar;
            this.g = scalar;
            this.b = scalar;

            return this;
        },

        setHex: function setHex(hex) {

            hex = Math.floor(hex);

            this.r = (hex >> 16 & 255) / 255;
            this.g = (hex >> 8 & 255) / 255;
            this.b = (hex & 255) / 255;

            return this;
        },

        setRGB: function setRGB(r, g, b) {

            this.r = r;
            this.g = g;
            this.b = b;

            return this;
        },

        setHSL: function () {

            function hue2rgb(p, q, t) {

                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
                return p;
            }

            return function setHSL(h, s, l) {

                // h,s,l ranges are in 0.0 - 1.0
                h = _Math.euclideanModulo(h, 1);
                s = _Math.clamp(s, 0, 1);
                l = _Math.clamp(l, 0, 1);

                if (s === 0) {

                    this.r = this.g = this.b = l;
                } else {

                    var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
                    var q = 2 * l - p;

                    this.r = hue2rgb(q, p, h + 1 / 3);
                    this.g = hue2rgb(q, p, h);
                    this.b = hue2rgb(q, p, h - 1 / 3);
                }

                return this;
            };
        }(),

        setStyle: function setStyle(style) {

            function handleAlpha(string) {

                if (string === undefined) return;

                if (parseFloat(string) < 1) {

                    console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
                }
            }

            var m;

            if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {

                // rgb / hsl

                var color;
                var name = m[1];
                var components = m[2];

                switch (name) {

                    case 'rgb':
                    case 'rgba':

                        if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {

                            // rgb(255,0,0) rgba(255,0,0,0.5)
                            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                            this.b = Math.min(255, parseInt(color[3], 10)) / 255;

                            handleAlpha(color[5]);

                            return this;
                        }

                        if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {

                            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                            this.b = Math.min(100, parseInt(color[3], 10)) / 100;

                            handleAlpha(color[5]);

                            return this;
                        }

                        break;

                    case 'hsl':
                    case 'hsla':

                        if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {

                            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                            var h = parseFloat(color[1]) / 360;
                            var s = parseInt(color[2], 10) / 100;
                            var l = parseInt(color[3], 10) / 100;

                            handleAlpha(color[5]);

                            return this.setHSL(h, s, l);
                        }

                        break;

                }
            } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {

                // hex color

                var hex = m[1];
                var size = hex.length;

                if (size === 3) {

                    // #ff0
                    this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                    this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                    this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;

                    return this;
                } else if (size === 6) {

                    // #ff0000
                    this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                    this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                    this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;

                    return this;
                }
            }

            if (style && style.length > 0) {

                // color keywords
                var hex = ColorKeywords[style];

                if (hex !== undefined) {

                    // red
                    this.setHex(hex);
                } else {

                    // unknown color
                    console.warn('THREE.Color: Unknown color ' + style);
                }
            }

            return this;
        },

        clone: function clone() {

            return new this.constructor(this.r, this.g, this.b);
        },

        copy: function copy(color) {

            this.r = color.r;
            this.g = color.g;
            this.b = color.b;

            return this;
        },

        copyGammaToLinear: function copyGammaToLinear(color, gammaFactor) {

            if (gammaFactor === undefined) gammaFactor = 2.0;

            this.r = Math.pow(color.r, gammaFactor);
            this.g = Math.pow(color.g, gammaFactor);
            this.b = Math.pow(color.b, gammaFactor);

            return this;
        },

        copyLinearToGamma: function copyLinearToGamma(color, gammaFactor) {

            if (gammaFactor === undefined) gammaFactor = 2.0;

            var safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;

            this.r = Math.pow(color.r, safeInverse);
            this.g = Math.pow(color.g, safeInverse);
            this.b = Math.pow(color.b, safeInverse);

            return this;
        },

        convertGammaToLinear: function convertGammaToLinear() {

            var r = this.r,
                g = this.g,
                b = this.b;

            this.r = r * r;
            this.g = g * g;
            this.b = b * b;

            return this;
        },

        convertLinearToGamma: function convertLinearToGamma() {

            this.r = Math.sqrt(this.r);
            this.g = Math.sqrt(this.g);
            this.b = Math.sqrt(this.b);

            return this;
        },

        getHex: function getHex() {

            return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
        },

        getHexString: function getHexString() {

            return ('000000' + this.getHex().toString(16)).slice(-6);
        },

        getHSL: function getHSL(optionalTarget) {

            // h,s,l ranges are in 0.0 - 1.0

            var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

            var r = this.r,
                g = this.g,
                b = this.b;

            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);

            var hue, saturation;
            var lightness = (min + max) / 2.0;

            if (min === max) {

                hue = 0;
                saturation = 0;
            } else {

                var delta = max - min;

                saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

                switch (max) {

                    case r:
                        hue = (g - b) / delta + (g < b ? 6 : 0);break;
                    case g:
                        hue = (b - r) / delta + 2;break;
                    case b:
                        hue = (r - g) / delta + 4;break;

                }

                hue /= 6;
            }

            hsl.h = hue;
            hsl.s = saturation;
            hsl.l = lightness;

            return hsl;
        },

        getStyle: function getStyle() {

            return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
        },

        offsetHSL: function offsetHSL(h, s, l) {

            var hsl = this.getHSL();

            hsl.h += h;hsl.s += s;hsl.l += l;

            this.setHSL(hsl.h, hsl.s, hsl.l);

            return this;
        },

        add: function add(color) {

            this.r += color.r;
            this.g += color.g;
            this.b += color.b;

            return this;
        },

        addColors: function addColors(color1, color2) {

            this.r = color1.r + color2.r;
            this.g = color1.g + color2.g;
            this.b = color1.b + color2.b;

            return this;
        },

        addScalar: function addScalar(s) {

            this.r += s;
            this.g += s;
            this.b += s;

            return this;
        },

        sub: function sub(color) {

            this.r = Math.max(0, this.r - color.r);
            this.g = Math.max(0, this.g - color.g);
            this.b = Math.max(0, this.b - color.b);

            return this;
        },

        multiply: function multiply(color) {

            this.r *= color.r;
            this.g *= color.g;
            this.b *= color.b;

            return this;
        },

        multiplyScalar: function multiplyScalar(s) {

            this.r *= s;
            this.g *= s;
            this.b *= s;

            return this;
        },

        lerp: function lerp(color, alpha) {

            this.r += (color.r - this.r) * alpha;
            this.g += (color.g - this.g) * alpha;
            this.b += (color.b - this.b) * alpha;

            return this;
        },

        equals: function equals(c) {

            return c.r === this.r && c.g === this.g && c.b === this.b;
        },

        fromArray: function fromArray(array, offset) {

            if (offset === undefined) offset = 0;

            this.r = array[offset];
            this.g = array[offset + 1];
            this.b = array[offset + 2];

            return this;
        },

        toArray: function toArray(array, offset) {

            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;

            array[offset] = this.r;
            array[offset + 1] = this.g;
            array[offset + 2] = this.b;

            return array;
        },

        toJSON: function toJSON() {

            return this.getHex();
        }

    });

    /**
     * Uniforms library for shared webgl shaders
     */

    var UniformsLib = {

        common: {

            diffuse: { value: new Color(0xeeeeee) },
            opacity: { value: 1.0 },

            map: { value: null },
            offsetRepeat: { value: new Vector4(0, 0, 1, 1) },
            rotateMatrix: { value: new Matrix3() }, // xmh add

            specularMap: { value: null },
            alphaMap: { value: null },

            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1.0 },
            refractionRatio: { value: 0.98 }

        },

        aomap: {

            aoMap: { value: null },
            aoMapIntensity: { value: 1 }

        },

        lightmap: {

            lightMap: { value: null },
            lightMapIntensity: { value: 1 }

        },

        emissivemap: {

            emissiveMap: { value: null }

        },

        bumpmap: {

            bumpMap: { value: null },
            bumpScale: { value: 1 }

        },

        normalmap: {

            normalMap: { value: null },
            normalScale: { value: new Vector2(1, 1) }

        },

        displacementmap: {

            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 }

        },

        roughnessmap: {

            roughnessMap: { value: null }

        },

        metalnessmap: {

            metalnessMap: { value: null }

        },

        gradientmap: {

            gradientMap: { value: null }

        },

        fog: {

            fogDensity: { value: 0.00025 },
            fogNear: { value: 1 },
            fogFar: { value: 2000 },
            fogColor: { value: new Color(0xffffff) }

        },

        lights: {

            ambientLightColor: { value: [] },

            directionalLights: { value: [], properties: {
                    direction: {},
                    color: {},

                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                } },

            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },

            spotLights: { value: [], properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},

                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                } },

            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },

            pointLights: { value: [], properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},

                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                } },

            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },

            hemisphereLights: { value: [], properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                } },

            // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
            rectAreaLights: { value: [], properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                } }

        },

        points: {

            diffuse: { value: new Color(0xeeeeee) },
            opacity: { value: 1.0 },
            size: { value: 1.0 },
            scale: { value: 1.0 },
            map: { value: null },
            offsetRepeat: { value: new Vector4(0, 0, 1, 1) }

        }

    };

    /**
     * Uniform Utilities
     */

    var UniformsUtils = {

        merge: function merge(uniforms) {

            var merged = {};

            for (var u = 0; u < uniforms.length; u++) {

                var tmp = this.clone(uniforms[u]);

                for (var p in tmp) {

                    merged[p] = tmp[p];
                }
            }

            return merged;
        },

        clone: function clone(uniforms_src) {

            var uniforms_dst = {};

            for (var u in uniforms_src) {

                uniforms_dst[u] = {};

                for (var p in uniforms_src[u]) {

                    var parameter_src = uniforms_src[u][p];

                    if (parameter_src && (parameter_src.isColor || parameter_src.isMatrix3 || parameter_src.isMatrix4 || parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 || parameter_src.isTexture)) {

                        uniforms_dst[u][p] = parameter_src.clone();
                    } else if (Array.isArray(parameter_src)) {

                        uniforms_dst[u][p] = parameter_src.slice();
                    } else {

                        uniforms_dst[u][p] = parameter_src;
                    }
                }
            }

            return uniforms_dst;
        }

    };

    var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

    var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

    var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

    var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

    var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

    var begin_vertex = "\nvec3 transformed = vec3( position );\n";

    var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";

    var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

    var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

    var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";

    var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

    var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

    var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

    var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

    var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

    var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

    var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

    var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n";

    var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

    var defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

    var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

    var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

    var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

    var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

    var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

    var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";

    var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

    var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

    var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

    var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

    var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";

    var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";

    var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

    var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";

    var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";

    var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

    var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

    var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

    var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

    var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

    var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

    var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

    var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

    var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

    var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";

    var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

    var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

    var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";

    var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

    var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

    var map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

    var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";

    var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";

    var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

    var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

    var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

    var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

    var normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";

    var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

    var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";

    var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

    var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

    var project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";

    var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";

    var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";

    var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";

    var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

    var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

    var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";

    var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";

    var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

    var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

    var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

    var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";

    var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

    var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

    var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

    var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

    var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

    var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

    // modified by xmh
    // var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";

    // var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";

    var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n\tuniform mat3 rotateMatrix;\n#endif\n";

    var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = mat2(rotateMatrix) * vec2(uv.x - 0.5, uv.y - 0.5) + vec2(0.5, 0.5);\n\tvUv = (vUv -  offsetRepeat.xy)* offsetRepeat.zw;\n#endif";

    var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

    var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

    var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

    var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";

    var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

    var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

    var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

    var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

    var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";

    var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";

    var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

    var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

    var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";

    var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";

    var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

    var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

    var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

    var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

    var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

    var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

    var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";

    var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";

    var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

    var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n";

    var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var ShaderChunk = {
        alphamap_fragment: alphamap_fragment,
        alphamap_pars_fragment: alphamap_pars_fragment,
        alphatest_fragment: alphatest_fragment,
        aomap_fragment: aomap_fragment,
        aomap_pars_fragment: aomap_pars_fragment,
        begin_vertex: begin_vertex,
        beginnormal_vertex: beginnormal_vertex,
        bsdfs: bsdfs,
        bumpmap_pars_fragment: bumpmap_pars_fragment,
        clipping_planes_fragment: clipping_planes_fragment,
        clipping_planes_pars_fragment: clipping_planes_pars_fragment,
        clipping_planes_pars_vertex: clipping_planes_pars_vertex,
        clipping_planes_vertex: clipping_planes_vertex,
        color_fragment: color_fragment,
        color_pars_fragment: color_pars_fragment,
        color_pars_vertex: color_pars_vertex,
        color_vertex: color_vertex,
        common: common,
        cube_uv_reflection_fragment: cube_uv_reflection_fragment,
        defaultnormal_vertex: defaultnormal_vertex,
        displacementmap_pars_vertex: displacementmap_pars_vertex,
        displacementmap_vertex: displacementmap_vertex,
        emissivemap_fragment: emissivemap_fragment,
        emissivemap_pars_fragment: emissivemap_pars_fragment,
        encodings_fragment: encodings_fragment,
        encodings_pars_fragment: encodings_pars_fragment,
        envmap_fragment: envmap_fragment,
        envmap_pars_fragment: envmap_pars_fragment,
        envmap_pars_vertex: envmap_pars_vertex,
        envmap_vertex: envmap_vertex,
        fog_vertex: fog_vertex,
        fog_pars_vertex: fog_pars_vertex,
        fog_fragment: fog_fragment,
        fog_pars_fragment: fog_pars_fragment,
        gradientmap_pars_fragment: gradientmap_pars_fragment,
        lightmap_fragment: lightmap_fragment,
        lightmap_pars_fragment: lightmap_pars_fragment,
        lights_lambert_vertex: lights_lambert_vertex,
        lights_pars: lights_pars,
        lights_phong_fragment: lights_phong_fragment,
        lights_phong_pars_fragment: lights_phong_pars_fragment,
        lights_physical_fragment: lights_physical_fragment,
        lights_physical_pars_fragment: lights_physical_pars_fragment,
        lights_template: lights_template,
        logdepthbuf_fragment: logdepthbuf_fragment,
        logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
        logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
        logdepthbuf_vertex: logdepthbuf_vertex,
        map_fragment: map_fragment,
        map_pars_fragment: map_pars_fragment,
        map_particle_fragment: map_particle_fragment,
        map_particle_pars_fragment: map_particle_pars_fragment,
        metalnessmap_fragment: metalnessmap_fragment,
        metalnessmap_pars_fragment: metalnessmap_pars_fragment,
        morphnormal_vertex: morphnormal_vertex,
        morphtarget_pars_vertex: morphtarget_pars_vertex,
        morphtarget_vertex: morphtarget_vertex,
        normal_flip: normal_flip,
        normal_fragment: normal_fragment,
        normalmap_pars_fragment: normalmap_pars_fragment,
        packing: packing,
        premultiplied_alpha_fragment: premultiplied_alpha_fragment,
        project_vertex: project_vertex,
        dithering_fragment: dithering_fragment,
        dithering_pars_fragment: dithering_pars_fragment,
        roughnessmap_fragment: roughnessmap_fragment,
        roughnessmap_pars_fragment: roughnessmap_pars_fragment,
        shadowmap_pars_fragment: shadowmap_pars_fragment,
        shadowmap_pars_vertex: shadowmap_pars_vertex,
        shadowmap_vertex: shadowmap_vertex,
        shadowmask_pars_fragment: shadowmask_pars_fragment,
        skinbase_vertex: skinbase_vertex,
        skinning_pars_vertex: skinning_pars_vertex,
        skinning_vertex: skinning_vertex,
        skinnormal_vertex: skinnormal_vertex,
        specularmap_fragment: specularmap_fragment,
        specularmap_pars_fragment: specularmap_pars_fragment,
        tonemapping_fragment: tonemapping_fragment,
        tonemapping_pars_fragment: tonemapping_pars_fragment,
        uv_pars_fragment: uv_pars_fragment,
        uv_pars_vertex: uv_pars_vertex,
        uv_vertex: uv_vertex,
        uv2_pars_fragment: uv2_pars_fragment,
        uv2_pars_vertex: uv2_pars_vertex,
        uv2_vertex: uv2_vertex,
        worldpos_vertex: worldpos_vertex,

        cube_frag: cube_frag,
        cube_vert: cube_vert,
        depth_frag: depth_frag,
        depth_vert: depth_vert,
        distanceRGBA_frag: distanceRGBA_frag,
        distanceRGBA_vert: distanceRGBA_vert,
        equirect_frag: equirect_frag,
        equirect_vert: equirect_vert,
        linedashed_frag: linedashed_frag,
        linedashed_vert: linedashed_vert,
        meshbasic_frag: meshbasic_frag,
        meshbasic_vert: meshbasic_vert,
        meshlambert_frag: meshlambert_frag,
        meshlambert_vert: meshlambert_vert,
        meshphong_frag: meshphong_frag,
        meshphong_vert: meshphong_vert,
        meshphysical_frag: meshphysical_frag,
        meshphysical_vert: meshphysical_vert,
        normal_frag: normal_frag,
        normal_vert: normal_vert,
        points_frag: points_frag,
        points_vert: points_vert,
        shadow_frag: shadow_frag,
        shadow_vert: shadow_vert
    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     */

    var ShaderLib = {

        basic: {

            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),

            vertexShader: ShaderChunk.meshbasic_vert,
            fragmentShader: ShaderChunk.meshbasic_frag

        },

        lambert: {

            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
                emissive: { value: new Color(0x000000) }
            }]),

            vertexShader: ShaderChunk.meshlambert_vert,
            fragmentShader: ShaderChunk.meshlambert_frag

        },

        phong: {

            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
                emissive: { value: new Color(0x000000) },
                specular: { value: new Color(0x111111) },
                shininess: { value: 30 }
            }]),

            vertexShader: ShaderChunk.meshphong_vert,
            fragmentShader: ShaderChunk.meshphong_frag

        },

        standard: {

            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
                emissive: { value: new Color(0x000000) },
                roughness: { value: 0.5 },
                metalness: { value: 0.5 },
                envMapIntensity: { value: 1 } // temporary
            }]),

            vertexShader: ShaderChunk.meshphysical_vert,
            fragmentShader: ShaderChunk.meshphysical_frag

        },

        points: {

            uniforms: UniformsUtils.merge([UniformsLib.points, UniformsLib.fog]),

            vertexShader: ShaderChunk.points_vert,
            fragmentShader: ShaderChunk.points_frag

        },

        dashed: {

            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 }
            }]),

            vertexShader: ShaderChunk.linedashed_vert,
            fragmentShader: ShaderChunk.linedashed_frag

        },

        depth: {

            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.displacementmap]),

            vertexShader: ShaderChunk.depth_vert,
            fragmentShader: ShaderChunk.depth_frag

        },

        normal: {

            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
                opacity: { value: 1.0 }
            }]),

            vertexShader: ShaderChunk.normal_vert,
            fragmentShader: ShaderChunk.normal_frag

        },

        /* -------------------------------------------------------------------------
        //	Cube map shader
         ------------------------------------------------------------------------- */

        cube: {

            uniforms: {
                tCube: { value: null },
                tFlip: { value: -1 },
                opacity: { value: 1.0 }
            },

            vertexShader: ShaderChunk.cube_vert,
            fragmentShader: ShaderChunk.cube_frag

        },

        /* -------------------------------------------------------------------------
        //	Cube map shader
         ------------------------------------------------------------------------- */

        equirect: {

            uniforms: {
                tEquirect: { value: null },
                tFlip: { value: -1 }
            },

            vertexShader: ShaderChunk.equirect_vert,
            fragmentShader: ShaderChunk.equirect_frag

        },

        distanceRGBA: {

            uniforms: {
                lightPos: { value: new Vector3() }
            },

            vertexShader: ShaderChunk.distanceRGBA_vert,
            fragmentShader: ShaderChunk.distanceRGBA_frag

        }

    };

    ShaderLib.physical = {

        uniforms: UniformsUtils.merge([ShaderLib.standard.uniforms, {
            clearCoat: { value: 0 },
            clearCoatRoughness: { value: 0 }
        }]),

        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag

    };

    /**
     * @author bhouston / http://clara.io
     */

    function Box2(min, max) {

        this.min = min !== undefined ? min : new Vector2(+Infinity, +Infinity);
        this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
    }

    Object.assign(Box2.prototype, {

        set: function set(min, max) {

            this.min.copy(min);
            this.max.copy(max);

            return this;
        },

        setFromPoints: function setFromPoints(points) {

            this.makeEmpty();

            for (var i = 0, il = points.length; i < il; i++) {

                this.expandByPoint(points[i]);
            }

            return this;
        },

        setFromCenterAndSize: function () {

            var v1 = new Vector2();

            return function setFromCenterAndSize(center, size) {

                var halfSize = v1.copy(size).multiplyScalar(0.5);
                this.min.copy(center).sub(halfSize);
                this.max.copy(center).add(halfSize);

                return this;
            };
        }(),

        clone: function clone() {

            return new this.constructor().copy(this);
        },

        copy: function copy(box) {

            this.min.copy(box.min);
            this.max.copy(box.max);

            return this;
        },

        makeEmpty: function makeEmpty() {

            this.min.x = this.min.y = +Infinity;
            this.max.x = this.max.y = -Infinity;

            return this;
        },

        isEmpty: function isEmpty() {

            // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

            return this.max.x < this.min.x || this.max.y < this.min.y;
        },

        getCenter: function getCenter(optionalTarget) {

            var result = optionalTarget || new Vector2();
            return this.isEmpty() ? result.set(0, 0) : result.addVectors(this.min, this.max).multiplyScalar(0.5);
        },

        getSize: function getSize(optionalTarget) {

            var result = optionalTarget || new Vector2();
            return this.isEmpty() ? result.set(0, 0) : result.subVectors(this.max, this.min);
        },

        expandByPoint: function expandByPoint(point) {

            this.min.min(point);
            this.max.max(point);

            return this;
        },

        expandByVector: function expandByVector(vector) {

            this.min.sub(vector);
            this.max.add(vector);

            return this;
        },

        expandByScalar: function expandByScalar(scalar) {

            this.min.addScalar(-scalar);
            this.max.addScalar(scalar);

            return this;
        },

        containsPoint: function containsPoint(point) {

            return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
        },

        containsBox: function containsBox(box) {

            return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
        },

        getParameter: function getParameter(point, optionalTarget) {

            // This can potentially have a divide by zero if the box
            // has a size dimension of 0.

            var result = optionalTarget || new Vector2();

            return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
        },

        intersectsBox: function intersectsBox(box) {

            // using 4 splitting planes to rule out intersections

            return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
        },

        clampPoint: function clampPoint(point, optionalTarget) {

            var result = optionalTarget || new Vector2();
            return result.copy(point).clamp(this.min, this.max);
        },

        distanceToPoint: function () {

            var v1 = new Vector2();

            return function distanceToPoint(point) {

                var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                return clampedPoint.sub(point).length();
            };
        }(),

        intersect: function intersect(box) {

            this.min.max(box.min);
            this.max.min(box.max);

            return this;
        },

        union: function union(box) {

            this.min.min(box.min);
            this.max.max(box.max);

            return this;
        },

        translate: function translate(offset) {

            this.min.add(offset);
            this.max.add(offset);

            return this;
        },

        equals: function equals(box) {

            return box.min.equals(this.min) && box.max.equals(this.max);
        }

    });

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function LensFlarePlugin(renderer, flares) {

        var gl = renderer.context;
        var state = renderer.state;

        var vertexBuffer, elementBuffer;
        var shader, program, attributes, uniforms;

        var tempTexture, occlusionTexture;

        function init() {

            var vertices = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]);

            var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);

            // buffers

            vertexBuffer = gl.createBuffer();
            elementBuffer = gl.createBuffer();

            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);

            // textures

            tempTexture = gl.createTexture();
            occlusionTexture = gl.createTexture();

            state.bindTexture(gl.TEXTURE_2D, tempTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

            state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

            shader = {

                vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),

                fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {",

                // pink square

                "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

                // restore

                "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );",

                // flare

                "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")

            };

            program = createProgram(shader);

            attributes = {
                vertex: gl.getAttribLocation(program, "position"),
                uv: gl.getAttribLocation(program, "uv")
            };

            uniforms = {
                renderType: gl.getUniformLocation(program, "renderType"),
                map: gl.getUniformLocation(program, "map"),
                occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
                opacity: gl.getUniformLocation(program, "opacity"),
                color: gl.getUniformLocation(program, "color"),
                scale: gl.getUniformLocation(program, "scale"),
                rotation: gl.getUniformLocation(program, "rotation"),
                screenPosition: gl.getUniformLocation(program, "screenPosition")
            };
        }

        /*
         * Render lens flares
         * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
         *         reads these back and calculates occlusion.
         */

        this.render = function (scene, camera, viewport) {

            if (flares.length === 0) return;

            var tempPosition = new Vector3();

            var invAspect = viewport.w / viewport.z,
                halfViewportWidth = viewport.z * 0.5,
                halfViewportHeight = viewport.w * 0.5;

            var size = 16 / viewport.w,
                scale = new Vector2(size * invAspect, size);

            var screenPosition = new Vector3(1, 1, 0),
                screenPositionPixels = new Vector2(1, 1);

            var validArea = new Box2();

            validArea.min.set(viewport.x, viewport.y);
            validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));

            if (program === undefined) {

                init();
            }

            gl.useProgram(program);

            state.initAttributes();
            state.enableAttribute(attributes.vertex);
            state.enableAttribute(attributes.uv);
            state.disableUnusedAttributes();

            // loop through all lens flares to update their occlusion and positions
            // setup gl and common used attribs/uniforms

            gl.uniform1i(uniforms.occlusionMap, 0);
            gl.uniform1i(uniforms.map, 1);

            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
            gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);

            state.disable(gl.CULL_FACE);
            state.buffers.depth.setMask(false);

            for (var i = 0, l = flares.length; i < l; i++) {

                size = 16 / viewport.w;
                scale.set(size * invAspect, size);

                // calc object screen position

                var flare = flares[i];

                tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);

                tempPosition.applyMatrix4(camera.matrixWorldInverse);
                tempPosition.applyMatrix4(camera.projectionMatrix);

                // setup arrays for gl programs

                screenPosition.copy(tempPosition);

                // horizontal and vertical coordinate of the lower left corner of the pixels to copy

                screenPositionPixels.x = viewport.x + screenPosition.x * halfViewportWidth + halfViewportWidth - 8;
                screenPositionPixels.y = viewport.y + screenPosition.y * halfViewportHeight + halfViewportHeight - 8;

                // screen cull

                if (validArea.containsPoint(screenPositionPixels) === true) {

                    // save current RGB to temp texture

                    state.activeTexture(gl.TEXTURE0);
                    state.bindTexture(gl.TEXTURE_2D, null);
                    state.activeTexture(gl.TEXTURE1);
                    state.bindTexture(gl.TEXTURE_2D, tempTexture);
                    gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);

                    // render pink quad

                    gl.uniform1i(uniforms.renderType, 0);
                    gl.uniform2f(uniforms.scale, scale.x, scale.y);
                    gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);

                    state.disable(gl.BLEND);
                    state.enable(gl.DEPTH_TEST);

                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

                    // copy result to occlusionMap

                    state.activeTexture(gl.TEXTURE0);
                    state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
                    gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);

                    // restore graphics

                    gl.uniform1i(uniforms.renderType, 1);
                    state.disable(gl.DEPTH_TEST);

                    state.activeTexture(gl.TEXTURE1);
                    state.bindTexture(gl.TEXTURE_2D, tempTexture);
                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

                    // update object positions

                    flare.positionScreen.copy(screenPosition);

                    if (flare.customUpdateCallback) {

                        flare.customUpdateCallback(flare);
                    } else {

                        flare.updateLensFlares();
                    }

                    // render flares

                    gl.uniform1i(uniforms.renderType, 2);
                    state.enable(gl.BLEND);

                    for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {

                        var sprite = flare.lensFlares[j];

                        if (sprite.opacity > 0.001 && sprite.scale > 0.001) {

                            screenPosition.x = sprite.x;
                            screenPosition.y = sprite.y;
                            screenPosition.z = sprite.z;

                            size = sprite.size * sprite.scale / viewport.w;

                            scale.x = size * invAspect;
                            scale.y = size;

                            gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                            gl.uniform2f(uniforms.scale, scale.x, scale.y);
                            gl.uniform1f(uniforms.rotation, sprite.rotation);

                            gl.uniform1f(uniforms.opacity, sprite.opacity);
                            gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);

                            state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
                            renderer.setTexture2D(sprite.texture, 1);

                            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                        }
                    }
                }
            }

            // restore gl

            state.enable(gl.CULL_FACE);
            state.enable(gl.DEPTH_TEST);
            state.buffers.depth.setMask(true);

            renderer.resetGLState();
        };

        function createProgram(shader) {

            var program = gl.createProgram();

            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);

            var prefix = "precision " + renderer.getPrecision() + " float;\n";

            gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
            gl.shaderSource(vertexShader, prefix + shader.vertexShader);

            gl.compileShader(fragmentShader);
            gl.compileShader(vertexShader);

            gl.attachShader(program, fragmentShader);
            gl.attachShader(program, vertexShader);

            gl.linkProgram(program);

            return program;
        }
    }

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function SpritePlugin(renderer, sprites) {

        var gl = renderer.context;
        var state = renderer.state;

        var vertexBuffer, elementBuffer;
        var program, attributes, uniforms;

        var texture;

        // decompose matrixWorld

        var spritePosition = new Vector3();
        var spriteRotation = new Quaternion();
        var spriteScale = new Vector3();

        function init() {

            var vertices = new Float32Array([-0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0, 0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1]);

            var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);

            vertexBuffer = gl.createBuffer();
            elementBuffer = gl.createBuffer();

            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);

            program = createProgram();

            attributes = {
                position: gl.getAttribLocation(program, 'position'),
                uv: gl.getAttribLocation(program, 'uv')
            };

            uniforms = {
                uvOffset: gl.getUniformLocation(program, 'uvOffset'),
                uvScale: gl.getUniformLocation(program, 'uvScale'),

                rotation: gl.getUniformLocation(program, 'rotation'),
                scale: gl.getUniformLocation(program, 'scale'),

                color: gl.getUniformLocation(program, 'color'),
                map: gl.getUniformLocation(program, 'map'),
                opacity: gl.getUniformLocation(program, 'opacity'),

                modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
                projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),

                fogType: gl.getUniformLocation(program, 'fogType'),
                fogDensity: gl.getUniformLocation(program, 'fogDensity'),
                fogNear: gl.getUniformLocation(program, 'fogNear'),
                fogFar: gl.getUniformLocation(program, 'fogFar'),
                fogColor: gl.getUniformLocation(program, 'fogColor'),

                alphaTest: gl.getUniformLocation(program, 'alphaTest')
            };

            var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            canvas.width = 8;
            canvas.height = 8;

            var context = canvas.getContext('2d');
            context.fillStyle = 'white';
            context.fillRect(0, 0, 8, 8);

            texture = new Texture(canvas);
            texture.needsUpdate = true;
        }

        this.render = function (scene, camera) {

            if (sprites.length === 0) return;

            // setup gl

            if (program === undefined) {

                init();
            }

            gl.useProgram(program);

            state.initAttributes();
            state.enableAttribute(attributes.position);
            state.enableAttribute(attributes.uv);
            state.disableUnusedAttributes();

            state.disable(gl.CULL_FACE);
            state.enable(gl.BLEND);

            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
            gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);

            gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);

            state.activeTexture(gl.TEXTURE0);
            gl.uniform1i(uniforms.map, 0);

            var oldFogType = 0;
            var sceneFogType = 0;
            var fog = scene.fog;

            if (fog) {

                gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);

                if (fog.isFog) {

                    gl.uniform1f(uniforms.fogNear, fog.near);
                    gl.uniform1f(uniforms.fogFar, fog.far);

                    gl.uniform1i(uniforms.fogType, 1);
                    oldFogType = 1;
                    sceneFogType = 1;
                } else if (fog.isFogExp2) {

                    gl.uniform1f(uniforms.fogDensity, fog.density);

                    gl.uniform1i(uniforms.fogType, 2);
                    oldFogType = 2;
                    sceneFogType = 2;
                }
            } else {

                gl.uniform1i(uniforms.fogType, 0);
                oldFogType = 0;
                sceneFogType = 0;
            }

            // update positions and sort

            for (var i = 0, l = sprites.length; i < l; i++) {

                var sprite = sprites[i];

                sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
                sprite.z = -sprite.modelViewMatrix.elements[14];
            }

            sprites.sort(painterSortStable);

            // render all sprites

            var scale = [];

            for (var i = 0, l = sprites.length; i < l; i++) {

                var sprite = sprites[i];
                var material = sprite.material;

                if (material.visible === false) continue;

                gl.uniform1f(uniforms.alphaTest, material.alphaTest);
                gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);

                sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);

                scale[0] = spriteScale.x;
                scale[1] = spriteScale.y;

                var fogType = 0;

                if (scene.fog && material.fog) {

                    fogType = sceneFogType;
                }

                if (oldFogType !== fogType) {

                    gl.uniform1i(uniforms.fogType, fogType);
                    oldFogType = fogType;
                }

                if (material.map !== null) {

                    gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
                    gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
                } else {

                    gl.uniform2f(uniforms.uvOffset, 0, 0);
                    gl.uniform2f(uniforms.uvScale, 1, 1);
                }

                gl.uniform1f(uniforms.opacity, material.opacity);
                gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);

                gl.uniform1f(uniforms.rotation, material.rotation);
                gl.uniform2fv(uniforms.scale, scale);

                state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
                state.buffers.depth.setTest(material.depthTest);
                state.buffers.depth.setMask(material.depthWrite);

                if (material.map) {

                    renderer.setTexture2D(material.map, 0);
                } else {

                    renderer.setTexture2D(texture, 0);
                }

                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            }

            // restore gl

            state.enable(gl.CULL_FACE);

            renderer.resetGLState();
        };

        function createProgram() {

            var program = gl.createProgram();

            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

            gl.shaderSource(vertexShader, ['precision ' + renderer.getPrecision() + ' float;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform float rotation;', 'uniform vec2 scale;', 'uniform vec2 uvOffset;', 'uniform vec2 uvScale;', 'attribute vec2 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'void main() {', 'vUV = uvOffset + uv * uvScale;', 'vec2 alignedPosition = position * scale;', 'vec2 rotatedPosition;', 'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;', 'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;', 'vec4 finalPosition;', 'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );', 'finalPosition.xy += rotatedPosition;', 'finalPosition = projectionMatrix * finalPosition;', 'gl_Position = finalPosition;', '}'].join('\n'));

            gl.shaderSource(fragmentShader, ['precision ' + renderer.getPrecision() + ' float;', 'uniform vec3 color;', 'uniform sampler2D map;', 'uniform float opacity;', 'uniform int fogType;', 'uniform vec3 fogColor;', 'uniform float fogDensity;', 'uniform float fogNear;', 'uniform float fogFar;', 'uniform float alphaTest;', 'varying vec2 vUV;', 'void main() {', 'vec4 texture = texture2D( map, vUV );', 'if ( texture.a < alphaTest ) discard;', 'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );', 'if ( fogType > 0 ) {', 'float depth = gl_FragCoord.z / gl_FragCoord.w;', 'float fogFactor = 0.0;', 'if ( fogType == 1 ) {', 'fogFactor = smoothstep( fogNear, fogFar, depth );', '} else {', 'const float LOG2 = 1.442695;', 'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );', 'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );', '}', 'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );', '}', '}'].join('\n'));

            gl.compileShader(vertexShader);
            gl.compileShader(fragmentShader);

            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);

            gl.linkProgram(program);

            return program;
        }

        function painterSortStable(a, b) {

            if (a.renderOrder !== b.renderOrder) {

                return a.renderOrder - b.renderOrder;
            } else if (a.z !== b.z) {

                return b.z - a.z;
            } else {

                return b.id - a.id;
            }
        }
    }

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    var materialId = 0;

    function Material() {

        Object.defineProperty(this, 'id', { value: materialId++ });

        this.uuid = _Math.generateUUID();

        this.name = '';
        this.type = 'Material';

        this.fog = true;
        this.lights = true;

        this.blending = NormalBlending;
        this.side = FrontSide;
        this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading
        this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

        this.opacity = 1;
        this.transparent = false;

        this.blendSrc = SrcAlphaFactor;
        this.blendDst = OneMinusSrcAlphaFactor;
        this.blendEquation = AddEquation;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;

        this.depthFunc = LessEqualDepth;
        this.depthTest = true;
        this.depthWrite = true;

        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;

        this.colorWrite = true;

        this.precision = null; // override the renderer's default precision for this material

        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;

        this.dithering = false;

        this.alphaTest = 0;
        this.premultipliedAlpha = false;

        this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

        this.visible = true;

        this.needsUpdate = true;
    }

    Object.assign(Material.prototype, EventDispatcher.prototype, {

        isMaterial: true,

        setValues: function setValues(values) {

            if (values === undefined) return;

            for (var key in values) {

                var newValue = values[key];

                if (newValue === undefined) {

                    console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                    continue;
                }

                var currentValue = this[key];

                if (currentValue === undefined) {

                    console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                    continue;
                }

                if (currentValue && currentValue.isColor) {

                    currentValue.set(newValue);
                } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {

                    currentValue.copy(newValue);
                } else if (key === 'overdraw') {

                    // ensure overdraw is backwards-compatible with legacy boolean type
                    this[key] = Number(newValue);
                } else {

                    this[key] = newValue;
                }
            }
        },

        toJSON: function toJSON(meta) {

            var isRoot = meta === undefined;

            if (isRoot) {

                meta = {
                    textures: {},
                    images: {}
                };
            }

            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Material',
                    generator: 'Material.toJSON'
                }
            };

            // standard Material serialization
            data.uuid = this.uuid;
            data.type = this.type;

            if (this.name !== '') data.name = this.name;

            if (this.color && this.color.isColor) data.color = this.color.getHex();

            if (this.roughness !== undefined) data.roughness = this.roughness;
            if (this.metalness !== undefined) data.metalness = this.metalness;

            if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
            if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
            if (this.shininess !== undefined) data.shininess = this.shininess;
            if (this.clearCoat !== undefined) data.clearCoat = this.clearCoat;
            if (this.clearCoatRoughness !== undefined) data.clearCoatRoughness = this.clearCoatRoughness;

            if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
            if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
            if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;
            if (this.bumpMap && this.bumpMap.isTexture) {

                data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                data.bumpScale = this.bumpScale;
            }
            if (this.normalMap && this.normalMap.isTexture) {

                data.normalMap = this.normalMap.toJSON(meta).uuid;
                data.normalScale = this.normalScale.toArray();
            }
            if (this.displacementMap && this.displacementMap.isTexture) {

                data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                data.displacementScale = this.displacementScale;
                data.displacementBias = this.displacementBias;
            }
            if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
            if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;

            if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
            if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;

            if (this.envMap && this.envMap.isTexture) {

                data.envMap = this.envMap.toJSON(meta).uuid;
                data.reflectivity = this.reflectivity; // Scale behind envMap
            }

            if (this.gradientMap && this.gradientMap.isTexture) {

                data.gradientMap = this.gradientMap.toJSON(meta).uuid;
            }

            if (this.size !== undefined) data.size = this.size;
            if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;

            if (this.blending !== NormalBlending) data.blending = this.blending;
            if (this.shading !== SmoothShading) data.shading = this.shading;
            if (this.side !== FrontSide) data.side = this.side;
            if (this.vertexColors !== NoColors) data.vertexColors = this.vertexColors;

            if (this.opacity < 1) data.opacity = this.opacity;
            if (this.transparent === true) data.transparent = this.transparent;

            data.depthFunc = this.depthFunc;
            data.depthTest = this.depthTest;
            data.depthWrite = this.depthWrite;

            if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
            if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
            if (this.wireframe === true) data.wireframe = this.wireframe;
            if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
            if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
            if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;

            data.skinning = this.skinning;
            data.morphTargets = this.morphTargets;

            data.dithering = this.dithering;

            // TODO: Copied from Object3D.toJSON

            function extractFromCache(cache) {

                var values = [];

                for (var key in cache) {

                    var data = cache[key];
                    delete data.metadata;
                    values.push(data);
                }

                return values;
            }

            if (isRoot) {

                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);

                if (textures.length > 0) data.textures = textures;
                if (images.length > 0) data.images = images;
            }

            return data;
        },

        clone: function clone() {

            return new this.constructor().copy(this);
        },

        copy: function copy(source) {

            this.name = source.name;

            this.fog = source.fog;
            this.lights = source.lights;

            this.blending = source.blending;
            this.side = source.side;
            this.shading = source.shading;
            this.vertexColors = source.vertexColors;

            this.opacity = source.opacity;
            this.transparent = source.transparent;

            this.blendSrc = source.blendSrc;
            this.blendDst = source.blendDst;
            this.blendEquation = source.blendEquation;
            this.blendSrcAlpha = source.blendSrcAlpha;
            this.blendDstAlpha = source.blendDstAlpha;
            this.blendEquationAlpha = source.blendEquationAlpha;

            this.depthFunc = source.depthFunc;
            this.depthTest = source.depthTest;
            this.depthWrite = source.depthWrite;

            this.colorWrite = source.colorWrite;

            this.precision = source.precision;

            this.polygonOffset = source.polygonOffset;
            this.polygonOffsetFactor = source.polygonOffsetFactor;
            this.polygonOffsetUnits = source.polygonOffsetUnits;

            this.dithering = source.dithering;

            this.alphaTest = source.alphaTest;

            this.premultipliedAlpha = source.premultipliedAlpha;

            this.overdraw = source.overdraw;

            this.visible = source.visible;
            this.clipShadows = source.clipShadows;
            this.clipIntersection = source.clipIntersection;

            var srcPlanes = source.clippingPlanes,
                dstPlanes = null;

            if (srcPlanes !== null) {

                var n = srcPlanes.length;
                dstPlanes = new Array(n);

                for (var i = 0; i !== n; ++i) {
                    dstPlanes[i] = srcPlanes[i].clone();
                }
            }

            this.clippingPlanes = dstPlanes;

            return this;
        },

        dispose: function dispose() {

            this.dispatchEvent({ type: 'dispose' });
        }

    });

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  defines: { "label" : "value" },
     *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
     *
     *  fragmentShader: <string>,
     *  vertexShader: <string>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  lights: <bool>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function ShaderMaterial(parameters) {

        Material.call(this);

        this.type = 'ShaderMaterial';

        this.defines = {};
        this.uniforms = {};

        this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
        this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

        this.linewidth = 1;

        this.wireframe = false;
        this.wireframeLinewidth = 1;

        this.fog = false; // set to use scene fog
        this.lights = false; // set to use scene lights
        this.clipping = false; // set to use user-defined clipping planes

        this.skinning = false; // set to use skinning attribute streams
        this.morphTargets = false; // set to use morph targets
        this.morphNormals = false; // set to use morph normals

        this.extensions = {
            derivatives: false, // set to use derivatives
            fragDepth: false, // set to use fragment depth values
            drawBuffers: false, // set to use draw buffers
            shaderTextureLOD: false // set to use shader texture LOD
        };

        // When rendered geometry doesn't include these attributes but the material does,
        // use these default values in WebGL. This avoids errors when buffer data is missing.
        this.defaultAttributeValues = {
            'color': [1, 1, 1],
            'uv': [0, 0],
            'uv2': [0, 0]
        };

        this.index0AttributeName = undefined;

        if (parameters !== undefined) {

            if (parameters.attributes !== undefined) {

                console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
            }

            this.setValues(parameters);
        }
    }

    ShaderMaterial.prototype = Object.create(Material.prototype);
    ShaderMaterial.prototype.constructor = ShaderMaterial;

    ShaderMaterial.prototype.isShaderMaterial = true;

    ShaderMaterial.prototype.copy = function (source) {

        Material.prototype.copy.call(this, source);

        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;

        this.uniforms = UniformsUtils.clone(source.uniforms);

        this.defines = source.defines;

        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;

        this.lights = source.lights;
        this.clipping = source.clipping;

        this.skinning = source.skinning;

        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;

        this.extensions = source.extensions;

        return this;
    };

    ShaderMaterial.prototype.toJSON = function (meta) {

        var data = Material.prototype.toJSON.call(this, meta);

        data.uniforms = this.uniforms;
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;

        return data;
    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author bhouston / https://clara.io
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>
     * }
     */

    function MeshDepthMaterial(parameters) {

        Material.call(this);

        this.type = 'MeshDepthMaterial';

        this.depthPacking = BasicDepthPacking;

        this.skinning = false;
        this.morphTargets = false;

        this.map = null;

        this.alphaMap = null;

        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;

        this.wireframe = false;
        this.wireframeLinewidth = 1;

        this.fog = false;
        this.lights = false;

        this.setValues(parameters);
    }

    MeshDepthMaterial.prototype = Object.create(Material.prototype);
    MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

    MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

    MeshDepthMaterial.prototype.copy = function (source) {

        Material.prototype.copy.call(this, source);

        this.depthPacking = source.depthPacking;

        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;

        this.map = source.map;

        this.alphaMap = source.alphaMap;

        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;

        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;

        return this;
    };

    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */

    function Box3(min, max) {

        this.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);
        this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
    }

    Object.assign(Box3.prototype, {

        isBox3: true,

        set: function set(min, max) {

            this.min.copy(min);
            this.max.copy(max);

            return this;
        },

        setFromArray: function setFromArray(array) {

            var minX = +Infinity;
            var minY = +Infinity;
            var minZ = +Infinity;

            var maxX = -Infinity;
            var maxY = -Infinity;
            var maxZ = -Infinity;

            for (var i = 0, l = array.length; i < l; i += 3) {

                var x = array[i];
                var y = array[i + 1];
                var z = array[i + 2];

                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (z < minZ) minZ = z;

                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                if (z > maxZ) maxZ = z;
            }

            this.min.set(minX, minY, minZ);
            this.max.set(maxX, maxY, maxZ);

            return this;
        },

        setFromBufferAttribute: function setFromBufferAttribute(attribute) {

            var minX = +Infinity;
            var minY = +Infinity;
            var minZ = +Infinity;

            var maxX = -Infinity;
            var maxY = -Infinity;
            var maxZ = -Infinity;

            for (var i = 0, l = attribute.count; i < l; i++) {

                var x = attribute.getX(i);
                var y = attribute.getY(i);
                var z = attribute.getZ(i);

                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (z < minZ) minZ = z;

                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                if (z > maxZ) maxZ = z;
            }

            this.min.set(minX, minY, minZ);
            this.max.set(maxX, maxY, maxZ);

            return this;
        },

        setFromPoints: function setFromPoints(points) {

            this.makeEmpty();

            for (var i = 0, il = points.length; i < il; i++) {

                this.expandByPoint(points[i]);
            }

            return this;
        },

        setFromCenterAndSize: function () {

            var v1 = new Vector3();

            return function setFromCenterAndSize(center, size) {

                var halfSize = v1.copy(size).multiplyScalar(0.5);

                this.min.copy(center).sub(halfSize);
                this.max.copy(center).add(halfSize);

                return this;
            };
        }(),

        setFromObject: function setFromObject(object) {

            this.makeEmpty();

            return this.expandByObject(object);
        },

        clone: function clone() {

            return new this.constructor().copy(this);
        },

        copy: function copy(box) {

            this.min.copy(box.min);
            this.max.copy(box.max);

            return this;
        },

        makeEmpty: function makeEmpty() {

            this.min.x = this.min.y = this.min.z = +Infinity;
            this.max.x = this.max.y = this.max.z = -Infinity;

            return this;
        },

        isEmpty: function isEmpty() {

            // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        },

        getCenter: function getCenter(optionalTarget) {

            var result = optionalTarget || new Vector3();
            return this.isEmpty() ? result.set(0, 0, 0) : result.addVectors(this.min, this.max).multiplyScalar(0.5);
        },

        getSize: function getSize(optionalTarget) {

            var result = optionalTarget || new Vector3();
            return this.isEmpty() ? result.set(0, 0, 0) : result.subVectors(this.max, this.min);
        },

        expandByPoint: function expandByPoint(point) {

            this.min.min(point);
            this.max.max(point);

            return this;
        },

        expandByVector: function expandByVector(vector) {

            this.min.sub(vector);
            this.max.add(vector);

            return this;
        },

        expandByScalar: function expandByScalar(scalar) {

            this.min.addScalar(-scalar);
            this.max.addScalar(scalar);

            return this;
        },

        expandByObject: function () {

            // Computes the world-axis-aligned bounding box of an object (including its children),
            // accounting for both the object's, and children's, world transforms

            var v1 = new Vector3();

            return function expandByObject(object) {

                var scope = this;

                object.updateMatrixWorld(true);

                object.traverse(function (node) {

                    var i, l;

                    var geometry = node.geometry;

                    if (geometry !== undefined) {

                        if (geometry.isGeometry) {

                            var vertices = geometry.vertices;

                            for (i = 0, l = vertices.length; i < l; i++) {

                                v1.copy(vertices[i]);
                                v1.applyMatrix4(node.matrixWorld);

                                scope.expandByPoint(v1);
                            }
                        } else if (geometry.isBufferGeometry) {

                            var attribute = geometry.attributes.position;

                            if (attribute !== undefined) {

                                for (i = 0, l = attribute.count; i < l; i++) {

                                    v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);

                                    scope.expandByPoint(v1);
                                }
                            }
                        }
                    }
                });

                return this;
            };
        }(),

        containsPoint: function containsPoint(point) {

            return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
        },

        containsBox: function containsBox(box) {

            return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
        },

        getParameter: function getParameter(point, optionalTarget) {

            // This can potentially have a divide by zero if the box
            // has a size dimension of 0.

            var result = optionalTarget || new Vector3();

            return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
        },

        intersectsBox: function intersectsBox(box) {

            // using 6 splitting planes to rule out intersections.
            return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
        },

        intersectsSphere: function () {

            var closestPoint = new Vector3();

            return function intersectsSphere(sphere) {

                // Find the point on the AABB closest to the sphere center.
                this.clampPoint(sphere.center, closestPoint);

                // If that point is inside the sphere, the AABB and sphere intersect.
                return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
            };
        }(),

        intersectsPlane: function intersectsPlane(plane) {

            // We compute the minimum and maximum dot product values. If those values
            // are on the same side (back or front) of the plane, then there is no intersection.

            var min, max;

            if (plane.normal.x > 0) {

                min = plane.normal.x * this.min.x;
                max = plane.normal.x * this.max.x;
            } else {

                min = plane.normal.x * this.max.x;
                max = plane.normal.x * this.min.x;
            }

            if (plane.normal.y > 0) {

                min += plane.normal.y * this.min.y;
                max += plane.normal.y * this.max.y;
            } else {

                min += plane.normal.y * this.max.y;
                max += plane.normal.y * this.min.y;
            }

            if (plane.normal.z > 0) {

                min += plane.normal.z * this.min.z;
                max += plane.normal.z * this.max.z;
            } else {

                min += plane.normal.z * this.max.z;
                max += plane.normal.z * this.min.z;
            }

            return min <= plane.constant && max >= plane.constant;
        },

        clampPoint: function clampPoint(point, optionalTarget) {

            var result = optionalTarget || new Vector3();
            return result.copy(point).clamp(this.min, this.max);
        },

        distanceToPoint: function () {

            var v1 = new Vector3();

            return function distanceToPoint(point) {

                var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                return clampedPoint.sub(point).length();
            };
        }(),

        getBoundingSphere: function () {

            var v1 = new Vector3();

            return function getBoundingSphere(optionalTarget) {

                var result = optionalTarget || new Sphere();

                this.getCenter(result.center);

                result.radius = this.getSize(v1).length() * 0.5;

                return result;
            };
        }(),

        intersect: function intersect(box) {

            this.min.max(box.min);
            this.max.min(box.max);

            // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
            if (this.isEmpty()) this.makeEmpty();

            return this;
        },

        union: function union(box) {

            this.min.min(box.min);
            this.max.max(box.max);

            return this;
        },

        applyMatrix4: function () {

            var points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];

            return function applyMatrix4(matrix) {

                // transform of empty box is an empty box.
                if (this.isEmpty()) return this;

                // NOTE: I am using a binary pattern to specify all 2^3 combinations below
                points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
                points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
                points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
                points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
                points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
                points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
                points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
                points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

                this.setFromPoints(points);

                return this;
            };
        }(),

        translate: function translate(offset) {

            this.min.add(offset);
            this.max.add(offset);

            return this;
        },

        equals: function equals(box) {

            return box.min.equals(this.min) && box.max.equals(this.max);
        }

    });

    /**
     * @author bhouston / http://clara.io
     * @author mrdoob / http://mrdoob.com/
     */

    function Sphere(center, radius) {

        this.center = center !== undefined ? center : new Vector3();
        this.radius = radius !== undefined ? radius : 0;
    }

    Object.assign(Sphere.prototype, {

        set: function set(center, radius) {

            this.center.copy(center);
            this.radius = radius;

            return this;
        },

        setFromPoints: function () {

            var box = new Box3();

            return function setFromPoints(points, optionalCenter) {

                var center = this.center;

                if (optionalCenter !== undefined) {

                    center.copy(optionalCenter);
                } else {

                    box.setFromPoints(points).getCenter(center);
                }

                var maxRadiusSq = 0;

                for (var i = 0, il = points.length; i < il; i++) {

                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
                }

                this.radius = Math.sqrt(maxRadiusSq);

                return this;
            };
        }(),

        clone: function clone() {

            return new this.constructor().copy(this);
        },

        copy: function copy(sphere) {

            this.center.copy(sphere.center);
            this.radius = sphere.radius;

            return this;
        },

        empty: function empty() {

            return this.radius <= 0;
        },

        containsPoint: function containsPoint(point) {

            return point.distanceToSquared(this.center) <= this.radius * this.radius;
        },

        distanceToPoint: function distanceToPoint(point) {

            return point.distanceTo(this.center) - this.radius;
        },

        intersectsSphere: function intersectsSphere(sphere) {

            var radiusSum = this.radius + sphere.radius;

            return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
        },

        intersectsBox: function intersectsBox(box) {

            return box.intersectsSphere(this);
        },

        intersectsPlane: function intersectsPlane(plane) {

            // We use the following equation to compute the signed distance from
            // the center of the sphere to the plane.
            //
            // distance = q * n - d
            //
            // If this distance is greater than the radius of the sphere,
            // then there is no intersection.

            return Math.abs(this.center.dot(plane.normal) - plane.constant) <= this.radius;
        },

        clampPoint: function clampPoint(point, optionalTarget) {

            var deltaLengthSq = this.center.distanceToSquared(point);

            var result = optionalTarget || new Vector3();

            result.copy(point);

            if (deltaLengthSq > this.radius * this.radius) {

                result.sub(this.center).normalize();
                result.multiplyScalar(this.radius).add(this.center);
            }

            return result;
        },

        getBoundingBox: function getBoundingBox(optionalTarget) {

            var box = optionalTarget || new Box3();

            box.set(this.center, this.center);
            box.expandByScalar(this.radius);

            return box;
        },

        applyMatrix4: function applyMatrix4(matrix) {

            this.center.applyMatrix4(matrix);
            this.radius = this.radius * matrix.getMaxScaleOnAxis();

            return this;
        },

        translate: function translate(offset) {

            this.center.add(offset);

            return this;
        },

        equals: function equals(sphere) {

            return sphere.center.equals(this.center) && sphere.radius === this.radius;
        }

    });

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     * @author tschw
     */

    function Matrix3() {

        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

        if (arguments.length > 0) {

            console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
        }
    }

    Object.assign(Matrix3.prototype, {

        isMatrix3: true,

        set: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {

            var te = this.elements;

            te[0] = n11;te[1] = n21;te[2] = n31;
            te[3] = n12;te[4] = n22;te[5] = n32;
            te[6] = n13;te[7] = n23;te[8] = n33;

            return this;
        },

        identity: function identity() {

            this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);

            return this;
        },

        clone: function clone() {

            return new this.constructor().fromArray(this.elements);
        },

        copy: function copy(m) {

            var te = this.elements;
            var me = m.elements;

            te[0] = me[0];te[1] = me[1];te[2] = me[2];
            te[3] = me[3];te[4] = me[4];te[5] = me[5];
            te[6] = me[6];te[7] = me[7];te[8] = me[8];

            return this;
        },

        setFromMatrix4: function setFromMatrix4(m) {

            var me = m.elements;

            this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);

            return this;
        },

        applyToBufferAttribute: function () {

            var v1 = new Vector3();

            return function applyToBufferAttribute(attribute) {

                for (var i = 0, l = attribute.count; i < l; i++) {

                    v1.x = attribute.getX(i);
                    v1.y = attribute.getY(i);
                    v1.z = attribute.getZ(i);

                    v1.applyMatrix3(this);

                    attribute.setXYZ(i, v1.x, v1.y, v1.z);
                }

                return attribute;
            };
        }(),

        multiply: function multiply(m) {

            return this.multiplyMatrices(this, m);
        },

        premultiply: function premultiply(m) {

            return this.multiplyMatrices(m, this);
        },

        multiplyMatrices: function multiplyMatrices(a, b) {

            var ae = a.elements;
            var be = b.elements;
            var te = this.elements;

            var a11 = ae[0],
                a12 = ae[3],
                a13 = ae[6];
            var a21 = ae[1],
                a22 = ae[4],
                a23 = ae[7];
            var a31 = ae[2],
                a32 = ae[5],
                a33 = ae[8];

            var b11 = be[0],
                b12 = be[3],
                b13 = be[6];
            var b21 = be[1],
                b22 = be[4],
                b23 = be[7];
            var b31 = be[2],
                b32 = be[5],
                b33 = be[8];

            te[0] = a11 * b11 + a12 * b21 + a13 * b31;
            te[3] = a11 * b12 + a12 * b22 + a13 * b32;
            te[6] = a11 * b13 + a12 * b23 + a13 * b33;

            te[1] = a21 * b11 + a22 * b21 + a23 * b31;
            te[4] = a21 * b12 + a22 * b22 + a23 * b32;
            te[7] = a21 * b13 + a22 * b23 + a23 * b33;

            te[2] = a31 * b11 + a32 * b21 + a33 * b31;
            te[5] = a31 * b12 + a32 * b22 + a33 * b32;
            te[8] = a31 * b13 + a32 * b23 + a33 * b33;

            return this;
        },

        multiplyScalar: function multiplyScalar(s) {

            var te = this.elements;

            te[0] *= s;te[3] *= s;te[6] *= s;
            te[1] *= s;te[4] *= s;te[7] *= s;
            te[2] *= s;te[5] *= s;te[8] *= s;

            return this;
        },

        determinant: function determinant() {

            var te = this.elements;

            var a = te[0],
                b = te[1],
                c = te[2],
                d = te[3],
                e = te[4],
                f = te[5],
                g = te[6],
                h = te[7],
                i = te[8];

            return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        },

        getInverse: function getInverse(matrix, throwOnDegenerate) {

            if (matrix && matrix.isMatrix4) {

                console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
            }

            var me = matrix.elements,
                te = this.elements,
                n11 = me[0],
                n21 = me[1],
                n31 = me[2],
                n12 = me[3],
                n22 = me[4],
                n32 = me[5],
                n13 = me[6],
                n23 = me[7],
                n33 = me[8],
                t11 = n33 * n22 - n32 * n23,
                t12 = n32 * n13 - n33 * n12,
                t13 = n23 * n12 - n22 * n13,
                det = n11 * t11 + n21 * t12 + n31 * t13;

            if (det === 0) {

                var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";

                if (throwOnDegenerate === true) {

                    throw new Error(msg);
                } else {

                    console.warn(msg);
                }

                return this.identity();
            }

            var detInv = 1 / det;

            te[0] = t11 * detInv;
            te[1] = (n31 * n23 - n33 * n21) * detInv;
            te[2] = (n32 * n21 - n31 * n22) * detInv;

            te[3] = t12 * detInv;
            te[4] = (n33 * n11 - n31 * n13) * detInv;
            te[5] = (n31 * n12 - n32 * n11) * detInv;

            te[6] = t13 * detInv;
            te[7] = (n21 * n13 - n23 * n11) * detInv;
            te[8] = (n22 * n11 - n21 * n12) * detInv;

            return this;
        },

        transpose: function transpose() {

            var tmp,
                m = this.elements;

            tmp = m[1];m[1] = m[3];m[3] = tmp;
            tmp = m[2];m[2] = m[6];m[6] = tmp;
            tmp = m[5];m[5] = m[7];m[7] = tmp;

            return this;
        },

        getNormalMatrix: function getNormalMatrix(matrix4) {

            return this.setFromMatrix4(matrix4).getInverse(this).transpose();
        },

        transposeIntoArray: function transposeIntoArray(r) {

            var m = this.elements;

            r[0] = m[0];
            r[1] = m[3];
            r[2] = m[6];
            r[3] = m[1];
            r[4] = m[4];
            r[5] = m[7];
            r[6] = m[2];
            r[7] = m[5];
            r[8] = m[8];

            return this;
        },

        equals: function equals(matrix) {

            var te = this.elements;
            var me = matrix.elements;

            for (var i = 0; i < 9; i++) {

                if (te[i] !== me[i]) return false;
            }

            return true;
        },

        fromArray: function fromArray(array, offset) {

            if (offset === undefined) offset = 0;

            for (var i = 0; i < 9; i++) {

                this.elements[i] = array[i + offset];
            }

            return this;
        },

        toArray: function toArray(array, offset) {

            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;

            var te = this.elements;

            array[offset] = te[0];
            array[offset + 1] = te[1];
            array[offset + 2] = te[2];

            array[offset + 3] = te[3];
            array[offset + 4] = te[4];
            array[offset + 5] = te[5];

            array[offset + 6] = te[6];
            array[offset + 7] = te[7];
            array[offset + 8] = te[8];

            return array;
        }

    });

    /**
     * @author bhouston / http://clara.io
     */

    function Plane(normal, constant) {

        this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
        this.constant = constant !== undefined ? constant : 0;
    }

    Object.assign(Plane.prototype, {

        set: function set(normal, constant) {

            this.normal.copy(normal);
            this.constant = constant;

            return this;
        },

        setComponents: function setComponents(x, y, z, w) {

            this.normal.set(x, y, z);
            this.constant = w;

            return this;
        },

        setFromNormalAndCoplanarPoint: function setFromNormalAndCoplanarPoint(normal, point) {

            this.normal.copy(normal);
            this.constant = -point.dot(this.normal); // must be this.normal, not normal, as this.normal is normalized

            return this;
        },

        setFromCoplanarPoints: function () {

            var v1 = new Vector3();
            var v2 = new Vector3();

            return function setFromCoplanarPoints(a, b, c) {

                var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();

                // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

                this.setFromNormalAndCoplanarPoint(normal, a);

                return this;
            };
        }(),

        clone: function clone() {

            return new this.constructor().copy(this);
        },

        copy: function copy(plane) {

            this.normal.copy(plane.normal);
            this.constant = plane.constant;

            return this;
        },

        normalize: function normalize() {

            // Note: will lead to a divide by zero if the plane is invalid.

            var inverseNormalLength = 1.0 / this.normal.length();
            this.normal.multiplyScalar(inverseNormalLength);
            this.constant *= inverseNormalLength;

            return this;
        },

        negate: function negate() {

            this.constant *= -1;
            this.normal.negate();

            return this;
        },

        distanceToPoint: function distanceToPoint(point) {

            return this.normal.dot(point) + this.constant;
        },

        distanceToSphere: function distanceToSphere(sphere) {

            return this.distanceToPoint(sphere.center) - sphere.radius;
        },

        projectPoint: function projectPoint(point, optionalTarget) {

            return this.orthoPoint(point, optionalTarget).sub(point).negate();
        },

        orthoPoint: function orthoPoint(point, optionalTarget) {

            var perpendicularMagnitude = this.distanceToPoint(point);

            var result = optionalTarget || new Vector3();
            return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
        },

        intersectLine: function () {

            var v1 = new Vector3();

            return function intersectLine(line, optionalTarget) {

                var result = optionalTarget || new Vector3();

                var direction = line.delta(v1);

                var denominator = this.normal.dot(direction);

                if (denominator === 0) {

                    // line is coplanar, return origin
                    if (this.distanceToPoint(line.start) === 0) {

                        return result.copy(line.start);
                    }

                    // Unsure if this is the correct method to handle this case.
                    return undefined;
                }

                var t = -(line.start.dot(this.normal) + this.constant) / denominator;

                if (t < 0 || t > 1) {

                    return undefined;
                }

                return result.copy(direction).multiplyScalar(t).add(line.start);
            };
        }(),

        intersectsLine: function intersectsLine(line) {

            // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

            var startSign = this.distanceToPoint(line.start);
            var endSign = this.distanceToPoint(line.end);

            return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
        },

        intersectsBox: function intersectsBox(box) {

            return box.intersectsPlane(this);
        },

        intersectsSphere: function intersectsSphere(sphere) {

            return sphere.intersectsPlane(this);
        },

        coplanarPoint: function coplanarPoint(optionalTarget) {

            var result = optionalTarget || new Vector3();
            return result.copy(this.normal).multiplyScalar(-this.constant);
        },

        applyMatrix4: function () {

            var v1 = new Vector3();
            var m1 = new Matrix3();

            return function applyMatrix4(matrix, optionalNormalMatrix) {

                var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);

                // transform normal based on theory here:
                // http://www.songho.ca/opengl/gl_normaltransform.html
                var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
                var normal = this.normal.applyMatrix3(normalMatrix).normalize();

                // recalculate constant (like in setFromNormalAndCoplanarPoint)
                this.constant = -referencePoint.dot(normal);

                return this;
            };
        }(),

        translate: function translate(offset) {

            this.constant = this.constant - offset.dot(this.normal);

            return this;
        },

        equals: function equals(plane) {

            return plane.normal.equals(this.normal) && plane.constant === this.constant;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author bhouston / http://clara.io
     */

    function Frustum(p0, p1, p2, p3, p4, p5) {

        this.planes = [p0 !== undefined ? p0 : new Plane(), p1 !== undefined ? p1 : new Plane(), p2 !== undefined ? p2 : new Plane(), p3 !== undefined ? p3 : new Plane(), p4 !== undefined ? p4 : new Plane(), p5 !== undefined ? p5 : new Plane()];
    }

    Object.assign(Frustum.prototype, {

        set: function set(p0, p1, p2, p3, p4, p5) {

            var planes = this.planes;

            planes[0].copy(p0);
            planes[1].copy(p1);
            planes[2].copy(p2);
            planes[3].copy(p3);
            planes[4].copy(p4);
            planes[5].copy(p5);

            return this;
        },

        clone: function clone() {

            return new this.constructor().copy(this);
        },

        copy: function copy(frustum) {

            var planes = this.planes;

            for (var i = 0; i < 6; i++) {

                planes[i].copy(frustum.planes[i]);
            }

            return this;
        },

        setFromMatrix: function setFromMatrix(m) {

            var planes = this.planes;
            var me = m.elements;
            var me0 = me[0],
                me1 = me[1],
                me2 = me[2],
                me3 = me[3];
            var me4 = me[4],
                me5 = me[5],
                me6 = me[6],
                me7 = me[7];
            var me8 = me[8],
                me9 = me[9],
                me10 = me[10],
                me11 = me[11];
            var me12 = me[12],
                me13 = me[13],
                me14 = me[14],
                me15 = me[15];

            planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
            planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
            planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
            planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
            planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
            planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();

            return this;
        },

        intersectsObject: function () {

            var sphere = new Sphere();

            return function intersectsObject(object) {

                var geometry = object.geometry;

                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

                sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

                return this.intersectsSphere(sphere);
            };
        }(),

        intersectsSprite: function () {

            var sphere = new Sphere();

            return function intersectsSprite(sprite) {

                sphere.center.set(0, 0, 0);
                sphere.radius = 0.7071067811865476;
                sphere.applyMatrix4(sprite.matrixWorld);

                return this.intersectsSphere(sphere);
            };
        }(),

        intersectsSphere: function intersectsSphere(sphere) {

            var planes = this.planes;
            var center = sphere.center;
            var negRadius = -sphere.radius;

            for (var i = 0; i < 6; i++) {

                var distance = planes[i].distanceToPoint(center);

                if (distance < negRadius) {

                    return false;
                }
            }

            return true;
        },

        intersectsBox: function () {

            var p1 = new Vector3(),
                p2 = new Vector3();

            return function intersectsBox(box) {

                var planes = this.planes;

                for (var i = 0; i < 6; i++) {

                    var plane = planes[i];

                    p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                    p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                    p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                    p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                    p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                    p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

                    var d1 = plane.distanceToPoint(p1);
                    var d2 = plane.distanceToPoint(p2);

                    // if both outside plane, no intersection

                    if (d1 < 0 && d2 < 0) {

                        return false;
                    }
                }

                return true;
            };
        }(),

        containsPoint: function containsPoint(point) {

            var planes = this.planes;

            for (var i = 0; i < 6; i++) {

                if (planes[i].distanceToPoint(point) < 0) {

                    return false;
                }
            }

            return true;
        }

    });

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLShadowMap(_renderer, _lights, _objects, capabilities) {

        var _gl = _renderer.context,
            _state = _renderer.state,
            _frustum = new Frustum(),
            _projScreenMatrix = new Matrix4(),
            _lightShadows = _lights.shadows,
            _shadowMapSize = new Vector2(),
            _maxShadowMapSize = new Vector2(capabilities.maxTextureSize, capabilities.maxTextureSize),
            _lookTarget = new Vector3(),
            _lightPositionWorld = new Vector3(),
            _MorphingFlag = 1,
            _SkinningFlag = 2,
            _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1,
            _depthMaterials = new Array(_NumberOfMaterialVariants),
            _distanceMaterials = new Array(_NumberOfMaterialVariants),
            _materialCache = {};

        var cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];

        var cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];

        var cube2DViewPorts = [new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4()];

        // init

        var depthMaterialTemplate = new MeshDepthMaterial();
        depthMaterialTemplate.depthPacking = RGBADepthPacking;
        depthMaterialTemplate.clipping = true;

        var distanceShader = ShaderLib["distanceRGBA"];
        var distanceUniforms = UniformsUtils.clone(distanceShader.uniforms);

        for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {

            var useMorphing = (i & _MorphingFlag) !== 0;
            var useSkinning = (i & _SkinningFlag) !== 0;

            var depthMaterial = depthMaterialTemplate.clone();
            depthMaterial.morphTargets = useMorphing;
            depthMaterial.skinning = useSkinning;

            _depthMaterials[i] = depthMaterial;

            var distanceMaterial = new ShaderMaterial({
                defines: {
                    'USE_SHADOWMAP': ''
                },
                uniforms: distanceUniforms,
                vertexShader: distanceShader.vertexShader,
                fragmentShader: distanceShader.fragmentShader,
                morphTargets: useMorphing,
                skinning: useSkinning,
                clipping: true
            });

            _distanceMaterials[i] = distanceMaterial;
        }

        //

        var scope = this;

        this.enabled = false;

        this.autoUpdate = true;
        this.needsUpdate = false;

        this.type = PCFShadowMap;

        this.renderReverseSided = true;
        this.renderSingleSided = true;

        this.render = function (scene, camera) {

            if (scope.enabled === false) return;
            if (scope.autoUpdate === false && scope.needsUpdate === false) return;

            if (_lightShadows.length === 0) return;

            // Set GL state for depth map.
            _state.disable(_gl.BLEND);
            _state.buffers.color.setClear(1, 1, 1, 1);
            _state.buffers.depth.setTest(true);
            _state.setScissorTest(false);

            // render depth map

            var faceCount, isPointLight;

            for (var i = 0, il = _lightShadows.length; i < il; i++) {

                var light = _lightShadows[i];
                var shadow = light.shadow;

                if (shadow === undefined) {

                    console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                    continue;
                }

                var shadowCamera = shadow.camera;
                var shadowMatrix = shadow.matrix;

                _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
                shadowCamera.position.copy(_lightPositionWorld);

                _shadowMapSize.copy(shadow.mapSize);
                _shadowMapSize.min(_maxShadowMapSize);

                if (light && light.isPointLight) {

                    faceCount = 6;
                    isPointLight = true;

                    var vpWidth = _shadowMapSize.x;
                    var vpHeight = _shadowMapSize.y;

                    // These viewports map a cube-map onto a 2D texture with the
                    // following orientation:
                    //
                    //  xzXZ
                    //   y Y
                    //
                    // X - Positive x direction
                    // x - Negative x direction
                    // Y - Positive y direction
                    // y - Negative y direction
                    // Z - Positive z direction
                    // z - Negative z direction

                    // positive X
                    cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
                    // negative X
                    cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
                    // positive Z
                    cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
                    // negative Z
                    cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
                    // positive Y
                    cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
                    // negative Y
                    cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);

                    _shadowMapSize.x *= 4.0;
                    _shadowMapSize.y *= 2.0;

                    // for point lights we set the shadow matrix to be a translation-only matrix
                    // equal to inverse of the light's position

                    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
                } else {

                    faceCount = 1;
                    isPointLight = false;

                    _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                    shadowCamera.lookAt(_lookTarget);
                    shadowCamera.updateMatrixWorld();
                    shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);

                    // compute shadow matrix

                    shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);

                    shadowMatrix.multiply(shadowCamera.projectionMatrix);
                    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
                }

                if (shadow.map === null) {

                    var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

                    shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                    shadow.map.texture.name = light.name + ".shadowMap";

                    shadowCamera.updateProjectionMatrix();
                }

                if (shadow.isSpotLightShadow) {

                    shadow.update(light);
                }

                var shadowMap = shadow.map;

                _renderer.setRenderTarget(shadowMap);
                _renderer.clear();

                // render shadow map for each cube face (if omni-directional) or
                // run a single pass if not

                for (var face = 0; face < faceCount; face++) {

                    if (isPointLight) {

                        _lookTarget.copy(shadowCamera.position);
                        _lookTarget.add(cubeDirections[face]);
                        shadowCamera.up.copy(cubeUps[face]);
                        shadowCamera.lookAt(_lookTarget);
                        shadowCamera.updateMatrixWorld();
                        shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);

                        var vpDimensions = cube2DViewPorts[face];
                        _state.viewport(vpDimensions);
                    }

                    // update camera matrices and frustum

                    _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
                    _frustum.setFromMatrix(_projScreenMatrix);

                    // set object matrices & frustum culling

                    renderObject(scene, camera, shadowCamera, isPointLight);
                }
            }

            // Restore GL state.
            var clearColor = _renderer.getClearColor();
            var clearAlpha = _renderer.getClearAlpha();
            _renderer.setClearColor(clearColor, clearAlpha);

            scope.needsUpdate = false;
        };

        function getDepthMaterial(object, material, isPointLight, lightPositionWorld) {

            var geometry = object.geometry;

            var result = null;

            var materialVariants = _depthMaterials;
            var customMaterial = object.customDepthMaterial;

            if (isPointLight) {

                materialVariants = _distanceMaterials;
                customMaterial = object.customDistanceMaterial;
            }

            if (!customMaterial) {

                var useMorphing = false;

                if (material.morphTargets) {

                    if (geometry && geometry.isBufferGeometry) {

                        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
                    } else if (geometry && geometry.isGeometry) {

                        useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
                    }
                }

                if (object.isSkinnedMesh && material.skinning === false) {

                    console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
                }

                var useSkinning = object.isSkinnedMesh && material.skinning;

                var variantIndex = 0;

                if (useMorphing) variantIndex |= _MorphingFlag;
                if (useSkinning) variantIndex |= _SkinningFlag;

                result = materialVariants[variantIndex];
            } else {

                result = customMaterial;
            }

            if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {

                // in this case we need a unique material instance reflecting the
                // appropriate state

                var keyA = result.uuid,
                    keyB = material.uuid;

                var materialsForVariant = _materialCache[keyA];

                if (materialsForVariant === undefined) {

                    materialsForVariant = {};
                    _materialCache[keyA] = materialsForVariant;
                }

                var cachedMaterial = materialsForVariant[keyB];

                if (cachedMaterial === undefined) {

                    cachedMaterial = result.clone();
                    materialsForVariant[keyB] = cachedMaterial;
                }

                result = cachedMaterial;
            }

            result.visible = material.visible;
            result.wireframe = material.wireframe;

            var side = material.side;

            if (scope.renderSingleSided && side == DoubleSide) {

                side = FrontSide;
            }

            if (scope.renderReverseSided) {

                if (side === FrontSide) side = BackSide;else if (side === BackSide) side = FrontSide;
            }

            result.side = side;

            result.clipShadows = material.clipShadows;
            result.clippingPlanes = material.clippingPlanes;

            result.wireframeLinewidth = material.wireframeLinewidth;
            result.linewidth = material.linewidth;

            if (isPointLight && result.uniforms.lightPos !== undefined) {

                result.uniforms.lightPos.value.copy(lightPositionWorld);
            }

            return result;
        }

        function renderObject(object, camera, shadowCamera, isPointLight) {

            if (object.visible === false) return;

            var visible = object.layers.test(camera.layers);

            if (visible && (object.isMesh || object.isLine || object.isPoints)) {

                if (object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {

                    object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

                    var geometry = _objects.update(object);
                    var material = object.material;

                    if (Array.isArray(material)) {

                        var groups = geometry.groups;

                        for (var k = 0, kl = groups.length; k < kl; k++) {

                            var group = groups[k];
                            var groupMaterial = material[group.materialIndex];

                            if (groupMaterial && groupMaterial.visible) {

                                var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld);
                                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                            }
                        }
                    } else if (material.visible) {

                        var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld);
                        _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                    }
                }
            }

            var children = object.children;

            for (var i = 0, l = children.length; i < l; i++) {

                renderObject(children[i], camera, shadowCamera, isPointLight);
            }
        }
    }

    /**
     * @author bhouston / http://clara.io
     */

    function Ray(origin, direction) {

        this.origin = origin !== undefined ? origin : new Vector3();
        this.direction = direction !== undefined ? direction : new Vector3();
    }

    Object.assign(Ray.prototype, {

        set: function set(origin, direction) {

            this.origin.copy(origin);
            this.direction.copy(direction);

            return this;
        },

        clone: function clone() {

            return new this.constructor().copy(this);
        },

        copy: function copy(ray) {

            this.origin.copy(ray.origin);
            this.direction.copy(ray.direction);

            return this;
        },

        at: function at(t, optionalTarget) {

            var result = optionalTarget || new Vector3();

            return result.copy(this.direction).multiplyScalar(t).add(this.origin);
        },

        lookAt: function lookAt(v) {

            this.direction.copy(v).sub(this.origin).normalize();

            return this;
        },

        recast: function () {

            var v1 = new Vector3();

            return function recast(t) {

                this.origin.copy(this.at(t, v1));

                return this;
            };
        }(),

        closestPointToPoint: function closestPointToPoint(point, optionalTarget) {

            var result = optionalTarget || new Vector3();
            result.subVectors(point, this.origin);
            var directionDistance = result.dot(this.direction);

            if (directionDistance < 0) {

                return result.copy(this.origin);
            }

            return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        },

        distanceToPoint: function distanceToPoint(point) {

            return Math.sqrt(this.distanceSqToPoint(point));
        },

        distanceSqToPoint: function () {

            var v1 = new Vector3();

            return function distanceSqToPoint(point) {

                var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);

                // point behind the ray

                if (directionDistance < 0) {

                    return this.origin.distanceToSquared(point);
                }

                v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

                return v1.distanceToSquared(point);
            };
        }(),

        distanceSqToSegment: function () {

            var segCenter = new Vector3();
            var segDir = new Vector3();
            var diff = new Vector3();

            return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {

                // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
                // It returns the min distance between the ray and the segment
                // defined by v0 and v1
                // It can also set two optional targets :
                // - The closest point on the ray
                // - The closest point on the segment

                segCenter.copy(v0).add(v1).multiplyScalar(0.5);
                segDir.copy(v1).sub(v0).normalize();
                diff.copy(this.origin).sub(segCenter);

                var segExtent = v0.distanceTo(v1) * 0.5;
                var a01 = -this.direction.dot(segDir);
                var b0 = diff.dot(this.direction);
                var b1 = -diff.dot(segDir);
                var c = diff.lengthSq();
                var det = Math.abs(1 - a01 * a01);
                var s0, s1, sqrDist, extDet;

                if (det > 0) {

                    // The ray and segment are not parallel.

                    s0 = a01 * b1 - b0;
                    s1 = a01 * b0 - b1;
                    extDet = segExtent * det;

                    if (s0 >= 0) {

                        if (s1 >= -extDet) {

                            if (s1 <= extDet) {

                                // region 0
                                // Minimum at interior points of ray and segment.

                                var invDet = 1 / det;
                                s0 *= invDet;
                                s1 *= invDet;
                                sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                            } else {

                                // region 1

                                s1 = segExtent;
                                s0 = Math.max(0, -(a01 * s1 + b0));
                                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                            }
                        } else {

                            // region 5

                            s1 = -segExtent;
                            s0 = Math.max(0, -(a01 * s1 + b0));
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    } else {

                        if (s1 <= -extDet) {

                            // region 4

                            s0 = Math.max(0, -(-a01 * segExtent + b0));
                            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        } else if (s1 <= extDet) {

                            // region 3

                            s0 = 0;
                            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                            sqrDist = s1 * (s1 + 2 * b1) + c;
                        } else {

                            // region 2

                            s0 = Math.max(0, -(a01 * segExtent + b0));
                            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    }
                } else {

                    // Ray and segment are parallel.

                    s1 = a01 > 0 ? -segExtent : segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }

                if (optionalPointOnRay) {

                    optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
                }

                if (optionalPointOnSegment) {

                    optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
                }

                return sqrDist;
            };
        }(),

        intersectSphere: function () {

            var v1 = new Vector3();

            return function intersectSphere(sphere, optionalTarget) {

                v1.subVectors(sphere.center, this.origin);
                var tca = v1.dot(this.direction);
                var d2 = v1.dot(v1) - tca * tca;
                var radius2 = sphere.radius * sphere.radius;

                if (d2 > radius2) return null;

                var thc = Math.sqrt(radius2 - d2);

                // t0 = first intersect point - entrance on front of sphere
                var t0 = tca - thc;

                // t1 = second intersect point - exit point on back of sphere
                var t1 = tca + thc;

                // test to see if both t0 and t1 are behind the ray - if so, return null
                if (t0 < 0 && t1 < 0) return null;

                // test to see if t0 is behind the ray:
                // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
                // in order to always return an intersect point that is in front of the ray.
                if (t0 < 0) return this.at(t1, optionalTarget);

                // else t0 is in front of the ray, so return the first collision point scaled by t0
                return this.at(t0, optionalTarget);
            };
        }(),

        intersectsSphere: function intersectsSphere(sphere) {

            return this.distanceToPoint(sphere.center) <= sphere.radius;
        },

        distanceToPlane: function distanceToPlane(plane) {

            var denominator = plane.normal.dot(this.direction);

            if (denominator === 0) {

                // line is coplanar, return origin
                if (plane.distanceToPoint(this.origin) === 0) {

                    return 0;
                }

                // Null is preferable to undefined since undefined means.... it is undefined

                return null;
            }

            var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;

            // Return if the ray never intersects the plane

            return t >= 0 ? t : null;
        },

        intersectPlane: function intersectPlane(plane, optionalTarget) {

            var t = this.distanceToPlane(plane);

            if (t === null) {

                return null;
            }

            return this.at(t, optionalTarget);
        },

        intersectsPlane: function intersectsPlane(plane) {

            // check if the ray lies on the plane first

            var distToPoint = plane.distanceToPoint(this.origin);

            if (distToPoint === 0) {

                return true;
            }

            var denominator = plane.normal.dot(this.direction);

            if (denominator * distToPoint < 0) {

                return true;
            }

            // ray origin is behind the plane (and is pointing behind it)

            return false;
        },

        intersectBox: function intersectBox(box, optionalTarget) {

            var tmin, tmax, tymin, tymax, tzmin, tzmax;

            var invdirx = 1 / this.direction.x,
                invdiry = 1 / this.direction.y,
                invdirz = 1 / this.direction.z;

            var origin = this.origin;

            if (invdirx >= 0) {

                tmin = (box.min.x - origin.x) * invdirx;
                tmax = (box.max.x - origin.x) * invdirx;
            } else {

                tmin = (box.max.x - origin.x) * invdirx;
                tmax = (box.min.x - origin.x) * invdirx;
            }

            if (invdiry >= 0) {

                tymin = (box.min.y - origin.y) * invdiry;
                tymax = (box.max.y - origin.y) * invdiry;
            } else {

                tymin = (box.max.y - origin.y) * invdiry;
                tymax = (box.min.y - origin.y) * invdiry;
            }

            if (tmin > tymax || tymin > tmax) return null;

            // These lines also handle the case where tmin or tmax is NaN
            // (result of 0 * Infinity). x !== x returns true if x is NaN

            if (tymin > tmin || tmin !== tmin) tmin = tymin;

            if (tymax < tmax || tmax !== tmax) tmax = tymax;

            if (invdirz >= 0) {

                tzmin = (box.min.z - origin.z) * invdirz;
                tzmax = (box.max.z - origin.z) * invdirz;
            } else {

                tzmin = (box.max.z - origin.z) * invdirz;
                tzmax = (box.min.z - origin.z) * invdirz;
            }

            if (tmin > tzmax || tzmin > tmax) return null;

            if (tzmin > tmin || tmin !== tmin) tmin = tzmin;

            if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

            //return point closest to the ray (positive side)

            if (tmax < 0) return null;

            return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
        },

        intersectsBox: function () {

            var v = new Vector3();

            return function intersectsBox(box) {

                return this.intersectBox(box, v) !== null;
            };
        }(),

        intersectTriangle: function () {

            // Compute the offset origin, edges, and normal.
            var diff = new Vector3();
            var edge1 = new Vector3();
            var edge2 = new Vector3();
            var normal = new Vector3();

            return function intersectTriangle(a, b, c, backfaceCulling, optionalTarget) {

                // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

                edge1.subVectors(b, a);
                edge2.subVectors(c, a);
                normal.crossVectors(edge1, edge2);

                // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
                // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
                //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
                //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
                //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
                var DdN = this.direction.dot(normal);
                var sign;

                if (DdN > 0) {

                    if (backfaceCulling) return null;
                    sign = 1;
                } else if (DdN < 0) {

                    sign = -1;
                    DdN = -DdN;
                } else {

                    return null;
                }

                diff.subVectors(this.origin, a);
                var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));

                // b1 < 0, no intersection
                if (DdQxE2 < 0) {

                    return null;
                }

                var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));

                // b2 < 0, no intersection
                if (DdE1xQ < 0) {

                    return null;
                }

                // b1+b2 > 1, no intersection
                if (DdQxE2 + DdE1xQ > DdN) {

                    return null;
                }

                // Line intersects triangle, check if ray does.
                var QdN = -sign * diff.dot(normal);

                // t < 0, no intersection
                if (QdN < 0) {

                    return null;
                }

                // Ray intersects triangle.
                return this.at(QdN / DdN, optionalTarget);
            };
        }(),

        applyMatrix4: function applyMatrix4(matrix4) {

            this.direction.add(this.origin).applyMatrix4(matrix4);
            this.origin.applyMatrix4(matrix4);
            this.direction.sub(this.origin);
            this.direction.normalize();

            return this;
        },

        equals: function equals(ray) {

            return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */

    function Euler(x, y, z, order) {

        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._order = order || Euler.DefaultOrder;
    }

    Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

    Euler.DefaultOrder = 'XYZ';

    Object.defineProperties(Euler.prototype, {

        x: {

            get: function get() {

                return this._x;
            },

            set: function set(value) {

                this._x = value;
                this.onChangeCallback();
            }

        },

        y: {

            get: function get() {

                return this._y;
            },

            set: function set(value) {

                this._y = value;
                this.onChangeCallback();
            }

        },

        z: {

            get: function get() {

                return this._z;
            },

            set: function set(value) {

                this._z = value;
                this.onChangeCallback();
            }

        },

        order: {

            get: function get() {

                return this._order;
            },

            set: function set(value) {

                this._order = value;
                this.onChangeCallback();
            }

        }

    });

    Object.assign(Euler.prototype, {

        isEuler: true,

        set: function set(x, y, z, order) {

            this._x = x;
            this._y = y;
            this._z = z;
            this._order = order || this._order;

            this.onChangeCallback();

            return this;
        },

        clone: function clone() {

            return new this.constructor(this._x, this._y, this._z, this._order);
        },

        copy: function copy(euler) {

            this._x = euler._x;
            this._y = euler._y;
            this._z = euler._z;
            this._order = euler._order;

            this.onChangeCallback();

            return this;
        },

        setFromRotationMatrix: function setFromRotationMatrix(m, order, update) {

            var clamp = _Math.clamp;

            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

            var te = m.elements;
            var m11 = te[0],
                m12 = te[4],
                m13 = te[8];
            var m21 = te[1],
                m22 = te[5],
                m23 = te[9];
            var m31 = te[2],
                m32 = te[6],
                m33 = te[10];

            order = order || this._order;

            if (order === 'XYZ') {

                this._y = Math.asin(clamp(m13, -1, 1));

                if (Math.abs(m13) < 0.99999) {

                    this._x = Math.atan2(-m23, m33);
                    this._z = Math.atan2(-m12, m11);
                } else {

                    this._x = Math.atan2(m32, m22);
                    this._z = 0;
                }
            } else if (order === 'YXZ') {

                this._x = Math.asin(-clamp(m23, -1, 1));

                if (Math.abs(m23) < 0.99999) {

                    this._y = Math.atan2(m13, m33);
                    this._z = Math.atan2(m21, m22);
                } else {

                    this._y = Math.atan2(-m31, m11);
                    this._z = 0;
                }
            } else if (order === 'ZXY') {

                this._x = Math.asin(clamp(m32, -1, 1));

                if (Math.abs(m32) < 0.99999) {

                    this._y = Math.atan2(-m31, m33);
                    this._z = Math.atan2(-m12, m22);
                } else {

                    this._y = 0;
                    this._z = Math.atan2(m21, m11);
                }
            } else if (order === 'ZYX') {

                this._y = Math.asin(-clamp(m31, -1, 1));

                if (Math.abs(m31) < 0.99999) {

                    this._x = Math.atan2(m32, m33);
                    this._z = Math.atan2(m21, m11);
                } else {

                    this._x = 0;
                    this._z = Math.atan2(-m12, m22);
                }
            } else if (order === 'YZX') {

                this._z = Math.asin(clamp(m21, -1, 1));

                if (Math.abs(m21) < 0.99999) {

                    this._x = Math.atan2(-m23, m22);
                    this._y = Math.atan2(-m31, m11);
                } else {

                    this._x = 0;
                    this._y = Math.atan2(m13, m33);
                }
            } else if (order === 'XZY') {

                this._z = Math.asin(-clamp(m12, -1, 1));

                if (Math.abs(m12) < 0.99999) {

                    this._x = Math.atan2(m32, m22);
                    this._y = Math.atan2(m13, m11);
                } else {

                    this._x = Math.atan2(-m23, m33);
                    this._y = 0;
                }
            } else {

                console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
            }

            this._order = order;

            if (update !== false) this.onChangeCallback();

            return this;
        },

        setFromQuaternion: function () {

            var matrix = new Matrix4();

            return function setFromQuaternion(q, order, update) {

                matrix.makeRotationFromQuaternion(q);

                return this.setFromRotationMatrix(matrix, order, update);
            };
        }(),

        setFromVector3: function setFromVector3(v, order) {

            return this.set(v.x, v.y, v.z, order || this._order);
        },

        reorder: function () {

            // WARNING: this discards revolution information -bhouston

            var q = new Quaternion();

            return function reorder(newOrder) {

                q.setFromEuler(this);

                return this.setFromQuaternion(q, newOrder);
            };
        }(),

        equals: function equals(euler) {

            return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
        },

        fromArray: function fromArray(array) {

            this._x = array[0];
            this._y = array[1];
            this._z = array[2];
            if (array[3] !== undefined) this._order = array[3];

            this.onChangeCallback();

            return this;
        },

        toArray: function toArray(array, offset) {

            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;

            array[offset] = this._x;
            array[offset + 1] = this._y;
            array[offset + 2] = this._z;
            array[offset + 3] = this._order;

            return array;
        },

        toVector3: function toVector3(optionalResult) {

            if (optionalResult) {

                return optionalResult.set(this._x, this._y, this._z);
            } else {

                return new Vector3(this._x, this._y, this._z);
            }
        },

        onChange: function onChange(callback) {

            this.onChangeCallback = callback;

            return this;
        },

        onChangeCallback: function onChangeCallback() {}

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Layers() {

        this.mask = 1 | 0;
    }

    Object.assign(Layers.prototype, {

        set: function set(channel) {

            this.mask = 1 << channel | 0;
        },

        enable: function enable(channel) {

            this.mask |= 1 << channel | 0;
        },

        toggle: function toggle(channel) {

            this.mask ^= 1 << channel | 0;
        },

        disable: function disable(channel) {

            this.mask &= ~(1 << channel | 0);
        },

        test: function test(layers) {

            return (this.mask & layers.mask) !== 0;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author elephantatwork / www.elephantatwork.ch
     */

    var object3DId = 0;

    function Object3D() {

        Object.defineProperty(this, 'id', { value: object3DId++ });

        this.uuid = _Math.generateUUID();

        this.name = '';
        this.type = 'Object3D';

        this.parent = null;
        this.children = [];

        this.up = Object3D.DefaultUp.clone();

        var position = new Vector3();
        var rotation = new Euler();
        var quaternion = new Quaternion();
        var scale = new Vector3(1, 1, 1);

        function onRotationChange() {

            quaternion.setFromEuler(rotation, false);
        }

        function onQuaternionChange() {

            rotation.setFromQuaternion(quaternion, undefined, false);
        }

        rotation.onChange(onRotationChange);
        quaternion.onChange(onQuaternionChange);

        Object.defineProperties(this, {
            position: {
                enumerable: true,
                value: position
            },
            rotation: {
                enumerable: true,
                value: rotation
            },
            quaternion: {
                enumerable: true,
                value: quaternion
            },
            scale: {
                enumerable: true,
                value: scale
            },
            modelViewMatrix: {
                value: new Matrix4()
            },
            normalMatrix: {
                value: new Matrix3()
            }
        });

        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();

        this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = false;

        this.layers = new Layers();
        this.visible = true;

        this.castShadow = false;
        this.receiveShadow = false;

        this.frustumCulled = true;
        this.renderOrder = 0;

        this.userData = {};

        this.onBeforeRender = function () {};
        this.onAfterRender = function () {};
    }

    Object3D.DefaultUp = new Vector3(0, 1, 0);
    Object3D.DefaultMatrixAutoUpdate = true;

    Object.assign(Object3D.prototype, EventDispatcher.prototype, {

        isObject3D: true,

        applyMatrix: function applyMatrix(matrix) {

            this.matrix.multiplyMatrices(matrix, this.matrix);

            this.matrix.decompose(this.position, this.quaternion, this.scale);
        },

        setRotationFromAxisAngle: function setRotationFromAxisAngle(axis, angle) {

            // assumes axis is normalized

            this.quaternion.setFromAxisAngle(axis, angle);
        },

        setRotationFromEuler: function setRotationFromEuler(euler) {

            this.quaternion.setFromEuler(euler, true);
        },

        setRotationFromMatrix: function setRotationFromMatrix(m) {

            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

            this.quaternion.setFromRotationMatrix(m);
        },

        setRotationFromQuaternion: function setRotationFromQuaternion(q) {

            // assumes q is normalized

            this.quaternion.copy(q);
        },

        rotateOnAxis: function () {

            // rotate object on axis in object space
            // axis is assumed to be normalized

            var q1 = new Quaternion();

            return function rotateOnAxis(axis, angle) {

                q1.setFromAxisAngle(axis, angle);

                this.quaternion.multiply(q1);

                return this;
            };
        }(),

        rotateX: function () {

            var v1 = new Vector3(1, 0, 0);

            return function rotateX(angle) {

                return this.rotateOnAxis(v1, angle);
            };
        }(),

        rotateY: function () {

            var v1 = new Vector3(0, 1, 0);

            return function rotateY(angle) {

                return this.rotateOnAxis(v1, angle);
            };
        }(),

        rotateZ: function () {

            var v1 = new Vector3(0, 0, 1);

            return function rotateZ(angle) {

                return this.rotateOnAxis(v1, angle);
            };
        }(),

        translateOnAxis: function () {

            // translate object by distance along axis in object space
            // axis is assumed to be normalized

            var v1 = new Vector3();

            return function translateOnAxis(axis, distance) {

                v1.copy(axis).applyQuaternion(this.quaternion);

                this.position.add(v1.multiplyScalar(distance));

                return this;
            };
        }(),

        translateX: function () {

            var v1 = new Vector3(1, 0, 0);

            return function translateX(distance) {

                return this.translateOnAxis(v1, distance);
            };
        }(),

        translateY: function () {

            var v1 = new Vector3(0, 1, 0);

            return function translateY(distance) {

                return this.translateOnAxis(v1, distance);
            };
        }(),

        translateZ: function () {

            var v1 = new Vector3(0, 0, 1);

            return function translateZ(distance) {

                return this.translateOnAxis(v1, distance);
            };
        }(),

        localToWorld: function localToWorld(vector) {

            return vector.applyMatrix4(this.matrixWorld);
        },

        worldToLocal: function () {

            var m1 = new Matrix4();

            return function worldToLocal(vector) {

                return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
            };
        }(),

        lookAt: function () {

            // This routine does not support objects with rotated and/or translated parent(s)

            var m1 = new Matrix4();

            return function lookAt(vector) {

                if (this.isCamera) {

                    m1.lookAt(this.position, vector, this.up);
                } else {

                    m1.lookAt(vector, this.position, this.up);
                }

                this.quaternion.setFromRotationMatrix(m1);
            };
        }(),

        add: function add(object) {

            if (arguments.length > 1) {

                for (var i = 0; i < arguments.length; i++) {

                    this.add(arguments[i]);
                }

                return this;
            }

            if (object === this) {

                console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
                return this;
            }

            if (object && object.isObject3D) {

                if (object.parent !== null) {

                    object.parent.remove(object);
                }

                object.parent = this;
                object.dispatchEvent({ type: 'added' });

                this.children.push(object);
            } else {

                console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
            }

            return this;
        },

        remove: function remove(object) {

            if (arguments.length > 1) {

                for (var i = 0; i < arguments.length; i++) {

                    this.remove(arguments[i]);
                }
            }

            var index = this.children.indexOf(object);

            if (index !== -1) {

                object.parent = null;

                object.dispatchEvent({ type: 'removed' });

                this.children.splice(index, 1);
            }
        },

        getObjectById: function getObjectById(id) {

            return this.getObjectByProperty('id', id);
        },

        getObjectByName: function getObjectByName(name) {

            return this.getObjectByProperty('name', name);
        },

        getObjectByProperty: function getObjectByProperty(name, value) {

            if (this[name] === value) return this;

            for (var i = 0, l = this.children.length; i < l; i++) {

                var child = this.children[i];
                var object = child.getObjectByProperty(name, value);

                if (object !== undefined) {

                    return object;
                }
            }

            return undefined;
        },

        getWorldPosition: function getWorldPosition(optionalTarget) {

            var result = optionalTarget || new Vector3();

            this.updateMatrixWorld(true);

            return result.setFromMatrixPosition(this.matrixWorld);
        },

        getWorldQuaternion: function () {

            var position = new Vector3();
            var scale = new Vector3();

            return function getWorldQuaternion(optionalTarget) {

                var result = optionalTarget || new Quaternion();

                this.updateMatrixWorld(true);

                this.matrixWorld.decompose(position, result, scale);

                return result;
            };
        }(),

        getWorldRotation: function () {

            var quaternion = new Quaternion();

            return function getWorldRotation(optionalTarget) {

                var result = optionalTarget || new Euler();

                this.getWorldQuaternion(quaternion);

                return result.setFromQuaternion(quaternion, this.rotation.order, false);
            };
        }(),

        getWorldScale: function () {

            var position = new Vector3();
            var quaternion = new Quaternion();

            return function getWorldScale(optionalTarget) {

                var result = optionalTarget || new Vector3();

                this.updateMatrixWorld(true);

                this.matrixWorld.decompose(position, quaternion, result);

                return result;
            };
        }(),

        getWorldDirection: function () {

            var quaternion = new Quaternion();

            return function getWorldDirection(optionalTarget) {

                var result = optionalTarget || new Vector3();

                this.getWorldQuaternion(quaternion);

                return result.set(0, 0, 1).applyQuaternion(quaternion);
            };
        }(),

        raycast: function raycast() {},

        traverse: function traverse(callback) {

            callback(this);

            var children = this.children;

            for (var i = 0, l = children.length; i < l; i++) {

                children[i].traverse(callback);
            }
        },

        traverseVisible: function traverseVisible(callback) {

            if (this.visible === false) return;

            callback(this);

            var children = this.children;

            for (var i = 0, l = children.length; i < l; i++) {

                children[i].traverseVisible(callback);
            }
        },

        traverseAncestors: function traverseAncestors(callback) {

            var parent = this.parent;

            if (parent !== null) {

                callback(parent);

                parent.traverseAncestors(callback);
            }
        },

        updateMatrix: function updateMatrix() {

            this.matrix.compose(this.position, this.quaternion, this.scale);

            this.matrixWorldNeedsUpdate = true;
        },

        updateMatrixWorld: function updateMatrixWorld(force) {

            if (this.matrixAutoUpdate) this.updateMatrix();

            if (this.matrixWorldNeedsUpdate || force) {

                if (this.parent === null) {

                    this.matrixWorld.copy(this.matrix);
                } else {

                    this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                }

                this.matrixWorldNeedsUpdate = false;

                force = true;
            }

            // update children

            var children = this.children;

            for (var i = 0, l = children.length; i < l; i++) {

                children[i].updateMatrixWorld(force);
            }
        },

        toJSON: function toJSON(meta) {

            // meta is '' when called from JSON.stringify
            var isRootObject = meta === undefined || meta === '';

            var output = {};

            // meta is a hash used to collect geometries, materials.
            // not providing it implies that this is the root object
            // being serialized.
            if (isRootObject) {

                // initialize meta obj
                meta = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {}
                };

                output.metadata = {
                    version: 4.5,
                    type: 'Object',
                    generator: 'Object3D.toJSON'
                };
            }

            // standard Object3D serialization

            var object = {};

            object.uuid = this.uuid;
            object.type = this.type;

            if (this.name !== '') object.name = this.name;
            if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
            if (this.castShadow === true) object.castShadow = true;
            if (this.receiveShadow === true) object.receiveShadow = true;
            if (this.visible === false) object.visible = false;

            object.matrix = this.matrix.toArray();

            //

            function serialize(library, element) {

                if (library[element.uuid] === undefined) {

                    library[element.uuid] = element.toJSON(meta);
                }

                return element.uuid;
            }

            if (this.geometry !== undefined) {

                object.geometry = serialize(meta.geometries, this.geometry);
            }

            if (this.material !== undefined) {

                if (Array.isArray(this.material)) {

                    var uuids = [];

                    for (var i = 0, l = this.material.length; i < l; i++) {

                        uuids.push(serialize(meta.materials, this.material[i]));
                    }

                    object.material = uuids;
                } else {

                    object.material = serialize(meta.materials, this.material);
                }
            }

            //

            if (this.children.length > 0) {

                object.children = [];

                for (var i = 0; i < this.children.length; i++) {

                    object.children.push(this.children[i].toJSON(meta).object);
                }
            }

            if (isRootObject) {

                var geometries = extractFromCache(meta.geometries);
                var materials = extractFromCache(meta.materials);
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);

                if (geometries.length > 0) output.geometries = geometries;
                if (materials.length > 0) output.materials = materials;
                if (textures.length > 0) output.textures = textures;
                if (images.length > 0) output.images = images;
            }

            output.object = object;

            return output;

            // extract data from the cache hash
            // remove metadata on each item
            // and return as array
            function extractFromCache(cache) {

                var values = [];
                for (var key in cache) {

                    var data = cache[key];
                    delete data.metadata;
                    values.push(data);
                }
                return values;
            }
        },

        clone: function clone(recursive) {

            return new this.constructor().copy(this, recursive);
        },

        copy: function copy(source, recursive) {

            if (recursive === undefined) recursive = true;

            this.name = source.name;

            this.up.copy(source.up);

            this.position.copy(source.position);
            this.quaternion.copy(source.quaternion);
            this.scale.copy(source.scale);

            this.matrix.copy(source.matrix);
            this.matrixWorld.copy(source.matrixWorld);

            this.matrixAutoUpdate = source.matrixAutoUpdate;
            this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

            this.layers.mask = source.layers.mask;
            this.visible = source.visible;

            this.castShadow = source.castShadow;
            this.receiveShadow = source.receiveShadow;

            this.frustumCulled = source.frustumCulled;
            this.renderOrder = source.renderOrder;

            this.userData = JSON.parse(JSON.stringify(source.userData));

            if (recursive === true) {

                for (var i = 0; i < source.children.length; i++) {

                    var child = source.children[i];
                    this.add(child.clone());
                }
            }

            return this;
        }

    });

    /**
     * @author bhouston / http://clara.io
     */

    function Line3(start, end) {

        this.start = start !== undefined ? start : new Vector3();
        this.end = end !== undefined ? end : new Vector3();
    }

    Object.assign(Line3.prototype, {

        set: function set(start, end) {

            this.start.copy(start);
            this.end.copy(end);

            return this;
        },

        clone: function clone() {

            return new this.constructor().copy(this);
        },

        copy: function copy(line) {

            this.start.copy(line.start);
            this.end.copy(line.end);

            return this;
        },

        getCenter: function getCenter(optionalTarget) {

            var result = optionalTarget || new Vector3();
            return result.addVectors(this.start, this.end).multiplyScalar(0.5);
        },

        delta: function delta(optionalTarget) {

            var result = optionalTarget || new Vector3();
            return result.subVectors(this.end, this.start);
        },

        distanceSq: function distanceSq() {

            return this.start.distanceToSquared(this.end);
        },

        distance: function distance() {

            return this.start.distanceTo(this.end);
        },

        at: function at(t, optionalTarget) {

            var result = optionalTarget || new Vector3();

            return this.delta(result).multiplyScalar(t).add(this.start);
        },

        closestPointToPointParameter: function () {

            var startP = new Vector3();
            var startEnd = new Vector3();

            return function closestPointToPointParameter(point, clampToLine) {

                startP.subVectors(point, this.start);
                startEnd.subVectors(this.end, this.start);

                var startEnd2 = startEnd.dot(startEnd);
                var startEnd_startP = startEnd.dot(startP);

                var t = startEnd_startP / startEnd2;

                if (clampToLine) {

                    t = _Math.clamp(t, 0, 1);
                }

                return t;
            };
        }(),

        closestPointToPoint: function closestPointToPoint(point, clampToLine, optionalTarget) {

            var t = this.closestPointToPointParameter(point, clampToLine);

            var result = optionalTarget || new Vector3();

            return this.delta(result).multiplyScalar(t).add(this.start);
        },

        applyMatrix4: function applyMatrix4(matrix) {

            this.start.applyMatrix4(matrix);
            this.end.applyMatrix4(matrix);

            return this;
        },

        equals: function equals(line) {

            return line.start.equals(this.start) && line.end.equals(this.end);
        }

    });

    /**
     * @author bhouston / http://clara.io
     * @author mrdoob / http://mrdoob.com/
     */

    function Triangle(a, b, c) {

        this.a = a !== undefined ? a : new Vector3();
        this.b = b !== undefined ? b : new Vector3();
        this.c = c !== undefined ? c : new Vector3();
    }

    Object.assign(Triangle, {

        normal: function () {

            var v0 = new Vector3();

            return function normal(a, b, c, optionalTarget) {

                var result = optionalTarget || new Vector3();

                result.subVectors(c, b);
                v0.subVectors(a, b);
                result.cross(v0);

                var resultLengthSq = result.lengthSq();
                if (resultLengthSq > 0) {

                    return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
                }

                return result.set(0, 0, 0);
            };
        }(),

        // static/instance method to calculate barycentric coordinates
        // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
        barycoordFromPoint: function () {

            var v0 = new Vector3();
            var v1 = new Vector3();
            var v2 = new Vector3();

            return function barycoordFromPoint(point, a, b, c, optionalTarget) {

                v0.subVectors(c, a);
                v1.subVectors(b, a);
                v2.subVectors(point, a);

                var dot00 = v0.dot(v0);
                var dot01 = v0.dot(v1);
                var dot02 = v0.dot(v2);
                var dot11 = v1.dot(v1);
                var dot12 = v1.dot(v2);

                var denom = dot00 * dot11 - dot01 * dot01;

                var result = optionalTarget || new Vector3();

                // collinear or singular triangle
                if (denom === 0) {

                    // arbitrary location outside of triangle?
                    // not sure if this is the best idea, maybe should be returning undefined
                    return result.set(-2, -1, -1);
                }

                var invDenom = 1 / denom;
                var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

                // barycentric coordinates must always sum to 1
                return result.set(1 - u - v, v, u);
            };
        }(),

        containsPoint: function () {

            var v1 = new Vector3();

            return function containsPoint(point, a, b, c) {

                var result = Triangle.barycoordFromPoint(point, a, b, c, v1);

                return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;
            };
        }()

    });

    Object.assign(Triangle.prototype, {

        set: function set(a, b, c) {

            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(c);

            return this;
        },

        setFromPointsAndIndices: function setFromPointsAndIndices(points, i0, i1, i2) {

            this.a.copy(points[i0]);
            this.b.copy(points[i1]);
            this.c.copy(points[i2]);

            return this;
        },

        clone: function clone() {

            return new this.constructor().copy(this);
        },

        copy: function copy(triangle) {

            this.a.copy(triangle.a);
            this.b.copy(triangle.b);
            this.c.copy(triangle.c);

            return this;
        },

        area: function () {

            var v0 = new Vector3();
            var v1 = new Vector3();

            return function area() {

                v0.subVectors(this.c, this.b);
                v1.subVectors(this.a, this.b);

                return v0.cross(v1).length() * 0.5;
            };
        }(),

        midpoint: function midpoint(optionalTarget) {

            var result = optionalTarget || new Vector3();
            return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        },

        normal: function normal(optionalTarget) {

            return Triangle.normal(this.a, this.b, this.c, optionalTarget);
        },

        plane: function plane(optionalTarget) {

            var result = optionalTarget || new Plane();

            return result.setFromCoplanarPoints(this.a, this.b, this.c);
        },

        barycoordFromPoint: function barycoordFromPoint(point, optionalTarget) {

            return Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
        },

        containsPoint: function containsPoint(point) {

            return Triangle.containsPoint(point, this.a, this.b, this.c);
        },

        closestPointToPoint: function () {

            var plane = new Plane();
            var edgeList = [new Line3(), new Line3(), new Line3()];
            var projectedPoint = new Vector3();
            var closestPoint = new Vector3();

            return function closestPointToPoint(point, optionalTarget) {

                var result = optionalTarget || new Vector3();
                var minDistance = Infinity;

                // project the point onto the plane of the triangle

                plane.setFromCoplanarPoints(this.a, this.b, this.c);
                plane.projectPoint(point, projectedPoint);

                // check if the projection lies within the triangle

                if (this.containsPoint(projectedPoint) === true) {

                    // if so, this is the closest point

                    result.copy(projectedPoint);
                } else {

                    // if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

                    edgeList[0].set(this.a, this.b);
                    edgeList[1].set(this.b, this.c);
                    edgeList[2].set(this.c, this.a);

                    for (var i = 0; i < edgeList.length; i++) {

                        edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);

                        var distance = projectedPoint.distanceToSquared(closestPoint);

                        if (distance < minDistance) {

                            minDistance = distance;

                            result.copy(closestPoint);
                        }
                    }
                }

                return result;
            };
        }(),

        equals: function equals(triangle) {

            return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Face3(a, b, c, normal, color, materialIndex) {

        this.a = a;
        this.b = b;
        this.c = c;

        this.normal = normal && normal.isVector3 ? normal : new Vector3();
        this.vertexNormals = Array.isArray(normal) ? normal : [];

        this.color = color && color.isColor ? color : new Color();
        this.vertexColors = Array.isArray(color) ? color : [];

        this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
    }

    Object.assign(Face3.prototype, {

        clone: function clone() {

            return new this.constructor().copy(this);
        },

        copy: function copy(source) {

            this.a = source.a;
            this.b = source.b;
            this.c = source.c;

            this.normal.copy(source.normal);
            this.color.copy(source.color);

            this.materialIndex = source.materialIndex;

            for (var i = 0, il = source.vertexNormals.length; i < il; i++) {

                this.vertexNormals[i] = source.vertexNormals[i].clone();
            }

            for (var i = 0, il = source.vertexColors.length; i < il; i++) {

                this.vertexColors[i] = source.vertexColors[i].clone();
            }

            return this;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  shading: THREE.SmoothShading,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>
     * }
     */

    function MeshBasicMaterial(parameters) {

        Material.call(this);

        this.type = 'MeshBasicMaterial';

        this.color = new Color(0xffffff); // emissive

        this.map = null;

        this.lightMap = null;
        this.lightMapIntensity = 1.0;

        this.aoMap = null;
        this.aoMapIntensity = 1.0;

        this.specularMap = null;

        this.alphaMap = null;

        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;

        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';

        this.skinning = false;
        this.morphTargets = false;

        this.lights = false;

        this.setValues(parameters);
    }

    MeshBasicMaterial.prototype = Object.create(Material.prototype);
    MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

    MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

    MeshBasicMaterial.prototype.copy = function (source) {

        Material.prototype.copy.call(this, source);

        this.color.copy(source.color);

        this.map = source.map;

        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;

        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;

        this.specularMap = source.specularMap;

        this.alphaMap = source.alphaMap;

        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;

        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;

        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;

        return this;
    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function BufferAttribute(array, itemSize, normalized) {

        if (Array.isArray(array)) {

            throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        }

        this.uuid = _Math.generateUUID();

        this.array = array;
        this.itemSize = itemSize;
        this.count = array !== undefined ? array.length / itemSize : 0;
        this.normalized = normalized === true;

        this.dynamic = false;
        this.updateRange = { offset: 0, count: -1 };

        this.onUploadCallback = function () {};

        this.version = 0;
    }

    Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {

        set: function set(value) {

            if (value === true) this.version++;
        }

    });

    Object.assign(BufferAttribute.prototype, {

        isBufferAttribute: true,

        setArray: function setArray(array) {

            if (Array.isArray(array)) {

                throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
            }

            this.count = array !== undefined ? array.length / this.itemSize : 0;
            this.array = array;
        },

        setDynamic: function setDynamic(value) {

            this.dynamic = value;

            return this;
        },

        copy: function copy(source) {

            this.array = new source.array.constructor(source.array);
            this.itemSize = source.itemSize;
            this.count = source.count;
            this.normalized = source.normalized;

            this.dynamic = source.dynamic;

            return this;
        },

        copyAt: function copyAt(index1, attribute, index2) {

            index1 *= this.itemSize;
            index2 *= attribute.itemSize;

            for (var i = 0, l = this.itemSize; i < l; i++) {

                this.array[index1 + i] = attribute.array[index2 + i];
            }

            return this;
        },

        copyArray: function copyArray(array) {

            this.array.set(array);

            return this;
        },

        copyColorsArray: function copyColorsArray(colors) {

            var array = this.array,
                offset = 0;

            for (var i = 0, l = colors.length; i < l; i++) {

                var color = colors[i];

                if (color === undefined) {

                    console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
                    color = new Color();
                }

                array[offset++] = color.r;
                array[offset++] = color.g;
                array[offset++] = color.b;
            }

            return this;
        },

        copyIndicesArray: function copyIndicesArray(indices) {

            var array = this.array,
                offset = 0;

            for (var i = 0, l = indices.length; i < l; i++) {

                var index = indices[i];

                array[offset++] = index.a;
                array[offset++] = index.b;
                array[offset++] = index.c;
            }

            return this;
        },

        copyVector2sArray: function copyVector2sArray(vectors) {

            var array = this.array,
                offset = 0;

            for (var i = 0, l = vectors.length; i < l; i++) {

                var vector = vectors[i];

                if (vector === undefined) {

                    console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
                    vector = new Vector2();
                }

                array[offset++] = vector.x;
                array[offset++] = vector.y;
            }

            return this;
        },

        copyVector3sArray: function copyVector3sArray(vectors) {

            var array = this.array,
                offset = 0;

            for (var i = 0, l = vectors.length; i < l; i++) {

                var vector = vectors[i];

                if (vector === undefined) {

                    console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
                    vector = new Vector3();
                }

                array[offset++] = vector.x;
                array[offset++] = vector.y;
                array[offset++] = vector.z;
            }

            return this;
        },

        copyVector4sArray: function copyVector4sArray(vectors) {

            var array = this.array,
                offset = 0;

            for (var i = 0, l = vectors.length; i < l; i++) {

                var vector = vectors[i];

                if (vector === undefined) {

                    console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
                    vector = new Vector4();
                }

                array[offset++] = vector.x;
                array[offset++] = vector.y;
                array[offset++] = vector.z;
                array[offset++] = vector.w;
            }

            return this;
        },

        set: function set(value, offset) {

            if (offset === undefined) offset = 0;

            this.array.set(value, offset);

            return this;
        },

        getX: function getX(index) {

            return this.array[index * this.itemSize];
        },

        setX: function setX(index, x) {

            this.array[index * this.itemSize] = x;

            return this;
        },

        getY: function getY(index) {

            return this.array[index * this.itemSize + 1];
        },

        setY: function setY(index, y) {

            this.array[index * this.itemSize + 1] = y;

            return this;
        },

        getZ: function getZ(index) {

            return this.array[index * this.itemSize + 2];
        },

        setZ: function setZ(index, z) {

            this.array[index * this.itemSize + 2] = z;

            return this;
        },

        getW: function getW(index) {

            return this.array[index * this.itemSize + 3];
        },

        setW: function setW(index, w) {

            this.array[index * this.itemSize + 3] = w;

            return this;
        },

        setXY: function setXY(index, x, y) {

            index *= this.itemSize;

            this.array[index + 0] = x;
            this.array[index + 1] = y;

            return this;
        },

        setXYZ: function setXYZ(index, x, y, z) {

            index *= this.itemSize;

            this.array[index + 0] = x;
            this.array[index + 1] = y;
            this.array[index + 2] = z;

            return this;
        },

        setXYZW: function setXYZW(index, x, y, z, w) {

            index *= this.itemSize;

            this.array[index + 0] = x;
            this.array[index + 1] = y;
            this.array[index + 2] = z;
            this.array[index + 3] = w;

            return this;
        },

        onUpload: function onUpload(callback) {

            this.onUploadCallback = callback;

            return this;
        },

        clone: function clone() {

            return new this.constructor(this.array, this.itemSize).copy(this);
        }

    });

    //

    function Int8BufferAttribute(array, itemSize) {

        BufferAttribute.call(this, new Int8Array(array), itemSize);
    }

    Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;

    function Uint8BufferAttribute(array, itemSize) {

        BufferAttribute.call(this, new Uint8Array(array), itemSize);
    }

    Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;

    function Uint8ClampedBufferAttribute(array, itemSize) {

        BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize);
    }

    Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;

    function Int16BufferAttribute(array, itemSize) {

        BufferAttribute.call(this, new Int16Array(array), itemSize);
    }

    Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;

    function Uint16BufferAttribute(array, itemSize) {

        BufferAttribute.call(this, new Uint16Array(array), itemSize);
    }

    Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;

    function Int32BufferAttribute(array, itemSize) {

        BufferAttribute.call(this, new Int32Array(array), itemSize);
    }

    Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;

    function Uint32BufferAttribute(array, itemSize) {

        BufferAttribute.call(this, new Uint32Array(array), itemSize);
    }

    Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

    function Float32BufferAttribute(array, itemSize) {

        BufferAttribute.call(this, new Float32Array(array), itemSize);
    }

    Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;

    function Float64BufferAttribute(array, itemSize) {

        BufferAttribute.call(this, new Float64Array(array), itemSize);
    }

    Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function DirectGeometry() {

        this.indices = [];
        this.vertices = [];
        this.normals = [];
        this.colors = [];
        this.uvs = [];
        this.uvs2 = [];

        this.groups = [];

        this.morphTargets = {};

        this.skinWeights = [];
        this.skinIndices = [];

        // this.lineDistances = [];

        this.boundingBox = null;
        this.boundingSphere = null;

        // update flags

        this.verticesNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.groupsNeedUpdate = false;
    }

    Object.assign(DirectGeometry.prototype, {

        computeGroups: function computeGroups(geometry) {

            var group;
            var groups = [];
            var materialIndex = undefined;

            var faces = geometry.faces;

            for (var i = 0; i < faces.length; i++) {

                var face = faces[i];

                // materials

                if (face.materialIndex !== materialIndex) {

                    materialIndex = face.materialIndex;

                    if (group !== undefined) {

                        group.count = i * 3 - group.start;
                        groups.push(group);
                    }

                    group = {
                        start: i * 3,
                        materialIndex: materialIndex
                    };
                }
            }

            if (group !== undefined) {

                group.count = i * 3 - group.start;
                groups.push(group);
            }

            this.groups = groups;
        },

        fromGeometry: function fromGeometry(geometry) {

            var faces = geometry.faces;
            var vertices = geometry.vertices;
            var faceVertexUvs = geometry.faceVertexUvs;

            var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
            var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;

            // morphs

            var morphTargets = geometry.morphTargets;
            var morphTargetsLength = morphTargets.length;

            var morphTargetsPosition;

            if (morphTargetsLength > 0) {

                morphTargetsPosition = [];

                for (var i = 0; i < morphTargetsLength; i++) {

                    morphTargetsPosition[i] = [];
                }

                this.morphTargets.position = morphTargetsPosition;
            }

            var morphNormals = geometry.morphNormals;
            var morphNormalsLength = morphNormals.length;

            var morphTargetsNormal;

            if (morphNormalsLength > 0) {

                morphTargetsNormal = [];

                for (var i = 0; i < morphNormalsLength; i++) {

                    morphTargetsNormal[i] = [];
                }

                this.morphTargets.normal = morphTargetsNormal;
            }

            // skins

            var skinIndices = geometry.skinIndices;
            var skinWeights = geometry.skinWeights;

            var hasSkinIndices = skinIndices.length === vertices.length;
            var hasSkinWeights = skinWeights.length === vertices.length;

            //

            for (var i = 0; i < faces.length; i++) {

                var face = faces[i];

                this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);

                var vertexNormals = face.vertexNormals;

                if (vertexNormals.length === 3) {

                    this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
                } else {

                    var normal = face.normal;

                    this.normals.push(normal, normal, normal);
                }

                var vertexColors = face.vertexColors;

                if (vertexColors.length === 3) {

                    this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
                } else {

                    var color = face.color;

                    this.colors.push(color, color, color);
                }

                if (hasFaceVertexUv === true) {

                    var vertexUvs = faceVertexUvs[0][i];

                    if (vertexUvs !== undefined) {

                        this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                    } else {

                        console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);

                        this.uvs.push(new Vector2(), new Vector2(), new Vector2());
                    }
                }

                if (hasFaceVertexUv2 === true) {

                    var vertexUvs = faceVertexUvs[1][i];

                    if (vertexUvs !== undefined) {

                        this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                    } else {

                        console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);

                        this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
                    }
                }

                // morphs

                for (var j = 0; j < morphTargetsLength; j++) {

                    var morphTarget = morphTargets[j].vertices;

                    morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
                }

                for (var j = 0; j < morphNormalsLength; j++) {

                    var morphNormal = morphNormals[j].vertexNormals[i];

                    morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
                }

                // skins

                if (hasSkinIndices) {

                    this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
                }

                if (hasSkinWeights) {

                    this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
                }
            }

            this.computeGroups(geometry);

            this.verticesNeedUpdate = geometry.verticesNeedUpdate;
            this.normalsNeedUpdate = geometry.normalsNeedUpdate;
            this.colorsNeedUpdate = geometry.colorsNeedUpdate;
            this.uvsNeedUpdate = geometry.uvsNeedUpdate;
            this.groupsNeedUpdate = geometry.groupsNeedUpdate;

            return this;
        }

    });

    function arrayMax(array) {

        if (array.length === 0) return -Infinity;

        var max = array[0];

        for (var i = 1, l = array.length; i < l; ++i) {

            if (array[i] > max) max = array[i];
        }

        return max;
    }

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author kile / http://kile.stravaganza.org/
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author bhouston / http://clara.io
     */

    var count = 0;
    function GeometryIdCount() {
        return count++;
    }

    function Geometry() {

        Object.defineProperty(this, 'id', { value: GeometryIdCount() });

        this.uuid = _Math.generateUUID();

        this.name = '';
        this.type = 'Geometry';

        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [[]];

        this.morphTargets = [];
        this.morphNormals = [];

        this.skinWeights = [];
        this.skinIndices = [];

        this.lineDistances = [];

        this.boundingBox = null;
        this.boundingSphere = null;

        // update flags

        this.elementsNeedUpdate = false;
        this.verticesNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.lineDistancesNeedUpdate = false;
        this.groupsNeedUpdate = false;
    }

    Object.assign(Geometry.prototype, EventDispatcher.prototype, {

        isGeometry: true,

        applyMatrix: function applyMatrix(matrix) {

            var normalMatrix = new Matrix3().getNormalMatrix(matrix);

            for (var i = 0, il = this.vertices.length; i < il; i++) {

                var vertex = this.vertices[i];
                vertex.applyMatrix4(matrix);
            }

            for (var i = 0, il = this.faces.length; i < il; i++) {

                var face = this.faces[i];
                face.normal.applyMatrix3(normalMatrix).normalize();

                for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {

                    face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
                }
            }

            if (this.boundingBox !== null) {

                this.computeBoundingBox();
            }

            if (this.boundingSphere !== null) {

                this.computeBoundingSphere();
            }

            this.verticesNeedUpdate = true;
            this.normalsNeedUpdate = true;

            return this;
        },

        rotateX: function () {

            // rotate geometry around world x-axis

            var m1 = new Matrix4();

            return function rotateX(angle) {

                m1.makeRotationX(angle);

                this.applyMatrix(m1);

                return this;
            };
        }(),

        rotateY: function () {

            // rotate geometry around world y-axis

            var m1 = new Matrix4();

            return function rotateY(angle) {

                m1.makeRotationY(angle);

                this.applyMatrix(m1);

                return this;
            };
        }(),

        rotateZ: function () {

            // rotate geometry around world z-axis

            var m1 = new Matrix4();

            return function rotateZ(angle) {

                m1.makeRotationZ(angle);

                this.applyMatrix(m1);

                return this;
            };
        }(),

        translate: function () {

            // translate geometry

            var m1 = new Matrix4();

            return function translate(x, y, z) {

                m1.makeTranslation(x, y, z);

                this.applyMatrix(m1);

                return this;
            };
        }(),

        scale: function () {

            // scale geometry

            var m1 = new Matrix4();

            return function scale(x, y, z) {

                m1.makeScale(x, y, z);

                this.applyMatrix(m1);

                return this;
            };
        }(),

        lookAt: function () {

            var obj = new Object3D();

            return function lookAt(vector) {

                obj.lookAt(vector);

                obj.updateMatrix();

                this.applyMatrix(obj.matrix);
            };
        }(),

        fromBufferGeometry: function fromBufferGeometry(geometry) {

            var scope = this;

            var indices = geometry.index !== null ? geometry.index.array : undefined;
            var attributes = geometry.attributes;

            var positions = attributes.position.array;
            var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
            var colors = attributes.color !== undefined ? attributes.color.array : undefined;
            var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
            var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

            if (uvs2 !== undefined) this.faceVertexUvs[1] = [];

            var tempNormals = [];
            var tempUVs = [];
            var tempUVs2 = [];

            for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {

                scope.vertices.push(new Vector3(positions[i], positions[i + 1], positions[i + 2]));

                if (normals !== undefined) {

                    tempNormals.push(new Vector3(normals[i], normals[i + 1], normals[i + 2]));
                }

                if (colors !== undefined) {

                    scope.colors.push(new Color(colors[i], colors[i + 1], colors[i + 2]));
                }

                if (uvs !== undefined) {

                    tempUVs.push(new Vector2(uvs[j], uvs[j + 1]));
                }

                if (uvs2 !== undefined) {

                    tempUVs2.push(new Vector2(uvs2[j], uvs2[j + 1]));
                }
            }

            function addFace(a, b, c, materialIndex) {

                var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
                var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];

                var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);

                scope.faces.push(face);

                if (uvs !== undefined) {

                    scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);
                }

                if (uvs2 !== undefined) {

                    scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()]);
                }
            }

            var groups = geometry.groups;

            if (groups.length > 0) {

                for (var i = 0; i < groups.length; i++) {

                    var group = groups[i];

                    var start = group.start;
                    var count = group.count;

                    for (var j = start, jl = start + count; j < jl; j += 3) {

                        if (indices !== undefined) {

                            addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
                        } else {

                            addFace(j, j + 1, j + 2, group.materialIndex);
                        }
                    }
                }
            } else {

                if (indices !== undefined) {

                    for (var i = 0; i < indices.length; i += 3) {

                        addFace(indices[i], indices[i + 1], indices[i + 2]);
                    }
                } else {

                    for (var i = 0; i < positions.length / 3; i += 3) {

                        addFace(i, i + 1, i + 2);
                    }
                }
            }

            this.computeFaceNormals();

            if (geometry.boundingBox !== null) {

                this.boundingBox = geometry.boundingBox.clone();
            }

            if (geometry.boundingSphere !== null) {

                this.boundingSphere = geometry.boundingSphere.clone();
            }

            return this;
        },

        center: function center() {

            this.computeBoundingBox();

            var offset = this.boundingBox.getCenter().negate();

            this.translate(offset.x, offset.y, offset.z);

            return offset;
        },

        normalize: function normalize() {

            this.computeBoundingSphere();

            var center = this.boundingSphere.center;
            var radius = this.boundingSphere.radius;

            var s = radius === 0 ? 1 : 1.0 / radius;

            var matrix = new Matrix4();
            matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);

            this.applyMatrix(matrix);

            return this;
        },

        computeFaceNormals: function computeFaceNormals() {

            var cb = new Vector3(),
                ab = new Vector3();

            for (var f = 0, fl = this.faces.length; f < fl; f++) {

                var face = this.faces[f];

                var vA = this.vertices[face.a];
                var vB = this.vertices[face.b];
                var vC = this.vertices[face.c];

                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);

                cb.normalize();

                face.normal.copy(cb);
            }
        },

        computeVertexNormals: function computeVertexNormals(areaWeighted) {

            if (areaWeighted === undefined) areaWeighted = true;

            var v, vl, f, fl, face, vertices;

            vertices = new Array(this.vertices.length);

            for (v = 0, vl = this.vertices.length; v < vl; v++) {

                vertices[v] = new Vector3();
            }

            if (areaWeighted) {

                // vertex normals weighted by triangle areas
                // http://www.iquilezles.org/www/articles/normals/normals.htm

                var vA, vB, vC;
                var cb = new Vector3(),
                    ab = new Vector3();

                for (f = 0, fl = this.faces.length; f < fl; f++) {

                    face = this.faces[f];

                    vA = this.vertices[face.a];
                    vB = this.vertices[face.b];
                    vC = this.vertices[face.c];

                    cb.subVectors(vC, vB);
                    ab.subVectors(vA, vB);
                    cb.cross(ab);

                    vertices[face.a].add(cb);
                    vertices[face.b].add(cb);
                    vertices[face.c].add(cb);
                }
            } else {

                this.computeFaceNormals();

                for (f = 0, fl = this.faces.length; f < fl; f++) {

                    face = this.faces[f];

                    vertices[face.a].add(face.normal);
                    vertices[face.b].add(face.normal);
                    vertices[face.c].add(face.normal);
                }
            }

            for (v = 0, vl = this.vertices.length; v < vl; v++) {

                vertices[v].normalize();
            }

            for (f = 0, fl = this.faces.length; f < fl; f++) {

                face = this.faces[f];

                var vertexNormals = face.vertexNormals;

                if (vertexNormals.length === 3) {

                    vertexNormals[0].copy(vertices[face.a]);
                    vertexNormals[1].copy(vertices[face.b]);
                    vertexNormals[2].copy(vertices[face.c]);
                } else {

                    vertexNormals[0] = vertices[face.a].clone();
                    vertexNormals[1] = vertices[face.b].clone();
                    vertexNormals[2] = vertices[face.c].clone();
                }
            }

            if (this.faces.length > 0) {

                this.normalsNeedUpdate = true;
            }
        },

        computeFlatVertexNormals: function computeFlatVertexNormals() {

            var f, fl, face;

            this.computeFaceNormals();

            for (f = 0, fl = this.faces.length; f < fl; f++) {

                face = this.faces[f];

                var vertexNormals = face.vertexNormals;

                if (vertexNormals.length === 3) {

                    vertexNormals[0].copy(face.normal);
                    vertexNormals[1].copy(face.normal);
                    vertexNormals[2].copy(face.normal);
                } else {

                    vertexNormals[0] = face.normal.clone();
                    vertexNormals[1] = face.normal.clone();
                    vertexNormals[2] = face.normal.clone();
                }
            }

            if (this.faces.length > 0) {

                this.normalsNeedUpdate = true;
            }
        },

        computeMorphNormals: function computeMorphNormals() {

            var i, il, f, fl, face;

            // save original normals
            // - create temp variables on first access
            //   otherwise just copy (for faster repeated calls)

            for (f = 0, fl = this.faces.length; f < fl; f++) {

                face = this.faces[f];

                if (!face.__originalFaceNormal) {

                    face.__originalFaceNormal = face.normal.clone();
                } else {

                    face.__originalFaceNormal.copy(face.normal);
                }

                if (!face.__originalVertexNormals) face.__originalVertexNormals = [];

                for (i = 0, il = face.vertexNormals.length; i < il; i++) {

                    if (!face.__originalVertexNormals[i]) {

                        face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
                    } else {

                        face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
                    }
                }
            }

            // use temp geometry to compute face and vertex normals for each morph

            var tmpGeo = new Geometry();
            tmpGeo.faces = this.faces;

            for (i = 0, il = this.morphTargets.length; i < il; i++) {

                // create on first access

                if (!this.morphNormals[i]) {

                    this.morphNormals[i] = {};
                    this.morphNormals[i].faceNormals = [];
                    this.morphNormals[i].vertexNormals = [];

                    var dstNormalsFace = this.morphNormals[i].faceNormals;
                    var dstNormalsVertex = this.morphNormals[i].vertexNormals;

                    var faceNormal, vertexNormals;

                    for (f = 0, fl = this.faces.length; f < fl; f++) {

                        faceNormal = new Vector3();
                        vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

                        dstNormalsFace.push(faceNormal);
                        dstNormalsVertex.push(vertexNormals);
                    }
                }

                var morphNormals = this.morphNormals[i];

                // set vertices to morph target

                tmpGeo.vertices = this.morphTargets[i].vertices;

                // compute morph normals

                tmpGeo.computeFaceNormals();
                tmpGeo.computeVertexNormals();

                // store morph normals

                var faceNormal, vertexNormals;

                for (f = 0, fl = this.faces.length; f < fl; f++) {

                    face = this.faces[f];

                    faceNormal = morphNormals.faceNormals[f];
                    vertexNormals = morphNormals.vertexNormals[f];

                    faceNormal.copy(face.normal);

                    vertexNormals.a.copy(face.vertexNormals[0]);
                    vertexNormals.b.copy(face.vertexNormals[1]);
                    vertexNormals.c.copy(face.vertexNormals[2]);
                }
            }

            // restore original normals

            for (f = 0, fl = this.faces.length; f < fl; f++) {

                face = this.faces[f];

                face.normal = face.__originalFaceNormal;
                face.vertexNormals = face.__originalVertexNormals;
            }
        },

        computeLineDistances: function computeLineDistances() {

            var d = 0;
            var vertices = this.vertices;

            for (var i = 0, il = vertices.length; i < il; i++) {

                if (i > 0) {

                    d += vertices[i].distanceTo(vertices[i - 1]);
                }

                this.lineDistances[i] = d;
            }
        },

        computeBoundingBox: function computeBoundingBox() {

            if (this.boundingBox === null) {

                this.boundingBox = new Box3();
            }

            this.boundingBox.setFromPoints(this.vertices);
        },

        computeBoundingSphere: function computeBoundingSphere() {

            if (this.boundingSphere === null) {

                this.boundingSphere = new Sphere();
            }

            this.boundingSphere.setFromPoints(this.vertices);
        },

        merge: function merge(geometry, matrix, materialIndexOffset) {

            if ((geometry && geometry.isGeometry) === false) {

                console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
                return;
            }

            var normalMatrix,
                vertexOffset = this.vertices.length,
                vertices1 = this.vertices,
                vertices2 = geometry.vertices,
                faces1 = this.faces,
                faces2 = geometry.faces,
                uvs1 = this.faceVertexUvs[0],
                uvs2 = geometry.faceVertexUvs[0],
                colors1 = this.colors,
                colors2 = geometry.colors;

            if (materialIndexOffset === undefined) materialIndexOffset = 0;

            if (matrix !== undefined) {

                normalMatrix = new Matrix3().getNormalMatrix(matrix);
            }

            // vertices

            for (var i = 0, il = vertices2.length; i < il; i++) {

                var vertex = vertices2[i];

                var vertexCopy = vertex.clone();

                if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);

                vertices1.push(vertexCopy);
            }

            // colors

            for (var i = 0, il = colors2.length; i < il; i++) {

                colors1.push(colors2[i].clone());
            }

            // faces

            for (i = 0, il = faces2.length; i < il; i++) {

                var face = faces2[i],
                    faceCopy,
                    normal,
                    color,
                    faceVertexNormals = face.vertexNormals,
                    faceVertexColors = face.vertexColors;

                faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
                faceCopy.normal.copy(face.normal);

                if (normalMatrix !== undefined) {

                    faceCopy.normal.applyMatrix3(normalMatrix).normalize();
                }

                for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {

                    normal = faceVertexNormals[j].clone();

                    if (normalMatrix !== undefined) {

                        normal.applyMatrix3(normalMatrix).normalize();
                    }

                    faceCopy.vertexNormals.push(normal);
                }

                faceCopy.color.copy(face.color);

                for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {

                    color = faceVertexColors[j];
                    faceCopy.vertexColors.push(color.clone());
                }

                faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

                faces1.push(faceCopy);
            }

            // uvs

            for (i = 0, il = uvs2.length; i < il; i++) {

                var uv = uvs2[i],
                    uvCopy = [];

                if (uv === undefined) {

                    continue;
                }

                for (var j = 0, jl = uv.length; j < jl; j++) {

                    uvCopy.push(uv[j].clone());
                }

                uvs1.push(uvCopy);
            }
        },

        mergeMesh: function mergeMesh(mesh) {

            if ((mesh && mesh.isMesh) === false) {

                console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
                return;
            }

            mesh.matrixAutoUpdate && mesh.updateMatrix();

            this.merge(mesh.geometry, mesh.matrix);
        },

        /*
         * Checks for duplicate vertices with hashmap.
         * Duplicated vertices are removed
         * and faces' vertices are updated.
         */

        mergeVertices: function mergeVertices() {

            var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
            var unique = [],
                changes = [];

            var v, key;
            var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
            var precision = Math.pow(10, precisionPoints);
            var i, il, face;
            var indices, j, jl;

            for (i = 0, il = this.vertices.length; i < il; i++) {

                v = this.vertices[i];
                key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);

                if (verticesMap[key] === undefined) {

                    verticesMap[key] = i;
                    unique.push(this.vertices[i]);
                    changes[i] = unique.length - 1;
                } else {

                    //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
                    changes[i] = changes[verticesMap[key]];
                }
            }

            // if faces are completely degenerate after merging vertices, we
            // have to remove them from the geometry.
            var faceIndicesToRemove = [];

            for (i = 0, il = this.faces.length; i < il; i++) {

                face = this.faces[i];

                face.a = changes[face.a];
                face.b = changes[face.b];
                face.c = changes[face.c];

                indices = [face.a, face.b, face.c];

                // if any duplicate vertices are found in a Face3
                // we have to remove the face as nothing can be saved
                for (var n = 0; n < 3; n++) {

                    if (indices[n] === indices[(n + 1) % 3]) {

                        faceIndicesToRemove.push(i);
                        break;
                    }
                }
            }

            for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {

                var idx = faceIndicesToRemove[i];

                this.faces.splice(idx, 1);

                for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {

                    this.faceVertexUvs[j].splice(idx, 1);
                }
            }

            // Use unique set of vertices

            var diff = this.vertices.length - unique.length;
            this.vertices = unique;
            return diff;
        },

        sortFacesByMaterialIndex: function sortFacesByMaterialIndex() {

            var faces = this.faces;
            var length = faces.length;

            // tag faces

            for (var i = 0; i < length; i++) {

                faces[i]._id = i;
            }

            // sort faces

            function materialIndexSort(a, b) {

                return a.materialIndex - b.materialIndex;
            }

            faces.sort(materialIndexSort);

            // sort uvs

            var uvs1 = this.faceVertexUvs[0];
            var uvs2 = this.faceVertexUvs[1];

            var newUvs1, newUvs2;

            if (uvs1 && uvs1.length === length) newUvs1 = [];
            if (uvs2 && uvs2.length === length) newUvs2 = [];

            for (var i = 0; i < length; i++) {

                var id = faces[i]._id;

                if (newUvs1) newUvs1.push(uvs1[id]);
                if (newUvs2) newUvs2.push(uvs2[id]);
            }

            if (newUvs1) this.faceVertexUvs[0] = newUvs1;
            if (newUvs2) this.faceVertexUvs[1] = newUvs2;
        },

        toJSON: function toJSON() {

            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Geometry',
                    generator: 'Geometry.toJSON'
                }
            };

            // standard Geometry serialization

            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '') data.name = this.name;

            if (this.parameters !== undefined) {

                var parameters = this.parameters;

                for (var key in parameters) {

                    if (parameters[key] !== undefined) data[key] = parameters[key];
                }

                return data;
            }

            var vertices = [];

            for (var i = 0; i < this.vertices.length; i++) {

                var vertex = this.vertices[i];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }

            var faces = [];
            var normals = [];
            var normalsHash = {};
            var colors = [];
            var colorsHash = {};
            var uvs = [];
            var uvsHash = {};

            for (var i = 0; i < this.faces.length; i++) {

                var face = this.faces[i];

                var hasMaterial = true;
                var hasFaceUv = false; // deprecated
                var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
                var hasFaceNormal = face.normal.length() > 0;
                var hasFaceVertexNormal = face.vertexNormals.length > 0;
                var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
                var hasFaceVertexColor = face.vertexColors.length > 0;

                var faceType = 0;

                faceType = setBit(faceType, 0, 0); // isQuad
                faceType = setBit(faceType, 1, hasMaterial);
                faceType = setBit(faceType, 2, hasFaceUv);
                faceType = setBit(faceType, 3, hasFaceVertexUv);
                faceType = setBit(faceType, 4, hasFaceNormal);
                faceType = setBit(faceType, 5, hasFaceVertexNormal);
                faceType = setBit(faceType, 6, hasFaceColor);
                faceType = setBit(faceType, 7, hasFaceVertexColor);

                faces.push(faceType);
                faces.push(face.a, face.b, face.c);
                faces.push(face.materialIndex);

                if (hasFaceVertexUv) {

                    var faceVertexUvs = this.faceVertexUvs[0][i];

                    faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
                }

                if (hasFaceNormal) {

                    faces.push(getNormalIndex(face.normal));
                }

                if (hasFaceVertexNormal) {

                    var vertexNormals = face.vertexNormals;

                    faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
                }

                if (hasFaceColor) {

                    faces.push(getColorIndex(face.color));
                }

                if (hasFaceVertexColor) {

                    var vertexColors = face.vertexColors;

                    faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
                }
            }

            function setBit(value, position, enabled) {

                return enabled ? value | 1 << position : value & ~(1 << position);
            }

            function getNormalIndex(normal) {

                var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

                if (normalsHash[hash] !== undefined) {

                    return normalsHash[hash];
                }

                normalsHash[hash] = normals.length / 3;
                normals.push(normal.x, normal.y, normal.z);

                return normalsHash[hash];
            }

            function getColorIndex(color) {

                var hash = color.r.toString() + color.g.toString() + color.b.toString();

                if (colorsHash[hash] !== undefined) {

                    return colorsHash[hash];
                }

                colorsHash[hash] = colors.length;
                colors.push(color.getHex());

                return colorsHash[hash];
            }

            function getUvIndex(uv) {

                var hash = uv.x.toString() + uv.y.toString();

                if (uvsHash[hash] !== undefined) {

                    return uvsHash[hash];
                }

                uvsHash[hash] = uvs.length / 2;
                uvs.push(uv.x, uv.y);

                return uvsHash[hash];
            }

            data.data = {};

            data.data.vertices = vertices;
            data.data.normals = normals;
            if (colors.length > 0) data.data.colors = colors;
            if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility
            data.data.faces = faces;

            return data;
        },

        clone: function clone() {

            /*
             // Handle primitives
            		 var parameters = this.parameters;
            		 if ( parameters !== undefined ) {
            		 var values = [];
            		 for ( var key in parameters ) {
            		 values.push( parameters[ key ] );
            		 }
            		 var geometry = Object.create( this.constructor.prototype );
             this.constructor.apply( geometry, values );
             return geometry;
            		 }
            		 return new this.constructor().copy( this );
             */

            return new Geometry().copy(this);
        },

        copy: function copy(source) {

            var i, il, j, jl, k, kl;

            // reset

            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [[]];
            this.morphTargets = [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingBox = null;
            this.boundingSphere = null;

            // name

            this.name = source.name;

            // vertices

            var vertices = source.vertices;

            for (i = 0, il = vertices.length; i < il; i++) {

                this.vertices.push(vertices[i].clone());
            }

            // colors

            var colors = source.colors;

            for (i = 0, il = colors.length; i < il; i++) {

                this.colors.push(colors[i].clone());
            }

            // faces

            var faces = source.faces;

            for (i = 0, il = faces.length; i < il; i++) {

                this.faces.push(faces[i].clone());
            }

            // face vertex uvs

            for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {

                var faceVertexUvs = source.faceVertexUvs[i];

                if (this.faceVertexUvs[i] === undefined) {

                    this.faceVertexUvs[i] = [];
                }

                for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {

                    var uvs = faceVertexUvs[j],
                        uvsCopy = [];

                    for (k = 0, kl = uvs.length; k < kl; k++) {

                        var uv = uvs[k];

                        uvsCopy.push(uv.clone());
                    }

                    this.faceVertexUvs[i].push(uvsCopy);
                }
            }

            // morph targets

            var morphTargets = source.morphTargets;

            for (i = 0, il = morphTargets.length; i < il; i++) {

                var morphTarget = {};
                morphTarget.name = morphTargets[i].name;

                // vertices

                if (morphTargets[i].vertices !== undefined) {

                    morphTarget.vertices = [];

                    for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {

                        morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
                    }
                }

                // normals

                if (morphTargets[i].normals !== undefined) {

                    morphTarget.normals = [];

                    for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {

                        morphTarget.normals.push(morphTargets[i].normals[j].clone());
                    }
                }

                this.morphTargets.push(morphTarget);
            }

            // morph normals

            var morphNormals = source.morphNormals;

            for (i = 0, il = morphNormals.length; i < il; i++) {

                var morphNormal = {};

                // vertex normals

                if (morphNormals[i].vertexNormals !== undefined) {

                    morphNormal.vertexNormals = [];

                    for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {

                        var srcVertexNormal = morphNormals[i].vertexNormals[j];
                        var destVertexNormal = {};

                        destVertexNormal.a = srcVertexNormal.a.clone();
                        destVertexNormal.b = srcVertexNormal.b.clone();
                        destVertexNormal.c = srcVertexNormal.c.clone();

                        morphNormal.vertexNormals.push(destVertexNormal);
                    }
                }

                // face normals

                if (morphNormals[i].faceNormals !== undefined) {

                    morphNormal.faceNormals = [];

                    for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {

                        morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
                    }
                }

                this.morphNormals.push(morphNormal);
            }

            // skin weights

            var skinWeights = source.skinWeights;

            for (i = 0, il = skinWeights.length; i < il; i++) {

                this.skinWeights.push(skinWeights[i].clone());
            }

            // skin indices

            var skinIndices = source.skinIndices;

            for (i = 0, il = skinIndices.length; i < il; i++) {

                this.skinIndices.push(skinIndices[i].clone());
            }

            // line distances

            var lineDistances = source.lineDistances;

            for (i = 0, il = lineDistances.length; i < il; i++) {

                this.lineDistances.push(lineDistances[i]);
            }

            // bounding box

            var boundingBox = source.boundingBox;

            if (boundingBox !== null) {

                this.boundingBox = boundingBox.clone();
            }

            // bounding sphere

            var boundingSphere = source.boundingSphere;

            if (boundingSphere !== null) {

                this.boundingSphere = boundingSphere.clone();
            }

            // update flags

            this.elementsNeedUpdate = source.elementsNeedUpdate;
            this.verticesNeedUpdate = source.verticesNeedUpdate;
            this.uvsNeedUpdate = source.uvsNeedUpdate;
            this.normalsNeedUpdate = source.normalsNeedUpdate;
            this.colorsNeedUpdate = source.colorsNeedUpdate;
            this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
            this.groupsNeedUpdate = source.groupsNeedUpdate;

            return this;
        },

        dispose: function dispose() {

            this.dispatchEvent({ type: 'dispose' });
        }

    });

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function BufferGeometry() {

        Object.defineProperty(this, 'id', { value: GeometryIdCount() });

        this.uuid = _Math.generateUUID();

        this.name = '';
        this.type = 'BufferGeometry';

        this.index = null;
        this.attributes = {};

        this.morphAttributes = {};

        this.groups = [];

        this.boundingBox = null;
        this.boundingSphere = null;

        this.drawRange = { start: 0, count: Infinity };
    }

    BufferGeometry.MaxIndex = 65535;

    Object.assign(BufferGeometry.prototype, EventDispatcher.prototype, {

        isBufferGeometry: true,

        getIndex: function getIndex() {

            return this.index;
        },

        setIndex: function setIndex(index) {

            if (Array.isArray(index)) {

                this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
            } else {

                this.index = index;
            }
        },

        addAttribute: function addAttribute(name, attribute) {

            if ((attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false) {

                console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');

                this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));

                return;
            }

            if (name === 'index') {

                console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
                this.setIndex(attribute);

                return;
            }

            this.attributes[name] = attribute;

            return this;
        },

        getAttribute: function getAttribute(name) {

            return this.attributes[name];
        },

        removeAttribute: function removeAttribute(name) {

            delete this.attributes[name];

            return this;
        },

        addGroup: function addGroup(start, count, materialIndex) {

            this.groups.push({

                start: start,
                count: count,
                materialIndex: materialIndex !== undefined ? materialIndex : 0

            });
        },

        clearGroups: function clearGroups() {

            this.groups = [];
        },

        setDrawRange: function setDrawRange(start, count) {

            this.drawRange.start = start;
            this.drawRange.count = count;
        },

        applyMatrix: function applyMatrix(matrix) {

            var position = this.attributes.position;

            if (position !== undefined) {

                matrix.applyToBufferAttribute(position);
                position.needsUpdate = true;
            }

            var normal = this.attributes.normal;

            if (normal !== undefined) {

                var normalMatrix = new Matrix3().getNormalMatrix(matrix);

                normalMatrix.applyToBufferAttribute(normal);
                normal.needsUpdate = true;
            }

            if (this.boundingBox !== null) {

                this.computeBoundingBox();
            }

            if (this.boundingSphere !== null) {

                this.computeBoundingSphere();
            }

            return this;
        },

        rotateX: function () {

            // rotate geometry around world x-axis

            var m1 = new Matrix4();

            return function rotateX(angle) {

                m1.makeRotationX(angle);

                this.applyMatrix(m1);

                return this;
            };
        }(),

        rotateY: function () {

            // rotate geometry around world y-axis

            var m1 = new Matrix4();

            return function rotateY(angle) {

                m1.makeRotationY(angle);

                this.applyMatrix(m1);

                return this;
            };
        }(),

        rotateZ: function () {

            // rotate geometry around world z-axis

            var m1 = new Matrix4();

            return function rotateZ(angle) {

                m1.makeRotationZ(angle);

                this.applyMatrix(m1);

                return this;
            };
        }(),

        translate: function () {

            // translate geometry

            var m1 = new Matrix4();

            return function translate(x, y, z) {

                m1.makeTranslation(x, y, z);

                this.applyMatrix(m1);

                return this;
            };
        }(),

        scale: function () {

            // scale geometry

            var m1 = new Matrix4();

            return function scale(x, y, z) {

                m1.makeScale(x, y, z);

                this.applyMatrix(m1);

                return this;
            };
        }(),

        lookAt: function () {

            var obj = new Object3D();

            return function lookAt(vector) {

                obj.lookAt(vector);

                obj.updateMatrix();

                this.applyMatrix(obj.matrix);
            };
        }(),

        center: function center() {

            this.computeBoundingBox();

            var offset = this.boundingBox.getCenter().negate();

            this.translate(offset.x, offset.y, offset.z);

            return offset;
        },

        setFromObject: function setFromObject(object) {

            // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

            var geometry = object.geometry;

            if (object.isPoints || object.isLine) {

                var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
                var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);

                this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
                this.addAttribute('color', colors.copyColorsArray(geometry.colors));

                if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {

                    var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);

                    this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
                }

                if (geometry.boundingSphere !== null) {

                    this.boundingSphere = geometry.boundingSphere.clone();
                }

                if (geometry.boundingBox !== null) {

                    this.boundingBox = geometry.boundingBox.clone();
                }
            } else if (object.isMesh) {

                if (geometry && geometry.isGeometry) {

                    this.fromGeometry(geometry);
                }
            }

            return this;
        },

        updateFromObject: function updateFromObject(object) {

            var geometry = object.geometry;

            if (object.isMesh) {

                var direct = geometry.__directGeometry;

                if (geometry.elementsNeedUpdate === true) {

                    direct = undefined;
                    geometry.elementsNeedUpdate = false;
                }

                if (direct === undefined) {

                    return this.fromGeometry(geometry);
                }

                direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
                direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
                direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
                direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
                direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

                geometry.verticesNeedUpdate = false;
                geometry.normalsNeedUpdate = false;
                geometry.colorsNeedUpdate = false;
                geometry.uvsNeedUpdate = false;
                geometry.groupsNeedUpdate = false;

                geometry = direct;
            }

            var attribute;

            if (geometry.verticesNeedUpdate === true) {

                attribute = this.attributes.position;

                if (attribute !== undefined) {

                    attribute.copyVector3sArray(geometry.vertices);
                    attribute.needsUpdate = true;
                }

                geometry.verticesNeedUpdate = false;
            }

            if (geometry.normalsNeedUpdate === true) {

                attribute = this.attributes.normal;

                if (attribute !== undefined) {

                    attribute.copyVector3sArray(geometry.normals);
                    attribute.needsUpdate = true;
                }

                geometry.normalsNeedUpdate = false;
            }

            if (geometry.colorsNeedUpdate === true) {

                attribute = this.attributes.color;

                if (attribute !== undefined) {

                    attribute.copyColorsArray(geometry.colors);
                    attribute.needsUpdate = true;
                }

                geometry.colorsNeedUpdate = false;
            }

            if (geometry.uvsNeedUpdate) {

                attribute = this.attributes.uv;

                if (attribute !== undefined) {

                    attribute.copyVector2sArray(geometry.uvs);
                    attribute.needsUpdate = true;
                }

                geometry.uvsNeedUpdate = false;
            }

            if (geometry.lineDistancesNeedUpdate) {

                attribute = this.attributes.lineDistance;

                if (attribute !== undefined) {

                    attribute.copyArray(geometry.lineDistances);
                    attribute.needsUpdate = true;
                }

                geometry.lineDistancesNeedUpdate = false;
            }

            if (geometry.groupsNeedUpdate) {

                geometry.computeGroups(object.geometry);
                this.groups = geometry.groups;

                geometry.groupsNeedUpdate = false;
            }

            return this;
        },

        fromGeometry: function fromGeometry(geometry) {

            geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);

            return this.fromDirectGeometry(geometry.__directGeometry);
        },

        fromDirectGeometry: function fromDirectGeometry(geometry) {

            var positions = new Float32Array(geometry.vertices.length * 3);
            this.addAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));

            if (geometry.normals.length > 0) {

                var normals = new Float32Array(geometry.normals.length * 3);
                this.addAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
            }

            if (geometry.colors.length > 0) {

                var colors = new Float32Array(geometry.colors.length * 3);
                this.addAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
            }

            if (geometry.uvs.length > 0) {

                var uvs = new Float32Array(geometry.uvs.length * 2);
                this.addAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
            }

            if (geometry.uvs2.length > 0) {

                var uvs2 = new Float32Array(geometry.uvs2.length * 2);
                this.addAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
            }

            if (geometry.indices.length > 0) {

                var TypeArray = arrayMax(geometry.indices) > 65535 ? Uint32Array : Uint16Array;
                var indices = new TypeArray(geometry.indices.length * 3);
                this.setIndex(new BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
            }

            // groups

            this.groups = geometry.groups;

            // morphs

            for (var name in geometry.morphTargets) {

                var array = [];
                var morphTargets = geometry.morphTargets[name];

                for (var i = 0, l = morphTargets.length; i < l; i++) {

                    var morphTarget = morphTargets[i];

                    var attribute = new Float32BufferAttribute(morphTarget.length * 3, 3);

                    array.push(attribute.copyVector3sArray(morphTarget));
                }

                this.morphAttributes[name] = array;
            }

            // skinning

            if (geometry.skinIndices.length > 0) {

                var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
                this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
            }

            if (geometry.skinWeights.length > 0) {

                var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
                this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
            }

            //

            if (geometry.boundingSphere !== null) {

                this.boundingSphere = geometry.boundingSphere.clone();
            }

            if (geometry.boundingBox !== null) {

                this.boundingBox = geometry.boundingBox.clone();
            }

            return this;
        },

        computeBoundingBox: function computeBoundingBox() {

            if (this.boundingBox === null) {

                this.boundingBox = new Box3();
            }

            var position = this.attributes.position;

            if (position !== undefined) {

                this.boundingBox.setFromBufferAttribute(position);
            } else {

                this.boundingBox.makeEmpty();
            }

            if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {

                console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
            }
        },

        computeBoundingSphere: function () {

            var box = new Box3();
            var vector = new Vector3();

            return function computeBoundingSphere() {

                if (this.boundingSphere === null) {

                    this.boundingSphere = new Sphere();
                }

                var position = this.attributes.position;

                if (position) {

                    var center = this.boundingSphere.center;

                    box.setFromBufferAttribute(position);
                    box.getCenter(center);

                    // hoping to find a boundingSphere with a radius smaller than the
                    // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

                    var maxRadiusSq = 0;

                    for (var i = 0, il = position.count; i < il; i++) {

                        vector.x = position.getX(i);
                        vector.y = position.getY(i);
                        vector.z = position.getZ(i);
                        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
                    }

                    this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

                    if (isNaN(this.boundingSphere.radius)) {

                        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                    }
                }
            };
        }(),

        computeFaceNormals: function computeFaceNormals() {

            // backwards compatibility

        },

        computeVertexNormals: function computeVertexNormals() {

            var index = this.index;
            var attributes = this.attributes;
            var groups = this.groups;

            if (attributes.position) {

                var positions = attributes.position.array;

                if (attributes.normal === undefined) {

                    this.addAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));
                } else {

                    // reset existing normals to zero

                    var array = attributes.normal.array;

                    for (var i = 0, il = array.length; i < il; i++) {

                        array[i] = 0;
                    }
                }

                var normals = attributes.normal.array;

                var vA, vB, vC;
                var pA = new Vector3(),
                    pB = new Vector3(),
                    pC = new Vector3();
                var cb = new Vector3(),
                    ab = new Vector3();

                // indexed elements

                if (index) {

                    var indices = index.array;

                    if (groups.length === 0) {

                        this.addGroup(0, indices.length);
                    }

                    for (var j = 0, jl = groups.length; j < jl; ++j) {

                        var group = groups[j];

                        var start = group.start;
                        var count = group.count;

                        for (var i = start, il = start + count; i < il; i += 3) {

                            vA = indices[i + 0] * 3;
                            vB = indices[i + 1] * 3;
                            vC = indices[i + 2] * 3;

                            pA.fromArray(positions, vA);
                            pB.fromArray(positions, vB);
                            pC.fromArray(positions, vC);

                            cb.subVectors(pC, pB);
                            ab.subVectors(pA, pB);
                            cb.cross(ab);

                            normals[vA] += cb.x;
                            normals[vA + 1] += cb.y;
                            normals[vA + 2] += cb.z;

                            normals[vB] += cb.x;
                            normals[vB + 1] += cb.y;
                            normals[vB + 2] += cb.z;

                            normals[vC] += cb.x;
                            normals[vC + 1] += cb.y;
                            normals[vC + 2] += cb.z;
                        }
                    }
                } else {

                    // non-indexed elements (unconnected triangle soup)

                    for (var i = 0, il = positions.length; i < il; i += 9) {

                        pA.fromArray(positions, i);
                        pB.fromArray(positions, i + 3);
                        pC.fromArray(positions, i + 6);

                        cb.subVectors(pC, pB);
                        ab.subVectors(pA, pB);
                        cb.cross(ab);

                        normals[i] = cb.x;
                        normals[i + 1] = cb.y;
                        normals[i + 2] = cb.z;

                        normals[i + 3] = cb.x;
                        normals[i + 4] = cb.y;
                        normals[i + 5] = cb.z;

                        normals[i + 6] = cb.x;
                        normals[i + 7] = cb.y;
                        normals[i + 8] = cb.z;
                    }
                }

                this.normalizeNormals();

                attributes.normal.needsUpdate = true;
            }
        },

        merge: function merge(geometry, offset) {

            if ((geometry && geometry.isBufferGeometry) === false) {

                console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
                return;
            }

            if (offset === undefined) offset = 0;

            var attributes = this.attributes;

            for (var key in attributes) {

                if (geometry.attributes[key] === undefined) continue;

                var attribute1 = attributes[key];
                var attributeArray1 = attribute1.array;

                var attribute2 = geometry.attributes[key];
                var attributeArray2 = attribute2.array;

                var attributeSize = attribute2.itemSize;

                for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {

                    attributeArray1[j] = attributeArray2[i];
                }
            }

            return this;
        },

        normalizeNormals: function normalizeNormals() {

            var normals = this.attributes.normal;

            var x, y, z, n;

            for (var i = 0, il = normals.count; i < il; i++) {

                x = normals.getX(i);
                y = normals.getY(i);
                z = normals.getZ(i);

                n = 1.0 / Math.sqrt(x * x + y * y + z * z);

                normals.setXYZ(i, x * n, y * n, z * n);
            }
        },

        toNonIndexed: function toNonIndexed() {

            if (this.index === null) {

                console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
                return this;
            }

            var geometry2 = new BufferGeometry();

            var indices = this.index.array;
            var attributes = this.attributes;

            for (var name in attributes) {

                var attribute = attributes[name];

                var array = attribute.array;
                var itemSize = attribute.itemSize;

                var array2 = new array.constructor(indices.length * itemSize);

                var index = 0,
                    index2 = 0;

                for (var i = 0, l = indices.length; i < l; i++) {

                    index = indices[i] * itemSize;

                    for (var j = 0; j < itemSize; j++) {

                        array2[index2++] = array[index++];
                    }
                }

                geometry2.addAttribute(name, new BufferAttribute(array2, itemSize));
            }

            return geometry2;
        },

        toJSON: function toJSON() {

            var data = {
                metadata: {
                    version: 4.5,
                    type: 'BufferGeometry',
                    generator: 'BufferGeometry.toJSON'
                }
            };

            // standard BufferGeometry serialization

            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '') data.name = this.name;

            if (this.parameters !== undefined) {

                var parameters = this.parameters;

                for (var key in parameters) {

                    if (parameters[key] !== undefined) data[key] = parameters[key];
                }

                return data;
            }

            data.data = { attributes: {} };

            var index = this.index;

            if (index !== null) {

                var array = Array.prototype.slice.call(index.array);

                data.data.index = {
                    type: index.array.constructor.name,
                    array: array
                };
            }

            var attributes = this.attributes;

            for (var key in attributes) {

                var attribute = attributes[key];

                var array = Array.prototype.slice.call(attribute.array);

                data.data.attributes[key] = {
                    itemSize: attribute.itemSize,
                    type: attribute.array.constructor.name,
                    array: array,
                    normalized: attribute.normalized
                };
            }

            var groups = this.groups;

            if (groups.length > 0) {

                data.data.groups = JSON.parse(JSON.stringify(groups));
            }

            var boundingSphere = this.boundingSphere;

            if (boundingSphere !== null) {

                data.data.boundingSphere = {
                    center: boundingSphere.center.toArray(),
                    radius: boundingSphere.radius
                };
            }

            return data;
        },

        clone: function clone() {

            /*
             // Handle primitives
            		 var parameters = this.parameters;
            		 if ( parameters !== undefined ) {
            		 var values = [];
            		 for ( var key in parameters ) {
            		 values.push( parameters[ key ] );
            		 }
            		 var geometry = Object.create( this.constructor.prototype );
             this.constructor.apply( geometry, values );
             return geometry;
            		 }
            		 return new this.constructor().copy( this );
             */

            return new BufferGeometry().copy(this);
        },

        copy: function copy(source) {

            var name, i, l;

            // reset

            this.index = null;
            this.attributes = {};
            this.morphAttributes = {};
            this.groups = [];
            this.boundingBox = null;
            this.boundingSphere = null;

            // name

            this.name = source.name;

            // index

            var index = source.index;

            if (index !== null) {

                this.setIndex(index.clone());
            }

            // attributes

            var attributes = source.attributes;

            for (name in attributes) {

                var attribute = attributes[name];
                this.addAttribute(name, attribute.clone());
            }

            // morph attributes

            var morphAttributes = source.morphAttributes;

            for (name in morphAttributes) {

                var array = [];
                var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

                for (i = 0, l = morphAttribute.length; i < l; i++) {

                    array.push(morphAttribute[i].clone());
                }

                this.morphAttributes[name] = array;
            }

            // groups

            var groups = source.groups;

            for (i = 0, l = groups.length; i < l; i++) {

                var group = groups[i];
                this.addGroup(group.start, group.count, group.materialIndex);
            }

            // bounding box

            var boundingBox = source.boundingBox;

            if (boundingBox !== null) {

                this.boundingBox = boundingBox.clone();
            }

            // bounding sphere

            var boundingSphere = source.boundingSphere;

            if (boundingSphere !== null) {

                this.boundingSphere = boundingSphere.clone();
            }

            // draw range

            this.drawRange.start = source.drawRange.start;
            this.drawRange.count = source.drawRange.count;

            return this;
        },

        dispose: function dispose() {

            this.dispatchEvent({ type: 'dispose' });
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author jonobr1 / http://jonobr1.com/
     */

    function Mesh(geometry, material) {

        Object3D.call(this);

        this.type = 'Mesh';

        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new MeshBasicMaterial({ color: Math.random() * 0xffffff });

        this.drawMode = TrianglesDrawMode;

        this.updateMorphTargets();
    }

    Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {

        constructor: Mesh,

        isMesh: true,

        setDrawMode: function setDrawMode(value) {

            this.drawMode = value;
        },

        copy: function copy(source) {

            Object3D.prototype.copy.call(this, source);

            this.drawMode = source.drawMode;

            return this;
        },

        updateMorphTargets: function updateMorphTargets() {

            var morphTargets = this.geometry.morphTargets;

            if (morphTargets !== undefined && morphTargets.length > 0) {

                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};

                for (var m = 0, ml = morphTargets.length; m < ml; m++) {

                    this.morphTargetInfluences.push(0);
                    this.morphTargetDictionary[morphTargets[m].name] = m;
                }
            }
        },

        raycast: function () {

            var inverseMatrix = new Matrix4();
            var ray = new Ray();
            var sphere = new Sphere();

            var vA = new Vector3();
            var vB = new Vector3();
            var vC = new Vector3();

            var tempA = new Vector3();
            var tempB = new Vector3();
            var tempC = new Vector3();

            var uvA = new Vector2();
            var uvB = new Vector2();
            var uvC = new Vector2();

            var barycoord = new Vector3();

            var intersectionPoint = new Vector3();
            var intersectionPointWorld = new Vector3();

            function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {

                Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);

                uv1.multiplyScalar(barycoord.x);
                uv2.multiplyScalar(barycoord.y);
                uv3.multiplyScalar(barycoord.z);

                uv1.add(uv2).add(uv3);

                return uv1.clone();
            }

            function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {

                var intersect;
                var material = object.material;

                if (material.side === BackSide) {

                    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
                } else {

                    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
                }

                if (intersect === null) return null;

                intersectionPointWorld.copy(point);
                intersectionPointWorld.applyMatrix4(object.matrixWorld);

                var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);

                if (distance < raycaster.near || distance > raycaster.far) return null;

                return {
                    distance: distance,
                    point: intersectionPointWorld.clone(),
                    object: object
                };
            }

            function checkBufferGeometryIntersection(object, raycaster, ray, position, uv, a, b, c) {

                vA.fromBufferAttribute(position, a);
                vB.fromBufferAttribute(position, b);
                vC.fromBufferAttribute(position, c);

                var intersection = checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);

                if (intersection) {

                    if (uv) {

                        uvA.fromBufferAttribute(uv, a);
                        uvB.fromBufferAttribute(uv, b);
                        uvC.fromBufferAttribute(uv, c);

                        intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
                    }

                    intersection.face = new Face3(a, b, c, Triangle.normal(vA, vB, vC));
                    intersection.faceIndex = a;
                }

                return intersection;
            }

            return function raycast(raycaster, intersects) {

                var geometry = this.geometry;
                var material = this.material;
                var matrixWorld = this.matrixWorld;

                if (material === undefined) return;

                // Checking boundingSphere distance to ray

                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(matrixWorld);

                if (raycaster.ray.intersectsSphere(sphere) === false) return;

                //

                inverseMatrix.getInverse(matrixWorld);
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

                // Check boundingBox before continuing

                if (geometry.boundingBox !== null) {

                    if (ray.intersectsBox(geometry.boundingBox) === false) return;
                }

                var intersection;

                if (geometry.isBufferGeometry) {

                    var a, b, c;
                    var index = geometry.index;
                    var position = geometry.attributes.position;
                    var uv = geometry.attributes.uv;
                    var i, l;

                    if (index !== null) {

                        // indexed buffer geometry

                        for (i = 0, l = index.count; i < l; i += 3) {

                            a = index.getX(i);
                            b = index.getX(i + 1);
                            c = index.getX(i + 2);

                            intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);

                            if (intersection) {

                                intersection.faceIndex = Math.floor(i / 3); // triangle number in indices buffer semantics
                                intersects.push(intersection);
                            }
                        }
                    } else {

                        // non-indexed buffer geometry

                        for (i = 0, l = position.count; i < l; i += 3) {

                            a = i;
                            b = i + 1;
                            c = i + 2;

                            intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);

                            if (intersection) {

                                intersection.index = a; // triangle number in positions buffer semantics
                                intersects.push(intersection);
                            }
                        }
                    }
                } else if (geometry.isGeometry) {

                    var fvA, fvB, fvC;
                    var isMultiMaterial = Array.isArray(material);

                    var vertices = geometry.vertices;
                    var faces = geometry.faces;
                    var uvs;

                    var faceVertexUvs = geometry.faceVertexUvs[0];
                    if (faceVertexUvs.length > 0) uvs = faceVertexUvs;

                    for (var f = 0, fl = faces.length; f < fl; f++) {

                        var face = faces[f];
                        var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;

                        if (faceMaterial === undefined) continue;

                        fvA = vertices[face.a];
                        fvB = vertices[face.b];
                        fvC = vertices[face.c];

                        if (faceMaterial.morphTargets === true) {

                            var morphTargets = geometry.morphTargets;
                            var morphInfluences = this.morphTargetInfluences;

                            vA.set(0, 0, 0);
                            vB.set(0, 0, 0);
                            vC.set(0, 0, 0);

                            for (var t = 0, tl = morphTargets.length; t < tl; t++) {

                                var influence = morphInfluences[t];

                                if (influence === 0) continue;

                                var targets = morphTargets[t].vertices;

                                vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
                                vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
                                vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
                            }

                            vA.add(fvA);
                            vB.add(fvB);
                            vC.add(fvC);

                            fvA = vA;
                            fvB = vB;
                            fvC = vC;
                        }

                        intersection = checkIntersection(this, raycaster, ray, fvA, fvB, fvC, intersectionPoint);

                        if (intersection) {

                            if (uvs && uvs[f]) {

                                var uvs_f = uvs[f];
                                uvA.copy(uvs_f[0]);
                                uvB.copy(uvs_f[1]);
                                uvC.copy(uvs_f[2]);

                                intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
                            }

                            intersection.face = face;
                            intersection.faceIndex = f;
                            intersects.push(intersection);
                        }
                    }
                }
            };
        }(),

        clone: function clone() {

            return new this.constructor(this.geometry, this.material).copy(this);
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */

    // BoxGeometry

    function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {

        Geometry.call(this);

        this.type = 'BoxGeometry';

        this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };

        this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
        this.mergeVertices();
    }

    BoxGeometry.prototype = Object.create(Geometry.prototype);
    BoxGeometry.prototype.constructor = BoxGeometry;

    // BoxBufferGeometry

    function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {

        BufferGeometry.call(this);

        this.type = 'BoxBufferGeometry';

        this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };

        var scope = this;

        // segments

        widthSegments = Math.floor(widthSegments) || 1;
        heightSegments = Math.floor(heightSegments) || 1;
        depthSegments = Math.floor(depthSegments) || 1;

        // buffers

        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];

        // helper variables

        var numberOfVertices = 0;
        var groupStart = 0;

        // build each side of the box geometry

        buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
        buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
        buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
        buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
        buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
        buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz

        // build geometry

        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {

            var segmentWidth = width / gridX;
            var segmentHeight = height / gridY;

            var widthHalf = width / 2;
            var heightHalf = height / 2;
            var depthHalf = depth / 2;

            var gridX1 = gridX + 1;
            var gridY1 = gridY + 1;

            var vertexCounter = 0;
            var groupCount = 0;

            var ix, iy;

            var vector = new Vector3();

            // generate vertices, normals and uvs

            for (iy = 0; iy < gridY1; iy++) {

                var y = iy * segmentHeight - heightHalf;

                for (ix = 0; ix < gridX1; ix++) {

                    var x = ix * segmentWidth - widthHalf;

                    // set values to correct vector component

                    vector[u] = x * udir;
                    vector[v] = y * vdir;
                    vector[w] = depthHalf;

                    // now apply vector to vertex buffer

                    vertices.push(vector.x, vector.y, vector.z);

                    // set values to correct vector component

                    vector[u] = 0;
                    vector[v] = 0;
                    vector[w] = depth > 0 ? 1 : -1;

                    // now apply vector to normal buffer

                    normals.push(vector.x, vector.y, vector.z);

                    // uvs

                    uvs.push(ix / gridX);
                    uvs.push(1 - iy / gridY);

                    // counters

                    vertexCounter += 1;
                }
            }

            // indices

            // 1. you need three indices to draw a single face
            // 2. a single segment consists of two faces
            // 3. so we need to generate six (2*3) indices per segment

            for (iy = 0; iy < gridY; iy++) {

                for (ix = 0; ix < gridX; ix++) {

                    var a = numberOfVertices + ix + gridX1 * iy;
                    var b = numberOfVertices + ix + gridX1 * (iy + 1);
                    var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                    var d = numberOfVertices + (ix + 1) + gridX1 * iy;

                    // faces

                    indices.push(a, b, d);
                    indices.push(b, c, d);

                    // increase counter

                    groupCount += 6;
                }
            }

            // add a group to the geometry. this will ensure multi material support

            scope.addGroup(groupStart, groupCount, materialIndex);

            // calculate new start value for groups

            groupStart += groupCount;

            // update total number of vertices

            numberOfVertices += vertexCounter;
        }
    }

    BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */

    // PlaneGeometry

    function PlaneGeometry(width, height, widthSegments, heightSegments) {

        Geometry.call(this);

        this.type = 'PlaneGeometry';

        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };

        this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
        this.mergeVertices();
    }

    PlaneGeometry.prototype = Object.create(Geometry.prototype);
    PlaneGeometry.prototype.constructor = PlaneGeometry;

    // PlaneBufferGeometry

    function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {

        BufferGeometry.call(this);

        this.type = 'PlaneBufferGeometry';

        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };

        var width_half = width / 2;
        var height_half = height / 2;

        var gridX = Math.floor(widthSegments) || 1;
        var gridY = Math.floor(heightSegments) || 1;

        var gridX1 = gridX + 1;
        var gridY1 = gridY + 1;

        var segment_width = width / gridX;
        var segment_height = height / gridY;

        var ix, iy;

        // buffers

        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];

        // generate vertices, normals and uvs

        for (iy = 0; iy < gridY1; iy++) {

            var y = iy * segment_height - height_half;

            for (ix = 0; ix < gridX1; ix++) {

                var x = ix * segment_width - width_half;

                vertices.push(x, -y, 0);

                normals.push(0, 0, 1);

                uvs.push(ix / gridX);
                uvs.push(1 - iy / gridY);
            }
        }

        // indices

        for (iy = 0; iy < gridY; iy++) {

            for (ix = 0; ix < gridX; ix++) {

                var a = ix + gridX1 * iy;
                var b = ix + gridX1 * (iy + 1);
                var c = ix + 1 + gridX1 * (iy + 1);
                var d = ix + 1 + gridX1 * iy;

                // faces

                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }

        // build geometry

        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }

    PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author WestLangley / http://github.com/WestLangley
    */

    function Camera() {

        Object3D.call(this);

        this.type = 'Camera';

        this.matrixWorldInverse = new Matrix4();
        this.projectionMatrix = new Matrix4();
    }

    Camera.prototype = Object.assign(Object.create(Object3D.prototype), {

        constructor: Camera,

        isCamera: true,

        copy: function copy(source) {

            Object3D.prototype.copy.call(this, source);

            this.matrixWorldInverse.copy(source.matrixWorldInverse);
            this.projectionMatrix.copy(source.projectionMatrix);

            return this;
        },

        getWorldDirection: function () {

            var quaternion = new Quaternion();

            return function getWorldDirection(optionalTarget) {

                var result = optionalTarget || new Vector3();

                this.getWorldQuaternion(quaternion);

                return result.set(0, 0, -1).applyQuaternion(quaternion);
            };
        }(),

        clone: function clone() {

            return new this.constructor().copy(this);
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author greggman / http://games.greggman.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author tschw
     */

    function PerspectiveCamera(fov, aspect, near, far) {

        Camera.call(this);

        this.type = 'PerspectiveCamera';

        this.fov = fov !== undefined ? fov : 50;
        this.zoom = 1;

        this.near = near !== undefined ? near : 0.1;
        this.far = far !== undefined ? far : 2000;
        this.focus = 10;

        this.aspect = aspect !== undefined ? aspect : 1;
        this.view = null;

        this.filmGauge = 35; // width of the film (default in millimeters)
        this.filmOffset = 0; // horizontal film offset (same unit as gauge)

        this.updateProjectionMatrix();
    }

    PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {

        constructor: PerspectiveCamera,

        isPerspectiveCamera: true,

        copy: function copy(source) {

            Camera.prototype.copy.call(this, source);

            this.fov = source.fov;
            this.zoom = source.zoom;

            this.near = source.near;
            this.far = source.far;
            this.focus = source.focus;

            this.aspect = source.aspect;
            this.view = source.view === null ? null : Object.assign({}, source.view);

            this.filmGauge = source.filmGauge;
            this.filmOffset = source.filmOffset;

            return this;
        },

        /**
         * Sets the FOV by focal length in respect to the current .filmGauge.
         *
         * The default film gauge is 35, so that the focal length can be specified for
         * a 35mm (full frame) camera.
         *
         * Values for focal length and film gauge must have the same unit.
         */
        setFocalLength: function setFocalLength(focalLength) {

            // see http://www.bobatkins.com/photography/technical/field_of_view.html
            var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

            this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
            this.updateProjectionMatrix();
        },

        /**
         * Calculates the focal length from the current .fov and .filmGauge.
         */
        getFocalLength: function getFocalLength() {

            var vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);

            return 0.5 * this.getFilmHeight() / vExtentSlope;
        },

        getEffectiveFOV: function getEffectiveFOV() {

            return _Math.RAD2DEG * 2 * Math.atan(Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom);
        },

        getFilmWidth: function getFilmWidth() {

            // film not completely covered in portrait format (aspect < 1)
            return this.filmGauge * Math.min(this.aspect, 1);
        },

        getFilmHeight: function getFilmHeight() {

            // film not completely covered in landscape format (aspect > 1)
            return this.filmGauge / Math.max(this.aspect, 1);
        },

        /**
         * Sets an offset in a larger frustum. This is useful for multi-window or
         * multi-monitor/multi-machine setups.
         *
         * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
         * the monitors are in grid like this
         *
         *   +---+---+---+
         *   | A | B | C |
         *   +---+---+---+
         *   | D | E | F |
         *   +---+---+---+
         *
         * then for each monitor you would call it like this
         *
         *   var w = 1920;
         *   var h = 1080;
         *   var fullWidth = w * 3;
         *   var fullHeight = h * 2;
         *
         *   --A--
         *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
         *   --B--
         *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
         *   --C--
         *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
         *   --D--
         *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
         *   --E--
         *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
         *   --F--
         *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
         *
         *   Note there is no reason monitors have to be the same size or in a grid.
         */
        setViewOffset: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {

            this.aspect = fullWidth / fullHeight;

            this.view = {
                fullWidth: fullWidth,
                fullHeight: fullHeight,
                offsetX: x,
                offsetY: y,
                width: width,
                height: height
            };

            this.updateProjectionMatrix();
        },

        clearViewOffset: function clearViewOffset() {

            this.view = null;
            this.updateProjectionMatrix();
        },

        updateProjectionMatrix: function updateProjectionMatrix() {

            var near = this.near,
                top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom,
                height = 2 * top,
                width = this.aspect * height,
                left = -0.5 * width,
                view = this.view;

            if (view !== null) {

                var fullWidth = view.fullWidth,
                    fullHeight = view.fullHeight;

                left += view.offsetX * width / fullWidth;
                top -= view.offsetY * height / fullHeight;
                width *= view.width / fullWidth;
                height *= view.height / fullHeight;
            }

            var skew = this.filmOffset;
            if (skew !== 0) left += near * skew / this.getFilmWidth();

            this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        },

        toJSON: function toJSON(meta) {

            var data = Object3D.prototype.toJSON.call(this, meta);

            data.object.fov = this.fov;
            data.object.zoom = this.zoom;

            data.object.near = this.near;
            data.object.far = this.far;
            data.object.focus = this.focus;

            data.object.aspect = this.aspect;

            if (this.view !== null) data.object.view = Object.assign({}, this.view);

            data.object.filmGauge = this.filmGauge;
            data.object.filmOffset = this.filmOffset;

            return data;
        }

    });

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author arose / http://github.com/arose
     */

    function OrthographicCamera(left, right, top, bottom, near, far) {

        Camera.call(this);

        this.type = 'OrthographicCamera';

        this.zoom = 1;
        this.view = null;

        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;

        this.near = near !== undefined ? near : 0.1;
        this.far = far !== undefined ? far : 2000;

        this.updateProjectionMatrix();
    }

    OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {

        constructor: OrthographicCamera,

        isOrthographicCamera: true,

        copy: function copy(source) {

            Camera.prototype.copy.call(this, source);

            this.left = source.left;
            this.right = source.right;
            this.top = source.top;
            this.bottom = source.bottom;
            this.near = source.near;
            this.far = source.far;

            this.zoom = source.zoom;
            this.view = source.view === null ? null : Object.assign({}, source.view);

            return this;
        },

        setViewOffset: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {

            this.view = {
                fullWidth: fullWidth,
                fullHeight: fullHeight,
                offsetX: x,
                offsetY: y,
                width: width,
                height: height
            };

            this.updateProjectionMatrix();
        },

        clearViewOffset: function clearViewOffset() {

            this.view = null;
            this.updateProjectionMatrix();
        },

        updateProjectionMatrix: function updateProjectionMatrix() {

            var dx = (this.right - this.left) / (2 * this.zoom);
            var dy = (this.top - this.bottom) / (2 * this.zoom);
            var cx = (this.right + this.left) / 2;
            var cy = (this.top + this.bottom) / 2;

            var left = cx - dx;
            var right = cx + dx;
            var top = cy + dy;
            var bottom = cy - dy;

            if (this.view !== null) {

                var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
                var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
                var scaleW = (this.right - this.left) / this.view.width;
                var scaleH = (this.top - this.bottom) / this.view.height;

                left += scaleW * (this.view.offsetX / zoomW);
                right = left + scaleW * (this.view.width / zoomW);
                top -= scaleH * (this.view.offsetY / zoomH);
                bottom = top - scaleH * (this.view.height / zoomH);
            }

            this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        },

        toJSON: function toJSON(meta) {

            var data = Object3D.prototype.toJSON.call(this, meta);

            data.object.zoom = this.zoom;
            data.object.left = this.left;
            data.object.right = this.right;
            data.object.top = this.top;
            data.object.bottom = this.bottom;
            data.object.near = this.near;
            data.object.far = this.far;

            if (this.view !== null) data.object.view = Object.assign({}, this.view);

            return data;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLAttributes(gl) {

        var buffers = {};

        function createBuffer(attribute, bufferType) {

            var array = attribute.array;
            var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

            var buffer = gl.createBuffer();

            gl.bindBuffer(bufferType, buffer);
            gl.bufferData(bufferType, array, usage);

            attribute.onUploadCallback();

            var type = gl.FLOAT;

            if (array instanceof Float32Array) {

                type = gl.FLOAT;
            } else if (array instanceof Float64Array) {

                console.warn("Unsupported data buffer format: Float64Array");
            } else if (array instanceof Uint16Array) {

                type = gl.UNSIGNED_SHORT;
            } else if (array instanceof Int16Array) {

                type = gl.SHORT;
            } else if (array instanceof Uint32Array) {

                type = gl.UNSIGNED_INT;
            } else if (array instanceof Int32Array) {

                type = gl.INT;
            } else if (array instanceof Int8Array) {

                type = gl.BYTE;
            } else if (array instanceof Uint8Array) {

                type = gl.UNSIGNED_BYTE;
            }

            return {
                buffer: buffer,
                type: type,
                bytesPerElement: array.BYTES_PER_ELEMENT,
                version: attribute.version
            };
        }

        function updateBuffer(buffer, attribute, bufferType) {

            var array = attribute.array;
            var updateRange = attribute.updateRange;

            gl.bindBuffer(bufferType, buffer);

            if (attribute.dynamic === false) {

                gl.bufferData(bufferType, array, gl.STATIC_DRAW);
            } else if (updateRange.count === -1) {

                // Not using update ranges

                gl.bufferSubData(bufferType, 0, array);
            } else if (updateRange.count === 0) {

                console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
            } else {

                gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));

                updateRange.count = 0; // reset range
            }
        }

        //

        function get(attribute) {

            if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

            return buffers[attribute.uuid];
        }

        function remove(attribute) {

            var data = buffers[attribute.uuid];

            if (data) {

                gl.deleteBuffer(data.buffer);

                delete buffers[attribute.uuid];
            }
        }

        function update(attribute, bufferType) {

            if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

            var data = buffers[attribute.uuid];

            if (data === undefined) {

                buffers[attribute.uuid] = createBuffer(attribute, bufferType);
            } else if (data.version < attribute.version) {

                updateBuffer(data.buffer, attribute, bufferType);

                data.version = attribute.version;
            }
        }

        return {

            get: get,
            remove: remove,
            update: update

        };
    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function painterSortStable(a, b) {

        if (a.renderOrder !== b.renderOrder) {

            return a.renderOrder - b.renderOrder;
        } else if (a.program && b.program && a.program !== b.program) {

            return a.program.id - b.program.id;
        } else if (a.material.id !== b.material.id) {

            return a.material.id - b.material.id;
        } else if (a.z !== b.z) {

            return a.z - b.z;
        } else {

            return a.id - b.id;
        }
    }

    function reversePainterSortStable(a, b) {

        if (a.renderOrder !== b.renderOrder) {

            return a.renderOrder - b.renderOrder;
        }if (a.z !== b.z) {

            return b.z - a.z;
        } else {

            return a.id - b.id;
        }
    }

    function WebGLRenderList() {

        var opaque = [];
        var opaqueLastIndex = -1;

        var transparent = [];
        var transparentLastIndex = -1;

        function init() {

            opaqueLastIndex = -1;
            transparentLastIndex = -1;
        }

        function push(object, geometry, material, z, group) {

            var array, index;

            // allocate the next position in the appropriate array

            if (material.transparent) {

                array = transparent;
                index = ++transparentLastIndex;
            } else {

                array = opaque;
                index = ++opaqueLastIndex;
            }

            // recycle existing render item or grow the array

            var renderItem = array[index];

            if (renderItem) {

                renderItem.id = object.id;
                renderItem.object = object;
                renderItem.geometry = geometry;
                renderItem.material = material;
                renderItem.program = material.program;
                renderItem.renderOrder = object.renderOrder;
                renderItem.z = z;
                renderItem.group = group;
            } else {

                renderItem = {
                    id: object.id,
                    object: object,
                    geometry: geometry,
                    material: material,
                    program: material.program,
                    renderOrder: object.renderOrder,
                    z: z,
                    group: group
                };

                // assert( index === array.length );
                array.push(renderItem);
            }
        }

        function finish() {

            opaque.length = opaqueLastIndex + 1;
            transparent.length = transparentLastIndex + 1;
        }

        function sort() {

            opaque.sort(painterSortStable);
            transparent.sort(reversePainterSortStable);
        }

        return {
            opaque: opaque,
            transparent: transparent,

            init: init,
            push: push,
            finish: finish,

            sort: sort
        };
    }

    function WebGLRenderLists() {

        var lists = {};

        function get(scene, camera) {

            var hash = scene.id + ',' + camera.id;
            var list = lists[hash];

            if (list === undefined) {

                // console.log( 'THREE.WebGLRenderLists:', hash );

                list = new WebGLRenderList();
                lists[hash] = list;
            }

            return list;
        }

        function dispose() {

            lists = {};
        }

        return {
            get: get,
            dispose: dispose
        };
    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLIndexedBufferRenderer(gl, extensions, infoRender) {

        var mode;

        function setMode(value) {

            mode = value;
        }

        var type, size;

        function setIndex(index) {

            if (index.array instanceof Uint32Array && extensions.get('OES_element_index_uint')) {

                type = gl.UNSIGNED_INT;
                size = 4;
            } else if (index.array instanceof Uint16Array) {

                type = gl.UNSIGNED_SHORT;
                size = 2;
            } else {

                type = gl.UNSIGNED_BYTE;
                size = 1;
            }
        }

        function render(start, count) {

            gl.drawElements(mode, count, type, start * size);

            infoRender.calls++;
            infoRender.vertices += count;

            if (mode === gl.TRIANGLES) infoRender.faces += count / 3;
        }

        function renderInstances(geometry, start, count) {

            var extension = extensions.get('ANGLE_instanced_arrays');

            if (extension === null) {

                console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }

            extension.drawElementsInstancedANGLE(mode, count, type, start * size, geometry.maxInstancedCount);

            infoRender.calls++;
            infoRender.vertices += count * geometry.maxInstancedCount;

            if (mode === gl.TRIANGLES) infoRender.faces += geometry.maxInstancedCount * count / 3;
        }

        //

        this.setMode = setMode;
        this.setIndex = setIndex;
        this.render = render;
        this.renderInstances = renderInstances;
    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLBufferRenderer(gl, extensions, infoRender) {

        var mode;

        function setMode(value) {

            mode = value;
        }

        function render(start, count) {

            gl.drawArrays(mode, start, count);

            infoRender.calls++;
            infoRender.vertices += count;

            if (mode === gl.TRIANGLES) infoRender.faces += count / 3;
        }

        function renderInstances(geometry, start, count) {

            var extension = extensions.get('ANGLE_instanced_arrays');

            if (extension === null) {

                console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }

            var position = geometry.attributes.position;

            if (position.isInterleavedBufferAttribute) {

                count = position.data.count;

                extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount);
            } else {

                extension.drawArraysInstancedANGLE(mode, start, count, geometry.maxInstancedCount);
            }

            infoRender.calls++;
            infoRender.vertices += count * geometry.maxInstancedCount;

            if (mode === gl.TRIANGLES) infoRender.faces += geometry.maxInstancedCount * count / 3;
        }

        //

        this.setMode = setMode;
        this.render = render;
        this.renderInstances = renderInstances;
    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLGeometries(gl, attributes, infoMemory) {

        var geometries = {};
        var wireframeAttributes = {};

        function onGeometryDispose(event) {

            var geometry = event.target;
            var buffergeometry = geometries[geometry.id];

            if (buffergeometry.index !== null) {

                attributes.remove(buffergeometry.index);
            }

            for (var name in buffergeometry.attributes) {

                attributes.remove(buffergeometry.attributes[name]);
            }

            geometry.removeEventListener('dispose', onGeometryDispose);

            delete geometries[geometry.id];

            // TODO Remove duplicate code

            var attribute = wireframeAttributes[geometry.id];

            if (attribute) {

                attributes.remove(attribute);
                delete wireframeAttributes[geometry.id];
            }

            attribute = wireframeAttributes[buffergeometry.id];

            if (attribute) {

                attributes.remove(attribute);
                delete wireframeAttributes[buffergeometry.id];
            }

            //

            infoMemory.geometries--;
        }

        function get(object, geometry) {

            var buffergeometry = geometries[geometry.id];

            if (buffergeometry) return buffergeometry;

            geometry.addEventListener('dispose', onGeometryDispose);

            if (geometry.isBufferGeometry) {

                buffergeometry = geometry;
            } else if (geometry.isGeometry) {

                if (geometry._bufferGeometry === undefined) {

                    geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
                }

                buffergeometry = geometry._bufferGeometry;
            }

            geometries[geometry.id] = buffergeometry;

            infoMemory.geometries++;

            return buffergeometry;
        }

        function update(geometry) {

            var index = geometry.index;
            var geometryAttributes = geometry.attributes;

            if (index !== null) {

                attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
            }

            for (var name in geometryAttributes) {

                attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
            }

            // morph targets

            var morphAttributes = geometry.morphAttributes;

            for (var name in morphAttributes) {

                var array = morphAttributes[name];

                for (var i = 0, l = array.length; i < l; i++) {

                    attributes.update(array[i], gl.ARRAY_BUFFER);
                }
            }
        }

        function getWireframeAttribute(geometry) {

            var attribute = wireframeAttributes[geometry.id];

            if (attribute) return attribute;

            var indices = [];

            var geometryIndex = geometry.index;
            var geometryAttributes = geometry.attributes;

            // console.time( 'wireframe' );

            if (geometryIndex !== null) {

                var array = geometryIndex.array;

                for (var i = 0, l = array.length; i < l; i += 3) {

                    var a = array[i + 0];
                    var b = array[i + 1];
                    var c = array[i + 2];

                    indices.push(a, b, b, c, c, a);
                }
            } else {

                var array = geometryAttributes.position.array;

                for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {

                    var a = i + 0;
                    var b = i + 1;
                    var c = i + 2;

                    indices.push(a, b, b, c, c, a);
                }
            }

            // console.timeEnd( 'wireframe' );

            attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);

            attributes.update(attribute, gl.ELEMENT_ARRAY_BUFFER);

            wireframeAttributes[geometry.id] = attribute;

            return attribute;
        }

        return {

            get: get,
            update: update,

            getWireframeAttribute: getWireframeAttribute

        };
    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLLights() {

        var lights = {};

        return {

            get: function get(light) {

                if (lights[light.id] !== undefined) {

                    return lights[light.id];
                }

                var uniforms;

                switch (light.type) {

                    case 'DirectionalLight':
                        uniforms = {
                            direction: new Vector3(),
                            color: new Color(),

                            shadow: false,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2()
                        };
                        break;

                    case 'SpotLight':
                        uniforms = {
                            position: new Vector3(),
                            direction: new Vector3(),
                            color: new Color(),
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,

                            shadow: false,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2()
                        };
                        break;

                    case 'PointLight':
                        uniforms = {
                            position: new Vector3(),
                            color: new Color(),
                            distance: 0,
                            decay: 0,

                            shadow: false,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2()
                        };
                        break;

                    case 'HemisphereLight':
                        uniforms = {
                            direction: new Vector3(),
                            skyColor: new Color(),
                            groundColor: new Color()
                        };
                        break;

                    case 'RectAreaLight':
                        uniforms = {
                            color: new Color(),
                            position: new Vector3(),
                            halfWidth: new Vector3(),
                            halfHeight: new Vector3()
                            // TODO (abelnation): set RectAreaLight shadow uniforms
                        };
                        break;

                }

                lights[light.id] = uniforms;

                return uniforms;
            }

        };
    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLObjects(gl, geometries, infoRender) {

        var updateList = {};

        function update(object) {

            var frame = infoRender.frame;

            var geometry = object.geometry;
            var buffergeometry = geometries.get(object, geometry);

            // Update once per frame

            if (updateList[buffergeometry.id] !== frame) {

                if (geometry.isGeometry) {

                    buffergeometry.updateFromObject(object);
                }

                geometries.update(buffergeometry);

                updateList[buffergeometry.id] = frame;
            }

            return buffergeometry;
        }

        function clear() {

            updateList = {};
        }

        return {

            update: update,
            clear: clear

        };
    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function addLineNumbers(string) {

        var lines = string.split('\n');

        for (var i = 0; i < lines.length; i++) {

            lines[i] = i + 1 + ': ' + lines[i];
        }

        return lines.join('\n');
    }

    function WebGLShader(gl, type, string) {

        var shader = gl.createShader(type);

        gl.shaderSource(shader, string);
        gl.compileShader(shader);

        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {

            console.error('THREE.WebGLShader: Shader couldn\'t compile.');
        }

        if (gl.getShaderInfoLog(shader) !== '') {

            console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(string));
        }

        // --enable-privileged-webgl-extension
        // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

        return shader;
    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    var programIdCount = 0;

    function getEncodingComponents(encoding) {

        switch (encoding) {

            case LinearEncoding:
                return ['Linear', '( value )'];
            case sRGBEncoding:
                return ['sRGB', '( value )'];
            case RGBEEncoding:
                return ['RGBE', '( value )'];
            case RGBM7Encoding:
                return ['RGBM', '( value, 7.0 )'];
            case RGBM16Encoding:
                return ['RGBM', '( value, 16.0 )'];
            case RGBDEncoding:
                return ['RGBD', '( value, 256.0 )'];
            case GammaEncoding:
                return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
            default:
                throw new Error('unsupported encoding: ' + encoding);

        }
    }

    function getTexelDecodingFunction(functionName, encoding) {

        var components = getEncodingComponents(encoding);
        return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
    }

    function getTexelEncodingFunction(functionName, encoding) {

        var components = getEncodingComponents(encoding);
        return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
    }

    function getToneMappingFunction(functionName, toneMapping) {

        var toneMappingName;

        switch (toneMapping) {

            case LinearToneMapping:
                toneMappingName = "Linear";
                break;

            case ReinhardToneMapping:
                toneMappingName = "Reinhard";
                break;

            case Uncharted2ToneMapping:
                toneMappingName = "Uncharted2";
                break;

            case CineonToneMapping:
                toneMappingName = "OptimizedCineon";
                break;

            default:
                throw new Error('unsupported toneMapping: ' + toneMapping);

        }

        return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
    }

    function generateExtensions(extensions, parameters, rendererExtensions) {

        extensions = extensions || {};

        var chunks = [extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ? '#extension GL_OES_standard_derivatives : enable' : '', (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '', extensions.drawBuffers && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '', (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : ''];

        return chunks.filter(filterEmptyLine).join('\n');
    }

    function generateDefines(defines) {

        var chunks = [];

        for (var name in defines) {

            var value = defines[name];

            if (value === false) continue;

            chunks.push('#define ' + name + ' ' + value);
        }

        return chunks.join('\n');
    }

    function fetchAttributeLocations(gl, program, identifiers) {

        var attributes = {};

        var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

        for (var i = 0; i < n; i++) {

            var info = gl.getActiveAttrib(program, i);
            var name = info.name;

            // console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

            attributes[name] = gl.getAttribLocation(program, name);
        }

        return attributes;
    }

    function filterEmptyLine(string) {

        return string !== '';
    }

    function replaceLightNums(string, parameters) {

        return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
    }

    function parseIncludes(string) {

        var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;

        function replace(match, include) {

            var replace = ShaderChunk[include];

            if (replace === undefined) {

                throw new Error('Can not resolve #include <' + include + '>');
            }

            return parseIncludes(replace);
        }

        return string.replace(pattern, replace);
    }

    function unrollLoops(string) {

        var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

        function replace(match, start, end, snippet) {

            var unroll = '';

            for (var i = parseInt(start); i < parseInt(end); i++) {

                unroll += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]');
            }

            return unroll;
        }

        return string.replace(pattern, replace);
    }

    function WebGLProgram(renderer, code, material, parameters) {

        var gl = renderer.context;

        var extensions = material.extensions;
        var defines = material.defines;

        var vertexShader = material.__webglShader.vertexShader;
        var fragmentShader = material.__webglShader.fragmentShader;

        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

        if (parameters.shadowMapType === PCFShadowMap) {

            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
        } else if (parameters.shadowMapType === PCFSoftShadowMap) {

            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
        }

        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
        var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

        if (parameters.envMap) {

            switch (material.envMap.mapping) {

                case CubeReflectionMapping:
                case CubeRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                    break;

                case CubeUVReflectionMapping:
                case CubeUVRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
                    break;

                case EquirectangularReflectionMapping:
                case EquirectangularRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
                    break;

                case SphericalReflectionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
                    break;

            }

            switch (material.envMap.mapping) {

                case CubeRefractionMapping:
                case EquirectangularRefractionMapping:
                    envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                    break;

            }

            switch (material.combine) {

                case MultiplyOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                    break;

                case MixOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                    break;

                case AddOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                    break;

            }
        }

        var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;

        // console.log( 'building new program ' );

        //

        var customExtensions = generateExtensions(extensions, parameters, renderer.extensions);

        var customDefines = generateDefines(defines);

        //

        var program = gl.createProgram();

        var prefixVertex, prefixFragment;

        if (material.isRawShaderMaterial) {

            prefixVertex = [customDefines, '\n'].filter(filterEmptyLine).join('\n');

            prefixFragment = [customExtensions, customDefines, '\n'].filter(filterEmptyLine).join('\n');
        } else {

            prefixVertex = ['precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + material.__webglShader.name, customDefines, parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes, parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');

            prefixFragment = [customExtensions, 'precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + material.__webglShader.name, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes, '#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection), parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '', parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '', parameters.envMap && renderer.extensions.get('EXT_shader_texture_lod') ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
            parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? ShaderChunk['encodings_pars_fragment'] : '', // this code is required here because it is used by the various encoding/decoding function defined below
            parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : '', parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
        }

        vertexShader = parseIncludes(vertexShader, parameters);
        vertexShader = replaceLightNums(vertexShader, parameters);

        fragmentShader = parseIncludes(fragmentShader, parameters);
        fragmentShader = replaceLightNums(fragmentShader, parameters);

        if (!material.isShaderMaterial) {

            vertexShader = unrollLoops(vertexShader);
            fragmentShader = unrollLoops(fragmentShader);
        }

        var vertexGlsl = prefixVertex + vertexShader;
        var fragmentGlsl = prefixFragment + fragmentShader;

        // console.log( '*VERTEX*', vertexGlsl );
        // console.log( '*FRAGMENT*', fragmentGlsl );

        var glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
        var glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);

        gl.attachShader(program, glVertexShader);
        gl.attachShader(program, glFragmentShader);

        // Force a particular attribute to index 0.

        if (material.index0AttributeName !== undefined) {

            gl.bindAttribLocation(program, 0, material.index0AttributeName);
        } else if (parameters.morphTargets === true) {

            // programs with morphTargets displace position out of attribute 0
            gl.bindAttribLocation(program, 0, 'position');
        }

        gl.linkProgram(program);

        var programLog = gl.getProgramInfoLog(program);
        var vertexLog = gl.getShaderInfoLog(glVertexShader);
        var fragmentLog = gl.getShaderInfoLog(glFragmentShader);

        var runnable = true;
        var haveDiagnostics = true;

        // console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
        // console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

        if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {

            runnable = false;

            console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);
        } else if (programLog !== '') {

            console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
        } else if (vertexLog === '' || fragmentLog === '') {

            haveDiagnostics = false;
        }

        if (haveDiagnostics) {

            this.diagnostics = {

                runnable: runnable,
                material: material,

                programLog: programLog,

                vertexShader: {

                    log: vertexLog,
                    prefix: prefixVertex

                },

                fragmentShader: {

                    log: fragmentLog,
                    prefix: prefixFragment

                }

            };
        }

        // clean up

        gl.deleteShader(glVertexShader);
        gl.deleteShader(glFragmentShader);

        // set up caching for uniform locations

        var cachedUniforms;

        this.getUniforms = function () {

            if (cachedUniforms === undefined) {

                cachedUniforms = new WebGLUniforms(gl, program, renderer);
            }

            return cachedUniforms;
        };

        // set up caching for attribute locations

        var cachedAttributes;

        this.getAttributes = function () {

            if (cachedAttributes === undefined) {

                cachedAttributes = fetchAttributeLocations(gl, program);
            }

            return cachedAttributes;
        };

        // free resource

        this.destroy = function () {

            gl.deleteProgram(program);
            this.program = undefined;
        };

        // DEPRECATED

        Object.defineProperties(this, {

            uniforms: {
                get: function get() {

                    console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
                    return this.getUniforms();
                }
            },

            attributes: {
                get: function get() {

                    console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
                    return this.getAttributes();
                }
            }

        });

        //

        this.id = programIdCount++;
        this.code = code;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;

        return this;
    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLPrograms(renderer, capabilities) {

        var programs = [];

        var shaderIDs = {
            MeshDepthMaterial: 'depth',
            MeshNormalMaterial: 'normal',
            MeshBasicMaterial: 'basic',
            MeshLambertMaterial: 'lambert',
            MeshPhongMaterial: 'phong',
            MeshToonMaterial: 'phong',
            MeshStandardMaterial: 'physical',
            MeshPhysicalMaterial: 'physical',
            LineBasicMaterial: 'basic',
            LineDashedMaterial: 'dashed',
            PointsMaterial: 'points'
        };

        var parameterNames = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights', "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

        function allocateBones(object) {

            var skeleton = object.skeleton;
            var bones = skeleton.bones;

            if (capabilities.floatVertexTextures) {

                return 1024;
            } else {

                // default for when object is not specified
                // ( for example when prebuilding shader to be used with multiple objects )
                //
                //  - leave some extra space for other uniforms
                //  - limit here is ANGLE's 254 max uniform vectors
                //    (up to 54 should be safe)

                var nVertexUniforms = capabilities.maxVertexUniforms;
                var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);

                var maxBones = Math.min(nVertexMatrices, bones.length);

                if (maxBones < bones.length) {

                    console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
                    return 0;
                }

                return maxBones;
            }
        }

        function getTextureEncodingFromMap(map, gammaOverrideLinear) {

            var encoding;

            if (!map) {

                encoding = LinearEncoding;
            } else if (map.isTexture) {

                encoding = map.encoding;
            } else if (map.isWebGLRenderTarget) {

                console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
                encoding = map.texture.encoding;
            }

            // add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
            if (encoding === LinearEncoding && gammaOverrideLinear) {

                encoding = GammaEncoding;
            }

            return encoding;
        }

        this.getParameters = function (material, lights, fog, nClipPlanes, nClipIntersection, object) {

            var shaderID = shaderIDs[material.type];

            // heuristics to create shader parameters according to lights in the scene
            // (not to blow over maxLights budget)

            var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
            var precision = renderer.getPrecision();

            if (material.precision !== null) {

                precision = capabilities.getMaxPrecision(material.precision);

                if (precision !== material.precision) {

                    console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
                }
            }

            var currentRenderTarget = renderer.getRenderTarget();

            var parameters = {

                shaderID: shaderID,

                precision: precision,
                supportsVertexTextures: capabilities.vertexTextures,
                outputEncoding: getTextureEncodingFromMap(!currentRenderTarget ? null : currentRenderTarget.texture, renderer.gammaOutput),
                map: !!material.map,
                mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
                envMap: !!material.envMap,
                envMapMode: material.envMap && material.envMap.mapping,
                envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
                envMapCubeUV: !!material.envMap && (material.envMap.mapping === CubeUVReflectionMapping || material.envMap.mapping === CubeUVRefractionMapping),
                lightMap: !!material.lightMap,
                aoMap: !!material.aoMap,
                emissiveMap: !!material.emissiveMap,
                emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
                bumpMap: !!material.bumpMap,
                normalMap: !!material.normalMap,
                displacementMap: !!material.displacementMap,
                roughnessMap: !!material.roughnessMap,
                metalnessMap: !!material.metalnessMap,
                specularMap: !!material.specularMap,
                alphaMap: !!material.alphaMap,

                gradientMap: !!material.gradientMap,

                combine: material.combine,

                vertexColors: material.vertexColors,

                fog: !!fog,
                useFog: material.fog,
                fogExp: fog && fog.isFogExp2,

                flatShading: material.shading === FlatShading,

                sizeAttenuation: material.sizeAttenuation,
                logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

                skinning: material.skinning && maxBones > 0,
                maxBones: maxBones,
                useVertexTexture: capabilities.floatVertexTextures,

                morphTargets: material.morphTargets,
                morphNormals: material.morphNormals,
                maxMorphTargets: renderer.maxMorphTargets,
                maxMorphNormals: renderer.maxMorphNormals,

                numDirLights: lights.directional.length,
                numPointLights: lights.point.length,
                numSpotLights: lights.spot.length,
                numRectAreaLights: lights.rectArea.length,
                numHemiLights: lights.hemi.length,

                numClippingPlanes: nClipPlanes,
                numClipIntersection: nClipIntersection,

                dithering: material.dithering,

                shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
                shadowMapType: renderer.shadowMap.type,

                toneMapping: renderer.toneMapping,
                physicallyCorrectLights: renderer.physicallyCorrectLights,

                premultipliedAlpha: material.premultipliedAlpha,

                alphaTest: material.alphaTest,
                doubleSided: material.side === DoubleSide,
                flipSided: material.side === BackSide,

                depthPacking: material.depthPacking !== undefined ? material.depthPacking : false

            };

            return parameters;
        };

        this.getProgramCode = function (material, parameters) {

            var array = [];

            if (parameters.shaderID) {

                array.push(parameters.shaderID);
            } else {

                array.push(material.fragmentShader);
                array.push(material.vertexShader);
            }

            if (material.defines !== undefined) {

                for (var name in material.defines) {

                    array.push(name);
                    array.push(material.defines[name]);
                }
            }

            for (var i = 0; i < parameterNames.length; i++) {

                array.push(parameters[parameterNames[i]]);
            }

            return array.join();
        };

        this.acquireProgram = function (material, parameters, code) {

            var program;

            // Check if code has been already compiled
            for (var p = 0, pl = programs.length; p < pl; p++) {

                var programInfo = programs[p];

                if (programInfo.code === code) {

                    program = programInfo;
                    ++program.usedTimes;

                    break;
                }
            }

            if (program === undefined) {

                program = new WebGLProgram(renderer, code, material, parameters);
                programs.push(program);
            }

            return program;
        };

        this.releaseProgram = function (program) {

            if (--program.usedTimes === 0) {

                // Remove from unordered set
                var i = programs.indexOf(program);
                programs[i] = programs[programs.length - 1];
                programs.pop();

                // Free WebGL resources
                program.destroy();
            }
        };

        // Exposed for resource monitoring & error feedback via renderer.info:
        this.programs = programs;
    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, infoMemory) {

        var _isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext;

        //

        function clampToMaxSize(image, maxSize) {

            if (image.width > maxSize || image.height > maxSize) {

                // Warning: Scaling through the canvas will only work with images that use
                // premultiplied alpha.

                var scale = maxSize / Math.max(image.width, image.height);

                var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                canvas.width = Math.floor(image.width * scale);
                canvas.height = Math.floor(image.height * scale);

                var context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);

                console.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);

                return canvas;
            }

            return image;
        }

        function isPowerOfTwo(image) {

            return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
        }

        function makePowerOfTwo(image) {

            if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {

                var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                canvas.width = _Math.nearestPowerOfTwo(image.width);
                canvas.height = _Math.nearestPowerOfTwo(image.height);

                var context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, canvas.width, canvas.height);

                console.warn('THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);

                return canvas;
            }

            return image;
        }

        function textureNeedsPowerOfTwo(texture) {

            return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }

        // Fallback filters for non-power-of-2 textures

        function filterFallback(f) {

            if (f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter) {

                return _gl.NEAREST;
            }

            return _gl.LINEAR;
        }

        //

        function onTextureDispose(event) {

            var texture = event.target;

            texture.removeEventListener('dispose', onTextureDispose);

            deallocateTexture(texture);

            infoMemory.textures--;
        }

        function onRenderTargetDispose(event) {

            var renderTarget = event.target;

            renderTarget.removeEventListener('dispose', onRenderTargetDispose);

            deallocateRenderTarget(renderTarget);

            infoMemory.textures--;
        }

        //

        function deallocateTexture(texture) {

            var textureProperties = properties.get(texture);

            if (texture.image && textureProperties.__image__webglTextureCube) {

                // cube texture

                _gl.deleteTexture(textureProperties.__image__webglTextureCube);
            } else {

                // 2D texture

                if (textureProperties.__webglInit === undefined) return;

                _gl.deleteTexture(textureProperties.__webglTexture);
            }

            // remove all webgl properties
            properties.remove(texture);
        }

        function deallocateRenderTarget(renderTarget) {

            var renderTargetProperties = properties.get(renderTarget);
            var textureProperties = properties.get(renderTarget.texture);

            if (!renderTarget) return;

            if (textureProperties.__webglTexture !== undefined) {

                _gl.deleteTexture(textureProperties.__webglTexture);
            }

            if (renderTarget.depthTexture) {

                renderTarget.depthTexture.dispose();
            }

            if (renderTarget.isWebGLRenderTargetCube) {

                for (var i = 0; i < 6; i++) {

                    _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                    if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
                }
            } else {

                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
                if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            }

            properties.remove(renderTarget.texture);
            properties.remove(renderTarget);
        }

        //


        function setTexture2D(texture, slot) {

            var textureProperties = properties.get(texture);

            if (texture.version > 0 && textureProperties.__version !== texture.version) {

                var image = texture.image;

                if (image === undefined) {

                    console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', texture);
                } else if (image.complete === false) {

                    console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture);
                } else {

                    uploadTexture(textureProperties, texture, slot);
                    return;
                }
            }

            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        }

        function setTextureCube(texture, slot) {

            var textureProperties = properties.get(texture);

            if (texture.image.length === 6) {

                if (texture.version > 0 && textureProperties.__version !== texture.version) {

                    if (!textureProperties.__image__webglTextureCube) {

                        texture.addEventListener('dispose', onTextureDispose);

                        textureProperties.__image__webglTextureCube = _gl.createTexture();

                        infoMemory.textures++;
                    }

                    state.activeTexture(_gl.TEXTURE0 + slot);
                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);

                    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

                    var isCompressed = texture && texture.isCompressedTexture;
                    var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;

                    var cubeImage = [];

                    for (var i = 0; i < 6; i++) {

                        if (!isCompressed && !isDataTexture) {

                            cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
                        } else {

                            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
                        }
                    }

                    var image = cubeImage[0],
                        isPowerOfTwoImage = isPowerOfTwo(image),
                        glFormat = paramThreeToGL(texture.format),
                        glType = paramThreeToGL(texture.type);

                    setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);

                    for (var i = 0; i < 6; i++) {

                        if (!isCompressed) {

                            if (isDataTexture) {

                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                            } else {

                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                            }
                        } else {

                            var mipmap,
                                mipmaps = cubeImage[i].mipmaps;

                            for (var j = 0, jl = mipmaps.length; j < jl; j++) {

                                mipmap = mipmaps[j];

                                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {

                                    if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {

                                        state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                                    } else {

                                        console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                                    }
                                } else {

                                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                                }
                            }
                        }
                    }

                    if (texture.generateMipmaps && isPowerOfTwoImage) {

                        _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
                    }

                    textureProperties.__version = texture.version;

                    if (texture.onUpdate) texture.onUpdate(texture);
                } else {

                    state.activeTexture(_gl.TEXTURE0 + slot);
                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
                }
            }
        }

        function setTextureCubeDynamic(texture, slot) {

            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
        }

        function setTextureParameters(textureType, texture, isPowerOfTwoImage) {

            var extension;

            if (isPowerOfTwoImage) {

                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));

                _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
                _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));
            } else {

                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);

                if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {

                    console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture);
                }

                _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
                _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));

                if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {

                    console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture);
                }
            }

            extension = extensions.get('EXT_texture_filter_anisotropic');

            if (extension) {

                if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
                if (texture.type === HalfFloatType && extensions.get('OES_texture_half_float_linear') === null) return;

                if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {

                    _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                    properties.get(texture).__currentAnisotropy = texture.anisotropy;
                }
            }
        }

        function uploadTexture(textureProperties, texture, slot) {

            if (textureProperties.__webglInit === undefined) {

                textureProperties.__webglInit = true;

                texture.addEventListener('dispose', onTextureDispose);

                textureProperties.__webglTexture = _gl.createTexture();

                infoMemory.textures++;
            }

            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);

            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

            var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);

            if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === false) {

                image = makePowerOfTwo(image);
            }

            var isPowerOfTwoImage = isPowerOfTwo(image),
                glFormat = paramThreeToGL(texture.format),
                glType = paramThreeToGL(texture.type);

            setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);

            var mipmap,
                mipmaps = texture.mipmaps;

            if (texture.isDepthTexture) {

                // populate depth texture with dummy data

                var internalFormat = _gl.DEPTH_COMPONENT;

                if (texture.type === FloatType) {

                    if (!_isWebGL2) throw new Error('Float Depth Texture only supported in WebGL2.0');
                    internalFormat = _gl.DEPTH_COMPONENT32F;
                } else if (_isWebGL2) {

                    // WebGL 2.0 requires signed internalformat for glTexImage2D
                    internalFormat = _gl.DEPTH_COMPONENT16;
                }

                if (texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT) {

                    // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                    // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                    if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {

                        console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');

                        texture.type = UnsignedShortType;
                        glType = paramThreeToGL(texture.type);
                    }
                }

                // Depth stencil textures need the DEPTH_STENCIL internal format
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                if (texture.format === DepthStencilFormat) {

                    internalFormat = _gl.DEPTH_STENCIL;

                    // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                    // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                    if (texture.type !== UnsignedInt248Type) {

                        console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');

                        texture.type = UnsignedInt248Type;
                        glType = paramThreeToGL(texture.type);
                    }
                }

                state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);
            } else if (texture.isDataTexture) {

                // use manually created mipmaps if available
                // if there are no manual mipmaps
                // set 0 level mipmap and then use GL to generate other mipmap levels

                if (mipmaps.length > 0 && isPowerOfTwoImage) {

                    for (var i = 0, il = mipmaps.length; i < il; i++) {

                        mipmap = mipmaps[i];
                        state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }

                    texture.generateMipmaps = false;
                } else {

                    state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
                }
            } else if (texture.isCompressedTexture) {

                for (var i = 0, il = mipmaps.length; i < il; i++) {

                    mipmap = mipmaps[i];

                    if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {

                        if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {

                            state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                        } else {

                            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        }
                    } else {

                        state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                }
            } else {

                // regular Texture (image, video, canvas)

                // use manually created mipmaps if available
                // if there are no manual mipmaps
                // set 0 level mipmap and then use GL to generate other mipmap levels

                if (mipmaps.length > 0 && isPowerOfTwoImage) {

                    for (var i = 0, il = mipmaps.length; i < il; i++) {

                        mipmap = mipmaps[i];
                        state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
                    }

                    texture.generateMipmaps = false;
                } else {

                    state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
                }
            }

            if (texture.generateMipmaps && isPowerOfTwoImage) _gl.generateMipmap(_gl.TEXTURE_2D);

            textureProperties.__version = texture.version;

            if (texture.onUpdate) texture.onUpdate(texture);
        }

        // Render targets

        // Setup storage for target texture and bind it to correct framebuffer
        function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {

            var glFormat = paramThreeToGL(renderTarget.texture.format);
            var glType = paramThreeToGL(renderTarget.texture.type);
            state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }

        // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
        function setupRenderBufferStorage(renderbuffer, renderTarget) {

            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);

            if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {

                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
            } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {

                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
            } else {

                // FIXME: We don't support !depth !stencil
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
            }

            _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        }

        // Setup resources for a Depth Texture for a FBO (needs an extension)
        function setupDepthTexture(framebuffer, renderTarget) {

            var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
            if (isCube) throw new Error('Depth Texture with cube render targets is not supported!');

            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

            if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {

                throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
            }

            // upload an empty depth texture with framebuffer size
            if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
                renderTarget.depthTexture.image.width = renderTarget.width;
                renderTarget.depthTexture.image.height = renderTarget.height;
                renderTarget.depthTexture.needsUpdate = true;
            }

            setTexture2D(renderTarget.depthTexture, 0);

            var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

            if (renderTarget.depthTexture.format === DepthFormat) {

                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            } else if (renderTarget.depthTexture.format === DepthStencilFormat) {

                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            } else {

                throw new Error('Unknown depthTexture format');
            }
        }

        // Setup GL resources for a non-texture depth buffer
        function setupDepthRenderbuffer(renderTarget) {

            var renderTargetProperties = properties.get(renderTarget);

            var isCube = renderTarget.isWebGLRenderTargetCube === true;

            if (renderTarget.depthTexture) {

                if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');

                setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
            } else {

                if (isCube) {

                    renderTargetProperties.__webglDepthbuffer = [];

                    for (var i = 0; i < 6; i++) {

                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
                        renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
                    }
                } else {

                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                    renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                    setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
                }
            }

            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }

        // Set up GL resources for the render target
        function setupRenderTarget(renderTarget) {

            var renderTargetProperties = properties.get(renderTarget);
            var textureProperties = properties.get(renderTarget.texture);

            renderTarget.addEventListener('dispose', onRenderTargetDispose);

            textureProperties.__webglTexture = _gl.createTexture();

            infoMemory.textures++;

            var isCube = renderTarget.isWebGLRenderTargetCube === true;
            var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);

            // Setup framebuffer

            if (isCube) {

                renderTargetProperties.__webglFramebuffer = [];

                for (var i = 0; i < 6; i++) {

                    renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
                }
            } else {

                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            }

            // Setup color buffer

            if (isCube) {

                state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
                setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);

                for (var i = 0; i < 6; i++) {

                    setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
                }

                if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo) _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
            } else {

                state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
                setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);

                if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo) _gl.generateMipmap(_gl.TEXTURE_2D);
                state.bindTexture(_gl.TEXTURE_2D, null);
            }

            // Setup depth and stencil buffers

            if (renderTarget.depthBuffer) {

                setupDepthRenderbuffer(renderTarget);
            }
        }

        function updateRenderTargetMipmap(renderTarget) {

            var texture = renderTarget.texture;

            if (texture.generateMipmaps && isPowerOfTwo(renderTarget) && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {

                var target = renderTarget && renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
                var webglTexture = properties.get(texture).__webglTexture;

                state.bindTexture(target, webglTexture);
                _gl.generateMipmap(target);
                state.bindTexture(target, null);
            }
        }

        this.setTexture2D = setTexture2D;
        this.setTextureCube = setTextureCube;
        this.setTextureCubeDynamic = setTextureCubeDynamic;
        this.setupRenderTarget = setupRenderTarget;
        this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    }

    /**
     * @author fordacious / fordacious.github.io
     */

    function WebGLProperties() {

        var properties = {};

        function get(object) {

            var uuid = object.uuid;
            var map = properties[uuid];

            if (map === undefined) {

                map = {};
                properties[uuid] = map;
            }

            return map;
        }

        function remove(object) {

            delete properties[object.uuid];
        }

        function clear() {

            properties = {};
        }

        return {
            get: get,
            remove: remove,
            clear: clear
        };
    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLState(gl, extensions, paramThreeToGL) {

        function ColorBuffer() {

            var locked = false;

            var color = new Vector4();
            var currentColorMask = null;
            var currentColorClear = new Vector4();

            return {

                setMask: function setMask(colorMask) {

                    if (currentColorMask !== colorMask && !locked) {

                        gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                        currentColorMask = colorMask;
                    }
                },

                setLocked: function setLocked(lock) {

                    locked = lock;
                },

                setClear: function setClear(r, g, b, a, premultipliedAlpha) {

                    if (premultipliedAlpha === true) {

                        r *= a;g *= a;b *= a;
                    }

                    color.set(r, g, b, a);

                    if (currentColorClear.equals(color) === false) {

                        gl.clearColor(r, g, b, a);
                        currentColorClear.copy(color);
                    }
                },

                reset: function reset() {

                    locked = false;

                    currentColorMask = null;
                    currentColorClear.set(0, 0, 0, 1);
                }

            };
        }

        function DepthBuffer() {

            var locked = false;

            var currentDepthMask = null;
            var currentDepthFunc = null;
            var currentDepthClear = null;

            return {

                setTest: function setTest(depthTest) {

                    if (depthTest) {

                        enable(gl.DEPTH_TEST);
                    } else {

                        disable(gl.DEPTH_TEST);
                    }
                },

                setMask: function setMask(depthMask) {

                    if (currentDepthMask !== depthMask && !locked) {

                        gl.depthMask(depthMask);
                        currentDepthMask = depthMask;
                    }
                },

                setFunc: function setFunc(depthFunc) {

                    if (currentDepthFunc !== depthFunc) {

                        if (depthFunc) {

                            switch (depthFunc) {

                                case NeverDepth:

                                    gl.depthFunc(gl.NEVER);
                                    break;

                                case AlwaysDepth:

                                    gl.depthFunc(gl.ALWAYS);
                                    break;

                                case LessDepth:

                                    gl.depthFunc(gl.LESS);
                                    break;

                                case LessEqualDepth:

                                    gl.depthFunc(gl.LEQUAL);
                                    break;

                                case EqualDepth:

                                    gl.depthFunc(gl.EQUAL);
                                    break;

                                case GreaterEqualDepth:

                                    gl.depthFunc(gl.GEQUAL);
                                    break;

                                case GreaterDepth:

                                    gl.depthFunc(gl.GREATER);
                                    break;

                                case NotEqualDepth:

                                    gl.depthFunc(gl.NOTEQUAL);
                                    break;

                                default:

                                    gl.depthFunc(gl.LEQUAL);

                            }
                        } else {

                            gl.depthFunc(gl.LEQUAL);
                        }

                        currentDepthFunc = depthFunc;
                    }
                },

                setLocked: function setLocked(lock) {

                    locked = lock;
                },

                setClear: function setClear(depth) {

                    if (currentDepthClear !== depth) {

                        gl.clearDepth(depth);
                        currentDepthClear = depth;
                    }
                },

                reset: function reset() {

                    locked = false;

                    currentDepthMask = null;
                    currentDepthFunc = null;
                    currentDepthClear = null;
                }

            };
        }

        function StencilBuffer() {

            var locked = false;

            var currentStencilMask = null;
            var currentStencilFunc = null;
            var currentStencilRef = null;
            var currentStencilFuncMask = null;
            var currentStencilFail = null;
            var currentStencilZFail = null;
            var currentStencilZPass = null;
            var currentStencilClear = null;

            return {

                setTest: function setTest(stencilTest) {

                    if (stencilTest) {

                        enable(gl.STENCIL_TEST);
                    } else {

                        disable(gl.STENCIL_TEST);
                    }
                },

                setMask: function setMask(stencilMask) {

                    if (currentStencilMask !== stencilMask && !locked) {

                        gl.stencilMask(stencilMask);
                        currentStencilMask = stencilMask;
                    }
                },

                setFunc: function setFunc(stencilFunc, stencilRef, stencilMask) {

                    if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {

                        gl.stencilFunc(stencilFunc, stencilRef, stencilMask);

                        currentStencilFunc = stencilFunc;
                        currentStencilRef = stencilRef;
                        currentStencilFuncMask = stencilMask;
                    }
                },

                setOp: function setOp(stencilFail, stencilZFail, stencilZPass) {

                    if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {

                        gl.stencilOp(stencilFail, stencilZFail, stencilZPass);

                        currentStencilFail = stencilFail;
                        currentStencilZFail = stencilZFail;
                        currentStencilZPass = stencilZPass;
                    }
                },

                setLocked: function setLocked(lock) {

                    locked = lock;
                },

                setClear: function setClear(stencil) {

                    if (currentStencilClear !== stencil) {

                        gl.clearStencil(stencil);
                        currentStencilClear = stencil;
                    }
                },

                reset: function reset() {

                    locked = false;

                    currentStencilMask = null;
                    currentStencilFunc = null;
                    currentStencilRef = null;
                    currentStencilFuncMask = null;
                    currentStencilFail = null;
                    currentStencilZFail = null;
                    currentStencilZPass = null;
                    currentStencilClear = null;
                }

            };
        }

        //

        var colorBuffer = new ColorBuffer();
        var depthBuffer = new DepthBuffer();
        var stencilBuffer = new StencilBuffer();

        var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        var newAttributes = new Uint8Array(maxVertexAttributes);
        var enabledAttributes = new Uint8Array(maxVertexAttributes);
        var attributeDivisors = new Uint8Array(maxVertexAttributes);

        var capabilities = {};

        var compressedTextureFormats = null;

        var currentBlending = null;
        var currentBlendEquation = null;
        var currentBlendSrc = null;
        var currentBlendDst = null;
        var currentBlendEquationAlpha = null;
        var currentBlendSrcAlpha = null;
        var currentBlendDstAlpha = null;
        var currentPremultipledAlpha = false;

        var currentFlipSided = null;
        var currentCullFace = null;

        var currentLineWidth = null;

        var currentPolygonOffsetFactor = null;
        var currentPolygonOffsetUnits = null;

        var currentScissorTest = null;

        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);

        var version = parseFloat(/^WebGL\ ([0-9])/.exec(gl.getParameter(gl.VERSION))[1]);
        var lineWidthAvailable = parseFloat(version) >= 1.0;

        var currentTextureSlot = null;
        var currentBoundTextures = {};

        var currentScissor = new Vector4();
        var currentViewport = new Vector4();

        function createTexture(type, target, count) {

            var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
            var texture = gl.createTexture();

            gl.bindTexture(type, texture);
            gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

            for (var i = 0; i < count; i++) {

                gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            }

            return texture;
        }

        var emptyTextures = {};
        emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
        emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);

        //

        function init() {

            colorBuffer.setClear(0, 0, 0, 1);
            depthBuffer.setClear(1);
            stencilBuffer.setClear(0);

            enable(gl.DEPTH_TEST);
            depthBuffer.setFunc(LessEqualDepth);

            setFlipSided(false);
            setCullFace(CullFaceBack);
            enable(gl.CULL_FACE);

            enable(gl.BLEND);
            setBlending(NormalBlending);
        }

        function initAttributes() {

            for (var i = 0, l = newAttributes.length; i < l; i++) {

                newAttributes[i] = 0;
            }
        }

        function enableAttribute(attribute) {

            newAttributes[attribute] = 1;

            if (enabledAttributes[attribute] === 0) {

                gl.enableVertexAttribArray(attribute);
                enabledAttributes[attribute] = 1;
            }

            if (attributeDivisors[attribute] !== 0) {

                var extension = extensions.get('ANGLE_instanced_arrays');

                extension.vertexAttribDivisorANGLE(attribute, 0);
                attributeDivisors[attribute] = 0;
            }
        }

        function enableAttributeAndDivisor(attribute, meshPerAttribute) {

            newAttributes[attribute] = 1;

            if (enabledAttributes[attribute] === 0) {

                gl.enableVertexAttribArray(attribute);
                enabledAttributes[attribute] = 1;
            }

            if (attributeDivisors[attribute] !== meshPerAttribute) {

                var extension = extensions.get('ANGLE_instanced_arrays');

                extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
                attributeDivisors[attribute] = meshPerAttribute;
            }
        }

        function disableUnusedAttributes() {

            for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {

                if (enabledAttributes[i] !== newAttributes[i]) {

                    gl.disableVertexAttribArray(i);
                    enabledAttributes[i] = 0;
                }
            }
        }

        function enable(id) {

            if (capabilities[id] !== true) {

                gl.enable(id);
                capabilities[id] = true;
            }
        }

        function disable(id) {

            if (capabilities[id] !== false) {

                gl.disable(id);
                capabilities[id] = false;
            }
        }

        function getCompressedTextureFormats() {

            if (compressedTextureFormats === null) {

                compressedTextureFormats = [];

                if (extensions.get('WEBGL_compressed_texture_pvrtc') || extensions.get('WEBGL_compressed_texture_s3tc') || extensions.get('WEBGL_compressed_texture_etc1')) {

                    var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);

                    for (var i = 0; i < formats.length; i++) {

                        compressedTextureFormats.push(formats[i]);
                    }
                }
            }

            return compressedTextureFormats;
        }

        function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {

            if (blending !== NoBlending) {

                enable(gl.BLEND);
            } else {

                disable(gl.BLEND);
            }

            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {

                if (blending === AdditiveBlending) {

                    if (premultipliedAlpha) {

                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                        gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
                    } else {

                        gl.blendEquation(gl.FUNC_ADD);
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                    }
                } else if (blending === SubtractiveBlending) {

                    if (premultipliedAlpha) {

                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                        gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                    } else {

                        gl.blendEquation(gl.FUNC_ADD);
                        gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
                    }
                } else if (blending === MultiplyBlending) {

                    if (premultipliedAlpha) {

                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                        gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                    } else {

                        gl.blendEquation(gl.FUNC_ADD);
                        gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                    }
                } else {

                    if (premultipliedAlpha) {

                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    } else {

                        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    }
                }

                currentBlending = blending;
                currentPremultipledAlpha = premultipliedAlpha;
            }

            if (blending === CustomBlending) {

                blendEquationAlpha = blendEquationAlpha || blendEquation;
                blendSrcAlpha = blendSrcAlpha || blendSrc;
                blendDstAlpha = blendDstAlpha || blendDst;

                if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {

                    gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha));

                    currentBlendEquation = blendEquation;
                    currentBlendEquationAlpha = blendEquationAlpha;
                }

                if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {

                    gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha));

                    currentBlendSrc = blendSrc;
                    currentBlendDst = blendDst;
                    currentBlendSrcAlpha = blendSrcAlpha;
                    currentBlendDstAlpha = blendDstAlpha;
                }
            } else {

                currentBlendEquation = null;
                currentBlendSrc = null;
                currentBlendDst = null;
                currentBlendEquationAlpha = null;
                currentBlendSrcAlpha = null;
                currentBlendDstAlpha = null;
            }
        }

        function setMaterial(material) {

            material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);

            setFlipSided(material.side === BackSide);

            material.transparent === true ? setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha) : setBlending(NoBlending);

            depthBuffer.setFunc(material.depthFunc);
            depthBuffer.setTest(material.depthTest);
            depthBuffer.setMask(material.depthWrite);
            colorBuffer.setMask(material.colorWrite);

            setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        }

        //

        function setFlipSided(flipSided) {

            if (currentFlipSided !== flipSided) {

                if (flipSided) {

                    gl.frontFace(gl.CW);
                } else {

                    gl.frontFace(gl.CCW);
                }

                currentFlipSided = flipSided;
            }
        }

        function setCullFace(cullFace) {

            if (cullFace !== CullFaceNone) {

                enable(gl.CULL_FACE);

                if (cullFace !== currentCullFace) {

                    if (cullFace === CullFaceBack) {

                        gl.cullFace(gl.BACK);
                    } else if (cullFace === CullFaceFront) {

                        gl.cullFace(gl.FRONT);
                    } else {

                        gl.cullFace(gl.FRONT_AND_BACK);
                    }
                }
            } else {

                disable(gl.CULL_FACE);
            }

            currentCullFace = cullFace;
        }

        function setLineWidth(width) {

            if (width !== currentLineWidth) {

                if (lineWidthAvailable) gl.lineWidth(width);

                currentLineWidth = width;
            }
        }

        function setPolygonOffset(polygonOffset, factor, units) {

            if (polygonOffset) {

                enable(gl.POLYGON_OFFSET_FILL);

                if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {

                    gl.polygonOffset(factor, units);

                    currentPolygonOffsetFactor = factor;
                    currentPolygonOffsetUnits = units;
                }
            } else {

                disable(gl.POLYGON_OFFSET_FILL);
            }
        }

        function getScissorTest() {

            return currentScissorTest;
        }

        function setScissorTest(scissorTest) {

            currentScissorTest = scissorTest;

            if (scissorTest) {

                enable(gl.SCISSOR_TEST);
            } else {

                disable(gl.SCISSOR_TEST);
            }
        }

        // texture

        function activeTexture(webglSlot) {

            if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;

            if (currentTextureSlot !== webglSlot) {

                gl.activeTexture(webglSlot);
                currentTextureSlot = webglSlot;
            }
        }

        function bindTexture(webglType, webglTexture) {

            if (currentTextureSlot === null) {

                activeTexture();
            }

            var boundTexture = currentBoundTextures[currentTextureSlot];

            if (boundTexture === undefined) {

                boundTexture = { type: undefined, texture: undefined };
                currentBoundTextures[currentTextureSlot] = boundTexture;
            }

            if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {

                gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);

                boundTexture.type = webglType;
                boundTexture.texture = webglTexture;
            }
        }

        function compressedTexImage2D() {

            try {

                gl.compressedTexImage2D.apply(gl, arguments);
            } catch (error) {

                console.error(error);
            }
        }

        function texImage2D() {

            try {

                gl.texImage2D.apply(gl, arguments);
            } catch (error) {

                console.error(error);
            }
        }

        //

        function scissor(scissor) {

            if (currentScissor.equals(scissor) === false) {

                gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
                currentScissor.copy(scissor);
            }
        }

        function viewport(viewport) {

            if (currentViewport.equals(viewport) === false) {

                gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
                currentViewport.copy(viewport);
            }
        }

        //

        function reset() {

            for (var i = 0; i < enabledAttributes.length; i++) {

                if (enabledAttributes[i] === 1) {

                    gl.disableVertexAttribArray(i);
                    enabledAttributes[i] = 0;
                }
            }

            capabilities = {};

            compressedTextureFormats = null;

            currentTextureSlot = null;
            currentBoundTextures = {};

            currentBlending = null;

            currentFlipSided = null;
            currentCullFace = null;

            colorBuffer.reset();
            depthBuffer.reset();
            stencilBuffer.reset();
        }

        return {

            buffers: {
                color: colorBuffer,
                depth: depthBuffer,
                stencil: stencilBuffer
            },

            init: init,
            initAttributes: initAttributes,
            enableAttribute: enableAttribute,
            enableAttributeAndDivisor: enableAttributeAndDivisor,
            disableUnusedAttributes: disableUnusedAttributes,
            enable: enable,
            disable: disable,
            getCompressedTextureFormats: getCompressedTextureFormats,

            setBlending: setBlending,
            setMaterial: setMaterial,

            setFlipSided: setFlipSided,
            setCullFace: setCullFace,

            setLineWidth: setLineWidth,
            setPolygonOffset: setPolygonOffset,

            getScissorTest: getScissorTest,
            setScissorTest: setScissorTest,

            activeTexture: activeTexture,
            bindTexture: bindTexture,
            compressedTexImage2D: compressedTexImage2D,
            texImage2D: texImage2D,

            scissor: scissor,
            viewport: viewport,

            reset: reset

        };
    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLCapabilities(gl, extensions, parameters) {

        var maxAnisotropy;

        function getMaxAnisotropy() {

            if (maxAnisotropy !== undefined) return maxAnisotropy;

            var extension = extensions.get('EXT_texture_filter_anisotropic');

            if (extension !== null) {

                maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else {

                maxAnisotropy = 0;
            }

            return maxAnisotropy;
        }

        function getMaxPrecision(precision) {

            if (precision === 'highp') {

                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {

                    return 'highp';
                }

                precision = 'mediump';
            }

            if (precision === 'mediump') {

                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {

                    return 'mediump';
                }
            }

            return 'lowp';
        }

        var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
        var maxPrecision = getMaxPrecision(precision);

        if (maxPrecision !== precision) {

            console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
            precision = maxPrecision;
        }

        var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !!extensions.get('EXT_frag_depth');

        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);

        var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
        var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);

        var vertexTextures = maxVertexTextures > 0;
        var floatFragmentTextures = !!extensions.get('OES_texture_float');
        var floatVertexTextures = vertexTextures && floatFragmentTextures;

        return {

            getMaxAnisotropy: getMaxAnisotropy,
            getMaxPrecision: getMaxPrecision,

            precision: precision,
            logarithmicDepthBuffer: logarithmicDepthBuffer,

            maxTextures: maxTextures,
            maxVertexTextures: maxVertexTextures,
            maxTextureSize: maxTextureSize,
            maxCubemapSize: maxCubemapSize,

            maxAttributes: maxAttributes,
            maxVertexUniforms: maxVertexUniforms,
            maxVaryings: maxVaryings,
            maxFragmentUniforms: maxFragmentUniforms,

            vertexTextures: vertexTextures,
            floatFragmentTextures: floatFragmentTextures,
            floatVertexTextures: floatVertexTextures

        };
    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLExtensions(gl) {

        var extensions = {};

        return {

            get: function get(name) {

                if (extensions[name] !== undefined) {

                    return extensions[name];
                }

                var extension;

                switch (name) {

                    case 'WEBGL_depth_texture':
                        extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                        break;

                    case 'EXT_texture_filter_anisotropic':
                        extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                        break;

                    case 'WEBGL_compressed_texture_s3tc':
                        extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                        break;

                    case 'WEBGL_compressed_texture_pvrtc':
                        extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                        break;

                    case 'WEBGL_compressed_texture_etc1':
                        extension = gl.getExtension('WEBGL_compressed_texture_etc1');
                        break;

                    default:
                        extension = gl.getExtension(name);

                }

                if (extension === null) {

                    console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
                }

                extensions[name] = extension;

                return extension;
            }

        };
    }

    /**
     * @author tschw
     */

    function WebGLClipping() {

        var scope = this,
            globalState = null,
            numGlobalPlanes = 0,
            localClippingEnabled = false,
            renderingShadows = false,
            plane = new Plane(),
            viewNormalMatrix = new Matrix3(),
            uniform = { value: null, needsUpdate: false };

        this.uniform = uniform;
        this.numPlanes = 0;
        this.numIntersection = 0;

        this.init = function (planes, enableLocalClipping, camera) {

            var enabled = planes.length !== 0 || enableLocalClipping ||
            // enable state of previous frame - the clipping code has to
            // run another frame in order to reset the state:
            numGlobalPlanes !== 0 || localClippingEnabled;

            localClippingEnabled = enableLocalClipping;

            globalState = projectPlanes(planes, camera, 0);
            numGlobalPlanes = planes.length;

            return enabled;
        };

        this.beginShadows = function () {

            renderingShadows = true;
            projectPlanes(null);
        };

        this.endShadows = function () {

            renderingShadows = false;
            resetGlobalState();
        };

        this.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {

            if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
                // there's no local clipping

                if (renderingShadows) {
                    // there's no global clipping

                    projectPlanes(null);
                } else {

                    resetGlobalState();
                }
            } else {

                var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
                    lGlobal = nGlobal * 4,
                    dstArray = cache.clippingState || null;

                uniform.value = dstArray; // ensure unique state

                dstArray = projectPlanes(planes, camera, lGlobal, fromCache);

                for (var i = 0; i !== lGlobal; ++i) {

                    dstArray[i] = globalState[i];
                }

                cache.clippingState = dstArray;
                this.numIntersection = clipIntersection ? this.numPlanes : 0;
                this.numPlanes += nGlobal;
            }
        };

        function resetGlobalState() {

            if (uniform.value !== globalState) {

                uniform.value = globalState;
                uniform.needsUpdate = numGlobalPlanes > 0;
            }

            scope.numPlanes = numGlobalPlanes;
            scope.numIntersection = 0;
        }

        function projectPlanes(planes, camera, dstOffset, skipTransform) {

            var nPlanes = planes !== null ? planes.length : 0,
                dstArray = null;

            if (nPlanes !== 0) {

                dstArray = uniform.value;

                if (skipTransform !== true || dstArray === null) {

                    var flatSize = dstOffset + nPlanes * 4,
                        viewMatrix = camera.matrixWorldInverse;

                    viewNormalMatrix.getNormalMatrix(viewMatrix);

                    if (dstArray === null || dstArray.length < flatSize) {

                        dstArray = new Float32Array(flatSize);
                    }

                    for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {

                        plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);

                        plane.normal.toArray(dstArray, i4);
                        dstArray[i4 + 3] = plane.constant;
                    }
                }

                uniform.value = dstArray;
                uniform.needsUpdate = true;
            }

            scope.numPlanes = nPlanes;

            return dstArray;
        }
    }

    // import { Sphere } from '../math/Sphere';
    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     * @author tschw
     */

    function WebGLRenderer(parameters) {

        console.log('THREE.WebGLRenderer', REVISION);

        parameters = parameters || {};

        var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
            _context = parameters.context !== undefined ? parameters.context : null,
            _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
            _depth = parameters.depth !== undefined ? parameters.depth : true,
            _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
            _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
            _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
            _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

        var lights = [];

        var currentRenderList = null;

        var morphInfluences = new Float32Array(8);

        var sprites = [];
        var lensFlares = [];

        // public properties

        this.domElement = _canvas;
        this.context = null;

        // clearing

        this.autoClear = true;
        this.autoClearColor = true;
        this.autoClearDepth = true;
        this.autoClearStencil = true;

        // scene graph

        this.sortObjects = true;

        // user-defined clipping

        this.clippingPlanes = [];
        this.localClippingEnabled = false;

        // physically based shading

        this.gammaFactor = 2.0; // for backwards compatibility
        this.gammaInput = false;
        this.gammaOutput = false;

        // physical lights

        this.physicallyCorrectLights = false;

        // tone mapping

        this.toneMapping = LinearToneMapping;
        this.toneMappingExposure = 1.0;
        this.toneMappingWhitePoint = 1.0;

        // morphs

        this.maxMorphTargets = 8;
        this.maxMorphNormals = 4;

        // internal properties

        var _this = this,


        // internal state cache

        _currentProgram = null,
            _currentRenderTarget = null,
            _currentFramebuffer = null,
            _currentMaterialId = -1,
            _currentGeometryProgram = '',
            _currentCamera = null,
            _currentScissor = new Vector4(),
            _currentScissorTest = null,
            _currentViewport = new Vector4(),


        //

        _usedTextureUnits = 0,


        //

        _clearColor = new Color(0x000000),
            _clearAlpha = 0,
            _width = _canvas.width,
            _height = _canvas.height,
            _pixelRatio = 1,
            _scissor = new Vector4(0, 0, _width, _height),
            _scissorTest = false,
            _viewport = new Vector4(0, 0, _width, _height),


        // frustum

        _frustum = new Frustum(),


        // clipping

        _clipping = new WebGLClipping(),
            _clippingEnabled = false,
            _localClippingEnabled = false,


        // camera matrices cache

        _projScreenMatrix = new Matrix4(),
            _vector3 = new Vector3(),
            _matrix4 = new Matrix4(),
            _matrix42 = new Matrix4(),


        // light arrays cache

        _lights = {

            hash: '',

            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],

            shadows: []

        },


        // info

        _infoMemory = {
            geometries: 0,
            textures: 0
        },
            _infoRender = {

            frame: 0,
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0

        };

        this.info = {

            render: _infoRender,
            memory: _infoMemory,
            programs: null

        };

        // initialize

        var _gl;

        try {

            var contextAttributes = {
                alpha: _alpha,
                depth: _depth,
                stencil: _stencil,
                antialias: _antialias,
                premultipliedAlpha: _premultipliedAlpha,
                preserveDrawingBuffer: _preserveDrawingBuffer
            };

            _gl = _context || _canvas.getContext('webgl', contextAttributes) || _canvas.getContext('experimental-webgl', contextAttributes);

            if (_gl === null) {

                if (_canvas.getContext('webgl') !== null) {

                    throw 'Error creating WebGL context with your selected attributes.';
                } else {

                    throw 'Error creating WebGL context.';
                }
            }

            // Some experimental-webgl implementations do not have getShaderPrecisionFormat

            if (_gl.getShaderPrecisionFormat === undefined) {

                _gl.getShaderPrecisionFormat = function () {

                    return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
                };
            }

            _canvas.addEventListener('webglcontextlost', onContextLost, false);
        } catch (error) {

            console.error('THREE.WebGLRenderer: ' + error);
        }

        var extensions = new WebGLExtensions(_gl);

        extensions.get('WEBGL_depth_texture');
        extensions.get('OES_texture_float');
        extensions.get('OES_texture_float_linear');
        extensions.get('OES_texture_half_float');
        extensions.get('OES_texture_half_float_linear');
        extensions.get('OES_standard_derivatives');
        extensions.get('ANGLE_instanced_arrays');

        if (extensions.get('OES_element_index_uint')) {

            BufferGeometry.MaxIndex = 4294967296;
        }

        var capabilities = new WebGLCapabilities(_gl, extensions, parameters);

        var state = new WebGLState(_gl, extensions, paramThreeToGL);

        var properties = new WebGLProperties();
        var textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, _infoMemory);
        var attributes = new WebGLAttributes(_gl);
        var geometries = new WebGLGeometries(_gl, attributes, _infoMemory);
        var objects = new WebGLObjects(_gl, geometries, _infoRender);
        var programCache = new WebGLPrograms(this, capabilities);
        var lightCache = new WebGLLights();
        var renderLists = new WebGLRenderLists();

        this.info.programs = programCache.programs;

        var bufferRenderer = new WebGLBufferRenderer(_gl, extensions, _infoRender);
        var indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, _infoRender);

        //

        var backgroundPlaneCamera, backgroundPlaneMesh;
        var backgroundBoxCamera, backgroundBoxMesh;

        //

        function getTargetPixelRatio() {

            return _currentRenderTarget === null ? _pixelRatio : 1;
        }

        function setDefaultGLState() {

            state.init();

            state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));

            state.buffers.color.setClear(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha);
        }

        function resetGLState() {

            _currentProgram = null;
            _currentCamera = null;

            _currentGeometryProgram = '';
            _currentMaterialId = -1;

            state.reset();
        }

        setDefaultGLState();

        this.context = _gl;
        this.capabilities = capabilities;
        this.extensions = extensions;
        this.properties = properties;
        this.state = state;

        // shadow map

        var shadowMap = new WebGLShadowMap(this, _lights, objects, capabilities);

        this.shadowMap = shadowMap;

        // Plugins

        var spritePlugin = new SpritePlugin(this, sprites);
        var lensFlarePlugin = new LensFlarePlugin(this, lensFlares);

        // API

        this.getContext = function () {

            return _gl;
        };

        this.getContextAttributes = function () {

            return _gl.getContextAttributes();
        };

        this.forceContextLoss = function () {

            var extension = extensions.get('WEBGL_lose_context');
            if (extension) extension.loseContext();
        };

        this.getMaxAnisotropy = function () {

            return capabilities.getMaxAnisotropy();
        };

        this.getPrecision = function () {

            return capabilities.precision;
        };

        this.getPixelRatio = function () {

            return _pixelRatio;
        };

        this.setPixelRatio = function (value) {

            if (value === undefined) return;

            _pixelRatio = value;

            this.setSize(_viewport.z, _viewport.w, false);
        };

        this.getSize = function () {

            return {
                width: _width,
                height: _height
            };
        };

        this.setSize = function (width, height, updateStyle) {

            _width = width;
            _height = height;

            _canvas.width = width * _pixelRatio;
            _canvas.height = height * _pixelRatio;

            if (updateStyle !== false) {

                _canvas.style.width = width + 'px';
                _canvas.style.height = height + 'px';
            }

            this.setViewport(0, 0, width, height);
        };

        this.setViewport = function (x, y, width, height) {

            state.viewport(_viewport.set(x, y, width, height));
        };

        this.setScissor = function (x, y, width, height) {

            state.scissor(_scissor.set(x, y, width, height));
        };

        this.setScissorTest = function (boolean) {

            state.setScissorTest(_scissorTest = boolean);
        };

        // Clearing

        this.getClearColor = function () {

            return _clearColor;
        };

        this.setClearColor = function (color, alpha) {

            _clearColor.set(color);

            _clearAlpha = alpha !== undefined ? alpha : 1;

            state.buffers.color.setClear(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha);
        };

        this.getClearAlpha = function () {

            return _clearAlpha;
        };

        this.setClearAlpha = function (alpha) {

            _clearAlpha = alpha;

            state.buffers.color.setClear(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha);
        };

        this.clear = function (color, depth, stencil) {

            var bits = 0;

            if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
            if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
            if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;

            _gl.clear(bits);
        };

        this.clearColor = function () {

            this.clear(true, false, false);
        };

        this.clearDepth = function () {

            this.clear(false, true, false);
        };

        this.clearStencil = function () {

            this.clear(false, false, true);
        };

        this.clearTarget = function (renderTarget, color, depth, stencil) {

            this.setRenderTarget(renderTarget);
            this.clear(color, depth, stencil);
        };

        // Reset

        this.resetGLState = resetGLState;

        this.dispose = function () {

            _canvas.removeEventListener('webglcontextlost', onContextLost, false);

            renderLists.dispose();
        };

        // Events

        function onContextLost(event) {

            event.preventDefault();

            resetGLState();
            setDefaultGLState();

            properties.clear();
            objects.clear();
        }

        function onMaterialDispose(event) {

            var material = event.target;

            material.removeEventListener('dispose', onMaterialDispose);

            deallocateMaterial(material);
        }

        // Buffer deallocation

        function deallocateMaterial(material) {

            releaseMaterialProgramReference(material);

            properties.remove(material);
        }

        function releaseMaterialProgramReference(material) {

            var programInfo = properties.get(material).program;

            material.program = undefined;

            if (programInfo !== undefined) {

                programCache.releaseProgram(programInfo);
            }
        }

        // Buffer rendering

        function renderObjectImmediate(object, program, material) {

            object.render(function (object) {

                _this.renderBufferImmediate(object, program, material);
            });
        }

        this.renderBufferImmediate = function (object, program, material) {

            state.initAttributes();

            var buffers = properties.get(object);

            if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
            if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
            if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
            if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();

            var programAttributes = program.getAttributes();

            if (object.hasPositions) {

                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);

                state.enableAttribute(programAttributes.position);
                _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
            }

            if (object.hasNormals) {

                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);

                if (!material.isMeshPhongMaterial && !material.isMeshStandardMaterial && !material.isMeshNormalMaterial && material.shading === FlatShading) {

                    for (var i = 0, l = object.count * 3; i < l; i += 9) {

                        var array = object.normalArray;

                        var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
                        var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
                        var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;

                        array[i + 0] = nx;
                        array[i + 1] = ny;
                        array[i + 2] = nz;

                        array[i + 3] = nx;
                        array[i + 4] = ny;
                        array[i + 5] = nz;

                        array[i + 6] = nx;
                        array[i + 7] = ny;
                        array[i + 8] = nz;
                    }
                }

                _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);

                state.enableAttribute(programAttributes.normal);

                _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
            }

            if (object.hasUvs && material.map) {

                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);

                state.enableAttribute(programAttributes.uv);

                _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
            }

            if (object.hasColors && material.vertexColors !== NoColors) {

                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);

                state.enableAttribute(programAttributes.color);

                _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
            }

            state.disableUnusedAttributes();

            _gl.drawArrays(_gl.TRIANGLES, 0, object.count);

            object.count = 0;
        };

        function absNumericalSort(a, b) {

            return Math.abs(b[0]) - Math.abs(a[0]);
        }

        this.renderBufferDirect = function (camera, fog, geometry, material, object, group) {

            state.setMaterial(material);

            var program = setProgram(camera, fog, material, object);
            //var geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );
            var geometryProgram = geometry.id;
            geometryProgram += '_';
            geometryProgram += program.id;
            geometryProgram += '_';
            geometryProgram += material.wireframe === true;

            var updateBuffers = false;

            if (geometryProgram !== _currentGeometryProgram) {

                _currentGeometryProgram = geometryProgram;
                updateBuffers = true;
            }

            // morph targets

            var morphTargetInfluences = object.morphTargetInfluences;

            if (morphTargetInfluences !== undefined) {

                // TODO Remove allocations

                var activeInfluences = [];

                for (var i = 0, l = morphTargetInfluences.length; i < l; i++) {

                    var influence = morphTargetInfluences[i];
                    activeInfluences.push([influence, i]);
                }

                activeInfluences.sort(absNumericalSort);

                if (activeInfluences.length > 8) {

                    activeInfluences.length = 8;
                }

                var morphAttributes = geometry.morphAttributes;

                for (var i = 0, l = activeInfluences.length; i < l; i++) {

                    var influence = activeInfluences[i];
                    morphInfluences[i] = influence[0];

                    if (influence[0] !== 0) {

                        var index = influence[1];

                        if (material.morphTargets === true && morphAttributes.position) geometry.addAttribute('morphTarget' + i, morphAttributes.position[index]);
                        if (material.morphNormals === true && morphAttributes.normal) geometry.addAttribute('morphNormal' + i, morphAttributes.normal[index]);
                    } else {

                        if (material.morphTargets === true) geometry.removeAttribute('morphTarget' + i);
                        if (material.morphNormals === true) geometry.removeAttribute('morphNormal' + i);
                    }
                }

                for (var i = activeInfluences.length, il = morphInfluences.length; i < il; i++) {

                    morphInfluences[i] = 0.0;
                }

                program.getUniforms().setValue(_gl, 'morphTargetInfluences', morphInfluences);

                updateBuffers = true;
            }

            //

            var index = geometry.index;
            var position = geometry.attributes.position;
            var rangeFactor = 1;

            if (material.wireframe === true) {

                index = geometries.getWireframeAttribute(geometry);
                rangeFactor = 2;
            }

            var renderer = bufferRenderer;

            if (index !== null) {

                renderer = indexedBufferRenderer;
                renderer.setIndex(index);
            }

            if (updateBuffers) {

                setupVertexAttributes(material, program, geometry);

                if (index !== null) {

                    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
                }
            }

            //

            var dataCount = 0;

            if (index !== null) {

                dataCount = index.count;
            } else if (position !== undefined) {

                dataCount = position.count;
            }

            var rangeStart = geometry.drawRange.start * rangeFactor;
            var rangeCount = geometry.drawRange.count * rangeFactor;

            var groupStart = group !== null ? group.start * rangeFactor : 0;
            var groupCount = group !== null ? group.count * rangeFactor : Infinity;

            var drawStart = Math.max(rangeStart, groupStart);
            var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;

            var drawCount = Math.max(0, drawEnd - drawStart + 1);

            if (drawCount === 0) return;

            //

            if (object.isMesh) {

                if (material.wireframe === true) {

                    state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                    renderer.setMode(_gl.LINES);
                } else {

                    switch (object.drawMode) {

                        case TrianglesDrawMode:
                            renderer.setMode(_gl.TRIANGLES);
                            break;

                        case TriangleStripDrawMode:
                            renderer.setMode(_gl.TRIANGLE_STRIP);
                            break;

                        case TriangleFanDrawMode:
                            renderer.setMode(_gl.TRIANGLE_FAN);
                            break;

                    }
                }
            } else if (object.isLine) {

                var lineWidth = material.linewidth;

                if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

                state.setLineWidth(lineWidth * getTargetPixelRatio());

                if (object.isLineSegments) {

                    renderer.setMode(_gl.LINES);
                } else if (object.isLineLoop) {

                    renderer.setMode(_gl.LINE_LOOP);
                } else {

                    renderer.setMode(_gl.LINE_STRIP);
                }
            } else if (object.isPoints) {

                renderer.setMode(_gl.POINTS);
            }

            if (geometry && geometry.isInstancedBufferGeometry) {

                if (geometry.maxInstancedCount > 0) {

                    renderer.renderInstances(geometry, drawStart, drawCount);
                }
            } else {

                renderer.render(drawStart, drawCount);
            }
        };

        function setupVertexAttributes(material, program, geometry, startIndex) {

            if (geometry && geometry.isInstancedBufferGeometry) {

                if (extensions.get('ANGLE_instanced_arrays') === null) {

                    console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                    return;
                }
            }

            if (startIndex === undefined) startIndex = 0;

            state.initAttributes();

            var geometryAttributes = geometry.attributes;

            var programAttributes = program.getAttributes();

            var materialDefaultAttributeValues = material.defaultAttributeValues;

            for (var name in programAttributes) {

                var programAttribute = programAttributes[name];

                if (programAttribute >= 0) {

                    var geometryAttribute = geometryAttributes[name];

                    if (geometryAttribute !== undefined) {

                        var normalized = geometryAttribute.normalized;
                        var size = geometryAttribute.itemSize;

                        var attributeProperties = attributes.get(geometryAttribute);

                        var buffer = attributeProperties.buffer;
                        var type = attributeProperties.type;
                        var bytesPerElement = attributeProperties.bytesPerElement;

                        if (geometryAttribute.isInterleavedBufferAttribute) {

                            var data = geometryAttribute.data;
                            var stride = data.stride;
                            var offset = geometryAttribute.offset;

                            if (data && data.isInstancedInterleavedBuffer) {

                                state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

                                if (geometry.maxInstancedCount === undefined) {

                                    geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                                }
                            } else {

                                state.enableAttribute(programAttribute);
                            }

                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                            _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, (startIndex * stride + offset) * bytesPerElement);
                        } else {

                            if (geometryAttribute.isInstancedBufferAttribute) {

                                state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

                                if (geometry.maxInstancedCount === undefined) {

                                    geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                                }
                            } else {

                                state.enableAttribute(programAttribute);
                            }

                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                            _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement);
                        }
                    } else if (materialDefaultAttributeValues !== undefined) {

                        var value = materialDefaultAttributeValues[name];

                        if (value !== undefined) {

                            switch (value.length) {

                                case 2:
                                    _gl.vertexAttrib2fv(programAttribute, value);
                                    break;

                                case 3:
                                    _gl.vertexAttrib3fv(programAttribute, value);
                                    break;

                                case 4:
                                    _gl.vertexAttrib4fv(programAttribute, value);
                                    break;

                                default:
                                    _gl.vertexAttrib1fv(programAttribute, value);

                            }
                        }
                    }
                }
            }

            state.disableUnusedAttributes();
        }

        // Compile

        this.compile = function (scene, camera) {

            lights = [];

            scene.traverse(function (object) {

                if (object.isLight) {

                    lights.push(object);
                }
            });

            setupLights(lights, camera);

            scene.traverse(function (object) {

                if (object.material) {

                    if (Array.isArray(object.material)) {

                        for (var i = 0; i < object.material.length; i++) {

                            initMaterial(object.material[i], scene.fog, object);
                        }
                    } else {

                        initMaterial(object.material, scene.fog, object);
                    }
                }
            });
        };

        // Rendering

        this.render = function (scene, camera, renderTarget, forceClear) {

            if (camera !== undefined && camera.isCamera !== true) {

                console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
                return;
            }

            // reset caching for this frame

            _currentGeometryProgram = '';
            _currentMaterialId = -1;
            _currentCamera = null;

            // update scene graph

            if (scene.autoUpdate === true) scene.updateMatrixWorld();

            // update camera matrices and frustum

            camera.onBeforeRender(_this);

            if (camera.parent === null) camera.updateMatrixWorld();

            camera.matrixWorldInverse.getInverse(camera.matrixWorld);

            _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            _frustum.setFromMatrix(_projScreenMatrix);

            lights.length = 0;
            sprites.length = 0;
            lensFlares.length = 0;

            _localClippingEnabled = this.localClippingEnabled;
            _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);

            currentRenderList = renderLists.get(scene, camera);
            currentRenderList.init();

            projectObject(scene, camera, _this.sortObjects);

            currentRenderList.finish();

            if (_this.sortObjects === true) {

                currentRenderList.sort();
            }

            //

            if (_clippingEnabled) _clipping.beginShadows();

            setupShadows(lights);

            shadowMap.render(scene, camera);

            setupLights(lights, camera);

            if (_clippingEnabled) _clipping.endShadows();

            //

            _infoRender.frame++;
            _infoRender.calls = 0;
            _infoRender.vertices = 0;
            _infoRender.faces = 0;
            _infoRender.points = 0;

            if (renderTarget === undefined) {

                renderTarget = null;
            }

            this.setRenderTarget(renderTarget);

            //

            var background = scene.background;

            if (background === null) {

                state.buffers.color.setClear(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha);
            } else if (background && background.isColor) {

                state.buffers.color.setClear(background.r, background.g, background.b, 1, _premultipliedAlpha);
                forceClear = true;
            }

            if (this.autoClear || forceClear) {

                this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
            }

            if (background && background.isCubeTexture) {

                if (backgroundBoxCamera === undefined) {

                    backgroundBoxCamera = new PerspectiveCamera();

                    backgroundBoxMesh = new Mesh(new BoxBufferGeometry(5, 5, 5), new ShaderMaterial({
                        uniforms: ShaderLib.cube.uniforms,
                        vertexShader: ShaderLib.cube.vertexShader,
                        fragmentShader: ShaderLib.cube.fragmentShader,
                        side: BackSide,
                        depthTest: false,
                        depthWrite: false,
                        fog: false
                    }));
                }

                backgroundBoxCamera.projectionMatrix.copy(camera.projectionMatrix);

                backgroundBoxCamera.matrixWorld.extractRotation(camera.matrixWorld);
                backgroundBoxCamera.matrixWorldInverse.getInverse(backgroundBoxCamera.matrixWorld);

                backgroundBoxMesh.material.uniforms["tCube"].value = background;
                backgroundBoxMesh.modelViewMatrix.multiplyMatrices(backgroundBoxCamera.matrixWorldInverse, backgroundBoxMesh.matrixWorld);

                objects.update(backgroundBoxMesh);

                _this.renderBufferDirect(backgroundBoxCamera, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null);
            } else if (background && background.isTexture) {

                if (backgroundPlaneCamera === undefined) {

                    backgroundPlaneCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);

                    backgroundPlaneMesh = new Mesh(new PlaneBufferGeometry(2, 2), new MeshBasicMaterial({ depthTest: false, depthWrite: false, fog: false }));
                }

                backgroundPlaneMesh.material.map = background;

                objects.update(backgroundPlaneMesh);

                _this.renderBufferDirect(backgroundPlaneCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null);
            }

            //

            var opaqueObjects = currentRenderList.opaque;
            var transparentObjects = currentRenderList.transparent;

            if (scene.overrideMaterial) {

                var overrideMaterial = scene.overrideMaterial;

                if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera, overrideMaterial);
                if (transparentObjects.length) renderObjects(transparentObjects, scene, camera, overrideMaterial);
            } else {

                // opaque pass (front-to-back order)

                if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera);

                // transparent pass (back-to-front order)

                if (transparentObjects.length) renderObjects(transparentObjects, scene, camera);
            }

            // custom render plugins (post pass)

            spritePlugin.render(scene, camera);
            lensFlarePlugin.render(scene, camera, _currentViewport);

            // Generate mipmap if we're using any kind of mipmap filtering

            if (renderTarget) {

                textures.updateRenderTargetMipmap(renderTarget);
            }

            // Ensure depth buffer writing is enabled so it can be cleared on next render

            state.buffers.depth.setTest(true);
            state.buffers.depth.setMask(true);
            state.buffers.color.setMask(true);

            if (camera.isArrayCamera && camera.enabled) {

                _this.setScissorTest(false);
            }

            camera.onAfterRender(_this);

            // _gl.finish();
        };

        /*
        // TODO Duplicated code (Frustum)
        		var _sphere = new Sphere();
        		function isObjectViewable( object ) {
        			var geometry = object.geometry;
        			if ( geometry.boundingSphere === null )
        		geometry.computeBoundingSphere();
        			_sphere.copy( geometry.boundingSphere ).
        	applyMatrix4( object.matrixWorld );
        			return isSphereViewable( _sphere );
        		}
        		function isSpriteViewable( sprite ) {
        			_sphere.center.set( 0, 0, 0 );
        	_sphere.radius = 0.7071067811865476;
        	_sphere.applyMatrix4( sprite.matrixWorld );
        			return isSphereViewable( _sphere );
        		}
        		function isSphereViewable( sphere ) {
        			if ( ! _frustum.intersectsSphere( sphere ) ) return false;
        			var numPlanes = _clipping.numPlanes;
        			if ( numPlanes === 0 ) return true;
        			var planes = _this.clippingPlanes,
        				center = sphere.center,
        		negRad = - sphere.radius,
        		i = 0;
        			do {
        				// out when deeper than radius in the negative halfspace
        		if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;
        			} while ( ++ i !== numPlanes );
        			return true;
        		}
        */

        function projectObject(object, camera, sortObjects) {

            // 置入 object.alive 判断
            if (!object.visible || object.alive === false) return;

            var visible = object.layers.test(camera.layers);

            if (visible) {

                if (object.isLight) {

                    lights.push(object);
                } else if (object.isSprite) {

                    if (!object.frustumCulled || _frustum.intersectsSprite(object)) {

                        sprites.push(object);
                    }
                } else if (object.isLensFlare) {

                    lensFlares.push(object);
                } else if (object.isImmediateRenderObject) {

                    if (sortObjects) {

                        _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    }

                    currentRenderList.push(object, null, object.material, _vector3.z, null);
                } else if (object.isMesh || object.isLine || object.isPoints) {

                    if (object.isSkinnedMesh) {

                        object.skeleton.update();
                    }

                    if (!object.frustumCulled || _frustum.intersectsObject(object)) {

                        if (sortObjects) {

                            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                        }

                        var geometry = objects.update(object);
                        var material = object.material;

                        if (Array.isArray(material)) {

                            var groups = geometry.groups;

                            for (var i = 0, l = groups.length; i < l; i++) {

                                var group = groups[i];
                                var groupMaterial = material[group.materialIndex];

                                if (groupMaterial && groupMaterial.visible) {

                                    currentRenderList.push(object, geometry, groupMaterial, _vector3.z, group);
                                }
                            }
                        } else if (material.visible) {

                            currentRenderList.push(object, geometry, material, _vector3.z, null);
                        }
                    }
                }
            }

            var children = object.children;

            for (var i = 0, l = children.length; i < l; i++) {

                projectObject(children[i], camera, sortObjects);
            }
        }

        function renderObjects(renderList, scene, camera, overrideMaterial) {

            for (var i = 0, l = renderList.length; i < l; i++) {

                var renderItem = renderList[i];

                var object = renderItem.object;
                var geometry = renderItem.geometry;
                var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
                var group = renderItem.group;

                object.onBeforeRender(_this, scene, camera, geometry, material, group);

                if (camera.isArrayCamera && camera.enabled) {

                    var cameras = camera.cameras;

                    for (var j = 0, jl = cameras.length; j < jl; j++) {

                        var camera2 = cameras[j];
                        var bounds = camera2.bounds;

                        _this.setViewport(bounds.x * _width * _pixelRatio, bounds.y * _height * _pixelRatio, bounds.z * _width * _pixelRatio, bounds.w * _height * _pixelRatio);
                        _this.setScissor(bounds.x * _width * _pixelRatio, bounds.y * _height * _pixelRatio, bounds.z * _width * _pixelRatio, bounds.w * _height * _pixelRatio);
                        _this.setScissorTest(true);

                        renderObject(object, scene, camera2, geometry, material, group);
                    }
                } else {

                    renderObject(object, scene, camera, geometry, material, group);
                }

                object.onAfterRender(_this, scene, camera, geometry, material, group);
            }
        }

        function renderObject(object, scene, camera, geometry, material, group) {

            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
            object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

            if (object.isImmediateRenderObject) {

                state.setMaterial(material);

                var program = setProgram(camera, scene.fog, material, object);

                _currentGeometryProgram = '';

                renderObjectImmediate(object, program, material);
            } else {

                _this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
            }
        }

        function initMaterial(material, fog, object) {

            var materialProperties = properties.get(material);

            var parameters = programCache.getParameters(material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object);

            var code = programCache.getProgramCode(material, parameters);

            var program = materialProperties.program;
            var programChange = true;

            if (program === undefined) {

                // new material
                material.addEventListener('dispose', onMaterialDispose);
            } else if (program.code !== code) {

                // changed glsl or parameters
                releaseMaterialProgramReference(material);
            } else if (parameters.shaderID !== undefined) {

                // same glsl and uniform list
                return;
            } else {

                // only rebuild uniform list
                programChange = false;
            }

            if (programChange) {

                if (parameters.shaderID) {

                    var shader = ShaderLib[parameters.shaderID];

                    materialProperties.__webglShader = {
                        name: material.type,
                        uniforms: UniformsUtils.clone(shader.uniforms),
                        vertexShader: shader.vertexShader,
                        fragmentShader: shader.fragmentShader
                    };
                } else {

                    materialProperties.__webglShader = {
                        name: material.type,
                        uniforms: material.uniforms,
                        vertexShader: material.vertexShader,
                        fragmentShader: material.fragmentShader
                    };
                }

                material.__webglShader = materialProperties.__webglShader;

                program = programCache.acquireProgram(material, parameters, code);

                materialProperties.program = program;
                material.program = program;
            }

            var programAttributes = program.getAttributes();

            if (material.morphTargets) {

                material.numSupportedMorphTargets = 0;

                for (var i = 0; i < _this.maxMorphTargets; i++) {

                    if (programAttributes['morphTarget' + i] >= 0) {

                        material.numSupportedMorphTargets++;
                    }
                }
            }

            if (material.morphNormals) {

                material.numSupportedMorphNormals = 0;

                for (var i = 0; i < _this.maxMorphNormals; i++) {

                    if (programAttributes['morphNormal' + i] >= 0) {

                        material.numSupportedMorphNormals++;
                    }
                }
            }

            var uniforms = materialProperties.__webglShader.uniforms;

            if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {

                materialProperties.numClippingPlanes = _clipping.numPlanes;
                materialProperties.numIntersection = _clipping.numIntersection;
                uniforms.clippingPlanes = _clipping.uniform;
            }

            materialProperties.fog = fog;

            // store the light setup it was created for

            materialProperties.lightsHash = _lights.hash;

            if (material.lights) {

                // wire up the material to this renderer's lighting state

                uniforms.ambientLightColor.value = _lights.ambient;
                uniforms.directionalLights.value = _lights.directional;
                uniforms.spotLights.value = _lights.spot;
                uniforms.rectAreaLights.value = _lights.rectArea;
                uniforms.pointLights.value = _lights.point;
                uniforms.hemisphereLights.value = _lights.hemi;

                uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
                uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
                uniforms.spotShadowMap.value = _lights.spotShadowMap;
                uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
                uniforms.pointShadowMap.value = _lights.pointShadowMap;
                uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
                // TODO (abelnation): add area lights shadow info to uniforms
            }

            var progUniforms = materialProperties.program.getUniforms(),
                uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);

            materialProperties.uniformsList = uniformsList;
        }

        function setProgram(camera, fog, material, object) {

            _usedTextureUnits = 0;

            var materialProperties = properties.get(material);

            if (_clippingEnabled) {

                if (_localClippingEnabled || camera !== _currentCamera) {

                    var useCache = camera === _currentCamera && material.id === _currentMaterialId;

                    // we might want to call this function with some ClippingGroup
                    // object instead of the material, once it becomes feasible
                    // (#8465, #8379)
                    _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
                }
            }

            if (material.needsUpdate === false) {

                if (materialProperties.program === undefined) {

                    material.needsUpdate = true;
                } else if (material.fog && materialProperties.fog !== fog) {

                    material.needsUpdate = true;
                } else if (material.lights && materialProperties.lightsHash !== _lights.hash) {

                    material.needsUpdate = true;
                } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {

                    material.needsUpdate = true;
                }
            }

            if (material.needsUpdate) {

                initMaterial(material, fog, object);
                material.needsUpdate = false;
            }

            var refreshProgram = false;
            var refreshMaterial = false;
            var refreshLights = false;

            var program = materialProperties.program,
                p_uniforms = program.getUniforms(),
                m_uniforms = materialProperties.__webglShader.uniforms;

            if (program.id !== _currentProgram) {

                _gl.useProgram(program.program);
                _currentProgram = program.id;

                refreshProgram = true;
                refreshMaterial = true;
                refreshLights = true;
            }

            if (material.id !== _currentMaterialId) {

                _currentMaterialId = material.id;

                refreshMaterial = true;
            }

            if (refreshProgram || camera !== _currentCamera) {

                p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

                if (capabilities.logarithmicDepthBuffer) {

                    p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
                }

                if (camera !== _currentCamera) {

                    _currentCamera = camera;

                    // lighting uniforms depend on the camera so enforce an update
                    // now, in case this material supports lights - or later, when
                    // the next material that does gets activated:

                    refreshMaterial = true; // set to true on material change
                    refreshLights = true; // remains set until update done
                }

                // load material specific uniforms
                // (shader material also gets them for the sake of genericity)

                if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {

                    var uCamPos = p_uniforms.map.cameraPosition;

                    if (uCamPos !== undefined) {

                        uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
                    }
                }

                if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {

                    p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
                }

                p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
                p_uniforms.setValue(_gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint);
            }

            // skinning uniforms must be set even if material didn't change
            // auto-setting of texture unit for bone texture must go before other textures
            // not sure why, but otherwise weird things happen

            if (material.skinning) {

                p_uniforms.setOptional(_gl, object, 'bindMatrix');
                p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');

                var skeleton = object.skeleton;

                if (skeleton) {

                    var bones = skeleton.bones;

                    if (capabilities.floatVertexTextures) {

                        if (skeleton.boneTexture === undefined) {

                            // layout (1 matrix = 4 pixels)
                            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                            //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
                            //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
                            //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
                            //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


                            var size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix
                            size = _Math.nextPowerOfTwo(Math.ceil(size));
                            size = Math.max(size, 4);

                            var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
                            boneMatrices.set(skeleton.boneMatrices); // copy current values

                            var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);

                            skeleton.boneMatrices = boneMatrices;
                            skeleton.boneTexture = boneTexture;
                            skeleton.boneTextureSize = size;
                        }

                        p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture);
                        p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
                    } else {

                        p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
                    }
                }
            }

            if (refreshMaterial) {

                if (material.lights) {

                    // the current material requires lighting info

                    // note: all lighting uniforms are always set correctly
                    // they simply reference the renderer's state for their
                    // values
                    //
                    // use the current material's .needsUpdate flags to set
                    // the GL state when required

                    markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
                }

                // refresh uniforms common to several materials

                if (fog && material.fog) {

                    refreshUniformsFog(m_uniforms, fog);
                }

                if (material.isMeshBasicMaterial || material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isMeshNormalMaterial || material.isMeshDepthMaterial) {

                    refreshUniformsCommon(m_uniforms, material);
                }

                // refresh single material specific uniforms

                if (material.isLineBasicMaterial) {

                    refreshUniformsLine(m_uniforms, material);
                } else if (material.isLineDashedMaterial) {

                    refreshUniformsLine(m_uniforms, material);
                    refreshUniformsDash(m_uniforms, material);
                } else if (material.isPointsMaterial) {

                    refreshUniformsPoints(m_uniforms, material);
                } else if (material.isMeshLambertMaterial) {

                    refreshUniformsLambert(m_uniforms, material);
                } else if (material.isMeshToonMaterial) {

                    refreshUniformsToon(m_uniforms, material);
                } else if (material.isMeshPhongMaterial) {

                    refreshUniformsPhong(m_uniforms, material);
                } else if (material.isMeshPhysicalMaterial) {

                    refreshUniformsPhysical(m_uniforms, material);
                } else if (material.isMeshStandardMaterial) {

                    refreshUniformsStandard(m_uniforms, material);
                } else if (material.isMeshDepthMaterial) {

                    if (material.displacementMap) {

                        m_uniforms.displacementMap.value = material.displacementMap;
                        m_uniforms.displacementScale.value = material.displacementScale;
                        m_uniforms.displacementBias.value = material.displacementBias;
                    }
                } else if (material.isMeshNormalMaterial) {

                    refreshUniformsNormal(m_uniforms, material);
                }

                // RectAreaLight Texture
                // TODO (mrdoob): Find a nicer implementation

                if (m_uniforms.ltcMat !== undefined) m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE;
                if (m_uniforms.ltcMag !== undefined) m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE;

                WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
            }

            // common matrices

            p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
            p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
            p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);

            return program;
        }

        // Uniforms (refresh uniforms objects)

        function refreshUniformsCommon(uniforms, material) {

            uniforms.opacity.value = material.opacity;

            uniforms.diffuse.value = material.color;

            if (material.emissive) {

                uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
            }

            uniforms.map.value = material.map;
            uniforms.specularMap.value = material.specularMap;
            uniforms.alphaMap.value = material.alphaMap;

            if (material.lightMap) {

                uniforms.lightMap.value = material.lightMap;
                uniforms.lightMapIntensity.value = material.lightMapIntensity;
            }

            if (material.aoMap) {

                uniforms.aoMap.value = material.aoMap;
                uniforms.aoMapIntensity.value = material.aoMapIntensity;
            }

            // uv repeat and offset setting priorities
            // 1. color map
            // 2. specular map
            // 3. normal map
            // 4. bump map
            // 5. alpha map
            // 6. emissive map

            var uvScaleMap;

            if (material.map) {

                uvScaleMap = material.map;
            } else if (material.specularMap) {

                uvScaleMap = material.specularMap;
            } else if (material.displacementMap) {

                uvScaleMap = material.displacementMap;
            } else if (material.normalMap) {

                uvScaleMap = material.normalMap;
            } else if (material.bumpMap) {

                uvScaleMap = material.bumpMap;
            } else if (material.roughnessMap) {

                uvScaleMap = material.roughnessMap;
            } else if (material.metalnessMap) {

                uvScaleMap = material.metalnessMap;
            } else if (material.alphaMap) {

                uvScaleMap = material.alphaMap;
            } else if (material.emissiveMap) {

                uvScaleMap = material.emissiveMap;
            }

            if (uvScaleMap !== undefined) {

                // backwards compatibility
                if (uvScaleMap.isWebGLRenderTarget) {

                    uvScaleMap = uvScaleMap.texture;
                }

                var offset = uvScaleMap.offset;
                var repeat = uvScaleMap.repeat;

                uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
                uniforms.rotateMatrix.value.copy(uvScaleMap.rotateMatrix); // xmh add
            }

            uniforms.envMap.value = material.envMap;

            // don't flip CubeTexture envMaps, flip everything else:
            //  WebGLRenderTargetCube will be flipped for backwards compatibility
            //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
            // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
            uniforms.flipEnvMap.value = !(material.envMap && material.envMap.isCubeTexture) ? 1 : -1;

            uniforms.reflectivity.value = material.reflectivity;
            uniforms.refractionRatio.value = material.refractionRatio;
        }

        function refreshUniformsLine(uniforms, material) {

            uniforms.diffuse.value = material.color;
            uniforms.opacity.value = material.opacity;
        }

        function refreshUniformsDash(uniforms, material) {

            uniforms.dashSize.value = material.dashSize;
            uniforms.totalSize.value = material.dashSize + material.gapSize;
            uniforms.scale.value = material.scale;
        }

        function refreshUniformsPoints(uniforms, material) {

            uniforms.diffuse.value = material.color;
            uniforms.opacity.value = material.opacity;
            uniforms.size.value = material.size * _pixelRatio;
            uniforms.scale.value = _height * 0.5;

            uniforms.map.value = material.map;

            if (material.map !== null) {

                var offset = material.map.offset;
                var repeat = material.map.repeat;

                uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
            }
        }

        function refreshUniformsFog(uniforms, fog) {

            uniforms.fogColor.value = fog.color;

            if (fog.isFog) {

                uniforms.fogNear.value = fog.near;
                uniforms.fogFar.value = fog.far;
            } else if (fog.isFogExp2) {

                uniforms.fogDensity.value = fog.density;
            }
        }

        function refreshUniformsLambert(uniforms, material) {

            if (material.emissiveMap) {

                uniforms.emissiveMap.value = material.emissiveMap;
            }
        }

        function refreshUniformsPhong(uniforms, material) {

            uniforms.specular.value = material.specular;
            uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

            if (material.emissiveMap) {

                uniforms.emissiveMap.value = material.emissiveMap;
            }

            if (material.bumpMap) {

                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
            }

            if (material.normalMap) {

                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
            }

            if (material.displacementMap) {

                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }

        function refreshUniformsToon(uniforms, material) {

            refreshUniformsPhong(uniforms, material);

            if (material.gradientMap) {

                uniforms.gradientMap.value = material.gradientMap;
            }
        }

        function refreshUniformsStandard(uniforms, material) {

            uniforms.roughness.value = material.roughness;
            uniforms.metalness.value = material.metalness;

            if (material.roughnessMap) {

                uniforms.roughnessMap.value = material.roughnessMap;
            }

            if (material.metalnessMap) {

                uniforms.metalnessMap.value = material.metalnessMap;
            }

            if (material.emissiveMap) {

                uniforms.emissiveMap.value = material.emissiveMap;
            }

            if (material.bumpMap) {

                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
            }

            if (material.normalMap) {

                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
            }

            if (material.displacementMap) {

                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }

            if (material.envMap) {

                //uniforms.envMap.value = material.envMap; // part of uniforms common
                uniforms.envMapIntensity.value = material.envMapIntensity;
            }
        }

        function refreshUniformsPhysical(uniforms, material) {

            uniforms.clearCoat.value = material.clearCoat;
            uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

            refreshUniformsStandard(uniforms, material);
        }

        function refreshUniformsNormal(uniforms, material) {

            if (material.bumpMap) {

                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
            }

            if (material.normalMap) {

                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
            }

            if (material.displacementMap) {

                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }

        // If uniforms are marked as clean, they don't need to be loaded to the GPU.

        function markUniformsLightsNeedsUpdate(uniforms, value) {

            uniforms.ambientLightColor.needsUpdate = value;

            uniforms.directionalLights.needsUpdate = value;
            uniforms.pointLights.needsUpdate = value;
            uniforms.spotLights.needsUpdate = value;
            uniforms.rectAreaLights.needsUpdate = value;
            uniforms.hemisphereLights.needsUpdate = value;
        }

        // Lighting

        function setupShadows(lights) {

            var lightShadowsLength = 0;

            for (var i = 0, l = lights.length; i < l; i++) {

                var light = lights[i];

                if (light.castShadow) {

                    _lights.shadows[lightShadowsLength] = light;
                    lightShadowsLength++;
                }
            }

            _lights.shadows.length = lightShadowsLength;
        }

        function setupLights(lights, camera) {

            var l,
                ll,
                light,
                shadow,
                r = 0,
                g = 0,
                b = 0,
                color,
                intensity,
                distance,
                shadowMap,
                viewMatrix = camera.matrixWorldInverse,
                directionalLength = 0,
                pointLength = 0,
                spotLength = 0,
                rectAreaLength = 0,
                hemiLength = 0;

            for (l = 0, ll = lights.length; l < ll; l++) {

                light = lights[l];

                color = light.color;
                intensity = light.intensity;
                distance = light.distance;

                shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

                if (light.isAmbientLight) {

                    r += color.r * intensity;
                    g += color.g * intensity;
                    b += color.b * intensity;
                } else if (light.isDirectionalLight) {

                    var uniforms = lightCache.get(light);

                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    _vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(_vector3);
                    uniforms.direction.transformDirection(viewMatrix);

                    uniforms.shadow = light.castShadow;

                    if (light.castShadow) {

                        shadow = light.shadow;

                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                    }

                    _lights.directionalShadowMap[directionalLength] = shadowMap;
                    _lights.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                    _lights.directional[directionalLength] = uniforms;

                    directionalLength++;
                } else if (light.isSpotLight) {

                    var uniforms = lightCache.get(light);

                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);

                    uniforms.color.copy(color).multiplyScalar(intensity);
                    uniforms.distance = distance;

                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    _vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(_vector3);
                    uniforms.direction.transformDirection(viewMatrix);

                    uniforms.coneCos = Math.cos(light.angle);
                    uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                    uniforms.decay = light.distance === 0 ? 0.0 : light.decay;

                    uniforms.shadow = light.castShadow;

                    if (light.castShadow) {

                        shadow = light.shadow;

                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                    }

                    _lights.spotShadowMap[spotLength] = shadowMap;
                    _lights.spotShadowMatrix[spotLength] = light.shadow.matrix;
                    _lights.spot[spotLength] = uniforms;

                    spotLength++;
                } else if (light.isRectAreaLight) {

                    var uniforms = lightCache.get(light);

                    // (a) intensity controls irradiance of entire light
                    uniforms.color.copy(color).multiplyScalar(intensity / (light.width * light.height));

                    // (b) intensity controls the radiance per light area
                    // uniforms.color.copy( color ).multiplyScalar( intensity );

                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);

                    // extract local rotation of light to derive width/height half vectors
                    _matrix42.identity();
                    _matrix4.copy(light.matrixWorld);
                    _matrix4.premultiply(viewMatrix);
                    _matrix42.extractRotation(_matrix4);

                    uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                    uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);

                    uniforms.halfWidth.applyMatrix4(_matrix42);
                    uniforms.halfHeight.applyMatrix4(_matrix42);

                    // TODO (abelnation): RectAreaLight distance?
                    // uniforms.distance = distance;

                    _lights.rectArea[rectAreaLength] = uniforms;

                    rectAreaLength++;
                } else if (light.isPointLight) {

                    var uniforms = lightCache.get(light);

                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);

                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    uniforms.distance = light.distance;
                    uniforms.decay = light.distance === 0 ? 0.0 : light.decay;

                    uniforms.shadow = light.castShadow;

                    if (light.castShadow) {

                        shadow = light.shadow;

                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                    }

                    _lights.pointShadowMap[pointLength] = shadowMap;
                    _lights.pointShadowMatrix[pointLength] = light.shadow.matrix;
                    _lights.point[pointLength] = uniforms;

                    pointLength++;
                } else if (light.isHemisphereLight) {

                    var uniforms = lightCache.get(light);

                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.direction.normalize();

                    uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                    uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);

                    _lights.hemi[hemiLength] = uniforms;

                    hemiLength++;
                }
            }

            _lights.ambient[0] = r;
            _lights.ambient[1] = g;
            _lights.ambient[2] = b;

            _lights.directional.length = directionalLength;
            _lights.spot.length = spotLength;
            _lights.rectArea.length = rectAreaLength;
            _lights.point.length = pointLength;
            _lights.hemi.length = hemiLength;

            // TODO (sam-g-steel) why aren't we using join
            _lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + _lights.shadows.length;
        }

        // GL state setting

        this.setFaceCulling = function (cullFace, frontFaceDirection) {

            state.setCullFace(cullFace);
            state.setFlipSided(frontFaceDirection === FrontFaceDirectionCW);
        };

        // Textures

        function allocTextureUnit() {

            var textureUnit = _usedTextureUnits;

            if (textureUnit >= capabilities.maxTextures) {

                console.warn('WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);
            }

            _usedTextureUnits += 1;

            return textureUnit;
        }

        this.allocTextureUnit = allocTextureUnit;

        // this.setTexture2D = setTexture2D;
        this.setTexture2D = function () {

            var warned = false;

            // backwards compatibility: peel texture.texture
            return function setTexture2D(texture, slot) {

                if (texture && texture.isWebGLRenderTarget) {

                    if (!warned) {

                        console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
                        warned = true;
                    }

                    texture = texture.texture;
                }

                textures.setTexture2D(texture, slot);
            };
        }();

        this.setTexture = function () {

            var warned = false;

            return function setTexture(texture, slot) {

                if (!warned) {

                    console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");
                    warned = true;
                }

                textures.setTexture2D(texture, slot);
            };
        }();

        this.setTextureCube = function () {

            var warned = false;

            return function setTextureCube(texture, slot) {

                // backwards compatibility: peel texture.texture
                if (texture && texture.isWebGLRenderTargetCube) {

                    if (!warned) {

                        console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                        warned = true;
                    }

                    texture = texture.texture;
                }

                // currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
                // TODO: unify these code paths
                if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {

                    // CompressedTexture can have Array in image :/

                    // this function alone should take care of cube textures
                    textures.setTextureCube(texture, slot);
                } else {

                    // assumed: texture property of THREE.WebGLRenderTargetCube

                    textures.setTextureCubeDynamic(texture, slot);
                }
            };
        }();

        this.getRenderTarget = function () {

            return _currentRenderTarget;
        };

        this.setRenderTarget = function (renderTarget) {

            _currentRenderTarget = renderTarget;

            if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {

                textures.setupRenderTarget(renderTarget);
            }

            var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
            var framebuffer;

            if (renderTarget) {

                var renderTargetProperties = properties.get(renderTarget);

                if (isCube) {

                    framebuffer = renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];
                } else {

                    framebuffer = renderTargetProperties.__webglFramebuffer;
                }

                _currentScissor.copy(renderTarget.scissor);
                _currentScissorTest = renderTarget.scissorTest;

                _currentViewport.copy(renderTarget.viewport);
            } else {

                framebuffer = null;

                _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
                _currentScissorTest = _scissorTest;

                _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
            }

            if (_currentFramebuffer !== framebuffer) {

                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                _currentFramebuffer = framebuffer;
            }

            state.scissor(_currentScissor);
            state.setScissorTest(_currentScissorTest);

            state.viewport(_currentViewport);

            if (isCube) {

                var textureProperties = properties.get(renderTarget.texture);
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
            }
        };

        this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer) {

            if ((renderTarget && renderTarget.isWebGLRenderTarget) === false) {

                console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
                return;
            }

            var framebuffer = properties.get(renderTarget).__webglFramebuffer;

            if (framebuffer) {

                var restore = false;

                if (framebuffer !== _currentFramebuffer) {

                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

                    restore = true;
                }

                try {

                    var texture = renderTarget.texture;
                    var textureFormat = texture.format;
                    var textureType = texture.type;

                    if (textureFormat !== RGBAFormat && paramThreeToGL(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {

                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                        return;
                    }

                    if (textureType !== UnsignedByteType && paramThreeToGL(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // IE11, Edge and Chrome Mac < 52 (#9513)
                    !(textureType === FloatType && (extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
                    !(textureType === HalfFloatType && extensions.get('EXT_color_buffer_half_float'))) {

                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                        return;
                    }

                    if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {

                        // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

                        if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {

                            _gl.readPixels(x, y, width, height, paramThreeToGL(textureFormat), paramThreeToGL(textureType), buffer);
                        }
                    } else {

                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
                    }
                } finally {

                    if (restore) {

                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
                    }
                }
            }
        };

        // Map three.js constants to WebGL constants

        function paramThreeToGL(p) {

            var extension;

            if (p === RepeatWrapping) return _gl.REPEAT;
            if (p === ClampToEdgeWrapping) return _gl.CLAMP_TO_EDGE;
            if (p === MirroredRepeatWrapping) return _gl.MIRRORED_REPEAT;

            if (p === NearestFilter) return _gl.NEAREST;
            if (p === NearestMipMapNearestFilter) return _gl.NEAREST_MIPMAP_NEAREST;
            if (p === NearestMipMapLinearFilter) return _gl.NEAREST_MIPMAP_LINEAR;

            if (p === LinearFilter) return _gl.LINEAR;
            if (p === LinearMipMapNearestFilter) return _gl.LINEAR_MIPMAP_NEAREST;
            if (p === LinearMipMapLinearFilter) return _gl.LINEAR_MIPMAP_LINEAR;

            if (p === UnsignedByteType) return _gl.UNSIGNED_BYTE;
            if (p === UnsignedShort4444Type) return _gl.UNSIGNED_SHORT_4_4_4_4;
            if (p === UnsignedShort5551Type) return _gl.UNSIGNED_SHORT_5_5_5_1;
            if (p === UnsignedShort565Type) return _gl.UNSIGNED_SHORT_5_6_5;

            if (p === ByteType) return _gl.BYTE;
            if (p === ShortType) return _gl.SHORT;
            if (p === UnsignedShortType) return _gl.UNSIGNED_SHORT;
            if (p === IntType) return _gl.INT;
            if (p === UnsignedIntType) return _gl.UNSIGNED_INT;
            if (p === FloatType) return _gl.FLOAT;

            if (p === HalfFloatType) {

                extension = extensions.get('OES_texture_half_float');

                if (extension !== null) return extension.HALF_FLOAT_OES;
            }

            if (p === AlphaFormat) return _gl.ALPHA;
            if (p === RGBFormat) return _gl.RGB;
            if (p === RGBAFormat) return _gl.RGBA;
            if (p === LuminanceFormat) return _gl.LUMINANCE;
            if (p === LuminanceAlphaFormat) return _gl.LUMINANCE_ALPHA;
            if (p === DepthFormat) return _gl.DEPTH_COMPONENT;
            if (p === DepthStencilFormat) return _gl.DEPTH_STENCIL;

            if (p === AddEquation) return _gl.FUNC_ADD;
            if (p === SubtractEquation) return _gl.FUNC_SUBTRACT;
            if (p === ReverseSubtractEquation) return _gl.FUNC_REVERSE_SUBTRACT;

            if (p === ZeroFactor) return _gl.ZERO;
            if (p === OneFactor) return _gl.ONE;
            if (p === SrcColorFactor) return _gl.SRC_COLOR;
            if (p === OneMinusSrcColorFactor) return _gl.ONE_MINUS_SRC_COLOR;
            if (p === SrcAlphaFactor) return _gl.SRC_ALPHA;
            if (p === OneMinusSrcAlphaFactor) return _gl.ONE_MINUS_SRC_ALPHA;
            if (p === DstAlphaFactor) return _gl.DST_ALPHA;
            if (p === OneMinusDstAlphaFactor) return _gl.ONE_MINUS_DST_ALPHA;

            if (p === DstColorFactor) return _gl.DST_COLOR;
            if (p === OneMinusDstColorFactor) return _gl.ONE_MINUS_DST_COLOR;
            if (p === SrcAlphaSaturateFactor) return _gl.SRC_ALPHA_SATURATE;

            if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {

                extension = extensions.get('WEBGL_compressed_texture_s3tc');

                if (extension !== null) {

                    if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                }
            }

            if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {

                extension = extensions.get('WEBGL_compressed_texture_pvrtc');

                if (extension !== null) {

                    if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                }
            }

            if (p === RGB_ETC1_Format) {

                extension = extensions.get('WEBGL_compressed_texture_etc1');

                if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
            }

            if (p === MinEquation || p === MaxEquation) {

                extension = extensions.get('EXT_blend_minmax');

                if (extension !== null) {

                    if (p === MinEquation) return extension.MIN_EXT;
                    if (p === MaxEquation) return extension.MAX_EXT;
                }
            }

            if (p === UnsignedInt248Type) {

                extension = extensions.get('WEBGL_depth_texture');

                if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
            }

            return 0;
        }
    }

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function FogExp2(color, density) {

        this.name = '';

        this.color = new Color(color);
        this.density = density !== undefined ? density : 0.00025;
    }

    FogExp2.prototype.isFogExp2 = true;

    FogExp2.prototype.clone = function () {

        return new FogExp2(this.color.getHex(), this.density);
    };

    FogExp2.prototype.toJSON = function (meta) {

        return {
            type: 'FogExp2',
            color: this.color.getHex(),
            density: this.density
        };
    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Fog(color, near, far) {

        this.name = '';

        this.color = new Color(color);

        this.near = near !== undefined ? near : 1;
        this.far = far !== undefined ? far : 1000;
    }

    Fog.prototype.isFog = true;

    Fog.prototype.clone = function () {

        return new Fog(this.color.getHex(), this.near, this.far);
    };

    Fog.prototype.toJSON = function (meta) {

        return {
            type: 'Fog',
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Scene() {

        Object3D.call(this);

        this.type = 'Scene';

        this.background = null;
        this.fog = null;
        this.overrideMaterial = null;

        this.autoUpdate = true; // checked by the renderer
    }

    Scene.prototype = Object.assign(Object.create(Object3D.prototype), {

        constructor: Scene,

        copy: function copy(source, recursive) {

            Object3D.prototype.copy.call(this, source, recursive);

            if (source.background !== null) this.background = source.background.clone();
            if (source.fog !== null) this.fog = source.fog.clone();
            if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();

            this.autoUpdate = source.autoUpdate;
            this.matrixAutoUpdate = source.matrixAutoUpdate;

            return this;
        },

        toJSON: function toJSON(meta) {

            var data = Object3D.prototype.toJSON.call(this, meta);

            if (this.background !== null) data.object.background = this.background.toJSON(meta);
            if (this.fog !== null) data.object.fog = this.fog.toJSON();

            return data;
        }

    });

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function LensFlare(texture, size, distance, blending, color) {

        Object3D.call(this);

        this.lensFlares = [];

        this.positionScreen = new Vector3();
        this.customUpdateCallback = undefined;

        if (texture !== undefined) {

            this.add(texture, size, distance, blending, color);
        }
    }

    LensFlare.prototype = Object.assign(Object.create(Object3D.prototype), {

        constructor: LensFlare,

        isLensFlare: true,

        copy: function copy(source) {

            Object3D.prototype.copy.call(this, source);

            this.positionScreen.copy(source.positionScreen);
            this.customUpdateCallback = source.customUpdateCallback;

            for (var i = 0, l = source.lensFlares.length; i < l; i++) {

                this.lensFlares.push(source.lensFlares[i]);
            }

            return this;
        },

        add: function add(texture, size, distance, blending, color, opacity) {

            if (size === undefined) size = -1;
            if (distance === undefined) distance = 0;
            if (opacity === undefined) opacity = 1;
            if (color === undefined) color = new Color(0xffffff);
            if (blending === undefined) blending = NormalBlending;

            distance = Math.min(distance, Math.max(0, distance));

            this.lensFlares.push({
                texture: texture, // THREE.Texture
                size: size, // size in pixels (-1 = use texture.width)
                distance: distance, // distance (0-1) from light source (0=at light source)
                x: 0, y: 0, z: 0, // screen position (-1 => 1) z = 0 is in front z = 1 is back
                scale: 1, // scale
                rotation: 0, // rotation
                opacity: opacity, // opacity
                color: color, // color
                blending: blending // blending
            });
        },

        /*
         * Update lens flares update positions on all flares based on the screen position
         * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
         */

        updateLensFlares: function updateLensFlares() {

            var f,
                fl = this.lensFlares.length;
            var flare;
            var vecX = -this.positionScreen.x * 2;
            var vecY = -this.positionScreen.y * 2;

            for (f = 0; f < fl; f++) {

                flare = this.lensFlares[f];

                flare.x = this.positionScreen.x + vecX * flare.distance;
                flare.y = this.positionScreen.y + vecY * flare.distance;

                flare.wantedRotation = flare.x * Math.PI * 0.25;
                flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
            }
        }

    });

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *	uvOffset: new THREE.Vector2(),
     *	uvScale: new THREE.Vector2()
     * }
     */

    function SpriteMaterial(parameters) {

        Material.call(this);

        this.type = 'SpriteMaterial';

        this.color = new Color(0xffffff);
        this.map = null;

        this.rotation = 0;

        this.fog = false;
        this.lights = false;

        this.setValues(parameters);
    }

    SpriteMaterial.prototype = Object.create(Material.prototype);
    SpriteMaterial.prototype.constructor = SpriteMaterial;
    SpriteMaterial.prototype.isSpriteMaterial = true;

    SpriteMaterial.prototype.copy = function (source) {

        Material.prototype.copy.call(this, source);

        this.color.copy(source.color);
        this.map = source.map;

        this.rotation = source.rotation;

        return this;
    };

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function Sprite(material) {

        Object3D.call(this);

        this.type = 'Sprite';

        this.material = material !== undefined ? material : new SpriteMaterial();
    }

    Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {

        constructor: Sprite,

        isSprite: true,

        raycast: function () {

            var intersectPoint = new Vector3();
            var worldPosition = new Vector3();
            var worldScale = new Vector3();

            return function raycast(raycaster, intersects) {

                worldPosition.setFromMatrixPosition(this.matrixWorld);
                raycaster.ray.closestPointToPoint(worldPosition, intersectPoint);

                worldScale.setFromMatrixScale(this.matrixWorld);
                var guessSizeSq = worldScale.x * worldScale.y / 4;

                if (worldPosition.distanceToSquared(intersectPoint) > guessSizeSq) return;

                var distance = raycaster.ray.origin.distanceTo(intersectPoint);

                if (distance < raycaster.near || distance > raycaster.far) return;

                intersects.push({

                    distance: distance,
                    point: intersectPoint.clone(),
                    face: null,
                    object: this

                });
            };
        }(),

        clone: function clone() {

            return new this.constructor(this.material).copy(this);
        }

    });

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function LOD() {

        Object3D.call(this);

        this.type = 'LOD';

        Object.defineProperties(this, {
            levels: {
                enumerable: true,
                value: []
            }
        });
    }

    LOD.prototype = Object.assign(Object.create(Object3D.prototype), {

        constructor: LOD,

        copy: function copy(source) {

            Object3D.prototype.copy.call(this, source, false);

            var levels = source.levels;

            for (var i = 0, l = levels.length; i < l; i++) {

                var level = levels[i];

                this.addLevel(level.object.clone(), level.distance);
            }

            return this;
        },

        addLevel: function addLevel(object, distance) {

            if (distance === undefined) distance = 0;

            distance = Math.abs(distance);

            var levels = this.levels;

            for (var l = 0; l < levels.length; l++) {

                if (distance < levels[l].distance) {

                    break;
                }
            }

            levels.splice(l, 0, { distance: distance, object: object });

            this.add(object);
        },

        getObjectForDistance: function getObjectForDistance(distance) {

            var levels = this.levels;

            for (var i = 1, l = levels.length; i < l; i++) {

                if (distance < levels[i].distance) {

                    break;
                }
            }

            return levels[i - 1].object;
        },

        raycast: function () {

            var matrixPosition = new Vector3();

            return function raycast(raycaster, intersects) {

                matrixPosition.setFromMatrixPosition(this.matrixWorld);

                var distance = raycaster.ray.origin.distanceTo(matrixPosition);

                this.getObjectForDistance(distance).raycast(raycaster, intersects);
            };
        }(),

        update: function () {

            var v1 = new Vector3();
            var v2 = new Vector3();

            return function update(camera) {

                var levels = this.levels;

                if (levels.length > 1) {

                    v1.setFromMatrixPosition(camera.matrixWorld);
                    v2.setFromMatrixPosition(this.matrixWorld);

                    var distance = v1.distanceTo(v2);

                    levels[0].object.visible = true;

                    for (var i = 1, l = levels.length; i < l; i++) {

                        if (distance >= levels[i].distance) {

                            levels[i - 1].object.visible = false;
                            levels[i].object.visible = true;
                        } else {

                            break;
                        }
                    }

                    for (; i < l; i++) {

                        levels[i].object.visible = false;
                    }
                }
            };
        }(),

        toJSON: function toJSON(meta) {

            var data = Object3D.prototype.toJSON.call(this, meta);

            data.object.levels = [];

            var levels = this.levels;

            for (var i = 0, l = levels.length; i < l; i++) {

                var level = levels[i];

                data.object.levels.push({
                    object: level.object.uuid,
                    distance: level.distance
                });
            }

            return data;
        }

    });

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author michael guerrero / http://realitymeltdown.com
     * @author ikerr / http://verold.com
     */

    function Skeleton(bones, boneInverses) {

        // copy the bone array

        bones = bones || [];

        this.bones = bones.slice(0);
        this.boneMatrices = new Float32Array(this.bones.length * 16);

        // use the supplied bone inverses or calculate the inverses

        if (boneInverses === undefined) {

            this.calculateInverses();
        } else {

            if (this.bones.length === boneInverses.length) {

                this.boneInverses = boneInverses.slice(0);
            } else {

                console.warn('THREE.Skeleton boneInverses is the wrong length.');

                this.boneInverses = [];

                for (var i = 0, il = this.bones.length; i < il; i++) {

                    this.boneInverses.push(new Matrix4());
                }
            }
        }
    }

    Object.assign(Skeleton.prototype, {

        calculateInverses: function calculateInverses() {

            this.boneInverses = [];

            for (var i = 0, il = this.bones.length; i < il; i++) {

                var inverse = new Matrix4();

                if (this.bones[i]) {

                    inverse.getInverse(this.bones[i].matrixWorld);
                }

                this.boneInverses.push(inverse);
            }
        },

        pose: function pose() {

            var bone, i, il;

            // recover the bind-time world matrices

            for (i = 0, il = this.bones.length; i < il; i++) {

                bone = this.bones[i];

                if (bone) {

                    bone.matrixWorld.getInverse(this.boneInverses[i]);
                }
            }

            // compute the local matrices, positions, rotations and scales

            for (i = 0, il = this.bones.length; i < il; i++) {

                bone = this.bones[i];

                if (bone) {

                    if (bone.parent && bone.parent.isBone) {

                        bone.matrix.getInverse(bone.parent.matrixWorld);
                        bone.matrix.multiply(bone.matrixWorld);
                    } else {

                        bone.matrix.copy(bone.matrixWorld);
                    }

                    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
                }
            }
        },

        update: function () {

            var offsetMatrix = new Matrix4();
            var identityMatrix = new Matrix4();

            return function update() {

                var bones = this.bones;
                var boneInverses = this.boneInverses;
                var boneMatrices = this.boneMatrices;
                var boneTexture = this.boneTexture;

                // flatten bone matrices to array

                for (var i = 0, il = bones.length; i < il; i++) {

                    // compute the offset between the current and the original transform

                    var matrix = bones[i] ? bones[i].matrixWorld : identityMatrix;

                    offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
                    offsetMatrix.toArray(boneMatrices, i * 16);
                }

                if (boneTexture !== undefined) {

                    boneTexture.needsUpdate = true;
                }
            };
        }(),

        clone: function clone() {

            return new Skeleton(this.bones, this.boneInverses);
        }

    });

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ikerr / http://verold.com
     */

    function Bone() {

        Object3D.call(this);

        this.type = 'Bone';
    }

    Bone.prototype = Object.assign(Object.create(Object3D.prototype), {

        constructor: Bone,

        isBone: true

    });

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ikerr / http://verold.com
     */

    function SkinnedMesh(geometry, material) {

        Mesh.call(this, geometry, material);

        this.type = 'SkinnedMesh';

        this.bindMode = 'attached';
        this.bindMatrix = new Matrix4();
        this.bindMatrixInverse = new Matrix4();

        var bones = this.initBones();
        var skeleton = new Skeleton(bones);

        this.bind(skeleton, this.matrixWorld);

        this.normalizeSkinWeights();
    }

    SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {

        constructor: SkinnedMesh,

        isSkinnedMesh: true,

        initBones: function initBones() {

            var bones = [],
                bone,
                gbone;
            var i, il;

            if (this.geometry && this.geometry.bones !== undefined) {

                // first, create array of 'Bone' objects from geometry data

                for (i = 0, il = this.geometry.bones.length; i < il; i++) {

                    gbone = this.geometry.bones[i];

                    // create new 'Bone' object

                    bone = new Bone();
                    bones.push(bone);

                    // apply values

                    bone.name = gbone.name;
                    bone.position.fromArray(gbone.pos);
                    bone.quaternion.fromArray(gbone.rotq);
                    if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl);
                }

                // second, create bone hierarchy

                for (i = 0, il = this.geometry.bones.length; i < il; i++) {

                    gbone = this.geometry.bones[i];

                    if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {

                        // subsequent bones in the hierarchy

                        bones[gbone.parent].add(bones[i]);
                    } else {

                        // topmost bone, immediate child of the skinned mesh

                        this.add(bones[i]);
                    }
                }
            }

            // now the bones are part of the scene graph and children of the skinned mesh.
            // let's update the corresponding matrices

            this.updateMatrixWorld(true);

            return bones;
        },

        bind: function bind(skeleton, bindMatrix) {

            this.skeleton = skeleton;

            if (bindMatrix === undefined) {

                this.updateMatrixWorld(true);

                this.skeleton.calculateInverses();

                bindMatrix = this.matrixWorld;
            }

            this.bindMatrix.copy(bindMatrix);
            this.bindMatrixInverse.getInverse(bindMatrix);
        },

        pose: function pose() {

            this.skeleton.pose();
        },

        normalizeSkinWeights: function normalizeSkinWeights() {

            var scale, i;

            if (this.geometry && this.geometry.isGeometry) {

                for (i = 0; i < this.geometry.skinWeights.length; i++) {

                    var sw = this.geometry.skinWeights[i];

                    scale = 1.0 / sw.lengthManhattan();

                    if (scale !== Infinity) {

                        sw.multiplyScalar(scale);
                    } else {

                        sw.set(1, 0, 0, 0); // do something reasonable
                    }
                }
            } else if (this.geometry && this.geometry.isBufferGeometry) {

                var vec = new Vector4();

                var skinWeight = this.geometry.attributes.skinWeight;

                for (i = 0; i < skinWeight.count; i++) {

                    vec.x = skinWeight.getX(i);
                    vec.y = skinWeight.getY(i);
                    vec.z = skinWeight.getZ(i);
                    vec.w = skinWeight.getW(i);

                    scale = 1.0 / vec.lengthManhattan();

                    if (scale !== Infinity) {

                        vec.multiplyScalar(scale);
                    } else {

                        vec.set(1, 0, 0, 0); // do something reasonable
                    }

                    skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);
                }
            }
        },

        updateMatrixWorld: function updateMatrixWorld(force) {

            Mesh.prototype.updateMatrixWorld.call(this, force);

            if (this.bindMode === 'attached') {

                this.bindMatrixInverse.getInverse(this.matrixWorld);
            } else if (this.bindMode === 'detached') {

                this.bindMatrixInverse.getInverse(this.bindMatrix);
            } else {

                console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
            }
        },

        clone: function clone() {

            return new this.constructor(this.geometry, this.material).copy(this);
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  linewidth: <float>,
     *  linecap: "round",
     *  linejoin: "round"
     * }
     */

    function LineBasicMaterial(parameters) {

        Material.call(this);

        this.type = 'LineBasicMaterial';

        this.color = new Color(0xffffff);

        this.linewidth = 1;
        this.linecap = 'round';
        this.linejoin = 'round';

        this.lights = false;

        this.setValues(parameters);
    }

    LineBasicMaterial.prototype = Object.create(Material.prototype);
    LineBasicMaterial.prototype.constructor = LineBasicMaterial;

    LineBasicMaterial.prototype.isLineBasicMaterial = true;

    LineBasicMaterial.prototype.copy = function (source) {

        Material.prototype.copy.call(this, source);

        this.color.copy(source.color);

        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;

        return this;
    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Line(geometry, material, mode) {

        if (mode === 1) {

            console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');
            return new LineSegments(geometry, material);
        }

        Object3D.call(this);

        this.type = 'Line';

        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new LineBasicMaterial({ color: Math.random() * 0xffffff });
    }

    Line.prototype = Object.assign(Object.create(Object3D.prototype), {

        constructor: Line,

        isLine: true,

        raycast: function () {

            var inverseMatrix = new Matrix4();
            var ray = new Ray();
            var sphere = new Sphere();

            return function raycast(raycaster, intersects) {

                var precision = raycaster.linePrecision;
                var precisionSq = precision * precision;

                var geometry = this.geometry;
                var matrixWorld = this.matrixWorld;

                // Checking boundingSphere distance to ray

                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(matrixWorld);

                if (raycaster.ray.intersectsSphere(sphere) === false) return;

                //

                inverseMatrix.getInverse(matrixWorld);
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

                var vStart = new Vector3();
                var vEnd = new Vector3();
                var interSegment = new Vector3();
                var interRay = new Vector3();
                var step = this && this.isLineSegments ? 2 : 1;

                if (geometry.isBufferGeometry) {

                    var index = geometry.index;
                    var attributes = geometry.attributes;
                    var positions = attributes.position.array;

                    if (index !== null) {

                        var indices = index.array;

                        for (var i = 0, l = indices.length - 1; i < l; i += step) {

                            var a = indices[i];
                            var b = indices[i + 1];

                            vStart.fromArray(positions, a * 3);
                            vEnd.fromArray(positions, b * 3);

                            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

                            if (distSq > precisionSq) continue;

                            interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

                            var distance = raycaster.ray.origin.distanceTo(interRay);

                            if (distance < raycaster.near || distance > raycaster.far) continue;

                            intersects.push({

                                distance: distance,
                                // What do we want? intersection point on the ray or on the segment??
                                // point: raycaster.ray.at( distance ),
                                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this

                            });
                        }
                    } else {

                        for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {

                            vStart.fromArray(positions, 3 * i);
                            vEnd.fromArray(positions, 3 * i + 3);

                            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

                            if (distSq > precisionSq) continue;

                            interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

                            var distance = raycaster.ray.origin.distanceTo(interRay);

                            if (distance < raycaster.near || distance > raycaster.far) continue;

                            intersects.push({

                                distance: distance,
                                // What do we want? intersection point on the ray or on the segment??
                                // point: raycaster.ray.at( distance ),
                                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this

                            });
                        }
                    }
                } else if (geometry.isGeometry) {

                    var vertices = geometry.vertices;
                    var nbVertices = vertices.length;

                    for (var i = 0; i < nbVertices - 1; i += step) {

                        var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);

                        if (distSq > precisionSq) continue;

                        interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

                        var distance = raycaster.ray.origin.distanceTo(interRay);

                        if (distance < raycaster.near || distance > raycaster.far) continue;

                        intersects.push({

                            distance: distance,
                            // What do we want? intersection point on the ray or on the segment??
                            // point: raycaster.ray.at( distance ),
                            point: interSegment.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this

                        });
                    }
                }
            };
        }(),

        clone: function clone() {

            return new this.constructor(this.geometry, this.material).copy(this);
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function LineSegments(geometry, material) {

        Line.call(this, geometry, material);

        this.type = 'LineSegments';
    }

    LineSegments.prototype = Object.assign(Object.create(Line.prototype), {

        constructor: LineSegments,

        isLineSegments: true

    });

    /**
     * @author mgreter / http://github.com/mgreter
     */

    function LineLoop(geometry, material) {

        Line.call(this, geometry, material);

        this.type = 'LineLoop';
    }

    LineLoop.prototype = Object.assign(Object.create(Line.prototype), {

        constructor: LineLoop,

        isLineLoop: true

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *  size: <float>,
     *  sizeAttenuation: <bool>
     * }
     */

    function PointsMaterial(parameters) {

        Material.call(this);

        this.type = 'PointsMaterial';

        this.color = new Color(0xffffff);

        this.map = null;

        this.size = 1;
        this.sizeAttenuation = true;

        this.lights = false;

        this.setValues(parameters);
    }

    PointsMaterial.prototype = Object.create(Material.prototype);
    PointsMaterial.prototype.constructor = PointsMaterial;

    PointsMaterial.prototype.isPointsMaterial = true;

    PointsMaterial.prototype.copy = function (source) {

        Material.prototype.copy.call(this, source);

        this.color.copy(source.color);

        this.map = source.map;

        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;

        return this;
    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function Points(geometry, material) {

        Object3D.call(this);

        this.type = 'Points';

        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new PointsMaterial({ color: Math.random() * 0xffffff });
    }

    Points.prototype = Object.assign(Object.create(Object3D.prototype), {

        constructor: Points,

        isPoints: true,

        raycast: function () {

            var inverseMatrix = new Matrix4();
            var ray = new Ray();
            var sphere = new Sphere();

            return function raycast(raycaster, intersects) {

                var object = this;
                var geometry = this.geometry;
                var matrixWorld = this.matrixWorld;
                var threshold = raycaster.params.Points.threshold;

                // Checking boundingSphere distance to ray

                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(matrixWorld);
                sphere.radius += threshold;

                if (raycaster.ray.intersectsSphere(sphere) === false) return;

                //

                inverseMatrix.getInverse(matrixWorld);
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

                var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
                var localThresholdSq = localThreshold * localThreshold;
                var position = new Vector3();

                function testPoint(point, index) {

                    var rayPointDistanceSq = ray.distanceSqToPoint(point);

                    if (rayPointDistanceSq < localThresholdSq) {

                        var intersectPoint = ray.closestPointToPoint(point);
                        intersectPoint.applyMatrix4(matrixWorld);

                        var distance = raycaster.ray.origin.distanceTo(intersectPoint);

                        if (distance < raycaster.near || distance > raycaster.far) return;

                        intersects.push({

                            distance: distance,
                            distanceToRay: Math.sqrt(rayPointDistanceSq),
                            point: intersectPoint.clone(),
                            index: index,
                            face: null,
                            object: object

                        });
                    }
                }

                if (geometry.isBufferGeometry) {

                    var index = geometry.index;
                    var attributes = geometry.attributes;
                    var positions = attributes.position.array;

                    if (index !== null) {

                        var indices = index.array;

                        for (var i = 0, il = indices.length; i < il; i++) {

                            var a = indices[i];

                            position.fromArray(positions, a * 3);

                            testPoint(position, a);
                        }
                    } else {

                        for (var i = 0, l = positions.length / 3; i < l; i++) {

                            position.fromArray(positions, i * 3);

                            testPoint(position, i);
                        }
                    }
                } else {

                    var vertices = geometry.vertices;

                    for (var i = 0, l = vertices.length; i < l; i++) {

                        testPoint(vertices[i], i);
                    }
                }
            };
        }(),

        clone: function clone() {

            return new this.constructor(this.geometry, this.material).copy(this);
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Group() {

        Object3D.call(this);

        this.type = 'Group';
    }

    Group.prototype = Object.assign(Object.create(Object3D.prototype), {

        constructor: Group

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {

        Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);

        this.generateMipmaps = false;

        var scope = this;

        function update() {

            requestAnimationFrame(update);

            if (video.readyState >= video.HAVE_CURRENT_DATA) {

                scope.needsUpdate = true;
            }
        }

        update();
    }

    VideoTexture.prototype = Object.create(Texture.prototype);
    VideoTexture.prototype.constructor = VideoTexture;

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {

        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

        this.image = { width: width, height: height };
        this.mipmaps = mipmaps;

        // no flipping for cube textures
        // (also flipping doesn't work for compressed textures )

        this.flipY = false;

        // can't generate mipmaps for compressed textures
        // mips must be embedded in DDS files

        this.generateMipmaps = false;
    }

    CompressedTexture.prototype = Object.create(Texture.prototype);
    CompressedTexture.prototype.constructor = CompressedTexture;

    CompressedTexture.prototype.isCompressedTexture = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {

        Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);

        this.needsUpdate = true;
    }

    CanvasTexture.prototype = Object.create(Texture.prototype);
    CanvasTexture.prototype.constructor = CanvasTexture;

    /**
     * @author Matt DesLauriers / @mattdesl
     * @author atix / arthursilber.de
     */

    function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {

        format = format !== undefined ? format : DepthFormat;

        if (format !== DepthFormat && format !== DepthStencilFormat) {

            throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
        }

        if (type === undefined && format === DepthFormat) type = UnsignedShortType;
        if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;

        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);

        this.image = { width: width, height: height };

        this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
        this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

        this.flipY = false;
        this.generateMipmaps = false;
    }

    DepthTexture.prototype = Object.create(Texture.prototype);
    DepthTexture.prototype.constructor = DepthTexture;
    DepthTexture.prototype.isDepthTexture = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */

    function WireframeGeometry(geometry) {

        BufferGeometry.call(this);

        this.type = 'WireframeGeometry';

        // buffer

        var vertices = [];

        // helper variables

        var i, j, l, o, ol;
        var edge = [0, 0],
            edges = {},
            e,
            edge1,
            edge2;
        var key,
            keys = ['a', 'b', 'c'];
        var vertex;

        // different logic for Geometry and BufferGeometry

        if (geometry && geometry.isGeometry) {

            // create a data structure that contains all edges without duplicates

            var faces = geometry.faces;

            for (i = 0, l = faces.length; i < l; i++) {

                var face = faces[i];

                for (j = 0; j < 3; j++) {

                    edge1 = face[keys[j]];
                    edge2 = face[keys[(j + 1) % 3]];
                    edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
                    edge[1] = Math.max(edge1, edge2);

                    key = edge[0] + ',' + edge[1];

                    if (edges[key] === undefined) {

                        edges[key] = { index1: edge[0], index2: edge[1] };
                    }
                }
            }

            // generate vertices

            for (key in edges) {

                e = edges[key];

                vertex = geometry.vertices[e.index1];
                vertices.push(vertex.x, vertex.y, vertex.z);

                vertex = geometry.vertices[e.index2];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        } else if (geometry && geometry.isBufferGeometry) {

            var position, indices, groups;
            var group, start, count;
            var index1, index2;

            vertex = new Vector3();

            if (geometry.index !== null) {

                // indexed BufferGeometry

                position = geometry.attributes.position;
                indices = geometry.index;
                groups = geometry.groups;

                if (groups.length === 0) {

                    groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
                }

                // create a data structure that contains all eges without duplicates

                for (o = 0, ol = groups.length; o < ol; ++o) {

                    group = groups[o];

                    start = group.start;
                    count = group.count;

                    for (i = start, l = start + count; i < l; i += 3) {

                        for (j = 0; j < 3; j++) {

                            edge1 = indices.getX(i + j);
                            edge2 = indices.getX(i + (j + 1) % 3);
                            edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
                            edge[1] = Math.max(edge1, edge2);

                            key = edge[0] + ',' + edge[1];

                            if (edges[key] === undefined) {

                                edges[key] = { index1: edge[0], index2: edge[1] };
                            }
                        }
                    }
                }

                // generate vertices

                for (key in edges) {

                    e = edges[key];

                    vertex.fromBufferAttribute(position, e.index1);
                    vertices.push(vertex.x, vertex.y, vertex.z);

                    vertex.fromBufferAttribute(position, e.index2);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                }
            } else {

                // non-indexed BufferGeometry

                position = geometry.attributes.position;

                for (i = 0, l = position.count / 3; i < l; i++) {

                    for (j = 0; j < 3; j++) {

                        // three edges per triangle, an edge is represented as (index1, index2)
                        // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

                        index1 = 3 * i + j;
                        vertex.fromBufferAttribute(position, index1);
                        vertices.push(vertex.x, vertex.y, vertex.z);

                        index2 = 3 * i + (j + 1) % 3;
                        vertex.fromBufferAttribute(position, index2);
                        vertices.push(vertex.x, vertex.y, vertex.z);
                    }
                }
            }
        }

        // build geometry

        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
    }

    WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
    WireframeGeometry.prototype.constructor = WireframeGeometry;

    /**
     * @author zz85 / https://github.com/zz85
     * @author Mugen87 / https://github.com/Mugen87
     *
     * Parametric Surfaces Geometry
     * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
     */

    // ParametricGeometry

    function ParametricGeometry(func, slices, stacks) {

        Geometry.call(this);

        this.type = 'ParametricGeometry';

        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };

        this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
        this.mergeVertices();
    }

    ParametricGeometry.prototype = Object.create(Geometry.prototype);
    ParametricGeometry.prototype.constructor = ParametricGeometry;

    // ParametricBufferGeometry

    function ParametricBufferGeometry(func, slices, stacks) {

        BufferGeometry.call(this);

        this.type = 'ParametricBufferGeometry';

        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };

        // buffers

        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];

        var EPS = 0.00001;

        var normal = new Vector3();

        var p0 = new Vector3(),
            p1 = new Vector3();
        var pu = new Vector3(),
            pv = new Vector3();

        var i, j;

        // generate vertices, normals and uvs

        var sliceCount = slices + 1;

        for (i = 0; i <= stacks; i++) {

            var v = i / stacks;

            for (j = 0; j <= slices; j++) {

                var u = j / slices;

                // vertex

                p0 = func(u, v, p0);
                vertices.push(p0.x, p0.y, p0.z);

                // normal

                // approximate tangent vectors via finite differences

                if (u - EPS >= 0) {

                    p1 = func(u - EPS, v, p1);
                    pu.subVectors(p0, p1);
                } else {

                    p1 = func(u + EPS, v, p1);
                    pu.subVectors(p1, p0);
                }

                if (v - EPS >= 0) {

                    p1 = func(u, v - EPS, p1);
                    pv.subVectors(p0, p1);
                } else {

                    p1 = func(u, v + EPS, p1);
                    pv.subVectors(p1, p0);
                }

                // cross product of tangent vectors returns surface normal

                normal.crossVectors(pu, pv).normalize();
                normals.push(normal.x, normal.y, normal.z);

                // uv

                uvs.push(u, v);
            }
        }

        // generate indices

        for (i = 0; i < stacks; i++) {

            for (j = 0; j < slices; j++) {

                var a = i * sliceCount + j;
                var b = i * sliceCount + j + 1;
                var c = (i + 1) * sliceCount + j + 1;
                var d = (i + 1) * sliceCount + j;

                // faces one and two

                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }

        // build geometry

        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }

    ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

    /**
     * @author clockworkgeek / https://github.com/clockworkgeek
     * @author timothypratley / https://github.com/timothypratley
     * @author WestLangley / http://github.com/WestLangley
     * @author Mugen87 / https://github.com/Mugen87
     */

    // PolyhedronGeometry

    function PolyhedronGeometry(vertices, indices, radius, detail) {

        Geometry.call(this);

        this.type = 'PolyhedronGeometry';

        this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        };

        this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
        this.mergeVertices();
    }

    PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
    PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

    // PolyhedronBufferGeometry

    function PolyhedronBufferGeometry(vertices, indices, radius, detail) {

        BufferGeometry.call(this);

        this.type = 'PolyhedronBufferGeometry';

        this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        };

        radius = radius || 1;
        detail = detail || 0;

        // default buffer data

        var vertexBuffer = [];
        var uvBuffer = [];

        // the subdivision creates the vertex buffer data

        subdivide(detail);

        // all vertices should lie on a conceptual sphere with a given radius

        appplyRadius(radius);

        // finally, create the uv data

        generateUVs();

        // build non-indexed geometry

        this.addAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
        this.addAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
        this.normalizeNormals();

        // helper functions

        function subdivide(detail) {

            var a = new Vector3();
            var b = new Vector3();
            var c = new Vector3();

            // iterate over all faces and apply a subdivison with the given detail value

            for (var i = 0; i < indices.length; i += 3) {

                // get the vertices of the face

                getVertexByIndex(indices[i + 0], a);
                getVertexByIndex(indices[i + 1], b);
                getVertexByIndex(indices[i + 2], c);

                // perform subdivision

                subdivideFace(a, b, c, detail);
            }
        }

        function subdivideFace(a, b, c, detail) {

            var cols = Math.pow(2, detail);

            // we use this multidimensional array as a data structure for creating the subdivision

            var v = [];

            var i, j;

            // construct all of the vertices for this subdivision

            for (i = 0; i <= cols; i++) {

                v[i] = [];

                var aj = a.clone().lerp(c, i / cols);
                var bj = b.clone().lerp(c, i / cols);

                var rows = cols - i;

                for (j = 0; j <= rows; j++) {

                    if (j === 0 && i === cols) {

                        v[i][j] = aj;
                    } else {

                        v[i][j] = aj.clone().lerp(bj, j / rows);
                    }
                }
            }

            // construct all of the faces

            for (i = 0; i < cols; i++) {

                for (j = 0; j < 2 * (cols - i) - 1; j++) {

                    var k = Math.floor(j / 2);

                    if (j % 2 === 0) {

                        pushVertex(v[i][k + 1]);
                        pushVertex(v[i + 1][k]);
                        pushVertex(v[i][k]);
                    } else {

                        pushVertex(v[i][k + 1]);
                        pushVertex(v[i + 1][k + 1]);
                        pushVertex(v[i + 1][k]);
                    }
                }
            }
        }

        function appplyRadius(radius) {

            var vertex = new Vector3();

            // iterate over the entire buffer and apply the radius to each vertex

            for (var i = 0; i < vertexBuffer.length; i += 3) {

                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];

                vertex.normalize().multiplyScalar(radius);

                vertexBuffer[i + 0] = vertex.x;
                vertexBuffer[i + 1] = vertex.y;
                vertexBuffer[i + 2] = vertex.z;
            }
        }

        function generateUVs() {

            var vertex = new Vector3();

            for (var i = 0; i < vertexBuffer.length; i += 3) {

                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];

                var u = azimuth(vertex) / 2 / Math.PI + 0.5;
                var v = inclination(vertex) / Math.PI + 0.5;
                uvBuffer.push(u, 1 - v);
            }

            correctUVs();

            correctSeam();
        }

        function correctSeam() {

            // handle case when face straddles the seam, see #3269

            for (var i = 0; i < uvBuffer.length; i += 6) {

                // uv data of a single face

                var x0 = uvBuffer[i + 0];
                var x1 = uvBuffer[i + 2];
                var x2 = uvBuffer[i + 4];

                var max = Math.max(x0, x1, x2);
                var min = Math.min(x0, x1, x2);

                // 0.9 is somewhat arbitrary

                if (max > 0.9 && min < 0.1) {

                    if (x0 < 0.2) uvBuffer[i + 0] += 1;
                    if (x1 < 0.2) uvBuffer[i + 2] += 1;
                    if (x2 < 0.2) uvBuffer[i + 4] += 1;
                }
            }
        }

        function pushVertex(vertex) {

            vertexBuffer.push(vertex.x, vertex.y, vertex.z);
        }

        function getVertexByIndex(index, vertex) {

            var stride = index * 3;

            vertex.x = vertices[stride + 0];
            vertex.y = vertices[stride + 1];
            vertex.z = vertices[stride + 2];
        }

        function correctUVs() {

            var a = new Vector3();
            var b = new Vector3();
            var c = new Vector3();

            var centroid = new Vector3();

            var uvA = new Vector2();
            var uvB = new Vector2();
            var uvC = new Vector2();

            for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {

                a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
                b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
                c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);

                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);

                centroid.copy(a).add(b).add(c).divideScalar(3);

                var azi = azimuth(centroid);

                correctUV(uvA, j + 0, a, azi);
                correctUV(uvB, j + 2, b, azi);
                correctUV(uvC, j + 4, c, azi);
            }
        }

        function correctUV(uv, stride, vector, azimuth) {

            if (azimuth < 0 && uv.x === 1) {

                uvBuffer[stride] = uv.x - 1;
            }

            if (vector.x === 0 && vector.z === 0) {

                uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
            }
        }

        // Angle around the Y axis, counter-clockwise when looking from above.

        function azimuth(vector) {

            return Math.atan2(vector.z, -vector.x);
        }

        // Angle above the XZ plane.

        function inclination(vector) {

            return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
        }
    }

    PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

    /**
     * @author timothypratley / https://github.com/timothypratley
     * @author Mugen87 / https://github.com/Mugen87
     */

    // TetrahedronGeometry

    function TetrahedronGeometry(radius, detail) {

        Geometry.call(this);

        this.type = 'TetrahedronGeometry';

        this.parameters = {
            radius: radius,
            detail: detail
        };

        this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }

    TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
    TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

    // TetrahedronBufferGeometry

    function TetrahedronBufferGeometry(radius, detail) {

        var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];

        var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];

        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);

        this.type = 'TetrahedronBufferGeometry';

        this.parameters = {
            radius: radius,
            detail: detail
        };
    }

    TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

    /**
     * @author timothypratley / https://github.com/timothypratley
     * @author Mugen87 / https://github.com/Mugen87
     */

    // OctahedronGeometry

    function OctahedronGeometry(radius, detail) {

        Geometry.call(this);

        this.type = 'OctahedronGeometry';

        this.parameters = {
            radius: radius,
            detail: detail
        };

        this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }

    OctahedronGeometry.prototype = Object.create(Geometry.prototype);
    OctahedronGeometry.prototype.constructor = OctahedronGeometry;

    // OctahedronBufferGeometry

    function OctahedronBufferGeometry(radius, detail) {

        var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];

        var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];

        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);

        this.type = 'OctahedronBufferGeometry';

        this.parameters = {
            radius: radius,
            detail: detail
        };
    }

    OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

    /**
     * @author timothypratley / https://github.com/timothypratley
     * @author Mugen87 / https://github.com/Mugen87
     */

    // IcosahedronGeometry

    function IcosahedronGeometry(radius, detail) {

        Geometry.call(this);

        this.type = 'IcosahedronGeometry';

        this.parameters = {
            radius: radius,
            detail: detail
        };

        this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }

    IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
    IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

    // IcosahedronBufferGeometry

    function IcosahedronBufferGeometry(radius, detail) {

        var t = (1 + Math.sqrt(5)) / 2;

        var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];

        var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];

        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);

        this.type = 'IcosahedronBufferGeometry';

        this.parameters = {
            radius: radius,
            detail: detail
        };
    }

    IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

    /**
     * @author Abe Pazos / https://hamoid.com
     * @author Mugen87 / https://github.com/Mugen87
     */

    // DodecahedronGeometry

    function DodecahedronGeometry(radius, detail) {

        Geometry.call(this);

        this.type = 'DodecahedronGeometry';

        this.parameters = {
            radius: radius,
            detail: detail
        };

        this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }

    DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
    DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

    // DodecahedronBufferGeometry

    function DodecahedronBufferGeometry(radius, detail) {

        var t = (1 + Math.sqrt(5)) / 2;
        var r = 1 / t;

        var vertices = [

        // (±1, ±1, ±1)
        -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1,

        // (0, ±1/φ, ±φ)
        0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t,

        // (±1/φ, ±φ, 0)
        -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0,

        // (±φ, 0, ±1/φ)
        -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];

        var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];

        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);

        this.type = 'DodecahedronBufferGeometry';

        this.parameters = {
            radius: radius,
            detail: detail
        };
    }

    DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

    /**
     * @author oosmoxiecode / https://github.com/oosmoxiecode
     * @author WestLangley / https://github.com/WestLangley
     * @author zz85 / https://github.com/zz85
     * @author miningold / https://github.com/miningold
     * @author jonobr1 / https://github.com/jonobr1
     * @author Mugen87 / https://github.com/Mugen87
     *
     */

    // TubeGeometry

    function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {

        Geometry.call(this);

        this.type = 'TubeGeometry';

        this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        };

        if (taper !== undefined) console.warn('THREE.TubeGeometry: taper has been removed.');

        var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);

        // expose internals

        this.tangents = bufferGeometry.tangents;
        this.normals = bufferGeometry.normals;
        this.binormals = bufferGeometry.binormals;

        // create geometry

        this.fromBufferGeometry(bufferGeometry);
        this.mergeVertices();
    }

    TubeGeometry.prototype = Object.create(Geometry.prototype);
    TubeGeometry.prototype.constructor = TubeGeometry;

    // TubeBufferGeometry

    function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {

        BufferGeometry.call(this);

        this.type = 'TubeBufferGeometry';

        this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        };

        tubularSegments = tubularSegments || 64;
        radius = radius || 1;
        radialSegments = radialSegments || 8;
        closed = closed || false;

        var frames = path.computeFrenetFrames(tubularSegments, closed);

        // expose internals

        this.tangents = frames.tangents;
        this.normals = frames.normals;
        this.binormals = frames.binormals;

        // helper variables

        var vertex = new Vector3();
        var normal = new Vector3();
        var uv = new Vector2();

        var i, j;

        // buffer

        var vertices = [];
        var normals = [];
        var uvs = [];
        var indices = [];

        // create buffer data

        generateBufferData();

        // build geometry

        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

        // functions

        function generateBufferData() {

            for (i = 0; i < tubularSegments; i++) {

                generateSegment(i);
            }

            // if the geometry is not closed, generate the last row of vertices and normals
            // at the regular position on the given path
            //
            // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

            generateSegment(closed === false ? tubularSegments : 0);

            // uvs are generated in a separate function.
            // this makes it easy compute correct values for closed geometries

            generateUVs();

            // finally create faces

            generateIndices();
        }

        function generateSegment(i) {

            // we use getPointAt to sample evenly distributed points from the given path

            var P = path.getPointAt(i / tubularSegments);

            // retrieve corresponding normal and binormal

            var N = frames.normals[i];
            var B = frames.binormals[i];

            // generate normals and vertices for the current segment

            for (j = 0; j <= radialSegments; j++) {

                var v = j / radialSegments * Math.PI * 2;

                var sin = Math.sin(v);
                var cos = -Math.cos(v);

                // normal

                normal.x = cos * N.x + sin * B.x;
                normal.y = cos * N.y + sin * B.y;
                normal.z = cos * N.z + sin * B.z;
                normal.normalize();

                normals.push(normal.x, normal.y, normal.z);

                // vertex

                vertex.x = P.x + radius * normal.x;
                vertex.y = P.y + radius * normal.y;
                vertex.z = P.z + radius * normal.z;

                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }

        function generateIndices() {

            for (j = 1; j <= tubularSegments; j++) {

                for (i = 1; i <= radialSegments; i++) {

                    var a = (radialSegments + 1) * (j - 1) + (i - 1);
                    var b = (radialSegments + 1) * j + (i - 1);
                    var c = (radialSegments + 1) * j + i;
                    var d = (radialSegments + 1) * (j - 1) + i;

                    // faces

                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
        }

        function generateUVs() {

            for (i = 0; i <= tubularSegments; i++) {

                for (j = 0; j <= radialSegments; j++) {

                    uv.x = i / tubularSegments;
                    uv.y = j / radialSegments;

                    uvs.push(uv.x, uv.y);
                }
            }
        }
    }

    TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

    /**
     * @author oosmoxiecode
     * @author Mugen87 / https://github.com/Mugen87
     *
     * based on http://www.blackpawn.com/texts/pqtorus/
     */

    // TorusKnotGeometry

    function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {

        Geometry.call(this);

        this.type = 'TorusKnotGeometry';

        this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        };

        if (heightScale !== undefined) console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');

        this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
        this.mergeVertices();
    }

    TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
    TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

    // TorusKnotBufferGeometry

    function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {

        BufferGeometry.call(this);

        this.type = 'TorusKnotBufferGeometry';

        this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        };

        radius = radius || 100;
        tube = tube || 40;
        tubularSegments = Math.floor(tubularSegments) || 64;
        radialSegments = Math.floor(radialSegments) || 8;
        p = p || 2;
        q = q || 3;

        // buffers

        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];

        // helper variables

        var i, j;

        var vertex = new Vector3();
        var normal = new Vector3();

        var P1 = new Vector3();
        var P2 = new Vector3();

        var B = new Vector3();
        var T = new Vector3();
        var N = new Vector3();

        // generate vertices, normals and uvs

        for (i = 0; i <= tubularSegments; ++i) {

            // the radian "u" is used to calculate the position on the torus curve of the current tubular segement

            var u = i / tubularSegments * p * Math.PI * 2;

            // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
            // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

            calculatePositionOnCurve(u, p, q, radius, P1);
            calculatePositionOnCurve(u + 0.01, p, q, radius, P2);

            // calculate orthonormal basis

            T.subVectors(P2, P1);
            N.addVectors(P2, P1);
            B.crossVectors(T, N);
            N.crossVectors(B, T);

            // normalize B, N. T can be ignored, we don't use it

            B.normalize();
            N.normalize();

            for (j = 0; j <= radialSegments; ++j) {

                // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
                // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

                var v = j / radialSegments * Math.PI * 2;
                var cx = -tube * Math.cos(v);
                var cy = tube * Math.sin(v);

                // now calculate the final vertex position.
                // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

                vertex.x = P1.x + (cx * N.x + cy * B.x);
                vertex.y = P1.y + (cx * N.y + cy * B.y);
                vertex.z = P1.z + (cx * N.z + cy * B.z);

                vertices.push(vertex.x, vertex.y, vertex.z);

                // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

                normal.subVectors(vertex, P1).normalize();

                normals.push(normal.x, normal.y, normal.z);

                // uv

                uvs.push(i / tubularSegments);
                uvs.push(j / radialSegments);
            }
        }

        // generate indices

        for (j = 1; j <= tubularSegments; j++) {

            for (i = 1; i <= radialSegments; i++) {

                // indices

                var a = (radialSegments + 1) * (j - 1) + (i - 1);
                var b = (radialSegments + 1) * j + (i - 1);
                var c = (radialSegments + 1) * j + i;
                var d = (radialSegments + 1) * (j - 1) + i;

                // faces

                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }

        // build geometry

        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

        // this function calculates the current position on the torus curve

        function calculatePositionOnCurve(u, p, q, radius, position) {

            var cu = Math.cos(u);
            var su = Math.sin(u);
            var quOverP = q / p * u;
            var cs = Math.cos(quOverP);

            position.x = radius * (2 + cs) * 0.5 * cu;
            position.y = radius * (2 + cs) * su * 0.5;
            position.z = radius * Math.sin(quOverP) * 0.5;
        }
    }

    TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

    /**
     * @author oosmoxiecode
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */

    // TorusGeometry

    function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {

        Geometry.call(this);

        this.type = 'TorusGeometry';

        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };

        this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
        this.mergeVertices();
    }

    TorusGeometry.prototype = Object.create(Geometry.prototype);
    TorusGeometry.prototype.constructor = TorusGeometry;

    // TorusBufferGeometry

    function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {

        BufferGeometry.call(this);

        this.type = 'TorusBufferGeometry';

        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };

        radius = radius || 100;
        tube = tube || 40;
        radialSegments = Math.floor(radialSegments) || 8;
        tubularSegments = Math.floor(tubularSegments) || 6;
        arc = arc || Math.PI * 2;

        // buffers

        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];

        // helper variables

        var center = new Vector3();
        var vertex = new Vector3();
        var normal = new Vector3();

        var j, i;

        // generate vertices, normals and uvs

        for (j = 0; j <= radialSegments; j++) {

            for (i = 0; i <= tubularSegments; i++) {

                var u = i / tubularSegments * arc;
                var v = j / radialSegments * Math.PI * 2;

                // vertex

                vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                vertex.z = tube * Math.sin(v);

                vertices.push(vertex.x, vertex.y, vertex.z);

                // normal

                center.x = radius * Math.cos(u);
                center.y = radius * Math.sin(u);
                normal.subVectors(vertex, center).normalize();

                normals.push(normal.x, normal.y, normal.z);

                // uv

                uvs.push(i / tubularSegments);
                uvs.push(j / radialSegments);
            }
        }

        // generate indices

        for (j = 1; j <= radialSegments; j++) {

            for (i = 1; i <= tubularSegments; i++) {

                // indices

                var a = (tubularSegments + 1) * j + i - 1;
                var b = (tubularSegments + 1) * (j - 1) + i - 1;
                var c = (tubularSegments + 1) * (j - 1) + i;
                var d = (tubularSegments + 1) * j + i;

                // faces

                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }

        // build geometry

        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }

    TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */

    var ShapeUtils = {

        // calculate area of the contour polygon

        area: function area(contour) {

            var n = contour.length;
            var a = 0.0;

            for (var p = n - 1, q = 0; q < n; p = q++) {

                a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
            }

            return a * 0.5;
        },

        triangulate: function () {

            /**
             * This code is a quick port of code written in C++ which was submitted to
             * flipcode.com by John W. Ratcliff  // July 22, 2000
             * See original code and more information here:
             * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
             *
             * ported to actionscript by Zevan Rosser
             * www.actionsnippet.com
             *
             * ported to javascript by Joshua Koo
             * http://www.lab4games.net/zz85/blog
             *
             */

            function snip(contour, u, v, w, n, verts) {

                var p;
                var ax, ay, bx, by;
                var cx, cy, px, py;

                ax = contour[verts[u]].x;
                ay = contour[verts[u]].y;

                bx = contour[verts[v]].x;
                by = contour[verts[v]].y;

                cx = contour[verts[w]].x;
                cy = contour[verts[w]].y;

                if ((bx - ax) * (cy - ay) - (by - ay) * (cx - ax) <= 0) return false;

                var aX, aY, bX, bY, cX, cY;
                var apx, apy, bpx, bpy, cpx, cpy;
                var cCROSSap, bCROSScp, aCROSSbp;

                aX = cx - bx;aY = cy - by;
                bX = ax - cx;bY = ay - cy;
                cX = bx - ax;cY = by - ay;

                for (p = 0; p < n; p++) {

                    px = contour[verts[p]].x;
                    py = contour[verts[p]].y;

                    if (px === ax && py === ay || px === bx && py === by || px === cx && py === cy) continue;

                    apx = px - ax;apy = py - ay;
                    bpx = px - bx;bpy = py - by;
                    cpx = px - cx;cpy = py - cy;

                    // see if p is inside triangle abc

                    aCROSSbp = aX * bpy - aY * bpx;
                    cCROSSap = cX * apy - cY * apx;
                    bCROSScp = bX * cpy - bY * cpx;

                    if (aCROSSbp >= -Number.EPSILON && bCROSScp >= -Number.EPSILON && cCROSSap >= -Number.EPSILON) return false;
                }

                return true;
            }

            // takes in an contour array and returns

            return function triangulate(contour, indices) {

                var n = contour.length;

                if (n < 3) return null;

                var result = [],
                    verts = [],
                    vertIndices = [];

                /* we want a counter-clockwise polygon in verts */

                var u, v, w;

                if (ShapeUtils.area(contour) > 0.0) {

                    for (v = 0; v < n; v++) {
                        verts[v] = v;
                    }
                } else {

                    for (v = 0; v < n; v++) {
                        verts[v] = n - 1 - v;
                    }
                }

                var nv = n;

                /*  remove nv - 2 vertices, creating 1 triangle every time */

                var count = 2 * nv; /* error detection */

                for (v = nv - 1; nv > 2;) {

                    /* if we loop, it is probably a non-simple polygon */

                    if (count-- <= 0) {

                        //** Triangulate: ERROR - probable bad polygon!

                        //throw ( "Warning, unable to triangulate polygon!" );
                        //return null;
                        // Sometimes warning is fine, especially polygons are triangulated in reverse.
                        console.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');

                        if (indices) return vertIndices;
                        return result;
                    }

                    /* three consecutive vertices in current polygon, <u,v,w> */

                    u = v;if (nv <= u) u = 0; /* previous */
                    v = u + 1;if (nv <= v) v = 0; /* new v    */
                    w = v + 1;if (nv <= w) w = 0; /* next     */

                    if (snip(contour, u, v, w, nv, verts)) {

                        var a, b, c, s, t;

                        /* true names of the vertices */

                        a = verts[u];
                        b = verts[v];
                        c = verts[w];

                        /* output Triangle */

                        result.push([contour[a], contour[b], contour[c]]);

                        vertIndices.push([verts[u], verts[v], verts[w]]);

                        /* remove v from the remaining polygon */

                        for (s = v, t = v + 1; t < nv; s++, t++) {

                            verts[s] = verts[t];
                        }

                        nv--;

                        /* reset error detection counter */

                        count = 2 * nv;
                    }
                }

                if (indices) return vertIndices;
                return result;
            };
        }(),

        triangulateShape: function triangulateShape(contour, holes) {

            function removeDupEndPts(points) {

                var l = points.length;

                if (l > 2 && points[l - 1].equals(points[0])) {

                    points.pop();
                }
            }

            removeDupEndPts(contour);
            holes.forEach(removeDupEndPts);

            function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {

                // inOtherPt needs to be collinear to the inSegment
                if (inSegPt1.x !== inSegPt2.x) {

                    if (inSegPt1.x < inSegPt2.x) {

                        return inSegPt1.x <= inOtherPt.x && inOtherPt.x <= inSegPt2.x;
                    } else {

                        return inSegPt2.x <= inOtherPt.x && inOtherPt.x <= inSegPt1.x;
                    }
                } else {

                    if (inSegPt1.y < inSegPt2.y) {

                        return inSegPt1.y <= inOtherPt.y && inOtherPt.y <= inSegPt2.y;
                    } else {

                        return inSegPt2.y <= inOtherPt.y && inOtherPt.y <= inSegPt1.y;
                    }
                }
            }

            function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {

                var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,
                    seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
                var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,
                    seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

                var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
                var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

                var limit = seg1dy * seg2dx - seg1dx * seg2dy;
                var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

                if (Math.abs(limit) > Number.EPSILON) {

                    // not parallel

                    var perpSeg2;
                    if (limit > 0) {

                        if (perpSeg1 < 0 || perpSeg1 > limit) return [];
                        perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                        if (perpSeg2 < 0 || perpSeg2 > limit) return [];
                    } else {

                        if (perpSeg1 > 0 || perpSeg1 < limit) return [];
                        perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
                        if (perpSeg2 > 0 || perpSeg2 < limit) return [];
                    }

                    // i.e. to reduce rounding errors
                    // intersection at endpoint of segment#1?
                    if (perpSeg2 === 0) {

                        if (inExcludeAdjacentSegs && (perpSeg1 === 0 || perpSeg1 === limit)) return [];
                        return [inSeg1Pt1];
                    }
                    if (perpSeg2 === limit) {

                        if (inExcludeAdjacentSegs && (perpSeg1 === 0 || perpSeg1 === limit)) return [];
                        return [inSeg1Pt2];
                    }
                    // intersection at endpoint of segment#2?
                    if (perpSeg1 === 0) return [inSeg2Pt1];
                    if (perpSeg1 === limit) return [inSeg2Pt2];

                    // return real intersection point
                    var factorSeg1 = perpSeg2 / limit;
                    return [{ x: inSeg1Pt1.x + factorSeg1 * seg1dx,
                        y: inSeg1Pt1.y + factorSeg1 * seg1dy }];
                } else {

                    // parallel or collinear
                    if (perpSeg1 !== 0 || seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy) return [];

                    // they are collinear or degenerate
                    var seg1Pt = seg1dx === 0 && seg1dy === 0; // segment1 is just a point?
                    var seg2Pt = seg2dx === 0 && seg2dy === 0; // segment2 is just a point?
                    // both segments are points
                    if (seg1Pt && seg2Pt) {

                        if (inSeg1Pt1.x !== inSeg2Pt1.x || inSeg1Pt1.y !== inSeg2Pt1.y) return []; // they are distinct  points
                        return [inSeg1Pt1]; // they are the same point
                    }
                    // segment#1  is a single point
                    if (seg1Pt) {

                        if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1)) return []; // but not in segment#2
                        return [inSeg1Pt1];
                    }
                    // segment#2  is a single point
                    if (seg2Pt) {

                        if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1)) return []; // but not in segment#1
                        return [inSeg2Pt1];
                    }

                    // they are collinear segments, which might overlap
                    var seg1min, seg1max, seg1minVal, seg1maxVal;
                    var seg2min, seg2max, seg2minVal, seg2maxVal;
                    if (seg1dx !== 0) {

                        // the segments are NOT on a vertical line
                        if (inSeg1Pt1.x < inSeg1Pt2.x) {

                            seg1min = inSeg1Pt1;seg1minVal = inSeg1Pt1.x;
                            seg1max = inSeg1Pt2;seg1maxVal = inSeg1Pt2.x;
                        } else {

                            seg1min = inSeg1Pt2;seg1minVal = inSeg1Pt2.x;
                            seg1max = inSeg1Pt1;seg1maxVal = inSeg1Pt1.x;
                        }
                        if (inSeg2Pt1.x < inSeg2Pt2.x) {

                            seg2min = inSeg2Pt1;seg2minVal = inSeg2Pt1.x;
                            seg2max = inSeg2Pt2;seg2maxVal = inSeg2Pt2.x;
                        } else {

                            seg2min = inSeg2Pt2;seg2minVal = inSeg2Pt2.x;
                            seg2max = inSeg2Pt1;seg2maxVal = inSeg2Pt1.x;
                        }
                    } else {

                        // the segments are on a vertical line
                        if (inSeg1Pt1.y < inSeg1Pt2.y) {

                            seg1min = inSeg1Pt1;seg1minVal = inSeg1Pt1.y;
                            seg1max = inSeg1Pt2;seg1maxVal = inSeg1Pt2.y;
                        } else {

                            seg1min = inSeg1Pt2;seg1minVal = inSeg1Pt2.y;
                            seg1max = inSeg1Pt1;seg1maxVal = inSeg1Pt1.y;
                        }
                        if (inSeg2Pt1.y < inSeg2Pt2.y) {

                            seg2min = inSeg2Pt1;seg2minVal = inSeg2Pt1.y;
                            seg2max = inSeg2Pt2;seg2maxVal = inSeg2Pt2.y;
                        } else {

                            seg2min = inSeg2Pt2;seg2minVal = inSeg2Pt2.y;
                            seg2max = inSeg2Pt1;seg2maxVal = inSeg2Pt1.y;
                        }
                    }
                    if (seg1minVal <= seg2minVal) {

                        if (seg1maxVal < seg2minVal) return [];
                        if (seg1maxVal === seg2minVal) {

                            if (inExcludeAdjacentSegs) return [];
                            return [seg2min];
                        }
                        if (seg1maxVal <= seg2maxVal) return [seg2min, seg1max];
                        return [seg2min, seg2max];
                    } else {

                        if (seg1minVal > seg2maxVal) return [];
                        if (seg1minVal === seg2maxVal) {

                            if (inExcludeAdjacentSegs) return [];
                            return [seg1min];
                        }
                        if (seg1maxVal <= seg2maxVal) return [seg1min, seg1max];
                        return [seg1min, seg2max];
                    }
                }
            }

            function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {

                // The order of legs is important

                // translation of all points, so that Vertex is at (0,0)
                var legFromPtX = inLegFromPt.x - inVertex.x,
                    legFromPtY = inLegFromPt.y - inVertex.y;
                var legToPtX = inLegToPt.x - inVertex.x,
                    legToPtY = inLegToPt.y - inVertex.y;
                var otherPtX = inOtherPt.x - inVertex.x,
                    otherPtY = inOtherPt.y - inVertex.y;

                // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
                var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
                var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;

                if (Math.abs(from2toAngle) > Number.EPSILON) {

                    // angle != 180 deg.

                    var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
                    // console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

                    if (from2toAngle > 0) {

                        // main angle < 180 deg.
                        return from2otherAngle >= 0 && other2toAngle >= 0;
                    } else {

                        // main angle > 180 deg.
                        return from2otherAngle >= 0 || other2toAngle >= 0;
                    }
                } else {

                    // angle == 180 deg.
                    // console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
                    return from2otherAngle > 0;
                }
            }

            function removeHoles(contour, holes) {

                var shape = contour.concat(); // work on this shape
                var hole;

                function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {

                    // Check if hole point lies within angle around shape point
                    var lastShapeIdx = shape.length - 1;

                    var prevShapeIdx = inShapeIdx - 1;
                    if (prevShapeIdx < 0) prevShapeIdx = lastShapeIdx;

                    var nextShapeIdx = inShapeIdx + 1;
                    if (nextShapeIdx > lastShapeIdx) nextShapeIdx = 0;

                    var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
                    if (!insideAngle) {

                        // console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
                        return false;
                    }

                    // Check if shape point lies within angle around hole point
                    var lastHoleIdx = hole.length - 1;

                    var prevHoleIdx = inHoleIdx - 1;
                    if (prevHoleIdx < 0) prevHoleIdx = lastHoleIdx;

                    var nextHoleIdx = inHoleIdx + 1;
                    if (nextHoleIdx > lastHoleIdx) nextHoleIdx = 0;

                    insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
                    if (!insideAngle) {

                        // console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
                        return false;
                    }

                    return true;
                }

                function intersectsShapeEdge(inShapePt, inHolePt) {

                    // checks for intersections with shape edges
                    var sIdx, nextIdx, intersection;
                    for (sIdx = 0; sIdx < shape.length; sIdx++) {

                        nextIdx = sIdx + 1;nextIdx %= shape.length;
                        intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
                        if (intersection.length > 0) return true;
                    }

                    return false;
                }

                var indepHoles = [];

                function intersectsHoleEdge(inShapePt, inHolePt) {

                    // checks for intersections with hole edges
                    var ihIdx, chkHole, hIdx, nextIdx, intersection;
                    for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {

                        chkHole = holes[indepHoles[ihIdx]];
                        for (hIdx = 0; hIdx < chkHole.length; hIdx++) {

                            nextIdx = hIdx + 1;nextIdx %= chkHole.length;
                            intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
                            if (intersection.length > 0) return true;
                        }
                    }
                    return false;
                }

                var holeIndex,
                    shapeIndex,
                    shapePt,
                    holePt,
                    holeIdx,
                    cutKey,
                    failedCuts = [],
                    tmpShape1,
                    tmpShape2,
                    tmpHole1,
                    tmpHole2;

                for (var h = 0, hl = holes.length; h < hl; h++) {

                    indepHoles.push(h);
                }

                var minShapeIndex = 0;
                var counter = indepHoles.length * 2;
                while (indepHoles.length > 0) {

                    counter--;
                    if (counter < 0) {

                        console.log("Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!");
                        break;
                    }

                    // search for shape-vertex and hole-vertex,
                    // which can be connected without intersections
                    for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {

                        shapePt = shape[shapeIndex];
                        holeIndex = -1;

                        // search for hole which can be reached without intersections
                        for (var h = 0; h < indepHoles.length; h++) {

                            holeIdx = indepHoles[h];

                            // prevent multiple checks
                            cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
                            if (failedCuts[cutKey] !== undefined) continue;

                            hole = holes[holeIdx];
                            for (var h2 = 0; h2 < hole.length; h2++) {

                                holePt = hole[h2];
                                if (!isCutLineInsideAngles(shapeIndex, h2)) continue;
                                if (intersectsShapeEdge(shapePt, holePt)) continue;
                                if (intersectsHoleEdge(shapePt, holePt)) continue;

                                holeIndex = h2;
                                indepHoles.splice(h, 1);

                                tmpShape1 = shape.slice(0, shapeIndex + 1);
                                tmpShape2 = shape.slice(shapeIndex);
                                tmpHole1 = hole.slice(holeIndex);
                                tmpHole2 = hole.slice(0, holeIndex + 1);

                                shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);

                                minShapeIndex = shapeIndex;

                                // Debug only, to show the selected cuts
                                // glob_CutLines.push( [ shapePt, holePt ] );

                                break;
                            }
                            if (holeIndex >= 0) break; // hole-vertex found

                            failedCuts[cutKey] = true; // remember failure
                        }
                        if (holeIndex >= 0) break; // hole-vertex found
                    }
                }

                return shape; /* shape with no holes */
            }

            var i,
                il,
                f,
                face,
                key,
                index,
                allPointsMap = {};

            // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

            var allpoints = contour.concat();

            for (var h = 0, hl = holes.length; h < hl; h++) {

                Array.prototype.push.apply(allpoints, holes[h]);
            }

            //console.log( "allpoints",allpoints, allpoints.length );

            // prepare all points map

            for (i = 0, il = allpoints.length; i < il; i++) {

                key = allpoints[i].x + ":" + allpoints[i].y;

                if (allPointsMap[key] !== undefined) {

                    console.warn("THREE.ShapeUtils: Duplicate point", key, i);
                }

                allPointsMap[key] = i;
            }

            // remove holes by cutting paths to holes and adding them to the shape
            var shapeWithoutHoles = removeHoles(contour, holes);

            var triangles = ShapeUtils.triangulate(shapeWithoutHoles, false); // True returns indices for points of spooled shape
            //console.log( "triangles",triangles, triangles.length );

            // check all face vertices against all points map

            for (i = 0, il = triangles.length; i < il; i++) {

                face = triangles[i];

                for (f = 0; f < 3; f++) {

                    key = face[f].x + ":" + face[f].y;

                    index = allPointsMap[key];

                    if (index !== undefined) {

                        face[f] = index;
                    }
                }
            }

            return triangles.concat();
        },

        isClockWise: function isClockWise(pts) {

            return ShapeUtils.area(pts) < 0;
        }

    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     * Creates extruded geometry from a path shape.
     *
     * parameters = {
     *
     *  curveSegments: <int>, // number of points on the curves
     *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
     *  amount: <int>, // Depth to extrude the shape
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into the original shape bevel goes
     *  bevelSize: <float>, // how far from shape outline is bevel
     *  bevelSegments: <int>, // number of bevel layers
     *
     *  extrudePath: <THREE.Curve> // curve to extrude shape along
     *  frames: <Object> // containing arrays of tangents, normals, binormals
     *
     *  UVGenerator: <Object> // object that provides UV generator functions
     *
     * }
     */

    // ExtrudeGeometry

    function ExtrudeGeometry(shapes, options) {

        Geometry.call(this);

        this.type = 'ExtrudeGeometry';

        this.parameters = {
            shapes: shapes,
            options: options
        };

        this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
        this.mergeVertices();
    }

    ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
    ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

    // ExtrudeBufferGeometry

    function ExtrudeBufferGeometry(shapes, options) {

        if (typeof shapes === "undefined") {

            shapes = [];
            return;
        }

        BufferGeometry.call(this);

        this.type = 'ExtrudeBufferGeometry';

        shapes = Array.isArray(shapes) ? shapes : [shapes];

        this.addShapeList(shapes, options);

        this.computeVertexNormals();

        // can't really use automatic vertex normals
        // as then front and back sides get smoothed too
        // should do separate smoothing just for sides

        //this.computeVertexNormals();

        //console.log( "took", ( Date.now() - startTime ) );
    }

    ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

    ExtrudeBufferGeometry.prototype.getArrays = function () {

        var positionAttribute = this.getAttribute("position");
        var verticesArray = positionAttribute ? Array.prototype.slice.call(positionAttribute.array) : [];

        var uvAttribute = this.getAttribute("uv");
        var uvArray = uvAttribute ? Array.prototype.slice.call(uvAttribute.array) : [];

        var IndexAttribute = this.index;
        var indicesArray = IndexAttribute ? Array.prototype.slice.call(IndexAttribute.array) : [];

        return {
            position: verticesArray,
            uv: uvArray,
            index: indicesArray
        };
    };

    ExtrudeBufferGeometry.prototype.addShapeList = function (shapes, options) {

        var sl = shapes.length;
        options.arrays = this.getArrays();

        for (var s = 0; s < sl; s++) {

            var shape = shapes[s];
            this.addShape(shape, options);
        }

        this.setIndex(options.arrays.index);
        this.addAttribute('position', new Float32BufferAttribute(options.arrays.position, 3));
        this.addAttribute('uv', new Float32BufferAttribute(options.arrays.uv, 2));
    };

    ExtrudeBufferGeometry.prototype.addShape = function (shape, options) {

        var arrays = options.arrays ? options.arrays : this.getArrays();
        var verticesArray = arrays.position;
        var indicesArray = arrays.index;
        var uvArray = arrays.uv;

        var placeholder = [];

        var amount = options.amount !== undefined ? options.amount : 100;

        var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
        var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
        var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

        var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

        var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

        var steps = options.steps !== undefined ? options.steps : 1;

        var extrudePath = options.extrudePath;
        var extrudePts,
            extrudeByPath = false;

        // Use default WorldUVGenerator if no UV generators are specified.
        var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;

        var splineTube, binormal, normal, position2;
        if (extrudePath) {

            extrudePts = extrudePath.getSpacedPoints(steps);

            extrudeByPath = true;
            bevelEnabled = false; // bevels not supported for path extrusion

            // SETUP TNB variables

            // TODO1 - have a .isClosed in spline?

            splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames(steps, false);

            // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

            binormal = new Vector3();
            normal = new Vector3();
            position2 = new Vector3();
        }

        // Safeguards if bevels are not enabled

        if (!bevelEnabled) {

            bevelSegments = 0;
            bevelThickness = 0;
            bevelSize = 0;
        }

        // Variables initialization

        var ahole, h, hl; // looping of holes
        var scope = this;

        var shapePoints = shape.extractPoints(curveSegments);

        var vertices = shapePoints.shape;
        var holes = shapePoints.holes;

        var reverse = !ShapeUtils.isClockWise(vertices);

        if (reverse) {

            vertices = vertices.reverse();

            // Maybe we should also check if holes are in the opposite direction, just to be safe ...

            for (h = 0, hl = holes.length; h < hl; h++) {

                ahole = holes[h];

                if (ShapeUtils.isClockWise(ahole)) {

                    holes[h] = ahole.reverse();
                }
            }

            reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
        }

        var faces = ShapeUtils.triangulateShape(vertices, holes);

        /* Vertices */

        var contour = vertices; // vertices has all points but contour has only points of circumference

        for (h = 0, hl = holes.length; h < hl; h++) {

            ahole = holes[h];

            vertices = vertices.concat(ahole);
        }

        function scalePt2(pt, vec, size) {

            if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");

            return vec.clone().multiplyScalar(size).add(pt);
        }

        var b,
            bs,
            t,
            z,
            vert,
            vlen = vertices.length,
            face,
            flen = faces.length;

        // Find directions for point movement


        function getBevelVec(inPt, inPrev, inNext) {

            // computes for inPt the corresponding point inPt' on a new contour
            //   shifted by 1 unit (length of normalized vector) to the left
            // if we walk along contour clockwise, this new contour is outside the old one
            //
            // inPt' is the intersection of the two lines parallel to the two
            //  adjacent edges of inPt at a distance of 1 unit on the left side.

            var v_trans_x,
                v_trans_y,
                shrink_by = 1; // resulting translation vector for inPt

            // good reading for geometry algorithms (here: line-line intersection)
            // http://geomalgorithms.com/a05-_intersect-1.html

            var v_prev_x = inPt.x - inPrev.x,
                v_prev_y = inPt.y - inPrev.y;
            var v_next_x = inNext.x - inPt.x,
                v_next_y = inNext.y - inPt.y;

            var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;

            // check for collinear edges
            var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

            if (Math.abs(collinear0) > Number.EPSILON) {

                // not collinear

                // length of vectors for normalizing

                var v_prev_len = Math.sqrt(v_prev_lensq);
                var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);

                // shift adjacent points by unit vectors to the left

                var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;

                var ptNextShift_x = inNext.x - v_next_y / v_next_len;
                var ptNextShift_y = inNext.y + v_next_x / v_next_len;

                // scaling factor for v_prev to intersection point

                var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);

                // vector from inPt to intersection point

                v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;

                // Don't normalize!, otherwise sharp corners become ugly
                //  but prevent crazy spikes
                var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                if (v_trans_lensq <= 2) {

                    return new Vector2(v_trans_x, v_trans_y);
                } else {

                    shrink_by = Math.sqrt(v_trans_lensq / 2);
                }
            } else {

                // handle special case of collinear edges

                var direction_eq = false; // assumes: opposite
                if (v_prev_x > Number.EPSILON) {

                    if (v_next_x > Number.EPSILON) {

                        direction_eq = true;
                    }
                } else {

                    if (v_prev_x < -Number.EPSILON) {

                        if (v_next_x < -Number.EPSILON) {

                            direction_eq = true;
                        }
                    } else {

                        if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {

                            direction_eq = true;
                        }
                    }
                }

                if (direction_eq) {

                    // console.log("Warning: lines are a straight sequence");
                    v_trans_x = -v_prev_y;
                    v_trans_y = v_prev_x;
                    shrink_by = Math.sqrt(v_prev_lensq);
                } else {

                    // console.log("Warning: lines are a straight spike");
                    v_trans_x = v_prev_x;
                    v_trans_y = v_prev_y;
                    shrink_by = Math.sqrt(v_prev_lensq / 2);
                }
            }

            return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
        }

        var contourMovements = [];

        for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {

            if (j === il) j = 0;
            if (k === il) k = 0;

            //  (j)---(i)---(k)
            // console.log('i,j,k', i, j , k)

            contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
        }

        var holesMovements = [],
            oneHoleMovements,
            verticesMovements = contourMovements.concat();

        for (h = 0, hl = holes.length; h < hl; h++) {

            ahole = holes[h];

            oneHoleMovements = [];

            for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {

                if (j === il) j = 0;
                if (k === il) k = 0;

                //  (j)---(i)---(k)
                oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
            }

            holesMovements.push(oneHoleMovements);
            verticesMovements = verticesMovements.concat(oneHoleMovements);
        }

        // Loop bevelSegments, 1 for the front, 1 for the back

        for (b = 0; b < bevelSegments; b++) {

            //for ( b = bevelSegments; b > 0; b -- ) {

            t = b / bevelSegments;
            z = bevelThickness * Math.cos(t * Math.PI / 2);
            bs = bevelSize * Math.sin(t * Math.PI / 2);

            // contract shape

            for (i = 0, il = contour.length; i < il; i++) {

                vert = scalePt2(contour[i], contourMovements[i], bs);

                v(vert.x, vert.y, -z);
            }

            // expand holes

            for (h = 0, hl = holes.length; h < hl; h++) {

                ahole = holes[h];
                oneHoleMovements = holesMovements[h];

                for (i = 0, il = ahole.length; i < il; i++) {

                    vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

                    v(vert.x, vert.y, -z);
                }
            }
        }

        bs = bevelSize;

        // Back facing vertices

        for (i = 0; i < vlen; i++) {

            vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

            if (!extrudeByPath) {

                v(vert.x, vert.y, 0);
            } else {

                // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

                normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);

                position2.copy(extrudePts[0]).add(normal).add(binormal);

                v(position2.x, position2.y, position2.z);
            }
        }

        // Add stepped vertices...
        // Including front facing vertices

        var s;

        for (s = 1; s <= steps; s++) {

            for (i = 0; i < vlen; i++) {

                vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

                if (!extrudeByPath) {

                    v(vert.x, vert.y, amount / steps * s);
                } else {

                    // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

                    normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                    binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);

                    position2.copy(extrudePts[s]).add(normal).add(binormal);

                    v(position2.x, position2.y, position2.z);
                }
            }
        }

        // Add bevel segments planes

        //for ( b = 1; b <= bevelSegments; b ++ ) {
        for (b = bevelSegments - 1; b >= 0; b--) {

            t = b / bevelSegments;
            z = bevelThickness * Math.cos(t * Math.PI / 2);
            bs = bevelSize * Math.sin(t * Math.PI / 2);

            // contract shape

            for (i = 0, il = contour.length; i < il; i++) {

                vert = scalePt2(contour[i], contourMovements[i], bs);
                v(vert.x, vert.y, amount + z);
            }

            // expand holes

            for (h = 0, hl = holes.length; h < hl; h++) {

                ahole = holes[h];
                oneHoleMovements = holesMovements[h];

                for (i = 0, il = ahole.length; i < il; i++) {

                    vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

                    if (!extrudeByPath) {

                        v(vert.x, vert.y, amount + z);
                    } else {

                        v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                    }
                }
            }
        }

        /* Faces */

        // Top and bottom faces

        buildLidFaces();

        // Sides faces

        buildSideFaces();

        /////  Internal functions

        function buildLidFaces() {

            var start = verticesArray.length / 3;

            if (bevelEnabled) {

                var layer = 0; // steps + 1
                var offset = vlen * layer;

                // Bottom faces

                for (i = 0; i < flen; i++) {

                    face = faces[i];
                    f3(face[2] + offset, face[1] + offset, face[0] + offset);
                }

                layer = steps + bevelSegments * 2;
                offset = vlen * layer;

                // Top faces

                for (i = 0; i < flen; i++) {

                    face = faces[i];
                    f3(face[0] + offset, face[1] + offset, face[2] + offset);
                }
            } else {

                // Bottom faces

                for (i = 0; i < flen; i++) {

                    face = faces[i];
                    f3(face[2], face[1], face[0]);
                }

                // Top faces

                for (i = 0; i < flen; i++) {

                    face = faces[i];
                    f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                }
            }

            scope.addGroup(start, verticesArray.length / 3 - start, options.material !== undefined ? options.material : 0);
        }

        // Create faces for the z-sides of the shape

        function buildSideFaces() {

            var start = verticesArray.length / 3;
            var layeroffset = 0;
            sidewalls(contour, layeroffset);
            layeroffset += contour.length;

            for (h = 0, hl = holes.length; h < hl; h++) {

                ahole = holes[h];
                sidewalls(ahole, layeroffset);

                //, true
                layeroffset += ahole.length;
            }

            scope.addGroup(start, verticesArray.length / 3 - start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1);
        }

        function sidewalls(contour, layeroffset) {

            var j, k;
            i = contour.length;

            while (--i >= 0) {

                j = i;
                k = i - 1;
                if (k < 0) k = contour.length - 1;

                //console.log('b', i,j, i-1, k,vertices.length);

                var s = 0,
                    sl = steps + bevelSegments * 2;

                for (s = 0; s < sl; s++) {

                    var slen1 = vlen * s;
                    var slen2 = vlen * (s + 1);

                    var a = layeroffset + j + slen1,
                        b = layeroffset + k + slen1,
                        c = layeroffset + k + slen2,
                        d = layeroffset + j + slen2;

                    f4(a, b, c, d, contour, s, sl, j, k);
                }
            }
        }

        function v(x, y, z) {

            placeholder.push(x);
            placeholder.push(y);
            placeholder.push(z);
        }

        function f3(a, b, c) {

            addVertex(a);
            addVertex(b);
            addVertex(c);

            var nextIndex = verticesArray.length / 3;
            var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);

            addUV(uvs[0]);
            addUV(uvs[1]);
            addUV(uvs[2]);
        }

        function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {

            addVertex(a);
            addVertex(b);
            addVertex(d);

            addVertex(b);
            addVertex(c);
            addVertex(d);

            var nextIndex = verticesArray.length / 3;
            var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);

            addUV(uvs[0]);
            addUV(uvs[1]);
            addUV(uvs[3]);

            addUV(uvs[1]);
            addUV(uvs[2]);
            addUV(uvs[3]);
        }

        function addVertex(index) {

            indicesArray.push(verticesArray.length / 3);
            verticesArray.push(placeholder[index * 3 + 0]);
            verticesArray.push(placeholder[index * 3 + 1]);
            verticesArray.push(placeholder[index * 3 + 2]);
        }

        function addUV(vector2) {

            uvArray.push(vector2.x);
            uvArray.push(vector2.y);
        }

        if (!options.arrays) {

            this.setIndex(indicesArray);
            this.addAttribute('position', new Float32BufferAttribute(verticesArray, 3));
            this.addAttribute('uv', new Float32BufferAttribute(options.arrays.uv, 2));
        }
    };

    ExtrudeGeometry.WorldUVGenerator = {

        generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {

            var a_x = vertices[indexA * 3];
            var a_y = vertices[indexA * 3 + 1];
            var b_x = vertices[indexB * 3];
            var b_y = vertices[indexB * 3 + 1];
            var c_x = vertices[indexC * 3];
            var c_y = vertices[indexC * 3 + 1];

            return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
        },

        generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {

            var a_x = vertices[indexA * 3];
            var a_y = vertices[indexA * 3 + 1];
            var a_z = vertices[indexA * 3 + 2];
            var b_x = vertices[indexB * 3];
            var b_y = vertices[indexB * 3 + 1];
            var b_z = vertices[indexB * 3 + 2];
            var c_x = vertices[indexC * 3];
            var c_y = vertices[indexC * 3 + 1];
            var c_z = vertices[indexC * 3 + 2];
            var d_x = vertices[indexD * 3];
            var d_y = vertices[indexD * 3 + 1];
            var d_z = vertices[indexD * 3 + 2];

            if (Math.abs(a_y - b_y) < 0.01) {

                return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
            } else {

                return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
            }
        }
    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author alteredq / http://alteredqualia.com/
     *
     * Text = 3D Text
     *
     * parameters = {
     *  font: <THREE.Font>, // font
     *
     *  size: <float>, // size of the text
     *  height: <float>, // thickness to extrude text
     *  curveSegments: <int>, // number of points on the curves
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into text bevel goes
     *  bevelSize: <float> // how far from text outline is bevel
     * }
     */

    // TextGeometry

    function TextGeometry(text, parameters) {

        Geometry.call(this);

        this.type = 'TextGeometry';

        this.parameters = {
            text: text,
            parameters: parameters
        };

        this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
        this.mergeVertices();
    }

    TextGeometry.prototype = Object.create(Geometry.prototype);
    TextGeometry.prototype.constructor = TextGeometry;

    // TextBufferGeometry

    function TextBufferGeometry(text, parameters) {

        parameters = parameters || {};

        var font = parameters.font;

        if ((font && font.isFont) === false) {

            console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
            return new Geometry();
        }

        var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);

        // translate parameters to ExtrudeGeometry API

        parameters.amount = parameters.height !== undefined ? parameters.height : 50;

        // defaults

        if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
        if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
        if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;

        ExtrudeBufferGeometry.call(this, shapes, parameters);

        this.type = 'TextBufferGeometry';
    }

    TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
    TextBufferGeometry.prototype.constructor = TextBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author benaadams / https://twitter.com/ben_a_adams
     * @author Mugen87 / https://github.com/Mugen87
     */

    // SphereGeometry

    function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {

        Geometry.call(this);

        this.type = 'SphereGeometry';

        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };

        this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
        this.mergeVertices();
    }

    SphereGeometry.prototype = Object.create(Geometry.prototype);
    SphereGeometry.prototype.constructor = SphereGeometry;

    // SphereBufferGeometry

    function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {

        BufferGeometry.call(this);

        this.type = 'SphereBufferGeometry';

        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };

        radius = radius || 50;

        widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
        heightSegments = Math.max(2, Math.floor(heightSegments) || 6);

        phiStart = phiStart !== undefined ? phiStart : 0;
        phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

        var thetaEnd = thetaStart + thetaLength;

        var ix, iy;

        var index = 0;
        var grid = [];

        var vertex = new Vector3();
        var normal = new Vector3();

        // buffers

        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];

        // generate vertices, normals and uvs

        for (iy = 0; iy <= heightSegments; iy++) {

            var verticesRow = [];

            var v = iy / heightSegments;

            for (ix = 0; ix <= widthSegments; ix++) {

                var u = ix / widthSegments;

                // vertex

                vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);

                vertices.push(vertex.x, vertex.y, vertex.z);

                // normal

                normal.set(vertex.x, vertex.y, vertex.z).normalize();
                normals.push(normal.x, normal.y, normal.z);

                // uv

                uvs.push(u, 1 - v);

                verticesRow.push(index++);
            }

            grid.push(verticesRow);
        }

        // indices

        for (iy = 0; iy < heightSegments; iy++) {

            for (ix = 0; ix < widthSegments; ix++) {

                var a = grid[iy][ix + 1];
                var b = grid[iy][ix];
                var c = grid[iy + 1][ix];
                var d = grid[iy + 1][ix + 1];

                if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
                if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
            }
        }

        // build geometry

        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }

    SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

    /**
     * @author Kaleb Murphy
     * @author Mugen87 / https://github.com/Mugen87
     */

    // RingGeometry

    function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {

        Geometry.call(this);

        this.type = 'RingGeometry';

        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };

        this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
        this.mergeVertices();
    }

    RingGeometry.prototype = Object.create(Geometry.prototype);
    RingGeometry.prototype.constructor = RingGeometry;

    // RingBufferGeometry

    function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {

        BufferGeometry.call(this);

        this.type = 'RingBufferGeometry';

        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };

        innerRadius = innerRadius || 20;
        outerRadius = outerRadius || 50;

        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

        thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
        phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;

        // buffers

        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];

        // some helper variables

        var segment;
        var radius = innerRadius;
        var radiusStep = (outerRadius - innerRadius) / phiSegments;
        var vertex = new Vector3();
        var uv = new Vector2();
        var j, i;

        // generate vertices, normals and uvs

        for (j = 0; j <= phiSegments; j++) {

            for (i = 0; i <= thetaSegments; i++) {

                // values are generate from the inside of the ring to the outside

                segment = thetaStart + i / thetaSegments * thetaLength;

                // vertex

                vertex.x = radius * Math.cos(segment);
                vertex.y = radius * Math.sin(segment);

                vertices.push(vertex.x, vertex.y, vertex.z);

                // normal

                normals.push(0, 0, 1);

                // uv

                uv.x = (vertex.x / outerRadius + 1) / 2;
                uv.y = (vertex.y / outerRadius + 1) / 2;

                uvs.push(uv.x, uv.y);
            }

            // increase the radius for next row of vertices

            radius += radiusStep;
        }

        // indices

        for (j = 0; j < phiSegments; j++) {

            var thetaSegmentLevel = j * (thetaSegments + 1);

            for (i = 0; i < thetaSegments; i++) {

                segment = i + thetaSegmentLevel;

                var a = segment;
                var b = segment + thetaSegments + 1;
                var c = segment + thetaSegments + 2;
                var d = segment + 1;

                // faces

                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }

        // build geometry

        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }

    RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    RingBufferGeometry.prototype.constructor = RingBufferGeometry;

    /**
     * @author astrodud / http://astrodud.isgreat.org/
     * @author zz85 / https://github.com/zz85
     * @author bhouston / http://clara.io
     * @author Mugen87 / https://github.com/Mugen87
     */

    // LatheGeometry

    function LatheGeometry(points, segments, phiStart, phiLength) {

        Geometry.call(this);

        this.type = 'LatheGeometry';

        this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        };

        this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
        this.mergeVertices();
    }

    LatheGeometry.prototype = Object.create(Geometry.prototype);
    LatheGeometry.prototype.constructor = LatheGeometry;

    // LatheBufferGeometry

    function LatheBufferGeometry(points, segments, phiStart, phiLength) {

        BufferGeometry.call(this);

        this.type = 'LatheBufferGeometry';

        this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        };

        segments = Math.floor(segments) || 12;
        phiStart = phiStart || 0;
        phiLength = phiLength || Math.PI * 2;

        // clamp phiLength so it's in range of [ 0, 2PI ]

        phiLength = _Math.clamp(phiLength, 0, Math.PI * 2);

        // buffers

        var indices = [];
        var vertices = [];
        var uvs = [];

        // helper variables

        var base;
        var inverseSegments = 1.0 / segments;
        var vertex = new Vector3();
        var uv = new Vector2();
        var i, j;

        // generate vertices and uvs

        for (i = 0; i <= segments; i++) {

            var phi = phiStart + i * inverseSegments * phiLength;

            var sin = Math.sin(phi);
            var cos = Math.cos(phi);

            for (j = 0; j <= points.length - 1; j++) {

                // vertex

                vertex.x = points[j].x * sin;
                vertex.y = points[j].y;
                vertex.z = points[j].x * cos;

                vertices.push(vertex.x, vertex.y, vertex.z);

                // uv

                uv.x = i / segments;
                uv.y = j / (points.length - 1);

                uvs.push(uv.x, uv.y);
            }
        }

        // indices

        for (i = 0; i < segments; i++) {

            for (j = 0; j < points.length - 1; j++) {

                base = j + i * points.length;

                var a = base;
                var b = base + points.length;
                var c = base + points.length + 1;
                var d = base + 1;

                // faces

                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }

        // build geometry

        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

        // generate normals

        this.computeVertexNormals();

        // if the geometry is closed, we need to average the normals along the seam.
        // because the corresponding vertices are identical (but still have different UVs).

        if (phiLength === Math.PI * 2) {

            var normals = this.attributes.normal.array;
            var n1 = new Vector3();
            var n2 = new Vector3();
            var n = new Vector3();

            // this is the buffer offset for the last line of vertices

            base = segments * points.length * 3;

            for (i = 0, j = 0; i < points.length; i++, j += 3) {

                // select the normal of the vertex in the first line

                n1.x = normals[j + 0];
                n1.y = normals[j + 1];
                n1.z = normals[j + 2];

                // select the normal of the vertex in the last line

                n2.x = normals[base + j + 0];
                n2.y = normals[base + j + 1];
                n2.z = normals[base + j + 2];

                // average normals

                n.addVectors(n1, n2).normalize();

                // assign the new values to both normals

                normals[j + 0] = normals[base + j + 0] = n.x;
                normals[j + 1] = normals[base + j + 1] = n.y;
                normals[j + 2] = normals[base + j + 2] = n.z;
            }
        }
    }

    LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

    /**
     * @author jonobr1 / http://jonobr1.com
     * @author Mugen87 / https://github.com/Mugen87
     */

    // ShapeGeometry

    function ShapeGeometry(shapes, curveSegments) {

        Geometry.call(this);

        this.type = 'ShapeGeometry';

        if ((typeof curveSegments === "undefined" ? "undefined" : _typeof(curveSegments)) === 'object') {

            console.warn('THREE.ShapeGeometry: Options parameter has been removed.');

            curveSegments = curveSegments.curveSegments;
        }

        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };

        this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
        this.mergeVertices();
    }

    ShapeGeometry.prototype = Object.create(Geometry.prototype);
    ShapeGeometry.prototype.constructor = ShapeGeometry;

    // ShapeBufferGeometry

    function ShapeBufferGeometry(shapes, curveSegments) {

        BufferGeometry.call(this);

        this.type = 'ShapeBufferGeometry';

        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };

        curveSegments = curveSegments || 12;

        // buffers

        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];

        // helper variables

        var groupStart = 0;
        var groupCount = 0;

        // allow single and array values for "shapes" parameter

        if (Array.isArray(shapes) === false) {

            addShape(shapes);
        } else {

            for (var i = 0; i < shapes.length; i++) {

                addShape(shapes[i]);

                this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

                groupStart += groupCount;
                groupCount = 0;
            }
        }

        // build geometry

        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

        // helper functions

        function addShape(shape) {

            var i, l, shapeHole;

            var indexOffset = vertices.length / 3;
            var points = shape.extractPoints(curveSegments);

            var shapeVertices = points.shape;
            var shapeHoles = points.holes;

            // check direction of vertices

            if (ShapeUtils.isClockWise(shapeVertices) === false) {

                shapeVertices = shapeVertices.reverse();

                // also check if holes are in the opposite direction

                for (i = 0, l = shapeHoles.length; i < l; i++) {

                    shapeHole = shapeHoles[i];

                    if (ShapeUtils.isClockWise(shapeHole) === true) {

                        shapeHoles[i] = shapeHole.reverse();
                    }
                }
            }

            var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);

            // join vertices of inner and outer paths to a single array

            for (i = 0, l = shapeHoles.length; i < l; i++) {

                shapeHole = shapeHoles[i];
                shapeVertices = shapeVertices.concat(shapeHole);
            }

            // vertices, normals, uvs

            for (i = 0, l = shapeVertices.length; i < l; i++) {

                var vertex = shapeVertices[i];

                vertices.push(vertex.x, vertex.y, 0);
                normals.push(0, 0, 1);
                uvs.push(vertex.x, vertex.y); // world uvs
            }

            // incides

            for (i = 0, l = faces.length; i < l; i++) {

                var face = faces[i];

                var a = face[0] + indexOffset;
                var b = face[1] + indexOffset;
                var c = face[2] + indexOffset;

                indices.push(a, b, c);
                groupCount += 3;
            }
        }
    }

    ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

    /**
     * @author WestLangley / http://github.com/WestLangley
     * @author Mugen87 / https://github.com/Mugen87
     */

    function EdgesGeometry(geometry, thresholdAngle) {

        BufferGeometry.call(this);

        this.type = 'EdgesGeometry';

        this.parameters = {
            thresholdAngle: thresholdAngle
        };

        thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;

        // buffer

        var vertices = [];

        // helper variables

        var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
        var edge = [0, 0],
            edges = {},
            edge1,
            edge2;
        var key,
            keys = ['a', 'b', 'c'];

        // prepare source geometry

        var geometry2;

        if (geometry.isBufferGeometry) {

            geometry2 = new Geometry();
            geometry2.fromBufferGeometry(geometry);
        } else {

            geometry2 = geometry.clone();
        }

        geometry2.mergeVertices();
        geometry2.computeFaceNormals();

        var sourceVertices = geometry2.vertices;
        var faces = geometry2.faces;

        // now create a data structure where each entry represents an edge with its adjoining faces

        for (var i = 0, l = faces.length; i < l; i++) {

            var face = faces[i];

            for (var j = 0; j < 3; j++) {

                edge1 = face[keys[j]];
                edge2 = face[keys[(j + 1) % 3]];
                edge[0] = Math.min(edge1, edge2);
                edge[1] = Math.max(edge1, edge2);

                key = edge[0] + ',' + edge[1];

                if (edges[key] === undefined) {

                    edges[key] = { index1: edge[0], index2: edge[1], face1: i, face2: undefined };
                } else {

                    edges[key].face2 = i;
                }
            }
        }

        // generate vertices

        for (key in edges) {

            var e = edges[key];

            // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

            if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {

                var vertex = sourceVertices[e.index1];
                vertices.push(vertex.x, vertex.y, vertex.z);

                vertex = sourceVertices[e.index2];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }

        // build geometry

        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
    }

    EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
    EdgesGeometry.prototype.constructor = EdgesGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */

    // CylinderGeometry

    function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {

        Geometry.call(this);

        this.type = 'CylinderGeometry';

        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };

        this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
        this.mergeVertices();
    }

    CylinderGeometry.prototype = Object.create(Geometry.prototype);
    CylinderGeometry.prototype.constructor = CylinderGeometry;

    // CylinderBufferGeometry

    function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {

        BufferGeometry.call(this);

        this.type = 'CylinderBufferGeometry';

        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };

        var scope = this;

        radiusTop = radiusTop !== undefined ? radiusTop : 20;
        radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
        height = height !== undefined ? height : 100;

        radialSegments = Math.floor(radialSegments) || 8;
        heightSegments = Math.floor(heightSegments) || 1;

        openEnded = openEnded !== undefined ? openEnded : false;
        thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
        thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

        // buffers

        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];

        // helper variables

        var index = 0;
        var indexArray = [];
        var halfHeight = height / 2;
        var groupStart = 0;

        // generate geometry

        generateTorso();

        if (openEnded === false) {

            if (radiusTop > 0) generateCap(true);
            if (radiusBottom > 0) generateCap(false);
        }

        // build geometry

        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

        function generateTorso() {

            var x, y;
            var normal = new Vector3();
            var vertex = new Vector3();

            var groupCount = 0;

            // this will be used to calculate the normal
            var slope = (radiusBottom - radiusTop) / height;

            // generate vertices, normals and uvs

            for (y = 0; y <= heightSegments; y++) {

                var indexRow = [];

                var v = y / heightSegments;

                // calculate the radius of the current row

                var radius = v * (radiusBottom - radiusTop) + radiusTop;

                for (x = 0; x <= radialSegments; x++) {

                    var u = x / radialSegments;

                    var theta = u * thetaLength + thetaStart;

                    var sinTheta = Math.sin(theta);
                    var cosTheta = Math.cos(theta);

                    // vertex

                    vertex.x = radius * sinTheta;
                    vertex.y = -v * height + halfHeight;
                    vertex.z = radius * cosTheta;
                    vertices.push(vertex.x, vertex.y, vertex.z);

                    // normal

                    normal.set(sinTheta, slope, cosTheta).normalize();
                    normals.push(normal.x, normal.y, normal.z);

                    // uv

                    uvs.push(u, 1 - v);

                    // save index of vertex in respective row

                    indexRow.push(index++);
                }

                // now save vertices of the row in our index array

                indexArray.push(indexRow);
            }

            // generate indices

            for (x = 0; x < radialSegments; x++) {

                for (y = 0; y < heightSegments; y++) {

                    // we use the index array to access the correct indices

                    var a = indexArray[y][x];
                    var b = indexArray[y + 1][x];
                    var c = indexArray[y + 1][x + 1];
                    var d = indexArray[y][x + 1];

                    // faces

                    indices.push(a, b, d);
                    indices.push(b, c, d);

                    // update group counter

                    groupCount += 6;
                }
            }

            // add a group to the geometry. this will ensure multi material support

            scope.addGroup(groupStart, groupCount, 0);

            // calculate new start value for groups

            groupStart += groupCount;
        }

        function generateCap(top) {

            var x, centerIndexStart, centerIndexEnd;

            var uv = new Vector2();
            var vertex = new Vector3();

            var groupCount = 0;

            var radius = top === true ? radiusTop : radiusBottom;
            var sign = top === true ? 1 : -1;

            // save the index of the first center vertex
            centerIndexStart = index;

            // first we generate the center vertex data of the cap.
            // because the geometry needs one set of uvs per face,
            // we must generate a center vertex per face/segment

            for (x = 1; x <= radialSegments; x++) {

                // vertex

                vertices.push(0, halfHeight * sign, 0);

                // normal

                normals.push(0, sign, 0);

                // uv

                uvs.push(0.5, 0.5);

                // increase index

                index++;
            }

            // save the index of the last center vertex

            centerIndexEnd = index;

            // now we generate the surrounding vertices, normals and uvs

            for (x = 0; x <= radialSegments; x++) {

                var u = x / radialSegments;
                var theta = u * thetaLength + thetaStart;

                var cosTheta = Math.cos(theta);
                var sinTheta = Math.sin(theta);

                // vertex

                vertex.x = radius * sinTheta;
                vertex.y = halfHeight * sign;
                vertex.z = radius * cosTheta;
                vertices.push(vertex.x, vertex.y, vertex.z);

                // normal

                normals.push(0, sign, 0);

                // uv

                uv.x = cosTheta * 0.5 + 0.5;
                uv.y = sinTheta * 0.5 * sign + 0.5;
                uvs.push(uv.x, uv.y);

                // increase index

                index++;
            }

            // generate indices

            for (x = 0; x < radialSegments; x++) {

                var c = centerIndexStart + x;
                var i = centerIndexEnd + x;

                if (top === true) {

                    // face top

                    indices.push(i, i + 1, c);
                } else {

                    // face bottom

                    indices.push(i + 1, i, c);
                }

                groupCount += 3;
            }

            // add a group to the geometry. this will ensure multi material support

            scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);

            // calculate new start value for groups

            groupStart += groupCount;
        }
    }

    CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

    /**
     * @author abelnation / http://github.com/abelnation
     */

    // ConeGeometry

    function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {

        CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);

        this.type = 'ConeGeometry';

        this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }

    ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
    ConeGeometry.prototype.constructor = ConeGeometry;

    // ConeBufferGeometry

    function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {

        CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);

        this.type = 'ConeBufferGeometry';

        this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }

    ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
    ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     * @author Mugen87 / https://github.com/Mugen87
     * @author hughes
     */

    // CircleGeometry

    function CircleGeometry(radius, segments, thetaStart, thetaLength) {

        Geometry.call(this);

        this.type = 'CircleGeometry';

        this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };

        this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
        this.mergeVertices();
    }

    CircleGeometry.prototype = Object.create(Geometry.prototype);
    CircleGeometry.prototype.constructor = CircleGeometry;

    // CircleBufferGeometry

    function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {

        BufferGeometry.call(this);

        this.type = 'CircleBufferGeometry';

        this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };

        radius = radius || 50;
        segments = segments !== undefined ? Math.max(3, segments) : 8;

        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

        // buffers

        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];

        // helper variables

        var i, s;
        var vertex = new Vector3();
        var uv = new Vector2();

        // center point

        vertices.push(0, 0, 0);
        normals.push(0, 0, 1);
        uvs.push(0.5, 0.5);

        for (s = 0, i = 3; s <= segments; s++, i += 3) {

            var segment = thetaStart + s / segments * thetaLength;

            // vertex

            vertex.x = radius * Math.cos(segment);
            vertex.y = radius * Math.sin(segment);

            vertices.push(vertex.x, vertex.y, vertex.z);

            // normal

            normals.push(0, 0, 1);

            // uvs

            uv.x = (vertices[i] / radius + 1) / 2;
            uv.y = (vertices[i + 1] / radius + 1) / 2;

            uvs.push(uv.x, uv.y);
        }

        // indices

        for (i = 1; i <= segments; i++) {

            indices.push(i, i + 1, 0);
        }

        // build geometry

        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }

    CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;

    var Geometries = Object.freeze({
        WireframeGeometry: WireframeGeometry,
        ParametricGeometry: ParametricGeometry,
        ParametricBufferGeometry: ParametricBufferGeometry,
        TetrahedronGeometry: TetrahedronGeometry,
        TetrahedronBufferGeometry: TetrahedronBufferGeometry,
        OctahedronGeometry: OctahedronGeometry,
        OctahedronBufferGeometry: OctahedronBufferGeometry,
        IcosahedronGeometry: IcosahedronGeometry,
        IcosahedronBufferGeometry: IcosahedronBufferGeometry,
        DodecahedronGeometry: DodecahedronGeometry,
        DodecahedronBufferGeometry: DodecahedronBufferGeometry,
        PolyhedronGeometry: PolyhedronGeometry,
        PolyhedronBufferGeometry: PolyhedronBufferGeometry,
        TubeGeometry: TubeGeometry,
        TubeBufferGeometry: TubeBufferGeometry,
        TorusKnotGeometry: TorusKnotGeometry,
        TorusKnotBufferGeometry: TorusKnotBufferGeometry,
        TorusGeometry: TorusGeometry,
        TorusBufferGeometry: TorusBufferGeometry,
        TextGeometry: TextGeometry,
        TextBufferGeometry: TextBufferGeometry,
        SphereGeometry: SphereGeometry,
        SphereBufferGeometry: SphereBufferGeometry,
        RingGeometry: RingGeometry,
        RingBufferGeometry: RingBufferGeometry,
        PlaneGeometry: PlaneGeometry,
        PlaneBufferGeometry: PlaneBufferGeometry,
        LatheGeometry: LatheGeometry,
        LatheBufferGeometry: LatheBufferGeometry,
        ShapeGeometry: ShapeGeometry,
        ShapeBufferGeometry: ShapeBufferGeometry,
        ExtrudeGeometry: ExtrudeGeometry,
        ExtrudeBufferGeometry: ExtrudeBufferGeometry,
        EdgesGeometry: EdgesGeometry,
        ConeGeometry: ConeGeometry,
        ConeBufferGeometry: ConeBufferGeometry,
        CylinderGeometry: CylinderGeometry,
        CylinderBufferGeometry: CylinderBufferGeometry,
        CircleGeometry: CircleGeometry,
        CircleBufferGeometry: CircleBufferGeometry,
        BoxGeometry: BoxGeometry,
        BoxBufferGeometry: BoxBufferGeometry
    });

    /**
     * @author mrdoob / http://mrdoob.com/
     *
     * parameters = {
     *  opacity: <float>
     * }
     */

    function ShadowMaterial(parameters) {

        ShaderMaterial.call(this, {
            uniforms: UniformsUtils.merge([UniformsLib.lights, {
                opacity: { value: 1.0 }
            }]),
            vertexShader: ShaderChunk['shadow_vert'],
            fragmentShader: ShaderChunk['shadow_frag']
        });

        this.lights = true;
        this.transparent = true;

        Object.defineProperties(this, {
            opacity: {
                enumerable: true,
                get: function get() {
                    return this.uniforms.opacity.value;
                },
                set: function set(value) {
                    this.uniforms.opacity.value = value;
                }
            }
        });

        this.setValues(parameters);
    }

    ShadowMaterial.prototype = Object.create(ShaderMaterial.prototype);
    ShadowMaterial.prototype.constructor = ShadowMaterial;

    ShadowMaterial.prototype.isShadowMaterial = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function RawShaderMaterial(parameters) {

        ShaderMaterial.call(this, parameters);

        this.type = 'RawShaderMaterial';
    }

    RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
    RawShaderMaterial.prototype.constructor = RawShaderMaterial;

    RawShaderMaterial.prototype.isRawShaderMaterial = true;

    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  color: <hex>,
     *  roughness: <float>,
     *  metalness: <float>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  roughnessMap: new THREE.Texture( <Image> ),
     *
     *  metalnessMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
     *  envMapIntensity: <float>
     *
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function MeshStandardMaterial(parameters) {

        Material.call(this);

        this.defines = { 'STANDARD': '' };

        this.type = 'MeshStandardMaterial';

        this.color = new Color(0xffffff); // diffuse
        this.roughness = 0.5;
        this.metalness = 0.5;

        this.map = null;

        this.lightMap = null;
        this.lightMapIntensity = 1.0;

        this.aoMap = null;
        this.aoMapIntensity = 1.0;

        this.emissive = new Color(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;

        this.bumpMap = null;
        this.bumpScale = 1;

        this.normalMap = null;
        this.normalScale = new Vector2(1, 1);

        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;

        this.roughnessMap = null;

        this.metalnessMap = null;

        this.alphaMap = null;

        this.envMap = null;
        this.envMapIntensity = 1.0;

        this.refractionRatio = 0.98;

        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';

        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;

        this.setValues(parameters);
    }

    MeshStandardMaterial.prototype = Object.create(Material.prototype);
    MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

    MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

    MeshStandardMaterial.prototype.copy = function (source) {

        Material.prototype.copy.call(this, source);

        this.defines = { 'STANDARD': '' };

        this.color.copy(source.color);
        this.roughness = source.roughness;
        this.metalness = source.metalness;

        this.map = source.map;

        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;

        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;

        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;

        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;

        this.normalMap = source.normalMap;
        this.normalScale.copy(source.normalScale);

        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;

        this.roughnessMap = source.roughnessMap;

        this.metalnessMap = source.metalnessMap;

        this.alphaMap = source.alphaMap;

        this.envMap = source.envMap;
        this.envMapIntensity = source.envMapIntensity;

        this.refractionRatio = source.refractionRatio;

        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;

        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;

        return this;
    };

    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  reflectivity: <float>
     * }
     */

    function MeshPhysicalMaterial(parameters) {

        MeshStandardMaterial.call(this);

        this.defines = { 'PHYSICAL': '' };

        this.type = 'MeshPhysicalMaterial';

        this.reflectivity = 0.5; // maps to F0 = 0.04

        this.clearCoat = 0.0;
        this.clearCoatRoughness = 0.0;

        this.setValues(parameters);
    }

    MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
    MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

    MeshPhysicalMaterial.prototype.copy = function (source) {

        MeshStandardMaterial.prototype.copy.call(this, source);

        this.defines = { 'PHYSICAL': '' };

        this.reflectivity = source.reflectivity;

        this.clearCoat = source.clearCoat;
        this.clearCoatRoughness = source.clearCoatRoughness;

        return this;
    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  specular: <hex>,
     *  shininess: <float>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function MeshPhongMaterial(parameters) {

        Material.call(this);

        this.type = 'MeshPhongMaterial';

        this.color = new Color(0xffffff); // diffuse
        this.specular = new Color(0x111111);
        this.shininess = 30;

        this.map = null;

        this.lightMap = null;
        this.lightMapIntensity = 1.0;

        this.aoMap = null;
        this.aoMapIntensity = 1.0;

        this.emissive = new Color(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;

        this.bumpMap = null;
        this.bumpScale = 1;

        this.normalMap = null;
        this.normalScale = new Vector2(1, 1);

        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;

        this.specularMap = null;

        this.alphaMap = null;

        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;

        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';

        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;

        this.setValues(parameters);
    }

    MeshPhongMaterial.prototype = Object.create(Material.prototype);
    MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

    MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

    MeshPhongMaterial.prototype.copy = function (source) {

        Material.prototype.copy.call(this, source);

        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;

        this.map = source.map;

        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;

        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;

        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;

        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;

        this.normalMap = source.normalMap;
        this.normalScale.copy(source.normalScale);

        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;

        this.specularMap = source.specularMap;

        this.alphaMap = source.alphaMap;

        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;

        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;

        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;

        return this;
    };

    /**
     * @author takahirox / http://github.com/takahirox
     *
     * parameters = {
     *  gradientMap: new THREE.Texture( <Image> )
     * }
     */

    function MeshToonMaterial(parameters) {

        MeshPhongMaterial.call(this);

        this.defines = { 'TOON': '' };

        this.type = 'MeshToonMaterial';

        this.gradientMap = null;

        this.setValues(parameters);
    }

    MeshToonMaterial.prototype = Object.create(MeshPhongMaterial.prototype);
    MeshToonMaterial.prototype.constructor = MeshToonMaterial;

    MeshToonMaterial.prototype.isMeshToonMaterial = true;

    MeshToonMaterial.prototype.copy = function (source) {

        MeshPhongMaterial.prototype.copy.call(this, source);

        this.gradientMap = source.gradientMap;

        return this;
    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  opacity: <float>,
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function MeshNormalMaterial(parameters) {

        Material.call(this, parameters);

        this.type = 'MeshNormalMaterial';

        this.bumpMap = null;
        this.bumpScale = 1;

        this.normalMap = null;
        this.normalScale = new Vector2(1, 1);

        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;

        this.wireframe = false;
        this.wireframeLinewidth = 1;

        this.fog = false;
        this.lights = false;

        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;

        this.setValues(parameters);
    }

    MeshNormalMaterial.prototype = Object.create(Material.prototype);
    MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

    MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

    MeshNormalMaterial.prototype.copy = function (source) {

        Material.prototype.copy.call(this, source);

        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;

        this.normalMap = source.normalMap;
        this.normalScale.copy(source.normalScale);

        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;

        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;

        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;

        return this;
    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function MeshLambertMaterial(parameters) {

        Material.call(this);

        this.type = 'MeshLambertMaterial';

        this.color = new Color(0xffffff); // diffuse

        this.map = null;

        this.lightMap = null;
        this.lightMapIntensity = 1.0;

        this.aoMap = null;
        this.aoMapIntensity = 1.0;

        this.emissive = new Color(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;

        this.specularMap = null;

        this.alphaMap = null;

        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;

        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';

        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;

        this.setValues(parameters);
    }

    MeshLambertMaterial.prototype = Object.create(Material.prototype);
    MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

    MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

    MeshLambertMaterial.prototype.copy = function (source) {

        Material.prototype.copy.call(this, source);

        this.color.copy(source.color);

        this.map = source.map;

        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;

        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;

        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;

        this.specularMap = source.specularMap;

        this.alphaMap = source.alphaMap;

        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;

        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;

        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;

        return this;
    };

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  linewidth: <float>,
     *
     *  scale: <float>,
     *  dashSize: <float>,
     *  gapSize: <float>
     * }
     */

    function LineDashedMaterial(parameters) {

        Material.call(this);

        this.type = 'LineDashedMaterial';

        this.color = new Color(0xffffff);

        this.linewidth = 1;

        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;

        this.lights = false;

        this.setValues(parameters);
    }

    LineDashedMaterial.prototype = Object.create(Material.prototype);
    LineDashedMaterial.prototype.constructor = LineDashedMaterial;

    LineDashedMaterial.prototype.isLineDashedMaterial = true;

    LineDashedMaterial.prototype.copy = function (source) {

        Material.prototype.copy.call(this, source);

        this.color.copy(source.color);

        this.linewidth = source.linewidth;

        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;

        return this;
    };

    var Materials = Object.freeze({
        ShadowMaterial: ShadowMaterial,
        SpriteMaterial: SpriteMaterial,
        RawShaderMaterial: RawShaderMaterial,
        ShaderMaterial: ShaderMaterial,
        PointsMaterial: PointsMaterial,
        MeshPhysicalMaterial: MeshPhysicalMaterial,
        MeshStandardMaterial: MeshStandardMaterial,
        MeshPhongMaterial: MeshPhongMaterial,
        MeshToonMaterial: MeshToonMaterial,
        MeshNormalMaterial: MeshNormalMaterial,
        MeshLambertMaterial: MeshLambertMaterial,
        MeshDepthMaterial: MeshDepthMaterial,
        MeshBasicMaterial: MeshBasicMaterial,
        LineDashedMaterial: LineDashedMaterial,
        LineBasicMaterial: LineBasicMaterial,
        Material: Material
    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    var Cache = {

        enabled: false,

        files: {},

        add: function add(key, file) {

            if (this.enabled === false) return;

            // console.log( 'THREE.Cache', 'Adding key:', key );

            this.files[key] = file;
        },

        get: function get(key) {

            if (this.enabled === false) return;

            // console.log( 'THREE.Cache', 'Checking key:', key );

            return this.files[key];
        },

        remove: function remove(key) {

            delete this.files[key];
        },

        clear: function clear() {

            this.files = {};
        }

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function LoadingManager(onLoad, onProgress, onError) {

        var scope = this;

        var isLoading = false,
            itemsLoaded = 0,
            itemsTotal = 0;

        this.onStart = undefined;
        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;

        this.itemStart = function (url) {

            itemsTotal++;

            if (isLoading === false) {

                if (scope.onStart !== undefined) {

                    scope.onStart(url, itemsLoaded, itemsTotal);
                }
            }

            isLoading = true;
        };

        this.itemEnd = function (url) {

            itemsLoaded++;

            if (scope.onProgress !== undefined) {

                scope.onProgress(url, itemsLoaded, itemsTotal);
            }

            if (itemsLoaded === itemsTotal) {

                isLoading = false;

                if (scope.onLoad !== undefined) {

                    scope.onLoad();
                }
            }
        };

        this.itemError = function (url) {

            if (scope.onError !== undefined) {

                scope.onError(url);
            }
        };
    }

    var DefaultLoadingManager = new LoadingManager();

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function FileLoader(manager) {

        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    }

    Object.assign(FileLoader.prototype, {

        load: function load(url, onLoad, onProgress, onError) {

            if (url === undefined) url = '';

            if (this.path !== undefined) url = this.path + url;

            var scope = this;

            var cached = Cache.get(url);

            if (cached !== undefined) {

                scope.manager.itemStart(url);

                setTimeout(function () {

                    if (onLoad) onLoad(cached);

                    scope.manager.itemEnd(url);
                }, 0);

                return cached;
            }

            // Check for data: URI
            var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
            var dataUriRegexResult = url.match(dataUriRegex);

            // Safari can not handle Data URIs through XMLHttpRequest so process manually
            if (dataUriRegexResult) {

                var mimeType = dataUriRegexResult[1];
                var isBase64 = !!dataUriRegexResult[2];
                var data = dataUriRegexResult[3];

                data = window.decodeURIComponent(data);

                if (isBase64) data = window.atob(data);

                try {

                    var response;
                    var responseType = (this.responseType || '').toLowerCase();

                    switch (responseType) {

                        case 'arraybuffer':
                        case 'blob':

                            response = new ArrayBuffer(data.length);

                            var view = new Uint8Array(response);

                            for (var i = 0; i < data.length; i++) {

                                view[i] = data.charCodeAt(i);
                            }

                            if (responseType === 'blob') {

                                response = new Blob([response], { type: mimeType });
                            }

                            break;

                        case 'document':

                            var parser = new DOMParser();
                            response = parser.parseFromString(data, mimeType);

                            break;

                        case 'json':

                            response = JSON.parse(data);

                            break;

                        default:
                            // 'text' or other

                            response = data;

                            break;

                    }

                    // Wait for next browser tick
                    window.setTimeout(function () {

                        if (onLoad) onLoad(response);

                        scope.manager.itemEnd(url);
                    }, 0);
                } catch (error) {

                    // Wait for next browser tick
                    window.setTimeout(function () {

                        if (onError) onError(error);

                        scope.manager.itemEnd(url);
                        scope.manager.itemError(url);
                    }, 0);
                }
            } else {

                var request = new XMLHttpRequest();
                request.open('GET', url, true);

                request.addEventListener('load', function (event) {

                    var response = event.target.response;

                    Cache.add(url, response);

                    if (this.status === 200) {

                        if (onLoad) onLoad(response);

                        scope.manager.itemEnd(url);
                    } else if (this.status === 0) {

                        // Some browsers return HTTP Status 0 when using non-http protocol
                        // e.g. 'file://' or 'data://'. Handle as success.

                        console.warn('THREE.FileLoader: HTTP Status 0 received.');

                        if (onLoad) onLoad(response);

                        scope.manager.itemEnd(url);
                    } else {

                        if (onError) onError(event);

                        scope.manager.itemEnd(url);
                        scope.manager.itemError(url);
                    }
                }, false);

                if (onProgress !== undefined) {

                    request.addEventListener('progress', function (event) {

                        onProgress(event);
                    }, false);
                }

                request.addEventListener('error', function (event) {

                    if (onError) onError(event);

                    scope.manager.itemEnd(url);
                    scope.manager.itemError(url);
                }, false);

                if (this.responseType !== undefined) request.responseType = this.responseType;
                if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;

                if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

                for (var header in this.requestHeader) {

                    request.setRequestHeader(header, this.requestHeader[header]);
                }

                request.send(null);
            }

            scope.manager.itemStart(url);

            return request;
        },

        setPath: function setPath(value) {

            this.path = value;
            return this;
        },

        setResponseType: function setResponseType(value) {

            this.responseType = value;
            return this;
        },

        setWithCredentials: function setWithCredentials(value) {

            this.withCredentials = value;
            return this;
        },

        setMimeType: function setMimeType(value) {

            this.mimeType = value;
            return this;
        },

        setRequestHeader: function setRequestHeader(value) {

            this.requestHeader = value;
            return this;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     *
     * Abstract Base class to block based textures loader (dds, pvr, ...)
     */

    function CompressedTextureLoader(manager) {

        this.manager = manager !== undefined ? manager : DefaultLoadingManager;

        // override in sub classes
        this._parser = null;
    }

    Object.assign(CompressedTextureLoader.prototype, {

        load: function load(url, onLoad, onProgress, onError) {

            var scope = this;

            var images = [];

            var texture = new CompressedTexture();
            texture.image = images;

            var loader = new FileLoader(this.manager);
            loader.setPath(this.path);
            loader.setResponseType('arraybuffer');

            function loadTexture(i) {

                loader.load(url[i], function (buffer) {

                    var texDatas = scope._parser(buffer, true);

                    images[i] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    };

                    loaded += 1;

                    if (loaded === 6) {

                        if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;

                        texture.format = texDatas.format;
                        texture.needsUpdate = true;

                        if (onLoad) onLoad(texture);
                    }
                }, onProgress, onError);
            }

            if (Array.isArray(url)) {

                var loaded = 0;

                for (var i = 0, il = url.length; i < il; ++i) {

                    loadTexture(i);
                }
            } else {

                // compressed cubemap texture stored in a single DDS file

                loader.load(url, function (buffer) {

                    var texDatas = scope._parser(buffer, true);

                    if (texDatas.isCubemap) {

                        var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

                        for (var f = 0; f < faces; f++) {

                            images[f] = { mipmaps: [] };

                            for (var i = 0; i < texDatas.mipmapCount; i++) {

                                images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                                images[f].format = texDatas.format;
                                images[f].width = texDatas.width;
                                images[f].height = texDatas.height;
                            }
                        }
                    } else {

                        texture.image.width = texDatas.width;
                        texture.image.height = texDatas.height;
                        texture.mipmaps = texDatas.mipmaps;
                    }

                    if (texDatas.mipmapCount === 1) {

                        texture.minFilter = LinearFilter;
                    }

                    texture.format = texDatas.format;
                    texture.needsUpdate = true;

                    if (onLoad) onLoad(texture);
                }, onProgress, onError);
            }

            return texture;
        },

        setPath: function setPath(value) {

            this.path = value;
            return this;
        }

    });

    /**
     * @author Nikos M. / https://github.com/foo123/
     *
     * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
     */

    function DataTextureLoader(manager) {

        this.manager = manager !== undefined ? manager : DefaultLoadingManager;

        // override in sub classes
        this._parser = null;
    }

    Object.assign(DataTextureLoader.prototype, {

        load: function load(url, onLoad, onProgress, onError) {

            var scope = this;

            var texture = new DataTexture();

            var loader = new FileLoader(this.manager);
            loader.setResponseType('arraybuffer');

            loader.load(url, function (buffer) {

                var texData = scope._parser(buffer);

                if (!texData) return;

                if (undefined !== texData.image) {

                    texture.image = texData.image;
                } else if (undefined !== texData.data) {

                    texture.image.width = texData.width;
                    texture.image.height = texData.height;
                    texture.image.data = texData.data;
                }

                texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
                texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

                texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
                texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

                texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

                if (undefined !== texData.format) {

                    texture.format = texData.format;
                }
                if (undefined !== texData.type) {

                    texture.type = texData.type;
                }

                if (undefined !== texData.mipmaps) {

                    texture.mipmaps = texData.mipmaps;
                }

                if (1 === texData.mipmapCount) {

                    texture.minFilter = LinearFilter;
                }

                texture.needsUpdate = true;

                if (onLoad) onLoad(texture, texData);
            }, onProgress, onError);

            return texture;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function ImageLoader(manager) {

        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    }

    Object.assign(ImageLoader.prototype, {

        load: function load(url, onLoad, onProgress, onError) {

            if (url === undefined) url = '';

            if (this.path !== undefined) url = this.path + url;

            var scope = this;

            var cached = Cache.get(url);

            if (cached !== undefined) {

                scope.manager.itemStart(url);

                setTimeout(function () {

                    if (onLoad) onLoad(cached);

                    scope.manager.itemEnd(url);
                }, 0);

                return cached;
            }

            var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

            image.addEventListener('load', function () {

                Cache.add(url, this);

                if (onLoad) onLoad(this);

                scope.manager.itemEnd(url);
            }, false);

            /*
            image.addEventListener( 'progress', function ( event ) {
            			if ( onProgress ) onProgress( event );
            		}, false );
            */

            image.addEventListener('error', function (event) {

                if (onError) onError(event);

                scope.manager.itemEnd(url);
                scope.manager.itemError(url);
            }, false);

            if (url.substr(0, 5) !== 'data:') {

                if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
            }

            scope.manager.itemStart(url);

            image.src = url;

            return image;
        },

        setCrossOrigin: function setCrossOrigin(value) {

            this.crossOrigin = value;
            return this;
        },

        setPath: function setPath(value) {

            this.path = value;
            return this;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CubeTextureLoader(manager) {

        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    }

    Object.assign(CubeTextureLoader.prototype, {

        load: function load(urls, onLoad, onProgress, onError) {

            var texture = new CubeTexture();

            var loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.setPath(this.path);

            var loaded = 0;

            function loadTexture(i) {

                loader.load(urls[i], function (image) {

                    texture.images[i] = image;

                    loaded++;

                    if (loaded === 6) {

                        texture.needsUpdate = true;

                        if (onLoad) onLoad(texture);
                    }
                }, undefined, onError);
            }

            for (var i = 0; i < urls.length; ++i) {

                loadTexture(i);
            }

            return texture;
        },

        setCrossOrigin: function setCrossOrigin(value) {

            this.crossOrigin = value;
            return this;
        },

        setPath: function setPath(value) {

            this.path = value;
            return this;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function TextureLoader(manager) {

        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    }

    Object.assign(TextureLoader.prototype, {

        load: function load(url, onLoad, onProgress, onError) {

            var loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.setPath(this.path);

            var texture = new Texture();
            texture.image = loader.load(url, function () {

                // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
                var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;

                texture.format = isJPEG ? RGBFormat : RGBAFormat;
                texture.needsUpdate = true;

                if (onLoad !== undefined) {

                    onLoad(texture);
                }
            }, onProgress, onError);

            return texture;
        },

        setCrossOrigin: function setCrossOrigin(value) {

            this.crossOrigin = value;
            return this;
        },

        setPath: function setPath(value) {

            this.path = value;
            return this;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Light(color, intensity) {

        Object3D.call(this);

        this.type = 'Light';

        this.color = new Color(color);
        this.intensity = intensity !== undefined ? intensity : 1;

        this.receiveShadow = undefined;
    }

    Light.prototype = Object.assign(Object.create(Object3D.prototype), {

        constructor: Light,

        isLight: true,

        copy: function copy(source) {

            Object3D.prototype.copy.call(this, source);

            this.color.copy(source.color);
            this.intensity = source.intensity;

            return this;
        },

        toJSON: function toJSON(meta) {

            var data = Object3D.prototype.toJSON.call(this, meta);

            data.object.color = this.color.getHex();
            data.object.intensity = this.intensity;

            if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();

            if (this.distance !== undefined) data.object.distance = this.distance;
            if (this.angle !== undefined) data.object.angle = this.angle;
            if (this.decay !== undefined) data.object.decay = this.decay;
            if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;

            if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();

            return data;
        }

    });

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function HemisphereLight(skyColor, groundColor, intensity) {

        Light.call(this, skyColor, intensity);

        this.type = 'HemisphereLight';

        this.castShadow = undefined;

        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();

        this.groundColor = new Color(groundColor);
    }

    HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {

        constructor: HemisphereLight,

        isHemisphereLight: true,

        copy: function copy(source) {

            Light.prototype.copy.call(this, source);

            this.groundColor.copy(source.groundColor);

            return this;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function LightShadow(camera) {

        this.camera = camera;

        this.bias = 0;
        this.radius = 1;

        this.mapSize = new Vector2(512, 512);

        this.map = null;
        this.matrix = new Matrix4();
    }

    Object.assign(LightShadow.prototype, {

        copy: function copy(source) {

            this.camera = source.camera.clone();

            this.bias = source.bias;
            this.radius = source.radius;

            this.mapSize.copy(source.mapSize);

            return this;
        },

        clone: function clone() {

            return new this.constructor().copy(this);
        },

        toJSON: function toJSON() {

            var object = {};

            if (this.bias !== 0) object.bias = this.bias;
            if (this.radius !== 1) object.radius = this.radius;
            if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();

            object.camera = this.camera.toJSON(false).object;
            delete object.camera.matrix;

            return object;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function SpotLightShadow() {

        LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
    }

    SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {

        constructor: SpotLightShadow,

        isSpotLightShadow: true,

        update: function update(light) {

            var camera = this.camera;

            var fov = _Math.RAD2DEG * 2 * light.angle;
            var aspect = this.mapSize.width / this.mapSize.height;
            var far = light.distance || camera.far;

            if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {

                camera.fov = fov;
                camera.aspect = aspect;
                camera.far = far;
                camera.updateProjectionMatrix();
            }
        }

    });

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function SpotLight(color, intensity, distance, angle, penumbra, decay) {

        Light.call(this, color, intensity);

        this.type = 'SpotLight';

        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();

        this.target = new Object3D();

        Object.defineProperty(this, 'power', {
            get: function get() {
                // intensity = power per solid angle.
                // ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
                return this.intensity * Math.PI;
            },
            set: function set(power) {
                // intensity = power per solid angle.
                // ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
                this.intensity = power / Math.PI;
            }
        });

        this.distance = distance !== undefined ? distance : 0;
        this.angle = angle !== undefined ? angle : Math.PI / 3;
        this.penumbra = penumbra !== undefined ? penumbra : 0;
        this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.

        this.shadow = new SpotLightShadow();
    }

    SpotLight.prototype = Object.assign(Object.create(Light.prototype), {

        constructor: SpotLight,

        isSpotLight: true,

        copy: function copy(source) {

            Light.prototype.copy.call(this, source);

            this.distance = source.distance;
            this.angle = source.angle;
            this.penumbra = source.penumbra;
            this.decay = source.decay;

            this.target = source.target.clone();

            this.shadow = source.shadow.clone();

            return this;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function PointLight(color, intensity, distance, decay) {

        Light.call(this, color, intensity);

        this.type = 'PointLight';

        Object.defineProperty(this, 'power', {
            get: function get() {
                // intensity = power per solid angle.
                // ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
                return this.intensity * 4 * Math.PI;
            },
            set: function set(power) {
                // intensity = power per solid angle.
                // ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
                this.intensity = power / (4 * Math.PI);
            }
        });

        this.distance = distance !== undefined ? distance : 0;
        this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.

        this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));
    }

    PointLight.prototype = Object.assign(Object.create(Light.prototype), {

        constructor: PointLight,

        isPointLight: true,

        copy: function copy(source) {

            Light.prototype.copy.call(this, source);

            this.distance = source.distance;
            this.decay = source.decay;

            this.shadow = source.shadow.clone();

            return this;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function DirectionalLightShadow() {

        LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    }

    DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {

        constructor: DirectionalLightShadow

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function DirectionalLight(color, intensity) {

        Light.call(this, color, intensity);

        this.type = 'DirectionalLight';

        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();

        this.target = new Object3D();

        this.shadow = new DirectionalLightShadow();
    }

    DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {

        constructor: DirectionalLight,

        isDirectionalLight: true,

        copy: function copy(source) {

            Light.prototype.copy.call(this, source);

            this.target = source.target.clone();

            this.shadow = source.shadow.clone();

            return this;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function AmbientLight(color, intensity) {

        Light.call(this, color, intensity);

        this.type = 'AmbientLight';

        this.castShadow = undefined;
    }

    AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {

        constructor: AmbientLight,

        isAmbientLight: true

    });

    /**
     * @author abelnation / http://github.com/abelnation
     */

    function RectAreaLight(color, intensity, width, height) {

        Light.call(this, color, intensity);

        this.type = 'RectAreaLight';

        this.position.set(0, 1, 0);
        this.updateMatrix();

        this.width = width !== undefined ? width : 10;
        this.height = height !== undefined ? height : 10;

        // TODO (abelnation): distance/decay

        // TODO (abelnation): update method for RectAreaLight to update transform to lookat target

        // TODO (abelnation): shadows
    }

    // TODO (abelnation): RectAreaLight update when light shape is changed
    RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {

        constructor: RectAreaLight,

        isRectAreaLight: true,

        copy: function copy(source) {

            Light.prototype.copy.call(this, source);

            this.width = source.width;
            this.height = source.height;

            return this;
        },

        toJSON: function toJSON(meta) {

            var data = Light.prototype.toJSON.call(this, meta);

            data.object.width = this.width;
            data.object.height = this.height;

            return data;
        }

    });

    /**
     * @author tschw
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     */

    var AnimationUtils = {

        // same as Array.prototype.slice, but also works on typed arrays
        arraySlice: function arraySlice(array, from, to) {

            if (AnimationUtils.isTypedArray(array)) {

                // in ios9 array.subarray(from, undefined) will return empty array
                // but array.subarray(from) or array.subarray(from, len) is correct
                return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
            }

            return array.slice(from, to);
        },

        // converts an array to a specific type
        convertArray: function convertArray(array, type, forceClone) {

            if (!array || // let 'undefined' and 'null' pass
            !forceClone && array.constructor === type) return array;

            if (typeof type.BYTES_PER_ELEMENT === 'number') {

                return new type(array); // create typed array
            }

            return Array.prototype.slice.call(array); // create Array
        },

        isTypedArray: function isTypedArray(object) {

            return ArrayBuffer.isView(object) && !(object instanceof DataView);
        },

        // returns an array by which times and values can be sorted
        getKeyframeOrder: function getKeyframeOrder(times) {

            function compareTime(i, j) {

                return times[i] - times[j];
            }

            var n = times.length;
            var result = new Array(n);
            for (var i = 0; i !== n; ++i) {
                result[i] = i;
            }result.sort(compareTime);

            return result;
        },

        // uses the array previously returned by 'getKeyframeOrder' to sort data
        sortedArray: function sortedArray(values, stride, order) {

            var nValues = values.length;
            var result = new values.constructor(nValues);

            for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {

                var srcOffset = order[i] * stride;

                for (var j = 0; j !== stride; ++j) {

                    result[dstOffset++] = values[srcOffset + j];
                }
            }

            return result;
        },

        // function for parsing AOS keyframe formats
        flattenJSON: function flattenJSON(jsonKeys, times, values, valuePropertyName) {

            var i = 1,
                key = jsonKeys[0];

            while (key !== undefined && key[valuePropertyName] === undefined) {

                key = jsonKeys[i++];
            }

            if (key === undefined) return; // no data

            var value = key[valuePropertyName];
            if (value === undefined) return; // no data

            if (Array.isArray(value)) {

                do {

                    value = key[valuePropertyName];

                    if (value !== undefined) {

                        times.push(key.time);
                        values.push.apply(values, value); // push all elements
                    }

                    key = jsonKeys[i++];
                } while (key !== undefined);
            } else if (value.toArray !== undefined) {

                // ...assume THREE.Math-ish

                do {

                    value = key[valuePropertyName];

                    if (value !== undefined) {

                        times.push(key.time);
                        value.toArray(values, values.length);
                    }

                    key = jsonKeys[i++];
                } while (key !== undefined);
            } else {

                // otherwise push as-is

                do {

                    value = key[valuePropertyName];

                    if (value !== undefined) {

                        times.push(key.time);
                        values.push(value);
                    }

                    key = jsonKeys[i++];
                } while (key !== undefined);
            }
        }

    };

    /**
     * Abstract base class of interpolants over parametric samples.
     *
     * The parameter domain is one dimensional, typically the time or a path
     * along a curve defined by the data.
     *
     * The sample values can have any dimensionality and derived classes may
     * apply special interpretations to the data.
     *
     * This class provides the interval seek in a Template Method, deferring
     * the actual interpolation to derived classes.
     *
     * Time complexity is O(1) for linear access crossing at most two points
     * and O(log N) for random access, where N is the number of positions.
     *
     * References:
     *
     * 		http://www.oodesign.com/template-method-pattern.html
     *
     * @author tschw
     */

    function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

        this.parameterPositions = parameterPositions;
        this._cachedIndex = 0;

        this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
        this.sampleValues = sampleValues;
        this.valueSize = sampleSize;
    }

    Object.assign(Interpolant.prototype, {

        evaluate: function evaluate(t) {

            var pp = this.parameterPositions,
                i1 = this._cachedIndex,
                t1 = pp[i1],
                t0 = pp[i1 - 1];

            validate_interval: {

                seek: {

                    var right;

                    linear_scan: {
                        //- See http://jsperf.com/comparison-to-undefined/3
                        //- slower code:
                        //-
                        //- 				if ( t >= t1 || t1 === undefined ) {
                        forward_scan: if (!(t < t1)) {

                            for (var giveUpAt = i1 + 2;;) {

                                if (t1 === undefined) {

                                    if (t < t0) break forward_scan;

                                    // after end

                                    i1 = pp.length;
                                    this._cachedIndex = i1;
                                    return this.afterEnd_(i1 - 1, t, t0);
                                }

                                if (i1 === giveUpAt) break; // this loop

                                t0 = t1;
                                t1 = pp[++i1];

                                if (t < t1) {

                                    // we have arrived at the sought interval
                                    break seek;
                                }
                            }

                            // prepare binary search on the right side of the index
                            right = pp.length;
                            break linear_scan;
                        }

                        //- slower code:
                        //-					if ( t < t0 || t0 === undefined ) {
                        if (!(t >= t0)) {

                            // looping?

                            var t1global = pp[1];

                            if (t < t1global) {

                                i1 = 2; // + 1, using the scan for the details
                                t0 = t1global;
                            }

                            // linear reverse scan

                            for (var giveUpAt = i1 - 2;;) {

                                if (t0 === undefined) {

                                    // before start

                                    this._cachedIndex = 0;
                                    return this.beforeStart_(0, t, t1);
                                }

                                if (i1 === giveUpAt) break; // this loop

                                t1 = t0;
                                t0 = pp[--i1 - 1];

                                if (t >= t0) {

                                    // we have arrived at the sought interval
                                    break seek;
                                }
                            }

                            // prepare binary search on the left side of the index
                            right = i1;
                            i1 = 0;
                            break linear_scan;
                        }

                        // the interval is valid

                        break validate_interval;
                    } // linear scan

                    // binary search

                    while (i1 < right) {

                        var mid = i1 + right >>> 1;

                        if (t < pp[mid]) {

                            right = mid;
                        } else {

                            i1 = mid + 1;
                        }
                    }

                    t1 = pp[i1];
                    t0 = pp[i1 - 1];

                    // check boundary cases, again

                    if (t0 === undefined) {

                        this._cachedIndex = 0;
                        return this.beforeStart_(0, t, t1);
                    }

                    if (t1 === undefined) {

                        i1 = pp.length;
                        this._cachedIndex = i1;
                        return this.afterEnd_(i1 - 1, t0, t);
                    }
                } // seek

                this._cachedIndex = i1;

                this.intervalChanged_(i1, t0, t1);
            } // validate_interval

            return this.interpolate_(i1, t0, t, t1);
        },

        settings: null, // optional, subclass-specific settings structure
        // Note: The indirection allows central control of many interpolants.

        // --- Protected interface

        DefaultSettings_: {},

        getSettings_: function getSettings_() {

            return this.settings || this.DefaultSettings_;
        },

        copySampleValue_: function copySampleValue_(index) {

            // copies a sample value to the result buffer

            var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                offset = index * stride;

            for (var i = 0; i !== stride; ++i) {

                result[i] = values[offset + i];
            }

            return result;
        },

        // Template methods for derived classes:

        interpolate_: function interpolate_(i1, t0, t, t1) {

            throw new Error("call to abstract method");
            // implementations shall return this.resultBuffer
        },

        intervalChanged_: function intervalChanged_(i1, t0, t1) {

            // empty

        }

    });

    //!\ DECLARE ALIAS AFTER assign prototype !
    Object.assign(Interpolant.prototype, {

        //( 0, t, t0 ), returns this.resultBuffer
        beforeStart_: Interpolant.prototype.copySampleValue_,

        //( N-1, tN-1, t ), returns this.resultBuffer
        afterEnd_: Interpolant.prototype.copySampleValue_

    });

    /**
     * Fast and simple cubic spline interpolant.
     *
     * It was derived from a Hermitian construction setting the first derivative
     * at each sample position to the linear slope between neighboring positions
     * over their parameter interval.
     *
     * @author tschw
     */

    function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);

        this._weightPrev = -0;
        this._offsetPrev = -0;
        this._weightNext = -0;
        this._offsetNext = -0;
    }

    CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {

        constructor: CubicInterpolant,

        DefaultSettings_: {

            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding

        },

        intervalChanged_: function intervalChanged_(i1, t0, t1) {

            var pp = this.parameterPositions,
                iPrev = i1 - 2,
                iNext = i1 + 1,
                tPrev = pp[iPrev],
                tNext = pp[iNext];

            if (tPrev === undefined) {

                switch (this.getSettings_().endingStart) {

                    case ZeroSlopeEnding:

                        // f'(t0) = 0
                        iPrev = i1;
                        tPrev = 2 * t0 - t1;

                        break;

                    case WrapAroundEnding:

                        // use the other end of the curve
                        iPrev = pp.length - 2;
                        tPrev = t0 + pp[iPrev] - pp[iPrev + 1];

                        break;

                    default:
                        // ZeroCurvatureEnding

                        // f''(t0) = 0 a.k.a. Natural Spline
                        iPrev = i1;
                        tPrev = t1;

                }
            }

            if (tNext === undefined) {

                switch (this.getSettings_().endingEnd) {

                    case ZeroSlopeEnding:

                        // f'(tN) = 0
                        iNext = i1;
                        tNext = 2 * t1 - t0;

                        break;

                    case WrapAroundEnding:

                        // use the other end of the curve
                        iNext = 1;
                        tNext = t1 + pp[1] - pp[0];

                        break;

                    default:
                        // ZeroCurvatureEnding

                        // f''(tN) = 0, a.k.a. Natural Spline
                        iNext = i1 - 1;
                        tNext = t0;

                }
            }

            var halfDt = (t1 - t0) * 0.5,
                stride = this.valueSize;

            this._weightPrev = halfDt / (t0 - tPrev);
            this._weightNext = halfDt / (tNext - t1);
            this._offsetPrev = iPrev * stride;
            this._offsetNext = iNext * stride;
        },

        interpolate_: function interpolate_(i1, t0, t, t1) {

            var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                o1 = i1 * stride,
                o0 = o1 - stride,
                oP = this._offsetPrev,
                oN = this._offsetNext,
                wP = this._weightPrev,
                wN = this._weightNext,
                p = (t - t0) / (t1 - t0),
                pp = p * p,
                ppp = pp * p;

            // evaluate polynomials

            var sP = -wP * ppp + 2 * wP * pp - wP * p;
            var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
            var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
            var sN = wN * ppp - wN * pp;

            // combine data linearly

            for (var i = 0; i !== stride; ++i) {

                result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
            }

            return result;
        }

    });

    /**
     * @author tschw
     */

    function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }

    LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {

        constructor: LinearInterpolant,

        interpolate_: function interpolate_(i1, t0, t, t1) {

            var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                offset1 = i1 * stride,
                offset0 = offset1 - stride,
                weight1 = (t - t0) / (t1 - t0),
                weight0 = 1 - weight1;

            for (var i = 0; i !== stride; ++i) {

                result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
            }

            return result;
        }

    });

    /**
     *
     * Interpolant that evaluates to the sample value at the position preceeding
     * the parameter.
     *
     * @author tschw
     */

    function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }

    DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {

        constructor: DiscreteInterpolant,

        interpolate_: function interpolate_(i1, t0, t, t1) {

            return this.copySampleValue_(i1 - 1);
        }

    });

    var KeyframeTrackPrototype;

    KeyframeTrackPrototype = {

        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,

        DefaultInterpolation: InterpolateLinear,

        InterpolantFactoryMethodDiscrete: function InterpolantFactoryMethodDiscrete(result) {

            return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        },

        InterpolantFactoryMethodLinear: function InterpolantFactoryMethodLinear(result) {

            return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        },

        InterpolantFactoryMethodSmooth: function InterpolantFactoryMethodSmooth(result) {

            return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        },

        setInterpolation: function setInterpolation(interpolation) {

            var factoryMethod;

            switch (interpolation) {

                case InterpolateDiscrete:

                    factoryMethod = this.InterpolantFactoryMethodDiscrete;

                    break;

                case InterpolateLinear:

                    factoryMethod = this.InterpolantFactoryMethodLinear;

                    break;

                case InterpolateSmooth:

                    factoryMethod = this.InterpolantFactoryMethodSmooth;

                    break;

            }

            if (factoryMethod === undefined) {

                var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;

                if (this.createInterpolant === undefined) {

                    // fall back to default, unless the default itself is messed up
                    if (interpolation !== this.DefaultInterpolation) {

                        this.setInterpolation(this.DefaultInterpolation);
                    } else {

                        throw new Error(message); // fatal, in this case
                    }
                }

                console.warn(message);
                return;
            }

            this.createInterpolant = factoryMethod;
        },

        getInterpolation: function getInterpolation() {

            switch (this.createInterpolant) {

                case this.InterpolantFactoryMethodDiscrete:

                    return InterpolateDiscrete;

                case this.InterpolantFactoryMethodLinear:

                    return InterpolateLinear;

                case this.InterpolantFactoryMethodSmooth:

                    return InterpolateSmooth;

            }
        },

        getValueSize: function getValueSize() {

            return this.values.length / this.times.length;
        },

        // move all keyframes either forwards or backwards in time
        shift: function shift(timeOffset) {

            if (timeOffset !== 0.0) {

                var times = this.times;

                for (var i = 0, n = times.length; i !== n; ++i) {

                    times[i] += timeOffset;
                }
            }

            return this;
        },

        // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
        scale: function scale(timeScale) {

            if (timeScale !== 1.0) {

                var times = this.times;

                for (var i = 0, n = times.length; i !== n; ++i) {

                    times[i] *= timeScale;
                }
            }

            return this;
        },

        // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
        // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
        trim: function trim(startTime, endTime) {

            var times = this.times,
                nKeys = times.length,
                from = 0,
                to = nKeys - 1;

            while (from !== nKeys && times[from] < startTime) {
                ++from;
            }while (to !== -1 && times[to] > endTime) {
                --to;
            }++to; // inclusive -> exclusive bound

            if (from !== 0 || to !== nKeys) {

                // empty tracks are forbidden, so keep at least one keyframe
                if (from >= to) to = Math.max(to, 1), from = to - 1;

                var stride = this.getValueSize();
                this.times = AnimationUtils.arraySlice(times, from, to);
                this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
            }

            return this;
        },

        // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
        validate: function validate() {

            var valid = true;

            var valueSize = this.getValueSize();
            if (valueSize - Math.floor(valueSize) !== 0) {

                console.error("invalid value size in track", this);
                valid = false;
            }

            var times = this.times,
                values = this.values,
                nKeys = times.length;

            if (nKeys === 0) {

                console.error("track is empty", this);
                valid = false;
            }

            var prevTime = null;

            for (var i = 0; i !== nKeys; i++) {

                var currTime = times[i];

                if (typeof currTime === 'number' && isNaN(currTime)) {

                    console.error("time is not a valid number", this, i, currTime);
                    valid = false;
                    break;
                }

                if (prevTime !== null && prevTime > currTime) {

                    console.error("out of order keys", this, i, currTime, prevTime);
                    valid = false;
                    break;
                }

                prevTime = currTime;
            }

            if (values !== undefined) {

                if (AnimationUtils.isTypedArray(values)) {

                    for (var i = 0, n = values.length; i !== n; ++i) {

                        var value = values[i];

                        if (isNaN(value)) {

                            console.error("value is not a valid number", this, i, value);
                            valid = false;
                            break;
                        }
                    }
                }
            }

            return valid;
        },

        // removes equivalent sequential keys as common in morph target sequences
        // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
        optimize: function optimize() {

            var times = this.times,
                values = this.values,
                stride = this.getValueSize(),
                smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
                writeIndex = 1,
                lastIndex = times.length - 1;

            for (var i = 1; i < lastIndex; ++i) {

                var keep = false;

                var time = times[i];
                var timeNext = times[i + 1];

                // remove adjacent keyframes scheduled at the same time

                if (time !== timeNext && (i !== 1 || time !== time[0])) {

                    if (!smoothInterpolation) {

                        // remove unnecessary keyframes same as their neighbors

                        var offset = i * stride,
                            offsetP = offset - stride,
                            offsetN = offset + stride;

                        for (var j = 0; j !== stride; ++j) {

                            var value = values[offset + j];

                            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {

                                keep = true;
                                break;
                            }
                        }
                    } else keep = true;
                }

                // in-place compaction

                if (keep) {

                    if (i !== writeIndex) {

                        times[writeIndex] = times[i];

                        var readOffset = i * stride,
                            writeOffset = writeIndex * stride;

                        for (var j = 0; j !== stride; ++j) {

                            values[writeOffset + j] = values[readOffset + j];
                        }
                    }

                    ++writeIndex;
                }
            }

            // flush last keyframe (compaction looks ahead)

            if (lastIndex > 0) {

                times[writeIndex] = times[lastIndex];

                for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {

                    values[writeOffset + j] = values[readOffset + j];
                }++writeIndex;
            }

            if (writeIndex !== times.length) {

                this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
                this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
            }

            return this;
        }

    };

    function KeyframeTrackConstructor(name, times, values, interpolation) {

        if (name === undefined) throw new Error("track name is undefined");

        if (times === undefined || times.length === 0) {

            throw new Error("no keyframes in track named " + name);
        }

        this.name = name;

        this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
        this.values = AnimationUtils.convertArray(values, this.ValueBufferType);

        this.setInterpolation(interpolation || this.DefaultInterpolation);

        this.validate();
        this.optimize();
    }

    /**
     *
     * A Track of vectored keyframe values.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function VectorKeyframeTrack(name, times, values, interpolation) {

        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }

    VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {

        constructor: VectorKeyframeTrack,

        ValueTypeName: 'vector'

        // ValueBufferType is inherited

        // DefaultInterpolation is inherited

    });

    /**
     * Spherical linear unit quaternion interpolant.
     *
     * @author tschw
     */

    function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }

    QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {

        constructor: QuaternionLinearInterpolant,

        interpolate_: function interpolate_(i1, t0, t, t1) {

            var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                offset = i1 * stride,
                alpha = (t - t0) / (t1 - t0);

            for (var end = offset + stride; offset !== end; offset += 4) {

                Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
            }

            return result;
        }

    });

    /**
     *
     * A Track of quaternion keyframe values.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function QuaternionKeyframeTrack(name, times, values, interpolation) {

        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }

    QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {

        constructor: QuaternionKeyframeTrack,

        ValueTypeName: 'quaternion',

        // ValueBufferType is inherited

        DefaultInterpolation: InterpolateLinear,

        InterpolantFactoryMethodLinear: function InterpolantFactoryMethodLinear(result) {

            return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        },

        InterpolantFactoryMethodSmooth: undefined // not yet implemented

    });

    /**
     *
     * A Track of numeric keyframe values.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function NumberKeyframeTrack(name, times, values, interpolation) {

        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }

    NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {

        constructor: NumberKeyframeTrack,

        ValueTypeName: 'number'

        // ValueBufferType is inherited

        // DefaultInterpolation is inherited

    });

    /**
     *
     * A Track that interpolates Strings
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function StringKeyframeTrack(name, times, values, interpolation) {

        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }

    StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {

        constructor: StringKeyframeTrack,

        ValueTypeName: 'string',
        ValueBufferType: Array,

        DefaultInterpolation: InterpolateDiscrete,

        InterpolantFactoryMethodLinear: undefined,

        InterpolantFactoryMethodSmooth: undefined

    });

    /**
     *
     * A Track of Boolean keyframe values.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function BooleanKeyframeTrack(name, times, values) {

        KeyframeTrackConstructor.call(this, name, times, values);
    }

    BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {

        constructor: BooleanKeyframeTrack,

        ValueTypeName: 'bool',
        ValueBufferType: Array,

        DefaultInterpolation: InterpolateDiscrete,

        InterpolantFactoryMethodLinear: undefined,
        InterpolantFactoryMethodSmooth: undefined

        // Note: Actually this track could have a optimized / compressed
        // representation of a single value and a custom interpolant that
        // computes "firstValue ^ isOdd( index )".

    });

    /**
     *
     * A Track of keyframe values that represent color.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function ColorKeyframeTrack(name, times, values, interpolation) {

        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }

    ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {

        constructor: ColorKeyframeTrack,

        ValueTypeName: 'color'

        // ValueBufferType is inherited

        // DefaultInterpolation is inherited


        // Note: Very basic implementation and nothing special yet.
        // However, this is the place for color space parameterization.

    });

    /**
     *
     * A timed sequence of keyframes for a specific property.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function KeyframeTrack(name, times, values, interpolation) {

        KeyframeTrackConstructor.apply(this, arguments);
    }

    KeyframeTrack.prototype = KeyframeTrackPrototype;
    KeyframeTrackPrototype.constructor = KeyframeTrack;

    // Static methods:

    Object.assign(KeyframeTrack, {

        // Serialization (in static context, because of constructor invocation
        // and automatic invocation of .toJSON):

        parse: function parse(json) {

            if (json.type === undefined) {

                throw new Error("track type undefined, can not parse");
            }

            var trackType = KeyframeTrack._getTrackTypeForValueTypeName(json.type);

            if (json.times === undefined) {

                var times = [],
                    values = [];

                AnimationUtils.flattenJSON(json.keys, times, values, 'value');

                json.times = times;
                json.values = values;
            }

            // derived classes can define a static parse method
            if (trackType.parse !== undefined) {

                return trackType.parse(json);
            } else {

                // by default, we asssume a constructor compatible with the base
                return new trackType(json.name, json.times, json.values, json.interpolation);
            }
        },

        toJSON: function toJSON(track) {

            var trackType = track.constructor;

            var json;

            // derived classes can define a static toJSON method
            if (trackType.toJSON !== undefined) {

                json = trackType.toJSON(track);
            } else {

                // by default, we assume the data can be serialized as-is
                json = {

                    'name': track.name,
                    'times': AnimationUtils.convertArray(track.times, Array),
                    'values': AnimationUtils.convertArray(track.values, Array)

                };

                var interpolation = track.getInterpolation();

                if (interpolation !== track.DefaultInterpolation) {

                    json.interpolation = interpolation;
                }
            }

            json.type = track.ValueTypeName; // mandatory

            return json;
        },

        _getTrackTypeForValueTypeName: function _getTrackTypeForValueTypeName(typeName) {

            switch (typeName.toLowerCase()) {

                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":

                    return NumberKeyframeTrack;

                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":

                    return VectorKeyframeTrack;

                case "color":

                    return ColorKeyframeTrack;

                case "quaternion":

                    return QuaternionKeyframeTrack;

                case "bool":
                case "boolean":

                    return BooleanKeyframeTrack;

                case "string":

                    return StringKeyframeTrack;

            }

            throw new Error("Unsupported typeName: " + typeName);
        }

    });

    /**
     *
     * Reusable set of Tracks that represent an animation.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     */

    function AnimationClip(name, duration, tracks) {

        this.name = name;
        this.tracks = tracks;
        this.duration = duration !== undefined ? duration : -1;

        this.uuid = _Math.generateUUID();

        // this means it should figure out its duration by scanning the tracks
        if (this.duration < 0) {

            this.resetDuration();
        }

        this.optimize();
    }

    Object.assign(AnimationClip, {

        parse: function parse(json) {

            var tracks = [],
                jsonTracks = json.tracks,
                frameTime = 1.0 / (json.fps || 1.0);

            for (var i = 0, n = jsonTracks.length; i !== n; ++i) {

                tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));
            }

            return new AnimationClip(json.name, json.duration, tracks);
        },

        toJSON: function toJSON(clip) {

            var tracks = [],
                clipTracks = clip.tracks;

            var json = {

                'name': clip.name,
                'duration': clip.duration,
                'tracks': tracks

            };

            for (var i = 0, n = clipTracks.length; i !== n; ++i) {

                tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
            }

            return json;
        },

        CreateFromMorphTargetSequence: function CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {

            var numMorphTargets = morphTargetSequence.length;
            var tracks = [];

            for (var i = 0; i < numMorphTargets; i++) {

                var times = [];
                var values = [];

                times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);

                values.push(0, 1, 0);

                var order = AnimationUtils.getKeyframeOrder(times);
                times = AnimationUtils.sortedArray(times, 1, order);
                values = AnimationUtils.sortedArray(values, 1, order);

                // if there is a key at the first frame, duplicate it as the
                // last frame as well for perfect loop.
                if (!noLoop && times[0] === 0) {

                    times.push(numMorphTargets);
                    values.push(values[0]);
                }

                tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
            }

            return new AnimationClip(name, -1, tracks);
        },

        findByName: function findByName(objectOrClipArray, name) {

            var clipArray = objectOrClipArray;

            if (!Array.isArray(objectOrClipArray)) {

                var o = objectOrClipArray;
                clipArray = o.geometry && o.geometry.animations || o.animations;
            }

            for (var i = 0; i < clipArray.length; i++) {

                if (clipArray[i].name === name) {

                    return clipArray[i];
                }
            }

            return null;
        },

        CreateClipsFromMorphTargetSequences: function CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {

            var animationToMorphTargets = {};

            // tested with https://regex101.com/ on trick sequences
            // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
            var pattern = /^([\w-]*?)([\d]+)$/;

            // sort morph target names into animation groups based
            // patterns like Walk_001, Walk_002, Run_001, Run_002
            for (var i = 0, il = morphTargets.length; i < il; i++) {

                var morphTarget = morphTargets[i];
                var parts = morphTarget.name.match(pattern);

                if (parts && parts.length > 1) {

                    var name = parts[1];

                    var animationMorphTargets = animationToMorphTargets[name];
                    if (!animationMorphTargets) {

                        animationToMorphTargets[name] = animationMorphTargets = [];
                    }

                    animationMorphTargets.push(morphTarget);
                }
            }

            var clips = [];

            for (var name in animationToMorphTargets) {

                clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
            }

            return clips;
        },

        // parse the animation.hierarchy format
        parseAnimation: function parseAnimation(animation, bones) {

            if (!animation) {

                console.error("  no animation in JSONLoader data");
                return null;
            }

            var addNonemptyTrack = function addNonemptyTrack(trackType, trackName, animationKeys, propertyName, destTracks) {

                // only return track if there are actually keys.
                if (animationKeys.length !== 0) {

                    var times = [];
                    var values = [];

                    AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);

                    // empty keys are filtered out, so check again
                    if (times.length !== 0) {

                        destTracks.push(new trackType(trackName, times, values));
                    }
                }
            };

            var tracks = [];

            var clipName = animation.name || 'default';
            // automatic length determination in AnimationClip.
            var duration = animation.length || -1;
            var fps = animation.fps || 30;

            var hierarchyTracks = animation.hierarchy || [];

            for (var h = 0; h < hierarchyTracks.length; h++) {

                var animationKeys = hierarchyTracks[h].keys;

                // skip empty tracks
                if (!animationKeys || animationKeys.length === 0) continue;

                // process morph targets in a way exactly compatible
                // with AnimationHandler.init( animation )
                if (animationKeys[0].morphTargets) {

                    // figure out all morph targets used in this track
                    var morphTargetNames = {};

                    for (var k = 0; k < animationKeys.length; k++) {

                        if (animationKeys[k].morphTargets) {

                            for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {

                                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                            }
                        }
                    }

                    // create a track for each morph target with all zero
                    // morphTargetInfluences except for the keys in which
                    // the morphTarget is named.
                    for (var morphTargetName in morphTargetNames) {

                        var times = [];
                        var values = [];

                        for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {

                            var animationKey = animationKeys[k];

                            times.push(animationKey.time);
                            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                        }

                        tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                    }

                    duration = morphTargetNames.length * (fps || 1.0);
                } else {

                    // ...assume skeletal animation

                    var boneName = '.bones[' + bones[h].name + ']';

                    addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);

                    addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);

                    addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
                }
            }

            if (tracks.length === 0) {

                return null;
            }

            var clip = new AnimationClip(clipName, duration, tracks);

            return clip;
        }

    });

    Object.assign(AnimationClip.prototype, {

        resetDuration: function resetDuration() {

            var tracks = this.tracks,
                duration = 0;

            for (var i = 0, n = tracks.length; i !== n; ++i) {

                var track = this.tracks[i];

                duration = Math.max(duration, track.times[track.times.length - 1]);
            }

            this.duration = duration;
        },

        trim: function trim() {

            for (var i = 0; i < this.tracks.length; i++) {

                this.tracks[i].trim(0, this.duration);
            }

            return this;
        },

        optimize: function optimize() {

            for (var i = 0; i < this.tracks.length; i++) {

                this.tracks[i].optimize();
            }

            return this;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function MaterialLoader(manager) {

        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
        this.textures = {};
    }

    Object.assign(MaterialLoader.prototype, {

        load: function load(url, onLoad, onProgress, onError) {

            var scope = this;

            var loader = new FileLoader(scope.manager);
            loader.setResponseType('json');
            loader.load(url, function (json) {

                onLoad(scope.parse(json));
            }, onProgress, onError);
        },

        setTextures: function setTextures(value) {

            this.textures = value;
        },

        parse: function parse(json) {

            var textures = this.textures;

            function getTexture(name) {

                if (textures[name] === undefined) {

                    console.warn('THREE.MaterialLoader: Undefined texture', name);
                }

                return textures[name];
            }

            var material = new Materials[json.type]();

            if (json.uuid !== undefined) material.uuid = json.uuid;
            if (json.name !== undefined) material.name = json.name;
            if (json.color !== undefined) material.color.setHex(json.color);
            if (json.roughness !== undefined) material.roughness = json.roughness;
            if (json.metalness !== undefined) material.metalness = json.metalness;
            if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
            if (json.specular !== undefined) material.specular.setHex(json.specular);
            if (json.shininess !== undefined) material.shininess = json.shininess;
            if (json.clearCoat !== undefined) material.clearCoat = json.clearCoat;
            if (json.clearCoatRoughness !== undefined) material.clearCoatRoughness = json.clearCoatRoughness;
            if (json.uniforms !== undefined) material.uniforms = json.uniforms;
            if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
            if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
            if (json.vertexColors !== undefined) material.vertexColors = json.vertexColors;
            if (json.fog !== undefined) material.fog = json.fog;
            if (json.shading !== undefined) material.shading = json.shading;
            if (json.blending !== undefined) material.blending = json.blending;
            if (json.side !== undefined) material.side = json.side;
            if (json.opacity !== undefined) material.opacity = json.opacity;
            if (json.transparent !== undefined) material.transparent = json.transparent;
            if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
            if (json.depthTest !== undefined) material.depthTest = json.depthTest;
            if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
            if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
            if (json.wireframe !== undefined) material.wireframe = json.wireframe;
            if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
            if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
            if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
            if (json.skinning !== undefined) material.skinning = json.skinning;
            if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;

            // for PointsMaterial

            if (json.size !== undefined) material.size = json.size;
            if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;

            // maps

            if (json.map !== undefined) material.map = getTexture(json.map);

            if (json.alphaMap !== undefined) {

                material.alphaMap = getTexture(json.alphaMap);
                material.transparent = true;
            }

            if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
            if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;

            if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
            if (json.normalScale !== undefined) {

                var normalScale = json.normalScale;

                if (Array.isArray(normalScale) === false) {

                    // Blender exporter used to export a scalar. See #7459

                    normalScale = [normalScale, normalScale];
                }

                material.normalScale = new Vector2().fromArray(normalScale);
            }

            if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
            if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
            if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;

            if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
            if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);

            if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
            if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;

            if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);

            if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);

            if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;

            if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
            if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;

            if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
            if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;

            if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);

            return material;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function BufferGeometryLoader(manager) {

        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    }

    Object.assign(BufferGeometryLoader.prototype, {

        load: function load(url, onLoad, onProgress, onError) {

            var scope = this;

            var loader = new FileLoader(scope.manager);
            loader.setResponseType('json');
            loader.load(url, function (json) {

                onLoad(scope.parse(json));
            }, onProgress, onError);
        },

        parse: function parse(json) {

            var geometry = new BufferGeometry();

            var index = json.data.index;

            if (index !== undefined) {

                var typedArray = new TYPED_ARRAYS[index.type](index.array);
                geometry.setIndex(new BufferAttribute(typedArray, 1));
            }

            var attributes = json.data.attributes;

            for (var key in attributes) {

                var attribute = attributes[key];
                var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);

                geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
            }

            var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

            if (groups !== undefined) {

                for (var i = 0, n = groups.length; i !== n; ++i) {

                    var group = groups[i];

                    geometry.addGroup(group.start, group.count, group.materialIndex);
                }
            }

            var boundingSphere = json.data.boundingSphere;

            if (boundingSphere !== undefined) {

                var center = new Vector3();

                if (boundingSphere.center !== undefined) {

                    center.fromArray(boundingSphere.center);
                }

                geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
            }

            return geometry;
        }

    });

    var TYPED_ARRAYS = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: Uint8ClampedArray,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function Loader() {

        this.onLoadStart = function () {};
        this.onLoadProgress = function () {};
        this.onLoadComplete = function () {};
    }

    Loader.Handlers = {

        handlers: [],

        add: function add(regex, loader) {

            this.handlers.push(regex, loader);
        },

        get: function get(file) {

            var handlers = this.handlers;

            for (var i = 0, l = handlers.length; i < l; i += 2) {

                var regex = handlers[i];
                var loader = handlers[i + 1];

                if (regex.test(file)) {

                    return loader;
                }
            }

            return null;
        }

    };

    Object.assign(Loader.prototype, {

        crossOrigin: undefined,

        extractUrlBase: function extractUrlBase(url) {

            var parts = url.split('/');

            if (parts.length === 1) return './';

            parts.pop();

            return parts.join('/') + '/';
        },

        initMaterials: function initMaterials(materials, texturePath, crossOrigin) {

            var array = [];

            for (var i = 0; i < materials.length; ++i) {

                array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
            }

            return array;
        },

        createMaterial: function () {

            var BlendingMode = {
                NoBlending: NoBlending,
                NormalBlending: NormalBlending,
                AdditiveBlending: AdditiveBlending,
                SubtractiveBlending: SubtractiveBlending,
                MultiplyBlending: MultiplyBlending,
                CustomBlending: CustomBlending
            };

            var color = new Color();
            var textureLoader = new TextureLoader();
            var materialLoader = new MaterialLoader();

            return function createMaterial(m, texturePath, crossOrigin) {

                // convert from old material format

                var textures = {};

                function loadTexture(path, repeat, offset, wrap, anisotropy) {

                    var fullPath = texturePath + path;
                    var loader = Loader.Handlers.get(fullPath);

                    var texture;

                    if (loader !== null) {

                        texture = loader.load(fullPath);
                    } else {

                        textureLoader.setCrossOrigin(crossOrigin);
                        texture = textureLoader.load(fullPath);
                    }

                    if (repeat !== undefined) {

                        texture.repeat.fromArray(repeat);

                        if (repeat[0] !== 1) texture.wrapS = RepeatWrapping;
                        if (repeat[1] !== 1) texture.wrapT = RepeatWrapping;
                    }

                    if (offset !== undefined) {

                        texture.offset.fromArray(offset);
                    }

                    if (wrap !== undefined) {

                        if (wrap[0] === 'repeat') texture.wrapS = RepeatWrapping;
                        if (wrap[0] === 'mirror') texture.wrapS = MirroredRepeatWrapping;

                        if (wrap[1] === 'repeat') texture.wrapT = RepeatWrapping;
                        if (wrap[1] === 'mirror') texture.wrapT = MirroredRepeatWrapping;
                    }

                    if (anisotropy !== undefined) {

                        texture.anisotropy = anisotropy;
                    }

                    var uuid = _Math.generateUUID();

                    textures[uuid] = texture;

                    return uuid;
                }

                //

                var json = {
                    uuid: _Math.generateUUID(),
                    type: 'MeshLambertMaterial'
                };

                for (var name in m) {

                    var value = m[name];

                    switch (name) {

                        case 'DbgColor':
                        case 'DbgIndex':
                        case 'opticalDensity':
                        case 'illumination':
                            break;
                        case 'DbgName':
                            json.name = value;
                            break;
                        case 'blending':
                            json.blending = BlendingMode[value];
                            break;
                        case 'colorAmbient':
                        case 'mapAmbient':
                            console.warn('THREE.Loader.createMaterial:', name, 'is no longer supported.');
                            break;
                        case 'colorDiffuse':
                            json.color = color.fromArray(value).getHex();
                            break;
                        case 'colorSpecular':
                            json.specular = color.fromArray(value).getHex();
                            break;
                        case 'colorEmissive':
                            json.emissive = color.fromArray(value).getHex();
                            break;
                        case 'specularCoef':
                            json.shininess = value;
                            break;
                        case 'shading':
                            if (value.toLowerCase() === 'basic') json.type = 'MeshBasicMaterial';
                            if (value.toLowerCase() === 'phong') json.type = 'MeshPhongMaterial';
                            if (value.toLowerCase() === 'standard') json.type = 'MeshStandardMaterial';
                            break;
                        case 'mapDiffuse':
                            json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                            break;
                        case 'mapDiffuseRepeat':
                        case 'mapDiffuseOffset':
                        case 'mapDiffuseWrap':
                        case 'mapDiffuseAnisotropy':
                            break;
                        case 'mapEmissive':
                            json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
                            break;
                        case 'mapEmissiveRepeat':
                        case 'mapEmissiveOffset':
                        case 'mapEmissiveWrap':
                        case 'mapEmissiveAnisotropy':
                            break;
                        case 'mapLight':
                            json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                            break;
                        case 'mapLightRepeat':
                        case 'mapLightOffset':
                        case 'mapLightWrap':
                        case 'mapLightAnisotropy':
                            break;
                        case 'mapAO':
                            json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                            break;
                        case 'mapAORepeat':
                        case 'mapAOOffset':
                        case 'mapAOWrap':
                        case 'mapAOAnisotropy':
                            break;
                        case 'mapBump':
                            json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                            break;
                        case 'mapBumpScale':
                            json.bumpScale = value;
                            break;
                        case 'mapBumpRepeat':
                        case 'mapBumpOffset':
                        case 'mapBumpWrap':
                        case 'mapBumpAnisotropy':
                            break;
                        case 'mapNormal':
                            json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                            break;
                        case 'mapNormalFactor':
                            json.normalScale = [value, value];
                            break;
                        case 'mapNormalRepeat':
                        case 'mapNormalOffset':
                        case 'mapNormalWrap':
                        case 'mapNormalAnisotropy':
                            break;
                        case 'mapSpecular':
                            json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                            break;
                        case 'mapSpecularRepeat':
                        case 'mapSpecularOffset':
                        case 'mapSpecularWrap':
                        case 'mapSpecularAnisotropy':
                            break;
                        case 'mapMetalness':
                            json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
                            break;
                        case 'mapMetalnessRepeat':
                        case 'mapMetalnessOffset':
                        case 'mapMetalnessWrap':
                        case 'mapMetalnessAnisotropy':
                            break;
                        case 'mapRoughness':
                            json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
                            break;
                        case 'mapRoughnessRepeat':
                        case 'mapRoughnessOffset':
                        case 'mapRoughnessWrap':
                        case 'mapRoughnessAnisotropy':
                            break;
                        case 'mapAlpha':
                            json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                            break;
                        case 'mapAlphaRepeat':
                        case 'mapAlphaOffset':
                        case 'mapAlphaWrap':
                        case 'mapAlphaAnisotropy':
                            break;
                        case 'flipSided':
                            json.side = BackSide;
                            break;
                        case 'doubleSided':
                            json.side = DoubleSide;
                            break;
                        case 'transparency':
                            console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');
                            json.opacity = value;
                            break;
                        case 'depthTest':
                        case 'depthWrite':
                        case 'colorWrite':
                        case 'opacity':
                        case 'reflectivity':
                        case 'transparent':
                        case 'visible':
                        case 'wireframe':
                            json[name] = value;
                            break;
                        case 'vertexColors':
                            if (value === true) json.vertexColors = VertexColors;
                            if (value === 'face') json.vertexColors = FaceColors;
                            break;
                        default:
                            console.error('THREE.Loader.createMaterial: Unsupported', name, value);
                            break;

                    }
                }

                if (json.type === 'MeshBasicMaterial') delete json.emissive;
                if (json.type !== 'MeshPhongMaterial') delete json.specular;

                if (json.opacity < 1) json.transparent = true;

                materialLoader.setTextures(textures);

                return materialLoader.parse(json);
            };
        }()

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function JSONLoader(manager) {

        if (typeof manager === 'boolean') {

            console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');
            manager = undefined;
        }

        this.manager = manager !== undefined ? manager : DefaultLoadingManager;

        this.withCredentials = false;
    }

    Object.assign(JSONLoader.prototype, {

        load: function load(url, onLoad, onProgress, onError) {

            var scope = this;

            var texturePath = this.texturePath && typeof this.texturePath === "string" ? this.texturePath : Loader.prototype.extractUrlBase(url);

            var loader = new FileLoader(this.manager);
            loader.setResponseType('json');
            loader.setWithCredentials(this.withCredentials);
            loader.load(url, function (json) {

                var metadata = json.metadata;

                if (metadata !== undefined) {

                    var type = metadata.type;

                    if (type !== undefined) {

                        if (type.toLowerCase() === 'object') {

                            console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');
                            return;
                        }

                        if (type.toLowerCase() === 'scene') {

                            console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.');
                            return;
                        }
                    }
                }

                var object = scope.parse(json, texturePath);
                onLoad(object.geometry, object.materials);
            }, onProgress, onError);
        },

        setTexturePath: function setTexturePath(value) {

            this.texturePath = value;
        },

        parse: function () {

            function parseModel(json, geometry) {

                function isBitSet(value, position) {

                    return value & 1 << position;
                }

                var i,
                    j,
                    fi,
                    offset,
                    zLength,
                    colorIndex,
                    normalIndex,
                    uvIndex,
                    materialIndex,
                    type,
                    isQuad,
                    hasMaterial,
                    hasFaceVertexUv,
                    hasFaceNormal,
                    hasFaceVertexNormal,
                    hasFaceColor,
                    hasFaceVertexColor,
                    vertex,
                    face,
                    faceA,
                    faceB,
                    hex,
                    normal,
                    uvLayer,
                    uv,
                    u,
                    v,
                    faces = json.faces,
                    vertices = json.vertices,
                    normals = json.normals,
                    colors = json.colors,
                    scale = json.scale,
                    nUvLayers = 0;

                if (json.uvs !== undefined) {

                    // disregard empty arrays

                    for (i = 0; i < json.uvs.length; i++) {

                        if (json.uvs[i].length) nUvLayers++;
                    }

                    for (i = 0; i < nUvLayers; i++) {

                        geometry.faceVertexUvs[i] = [];
                    }
                }

                offset = 0;
                zLength = vertices.length;

                while (offset < zLength) {

                    vertex = new Vector3();

                    vertex.x = vertices[offset++] * scale;
                    vertex.y = vertices[offset++] * scale;
                    vertex.z = vertices[offset++] * scale;

                    geometry.vertices.push(vertex);
                }

                offset = 0;
                zLength = faces.length;

                while (offset < zLength) {

                    type = faces[offset++];

                    isQuad = isBitSet(type, 0);
                    hasMaterial = isBitSet(type, 1);
                    hasFaceVertexUv = isBitSet(type, 3);
                    hasFaceNormal = isBitSet(type, 4);
                    hasFaceVertexNormal = isBitSet(type, 5);
                    hasFaceColor = isBitSet(type, 6);
                    hasFaceVertexColor = isBitSet(type, 7);

                    // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

                    if (isQuad) {

                        faceA = new Face3();
                        faceA.a = faces[offset];
                        faceA.b = faces[offset + 1];
                        faceA.c = faces[offset + 3];

                        faceB = new Face3();
                        faceB.a = faces[offset + 1];
                        faceB.b = faces[offset + 2];
                        faceB.c = faces[offset + 3];

                        offset += 4;

                        if (hasMaterial) {

                            materialIndex = faces[offset++];
                            faceA.materialIndex = materialIndex;
                            faceB.materialIndex = materialIndex;
                        }

                        // to get face <=> uv index correspondence

                        fi = geometry.faces.length;

                        if (hasFaceVertexUv) {

                            for (i = 0; i < nUvLayers; i++) {

                                uvLayer = json.uvs[i];

                                geometry.faceVertexUvs[i][fi] = [];
                                geometry.faceVertexUvs[i][fi + 1] = [];

                                for (j = 0; j < 4; j++) {

                                    uvIndex = faces[offset++];

                                    u = uvLayer[uvIndex * 2];
                                    v = uvLayer[uvIndex * 2 + 1];

                                    uv = new Vector2(u, v);

                                    if (j !== 2) geometry.faceVertexUvs[i][fi].push(uv);
                                    if (j !== 0) geometry.faceVertexUvs[i][fi + 1].push(uv);
                                }
                            }
                        }

                        if (hasFaceNormal) {

                            normalIndex = faces[offset++] * 3;

                            faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);

                            faceB.normal.copy(faceA.normal);
                        }

                        if (hasFaceVertexNormal) {

                            for (i = 0; i < 4; i++) {

                                normalIndex = faces[offset++] * 3;

                                normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);

                                if (i !== 2) faceA.vertexNormals.push(normal);
                                if (i !== 0) faceB.vertexNormals.push(normal);
                            }
                        }

                        if (hasFaceColor) {

                            colorIndex = faces[offset++];
                            hex = colors[colorIndex];

                            faceA.color.setHex(hex);
                            faceB.color.setHex(hex);
                        }

                        if (hasFaceVertexColor) {

                            for (i = 0; i < 4; i++) {

                                colorIndex = faces[offset++];
                                hex = colors[colorIndex];

                                if (i !== 2) faceA.vertexColors.push(new Color(hex));
                                if (i !== 0) faceB.vertexColors.push(new Color(hex));
                            }
                        }

                        geometry.faces.push(faceA);
                        geometry.faces.push(faceB);
                    } else {

                        face = new Face3();
                        face.a = faces[offset++];
                        face.b = faces[offset++];
                        face.c = faces[offset++];

                        if (hasMaterial) {

                            materialIndex = faces[offset++];
                            face.materialIndex = materialIndex;
                        }

                        // to get face <=> uv index correspondence

                        fi = geometry.faces.length;

                        if (hasFaceVertexUv) {

                            for (i = 0; i < nUvLayers; i++) {

                                uvLayer = json.uvs[i];

                                geometry.faceVertexUvs[i][fi] = [];

                                for (j = 0; j < 3; j++) {

                                    uvIndex = faces[offset++];

                                    u = uvLayer[uvIndex * 2];
                                    v = uvLayer[uvIndex * 2 + 1];

                                    uv = new Vector2(u, v);

                                    geometry.faceVertexUvs[i][fi].push(uv);
                                }
                            }
                        }

                        if (hasFaceNormal) {

                            normalIndex = faces[offset++] * 3;

                            face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                        }

                        if (hasFaceVertexNormal) {

                            for (i = 0; i < 3; i++) {

                                normalIndex = faces[offset++] * 3;

                                normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);

                                face.vertexNormals.push(normal);
                            }
                        }

                        if (hasFaceColor) {

                            colorIndex = faces[offset++];
                            face.color.setHex(colors[colorIndex]);
                        }

                        if (hasFaceVertexColor) {

                            for (i = 0; i < 3; i++) {

                                colorIndex = faces[offset++];
                                face.vertexColors.push(new Color(colors[colorIndex]));
                            }
                        }

                        geometry.faces.push(face);
                    }
                }
            }

            function parseSkin(json, geometry) {

                var influencesPerVertex = json.influencesPerVertex !== undefined ? json.influencesPerVertex : 2;

                if (json.skinWeights) {

                    for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {

                        var x = json.skinWeights[i];
                        var y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0;
                        var z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0;
                        var w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;

                        geometry.skinWeights.push(new Vector4(x, y, z, w));
                    }
                }

                if (json.skinIndices) {

                    for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {

                        var a = json.skinIndices[i];
                        var b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0;
                        var c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0;
                        var d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;

                        geometry.skinIndices.push(new Vector4(a, b, c, d));
                    }
                }

                geometry.bones = json.bones;

                if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {

                    console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' + geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');
                }
            }

            function parseMorphing(json, geometry) {

                var scale = json.scale;

                if (json.morphTargets !== undefined) {

                    for (var i = 0, l = json.morphTargets.length; i < l; i++) {

                        geometry.morphTargets[i] = {};
                        geometry.morphTargets[i].name = json.morphTargets[i].name;
                        geometry.morphTargets[i].vertices = [];

                        var dstVertices = geometry.morphTargets[i].vertices;
                        var srcVertices = json.morphTargets[i].vertices;

                        for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {

                            var vertex = new Vector3();
                            vertex.x = srcVertices[v] * scale;
                            vertex.y = srcVertices[v + 1] * scale;
                            vertex.z = srcVertices[v + 2] * scale;

                            dstVertices.push(vertex);
                        }
                    }
                }

                if (json.morphColors !== undefined && json.morphColors.length > 0) {

                    console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');

                    var faces = geometry.faces;
                    var morphColors = json.morphColors[0].colors;

                    for (var i = 0, l = faces.length; i < l; i++) {

                        faces[i].color.fromArray(morphColors, i * 3);
                    }
                }
            }

            function parseAnimations(json, geometry) {

                var outputAnimations = [];

                // parse old style Bone/Hierarchy animations
                var animations = [];

                if (json.animation !== undefined) {

                    animations.push(json.animation);
                }

                if (json.animations !== undefined) {

                    if (json.animations.length) {

                        animations = animations.concat(json.animations);
                    } else {

                        animations.push(json.animations);
                    }
                }

                for (var i = 0; i < animations.length; i++) {

                    var clip = AnimationClip.parseAnimation(animations[i], geometry.bones);
                    if (clip) outputAnimations.push(clip);
                }

                // parse implicit morph animations
                if (geometry.morphTargets) {

                    // TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
                    var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
                    outputAnimations = outputAnimations.concat(morphAnimationClips);
                }

                if (outputAnimations.length > 0) geometry.animations = outputAnimations;
            }

            return function (json, texturePath) {

                if (json.data !== undefined) {

                    // Geometry 4.0 spec
                    json = json.data;
                }

                if (json.scale !== undefined) {

                    json.scale = 1.0 / json.scale;
                } else {

                    json.scale = 1.0;
                }

                var geometry = new Geometry();

                parseModel(json, geometry);
                parseSkin(json, geometry);
                parseMorphing(json, geometry);
                parseAnimations(json, geometry);

                geometry.computeFaceNormals();
                geometry.computeBoundingSphere();

                if (json.materials === undefined || json.materials.length === 0) {

                    return { geometry: geometry };
                } else {

                    var materials = Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);

                    return { geometry: geometry, materials: materials };
                }
            };
        }()

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function ObjectLoader(manager) {

        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
        this.texturePath = '';
    }

    Object.assign(ObjectLoader.prototype, {

        load: function load(url, onLoad, onProgress, onError) {

            if (this.texturePath === '') {

                this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);
            }

            var scope = this;

            var loader = new FileLoader(scope.manager);
            loader.load(url, function (text) {

                var json = null;

                try {

                    json = JSON.parse(text);
                } catch (error) {

                    if (onError !== undefined) onError(error);

                    console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);

                    return;
                }

                var metadata = json.metadata;

                if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {

                    console.error('THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.');
                    return;
                }

                scope.parse(json, onLoad);
            }, onProgress, onError);
        },

        setTexturePath: function setTexturePath(value) {

            this.texturePath = value;
        },

        setCrossOrigin: function setCrossOrigin(value) {

            this.crossOrigin = value;
        },

        parse: function parse(json, onLoad) {

            var geometries = this.parseGeometries(json.geometries);

            var images = this.parseImages(json.images, function () {

                if (onLoad !== undefined) onLoad(object);
            });

            var textures = this.parseTextures(json.textures, images);
            var materials = this.parseMaterials(json.materials, textures);

            var object = this.parseObject(json.object, geometries, materials);

            if (json.animations) {

                object.animations = this.parseAnimations(json.animations);
            }

            if (json.images === undefined || json.images.length === 0) {

                if (onLoad !== undefined) onLoad(object);
            }

            return object;
        },

        parseGeometries: function parseGeometries(json) {

            var geometries = {};

            if (json !== undefined) {

                var geometryLoader = new JSONLoader();
                var bufferGeometryLoader = new BufferGeometryLoader();

                for (var i = 0, l = json.length; i < l; i++) {

                    var geometry;
                    var data = json[i];

                    switch (data.type) {

                        case 'PlaneGeometry':
                        case 'PlaneBufferGeometry':

                            geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);

                            break;

                        case 'BoxGeometry':
                        case 'BoxBufferGeometry':
                        case 'CubeGeometry':
                            // backwards compatible

                            geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);

                            break;

                        case 'CircleGeometry':
                        case 'CircleBufferGeometry':

                            geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);

                            break;

                        case 'CylinderGeometry':
                        case 'CylinderBufferGeometry':

                            geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);

                            break;

                        case 'ConeGeometry':
                        case 'ConeBufferGeometry':

                            geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);

                            break;

                        case 'SphereGeometry':
                        case 'SphereBufferGeometry':

                            geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);

                            break;

                        case 'DodecahedronGeometry':
                        case 'IcosahedronGeometry':
                        case 'OctahedronGeometry':
                        case 'TetrahedronGeometry':

                            geometry = new Geometries[data.type](data.radius, data.detail);

                            break;

                        case 'RingGeometry':
                        case 'RingBufferGeometry':

                            geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);

                            break;

                        case 'TorusGeometry':
                        case 'TorusBufferGeometry':

                            geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);

                            break;

                        case 'TorusKnotGeometry':
                        case 'TorusKnotBufferGeometry':

                            geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);

                            break;

                        case 'LatheGeometry':
                        case 'LatheBufferGeometry':

                            geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);

                            break;

                        case 'BufferGeometry':

                            geometry = bufferGeometryLoader.parse(data);

                            break;

                        case 'Geometry':

                            geometry = geometryLoader.parse(data, this.texturePath).geometry;

                            break;

                        default:

                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');

                            continue;

                    }

                    geometry.uuid = data.uuid;

                    if (data.name !== undefined) geometry.name = data.name;

                    geometries[data.uuid] = geometry;
                }
            }

            return geometries;
        },

        parseMaterials: function parseMaterials(json, textures) {

            var materials = {};

            if (json !== undefined) {

                var loader = new MaterialLoader();
                loader.setTextures(textures);

                for (var i = 0, l = json.length; i < l; i++) {

                    var data = json[i];

                    if (data.type === 'MultiMaterial') {

                        // Deprecated

                        var array = [];

                        for (var j = 0; j < data.materials.length; j++) {

                            array.push(loader.parse(data.materials[j]));
                        }

                        materials[data.uuid] = array;
                    } else {

                        materials[data.uuid] = loader.parse(data);
                    }
                }
            }

            return materials;
        },

        parseAnimations: function parseAnimations(json) {

            var animations = [];

            for (var i = 0; i < json.length; i++) {

                var clip = AnimationClip.parse(json[i]);

                animations.push(clip);
            }

            return animations;
        },

        parseImages: function parseImages(json, onLoad) {

            var scope = this;
            var images = {};

            function loadImage(url) {

                scope.manager.itemStart(url);

                return loader.load(url, function () {

                    scope.manager.itemEnd(url);
                }, undefined, function () {

                    scope.manager.itemEnd(url);
                    scope.manager.itemError(url);
                });
            }

            if (json !== undefined && json.length > 0) {

                var manager = new LoadingManager(onLoad);

                var loader = new ImageLoader(manager);
                loader.setCrossOrigin(this.crossOrigin);

                for (var i = 0, l = json.length; i < l; i++) {

                    var image = json[i];
                    var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;

                    images[image.uuid] = loadImage(path);
                }
            }

            return images;
        },

        parseTextures: function parseTextures(json, images) {

            function parseConstant(value, type) {

                if (typeof value === 'number') return value;

                console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);

                return type[value];
            }

            var textures = {};

            if (json !== undefined) {

                for (var i = 0, l = json.length; i < l; i++) {

                    var data = json[i];

                    if (data.image === undefined) {

                        console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
                    }

                    if (images[data.image] === undefined) {

                        console.warn('THREE.ObjectLoader: Undefined image', data.image);
                    }

                    var texture = new Texture(images[data.image]);
                    texture.needsUpdate = true;

                    texture.uuid = data.uuid;

                    if (data.name !== undefined) texture.name = data.name;

                    if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);

                    if (data.offset !== undefined) texture.offset.fromArray(data.offset);
                    if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
                    if (data.wrap !== undefined) {

                        texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                        texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
                    }

                    if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
                    if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
                    if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;

                    if (data.flipY !== undefined) texture.flipY = data.flipY;

                    textures[data.uuid] = texture;
                }
            }

            return textures;
        },

        parseObject: function () {

            var matrix = new Matrix4();

            return function parseObject(data, geometries, materials) {

                var object;

                function getGeometry(name) {

                    if (geometries[name] === undefined) {

                        console.warn('THREE.ObjectLoader: Undefined geometry', name);
                    }

                    return geometries[name];
                }

                function getMaterial(name) {

                    if (name === undefined) return undefined;

                    if (Array.isArray(name)) {

                        var array = [];

                        for (var i = 0, l = name.length; i < l; i++) {

                            var uuid = name[i];

                            if (materials[uuid] === undefined) {

                                console.warn('THREE.ObjectLoader: Undefined material', uuid);
                            }

                            array.push(materials[uuid]);
                        }

                        return array;
                    }

                    if (materials[name] === undefined) {

                        console.warn('THREE.ObjectLoader: Undefined material', name);
                    }

                    return materials[name];
                }

                switch (data.type) {

                    case 'Scene':

                        object = new Scene();

                        if (data.background !== undefined) {

                            if (Number.isInteger(data.background)) {

                                object.background = new Color(data.background);
                            }
                        }

                        if (data.fog !== undefined) {

                            if (data.fog.type === 'Fog') {

                                object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                            } else if (data.fog.type === 'FogExp2') {

                                object.fog = new FogExp2(data.fog.color, data.fog.density);
                            }
                        }

                        break;

                    case 'PerspectiveCamera':

                        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);

                        if (data.focus !== undefined) object.focus = data.focus;
                        if (data.zoom !== undefined) object.zoom = data.zoom;
                        if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                        if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                        if (data.view !== undefined) object.view = Object.assign({}, data.view);

                        break;

                    case 'OrthographicCamera':

                        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);

                        break;

                    case 'AmbientLight':

                        object = new AmbientLight(data.color, data.intensity);

                        break;

                    case 'DirectionalLight':

                        object = new DirectionalLight(data.color, data.intensity);

                        break;

                    case 'PointLight':

                        object = new PointLight(data.color, data.intensity, data.distance, data.decay);

                        break;

                    case 'RectAreaLight':

                        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);

                        break;

                    case 'SpotLight':

                        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);

                        break;

                    case 'HemisphereLight':

                        object = new HemisphereLight(data.color, data.groundColor, data.intensity);

                        break;

                    case 'SkinnedMesh':

                        console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');

                    case 'Mesh':

                        var geometry = getGeometry(data.geometry);
                        var material = getMaterial(data.material);

                        if (geometry.bones && geometry.bones.length > 0) {

                            object = new SkinnedMesh(geometry, material);
                        } else {

                            object = new Mesh(geometry, material);
                        }

                        break;

                    case 'LOD':

                        object = new LOD();

                        break;

                    case 'Line':

                        object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);

                        break;

                    case 'LineLoop':

                        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));

                        break;

                    case 'LineSegments':

                        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));

                        break;

                    case 'PointCloud':
                    case 'Points':

                        object = new Points(getGeometry(data.geometry), getMaterial(data.material));

                        break;

                    case 'Sprite':

                        object = new Sprite(getMaterial(data.material));

                        break;

                    case 'Group':

                        object = new Group();

                        break;

                    default:

                        object = new Object3D();

                }

                object.uuid = data.uuid;

                if (data.name !== undefined) object.name = data.name;
                if (data.matrix !== undefined) {

                    matrix.fromArray(data.matrix);
                    matrix.decompose(object.position, object.quaternion, object.scale);
                } else {

                    if (data.position !== undefined) object.position.fromArray(data.position);
                    if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
                    if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
                    if (data.scale !== undefined) object.scale.fromArray(data.scale);
                }

                if (data.castShadow !== undefined) object.castShadow = data.castShadow;
                if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

                if (data.shadow) {

                    if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
                    if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
                    if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
                    if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
                }

                if (data.visible !== undefined) object.visible = data.visible;
                if (data.userData !== undefined) object.userData = data.userData;

                if (data.children !== undefined) {

                    for (var child in data.children) {

                        object.add(this.parseObject(data.children[child], geometries, materials));
                    }
                }

                if (data.type === 'LOD') {

                    var levels = data.levels;

                    for (var l = 0; l < levels.length; l++) {

                        var level = levels[l];
                        var child = object.getObjectByProperty('uuid', level.object);

                        if (child !== undefined) {

                            object.addLevel(child, level.distance);
                        }
                    }
                }

                return object;
            };
        }()

    });

    var TEXTURE_MAPPING = {
        UVMapping: UVMapping,
        CubeReflectionMapping: CubeReflectionMapping,
        CubeRefractionMapping: CubeRefractionMapping,
        EquirectangularReflectionMapping: EquirectangularReflectionMapping,
        EquirectangularRefractionMapping: EquirectangularRefractionMapping,
        SphericalReflectionMapping: SphericalReflectionMapping,
        CubeUVReflectionMapping: CubeUVReflectionMapping,
        CubeUVRefractionMapping: CubeUVRefractionMapping
    };

    var TEXTURE_WRAPPING = {
        RepeatWrapping: RepeatWrapping,
        ClampToEdgeWrapping: ClampToEdgeWrapping,
        MirroredRepeatWrapping: MirroredRepeatWrapping
    };

    var TEXTURE_FILTER = {
        NearestFilter: NearestFilter,
        NearestMipMapNearestFilter: NearestMipMapNearestFilter,
        NearestMipMapLinearFilter: NearestMipMapLinearFilter,
        LinearFilter: LinearFilter,
        LinearMipMapNearestFilter: LinearMipMapNearestFilter,
        LinearMipMapLinearFilter: LinearMipMapLinearFilter
    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     * Bezier Curves formulas obtained from
     * http://en.wikipedia.org/wiki/Bézier_curve
     */

    function CatmullRom(t, p0, p1, p2, p3) {

        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }

    //

    function QuadraticBezierP0(t, p) {

        var k = 1 - t;
        return k * k * p;
    }

    function QuadraticBezierP1(t, p) {

        return 2 * (1 - t) * t * p;
    }

    function QuadraticBezierP2(t, p) {

        return t * t * p;
    }

    function QuadraticBezier(t, p0, p1, p2) {

        return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
    }

    //

    function CubicBezierP0(t, p) {

        var k = 1 - t;
        return k * k * k * p;
    }

    function CubicBezierP1(t, p) {

        var k = 1 - t;
        return 3 * k * k * t * p;
    }

    function CubicBezierP2(t, p) {

        return 3 * (1 - t) * t * t * p;
    }

    function CubicBezierP3(t, p) {

        return t * t * t * p;
    }

    function CubicBezier(t, p0, p1, p2, p3) {

        return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
    }

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Extensible curve object
     *
     * Some common of curve methods:
     * .getPoint(t), getTangent(t)
     * .getPointAt(u), getTangentAt(u)
     * .getPoints(), .getSpacedPoints()
     * .getLength()
     * .updateArcLengths()
     *
     * This following curves inherit from THREE.Curve:
     *
     * -- 2D curves --
     * THREE.ArcCurve
     * THREE.CubicBezierCurve
     * THREE.EllipseCurve
     * THREE.LineCurve
     * THREE.QuadraticBezierCurve
     * THREE.SplineCurve
     *
     * -- 3D curves --
     * THREE.CatmullRomCurve3
     * THREE.CubicBezierCurve3
     * THREE.LineCurve3
     * THREE.QuadraticBezierCurve3
     *
     * A series of curves can be represented as a THREE.CurvePath.
     *
     **/

    /**************************************************************
     *	Abstract Curve base class
     **************************************************************/

    function Curve() {

        this.arcLengthDivisions = 200;
    }

    Object.assign(Curve.prototype, {

        // Virtual base class method to overwrite and implement in subclasses
        //	- t [0 .. 1]

        getPoint: function getPoint() {

            console.warn('THREE.Curve: .getPoint() not implemented.');
            return null;
        },

        // Get point at relative position in curve according to arc length
        // - u [0 .. 1]

        getPointAt: function getPointAt(u) {

            var t = this.getUtoTmapping(u);
            return this.getPoint(t);
        },

        // Get sequence of points using getPoint( t )

        getPoints: function getPoints(divisions) {

            if (divisions === undefined) divisions = 5;

            var points = [];

            for (var d = 0; d <= divisions; d++) {

                points.push(this.getPoint(d / divisions));
            }

            return points;
        },

        // Get sequence of points using getPointAt( u )

        getSpacedPoints: function getSpacedPoints(divisions) {

            if (divisions === undefined) divisions = 5;

            var points = [];

            for (var d = 0; d <= divisions; d++) {

                points.push(this.getPointAt(d / divisions));
            }

            return points;
        },

        // Get total curve arc length

        getLength: function getLength() {

            var lengths = this.getLengths();
            return lengths[lengths.length - 1];
        },

        // Get list of cumulative segment lengths

        getLengths: function getLengths(divisions) {

            if (divisions === undefined) divisions = this.arcLengthDivisions;

            if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {

                return this.cacheArcLengths;
            }

            this.needsUpdate = false;

            var cache = [];
            var current,
                last = this.getPoint(0);
            var p,
                sum = 0;

            cache.push(0);

            for (p = 1; p <= divisions; p++) {

                current = this.getPoint(p / divisions);
                sum += current.distanceTo(last);
                cache.push(sum);
                last = current;
            }

            this.cacheArcLengths = cache;

            return cache; // { sums: cache, sum: sum }; Sum is in the last element.
        },

        updateArcLengths: function updateArcLengths() {

            this.needsUpdate = true;
            this.getLengths();
        },

        // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

        getUtoTmapping: function getUtoTmapping(u, distance) {

            var arcLengths = this.getLengths();

            var i = 0,
                il = arcLengths.length;

            var targetArcLength; // The targeted u distance value to get

            if (distance) {

                targetArcLength = distance;
            } else {

                targetArcLength = u * arcLengths[il - 1];
            }

            // binary search for the index with largest value smaller than target u distance

            var low = 0,
                high = il - 1,
                comparison;

            while (low <= high) {

                i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

                comparison = arcLengths[i] - targetArcLength;

                if (comparison < 0) {

                    low = i + 1;
                } else if (comparison > 0) {

                    high = i - 1;
                } else {

                    high = i;
                    break;

                    // DONE
                }
            }

            i = high;

            if (arcLengths[i] === targetArcLength) {

                return i / (il - 1);
            }

            // we could get finer grain at lengths, or use simple interpolation between two points

            var lengthBefore = arcLengths[i];
            var lengthAfter = arcLengths[i + 1];

            var segmentLength = lengthAfter - lengthBefore;

            // determine where we are between the 'before' and 'after' points

            var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;

            // add that fractional amount to t

            var t = (i + segmentFraction) / (il - 1);

            return t;
        },

        // Returns a unit vector tangent at t
        // In case any sub curve does not implement its tangent derivation,
        // 2 points a small delta apart will be used to find its gradient
        // which seems to give a reasonable approximation

        getTangent: function getTangent(t) {

            var delta = 0.0001;
            var t1 = t - delta;
            var t2 = t + delta;

            // Capping in case of danger

            if (t1 < 0) t1 = 0;
            if (t2 > 1) t2 = 1;

            var pt1 = this.getPoint(t1);
            var pt2 = this.getPoint(t2);

            var vec = pt2.clone().sub(pt1);
            return vec.normalize();
        },

        getTangentAt: function getTangentAt(u) {

            var t = this.getUtoTmapping(u);
            return this.getTangent(t);
        },

        computeFrenetFrames: function computeFrenetFrames(segments, closed) {

            // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

            var normal = new Vector3();

            var tangents = [];
            var normals = [];
            var binormals = [];

            var vec = new Vector3();
            var mat = new Matrix4();

            var i, u, theta;

            // compute the tangent vectors for each segment on the curve

            for (i = 0; i <= segments; i++) {

                u = i / segments;

                tangents[i] = this.getTangentAt(u);
                tangents[i].normalize();
            }

            // select an initial normal vector perpendicular to the first tangent vector,
            // and in the direction of the minimum tangent xyz component

            normals[0] = new Vector3();
            binormals[0] = new Vector3();
            var min = Number.MAX_VALUE;
            var tx = Math.abs(tangents[0].x);
            var ty = Math.abs(tangents[0].y);
            var tz = Math.abs(tangents[0].z);

            if (tx <= min) {

                min = tx;
                normal.set(1, 0, 0);
            }

            if (ty <= min) {

                min = ty;
                normal.set(0, 1, 0);
            }

            if (tz <= min) {

                normal.set(0, 0, 1);
            }

            vec.crossVectors(tangents[0], normal).normalize();

            normals[0].crossVectors(tangents[0], vec);
            binormals[0].crossVectors(tangents[0], normals[0]);

            // compute the slowly-varying normal and binormal vectors for each segment on the curve

            for (i = 1; i <= segments; i++) {

                normals[i] = normals[i - 1].clone();

                binormals[i] = binormals[i - 1].clone();

                vec.crossVectors(tangents[i - 1], tangents[i]);

                if (vec.length() > Number.EPSILON) {

                    vec.normalize();

                    theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

                    normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
                }

                binormals[i].crossVectors(tangents[i], normals[i]);
            }

            // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

            if (closed === true) {

                theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
                theta /= segments;

                if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {

                    theta = -theta;
                }

                for (i = 1; i <= segments; i++) {

                    // twist a little...
                    normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
                    binormals[i].crossVectors(tangents[i], normals[i]);
                }
            }

            return {
                tangents: tangents,
                normals: normals,
                binormals: binormals
            };
        }

    });

    function LineCurve(v1, v2) {

        Curve.call(this);

        this.v1 = v1;
        this.v2 = v2;
    }

    LineCurve.prototype = Object.create(Curve.prototype);
    LineCurve.prototype.constructor = LineCurve;

    LineCurve.prototype.isLineCurve = true;

    LineCurve.prototype.getPoint = function (t) {

        if (t === 1) {

            return this.v2.clone();
        }

        var point = this.v2.clone().sub(this.v1);
        point.multiplyScalar(t).add(this.v1);

        return point;
    };

    // Line curve is linear, so we can overwrite default getPointAt

    LineCurve.prototype.getPointAt = function (u) {

        return this.getPoint(u);
    };

    LineCurve.prototype.getTangent = function (t) {

        var tangent = this.v2.clone().sub(this.v1);

        return tangent.normalize();
    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     **/

    /**************************************************************
     *	Curved Path - a curve path is simply a array of connected
     *  curves, but retains the api of a curve
     **************************************************************/

    function CurvePath() {

        Curve.call(this);

        this.curves = [];

        this.autoClose = false; // Automatically closes the path
    }

    CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {

        constructor: CurvePath,

        add: function add(curve) {

            this.curves.push(curve);
        },

        closePath: function closePath() {

            // Add a line curve if start and end of lines are not connected
            var startPoint = this.curves[0].getPoint(0);
            var endPoint = this.curves[this.curves.length - 1].getPoint(1);

            if (!startPoint.equals(endPoint)) {

                this.curves.push(new LineCurve(endPoint, startPoint));
            }
        },

        // To get accurate point with reference to
        // entire path distance at time t,
        // following has to be done:

        // 1. Length of each sub path have to be known
        // 2. Locate and identify type of curve
        // 3. Get t for the curve
        // 4. Return curve.getPointAt(t')

        getPoint: function getPoint(t) {

            var d = t * this.getLength();
            var curveLengths = this.getCurveLengths();
            var i = 0;

            // To think about boundaries points.

            while (i < curveLengths.length) {

                if (curveLengths[i] >= d) {

                    var diff = curveLengths[i] - d;
                    var curve = this.curves[i];

                    var segmentLength = curve.getLength();
                    var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

                    return curve.getPointAt(u);
                }

                i++;
            }

            return null;

            // loop where sum != 0, sum > d , sum+1 <d
        },

        // We cannot use the default THREE.Curve getPoint() with getLength() because in
        // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
        // getPoint() depends on getLength

        getLength: function getLength() {

            var lens = this.getCurveLengths();
            return lens[lens.length - 1];
        },

        // cacheLengths must be recalculated.
        updateArcLengths: function updateArcLengths() {

            this.needsUpdate = true;
            this.cacheLengths = null;
            this.getCurveLengths();
        },

        // Compute lengths and cache them
        // We cannot overwrite getLengths() because UtoT mapping uses it.

        getCurveLengths: function getCurveLengths() {

            // We use cache values if curves and cache array are same length

            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {

                return this.cacheLengths;
            }

            // Get length of sub-curve
            // Push sums into cached array

            var lengths = [],
                sums = 0;

            for (var i = 0, l = this.curves.length; i < l; i++) {

                sums += this.curves[i].getLength();
                lengths.push(sums);
            }

            this.cacheLengths = lengths;

            return lengths;
        },

        getSpacedPoints: function getSpacedPoints(divisions) {

            if (divisions === undefined) divisions = 40;

            var points = [];

            for (var i = 0; i <= divisions; i++) {

                points.push(this.getPoint(i / divisions));
            }

            if (this.autoClose) {

                points.push(points[0]);
            }

            return points;
        },

        getPoints: function getPoints(divisions) {

            divisions = divisions || 12;

            var points = [],
                last;

            for (var i = 0, curves = this.curves; i < curves.length; i++) {

                var curve = curves[i];
                var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && curve.isLineCurve ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;

                var pts = curve.getPoints(resolution);

                for (var j = 0; j < pts.length; j++) {

                    var point = pts[j];

                    if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

                    points.push(point);
                    last = point;
                }
            }

            if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {

                points.push(points[0]);
            }

            return points;
        },

        /**************************************************************
         *	Create Geometries Helpers
         **************************************************************/

        /// Generate geometry from path points (for Line or Points objects)

        createPointsGeometry: function createPointsGeometry(divisions) {

            var pts = this.getPoints(divisions);
            return this.createGeometry(pts);
        },

        // Generate geometry from equidistant sampling along the path

        createSpacedPointsGeometry: function createSpacedPointsGeometry(divisions) {

            var pts = this.getSpacedPoints(divisions);
            return this.createGeometry(pts);
        },

        createGeometry: function createGeometry(points) {

            var geometry = new Geometry();

            for (var i = 0, l = points.length; i < l; i++) {

                var point = points[i];
                geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
            }

            return geometry;
        }

    });

    function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

        Curve.call(this);

        this.aX = aX;
        this.aY = aY;

        this.xRadius = xRadius;
        this.yRadius = yRadius;

        this.aStartAngle = aStartAngle;
        this.aEndAngle = aEndAngle;

        this.aClockwise = aClockwise;

        this.aRotation = aRotation || 0;
    }

    EllipseCurve.prototype = Object.create(Curve.prototype);
    EllipseCurve.prototype.constructor = EllipseCurve;

    EllipseCurve.prototype.isEllipseCurve = true;

    EllipseCurve.prototype.getPoint = function (t) {

        var twoPi = Math.PI * 2;
        var deltaAngle = this.aEndAngle - this.aStartAngle;
        var samePoints = Math.abs(deltaAngle) < Number.EPSILON;

        // ensures that deltaAngle is 0 .. 2 PI
        while (deltaAngle < 0) {
            deltaAngle += twoPi;
        }while (deltaAngle > twoPi) {
            deltaAngle -= twoPi;
        }if (deltaAngle < Number.EPSILON) {

            if (samePoints) {

                deltaAngle = 0;
            } else {

                deltaAngle = twoPi;
            }
        }

        if (this.aClockwise === true && !samePoints) {

            if (deltaAngle === twoPi) {

                deltaAngle = -twoPi;
            } else {

                deltaAngle = deltaAngle - twoPi;
            }
        }

        var angle = this.aStartAngle + t * deltaAngle;
        var x = this.aX + this.xRadius * Math.cos(angle);
        var y = this.aY + this.yRadius * Math.sin(angle);

        if (this.aRotation !== 0) {

            var cos = Math.cos(this.aRotation);
            var sin = Math.sin(this.aRotation);

            var tx = x - this.aX;
            var ty = y - this.aY;

            // Rotate the point about the center of the ellipse.
            x = tx * cos - ty * sin + this.aX;
            y = tx * sin + ty * cos + this.aY;
        }

        return new Vector2(x, y);
    };

    function SplineCurve(points /* array of Vector2 */) {

        Curve.call(this);

        this.points = points === undefined ? [] : points;
    }

    SplineCurve.prototype = Object.create(Curve.prototype);
    SplineCurve.prototype.constructor = SplineCurve;

    SplineCurve.prototype.isSplineCurve = true;

    SplineCurve.prototype.getPoint = function (t) {

        var points = this.points;
        var point = (points.length - 1) * t;

        var intPoint = Math.floor(point);
        var weight = point - intPoint;

        var point0 = points[intPoint === 0 ? intPoint : intPoint - 1];
        var point1 = points[intPoint];
        var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
        var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];

        return new Vector2(CatmullRom(weight, point0.x, point1.x, point2.x, point3.x), CatmullRom(weight, point0.y, point1.y, point2.y, point3.y));
    };

    function CubicBezierCurve(v0, v1, v2, v3) {

        Curve.call(this);

        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    }

    CubicBezierCurve.prototype = Object.create(Curve.prototype);
    CubicBezierCurve.prototype.constructor = CubicBezierCurve;

    CubicBezierCurve.prototype.getPoint = function (t) {

        var v0 = this.v0,
            v1 = this.v1,
            v2 = this.v2,
            v3 = this.v3;

        return new Vector2(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
    };

    function QuadraticBezierCurve(v0, v1, v2) {

        Curve.call(this);

        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
    }

    QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
    QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

    QuadraticBezierCurve.prototype.getPoint = function (t) {

        var v0 = this.v0,
            v1 = this.v1,
            v2 = this.v2;

        return new Vector2(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
    };

    var PathPrototype = Object.assign(Object.create(CurvePath.prototype), {

        fromPoints: function fromPoints(vectors) {

            this.moveTo(vectors[0].x, vectors[0].y);

            for (var i = 1, l = vectors.length; i < l; i++) {

                this.lineTo(vectors[i].x, vectors[i].y);
            }
        },

        moveTo: function moveTo(x, y) {

            this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
        },

        lineTo: function lineTo(x, y) {

            var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
            this.curves.push(curve);

            this.currentPoint.set(x, y);
        },

        quadraticCurveTo: function quadraticCurveTo(aCPx, aCPy, aX, aY) {

            var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));

            this.curves.push(curve);

            this.currentPoint.set(aX, aY);
        },

        bezierCurveTo: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {

            var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));

            this.curves.push(curve);

            this.currentPoint.set(aX, aY);
        },

        splineThru: function splineThru(pts /*Array of Vector*/) {

            var npts = [this.currentPoint.clone()].concat(pts);

            var curve = new SplineCurve(npts);
            this.curves.push(curve);

            this.currentPoint.copy(pts[pts.length - 1]);
        },

        arc: function arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

            var x0 = this.currentPoint.x;
            var y0 = this.currentPoint.y;

            this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        },

        absarc: function absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

            this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        },

        ellipse: function ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

            var x0 = this.currentPoint.x;
            var y0 = this.currentPoint.y;

            this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        },

        absellipse: function absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {

            var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

            if (this.curves.length > 0) {

                // if a previous curve is present, attempt to join
                var firstPoint = curve.getPoint(0);

                if (!firstPoint.equals(this.currentPoint)) {

                    this.lineTo(firstPoint.x, firstPoint.y);
                }
            }

            this.curves.push(curve);

            var lastPoint = curve.getPoint(1);
            this.currentPoint.copy(lastPoint);
        }

    });

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Creates free form 2d path using series of points, lines or curves.
     **/

    function Path(points) {

        CurvePath.call(this);
        this.currentPoint = new Vector2();

        if (points) {

            this.fromPoints(points);
        }
    }

    Path.prototype = PathPrototype;
    PathPrototype.constructor = Path;

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Defines a 2d shape plane using paths.
     **/

    // STEP 1 Create a path.
    // STEP 2 Turn path into shape.
    // STEP 3 ExtrudeGeometry takes in Shape/Shapes
    // STEP 3a - Extract points from each shape, turn to vertices
    // STEP 3b - Triangulate each shape, add faces.

    function Shape() {

        Path.apply(this, arguments);

        this.holes = [];
    }

    Shape.prototype = Object.assign(Object.create(PathPrototype), {

        constructor: Shape,

        getPointsHoles: function getPointsHoles(divisions) {

            var holesPts = [];

            for (var i = 0, l = this.holes.length; i < l; i++) {

                holesPts[i] = this.holes[i].getPoints(divisions);
            }

            return holesPts;
        },

        // Get points of shape and holes (keypoints based on segments parameter)

        extractAllPoints: function extractAllPoints(divisions) {

            return {

                shape: this.getPoints(divisions),
                holes: this.getPointsHoles(divisions)

            };
        },

        extractPoints: function extractPoints(divisions) {

            return this.extractAllPoints(divisions);
        }

    });

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
     **/

    function ShapePath() {

        this.subPaths = [];
        this.currentPath = null;
    }

    Object.assign(ShapePath.prototype, {

        moveTo: function moveTo(x, y) {

            this.currentPath = new Path();
            this.subPaths.push(this.currentPath);
            this.currentPath.moveTo(x, y);
        },

        lineTo: function lineTo(x, y) {

            this.currentPath.lineTo(x, y);
        },

        quadraticCurveTo: function quadraticCurveTo(aCPx, aCPy, aX, aY) {

            this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        },

        bezierCurveTo: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {

            this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        },

        splineThru: function splineThru(pts) {

            this.currentPath.splineThru(pts);
        },

        toShapes: function toShapes(isCCW, noHoles) {

            function toShapesNoHoles(inSubpaths) {

                var shapes = [];

                for (var i = 0, l = inSubpaths.length; i < l; i++) {

                    var tmpPath = inSubpaths[i];

                    var tmpShape = new Shape();
                    tmpShape.curves = tmpPath.curves;

                    shapes.push(tmpShape);
                }

                return shapes;
            }

            function isPointInsidePolygon(inPt, inPolygon) {

                var polyLen = inPolygon.length;

                // inPt on polygon contour => immediate success    or
                // toggling of inside/outside at every single! intersection point of an edge
                //  with the horizontal line through inPt, left of inPt
                //  not counting lowerY endpoints of edges and whole edges on that line
                var inside = false;
                for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {

                    var edgeLowPt = inPolygon[p];
                    var edgeHighPt = inPolygon[q];

                    var edgeDx = edgeHighPt.x - edgeLowPt.x;
                    var edgeDy = edgeHighPt.y - edgeLowPt.y;

                    if (Math.abs(edgeDy) > Number.EPSILON) {

                        // not parallel
                        if (edgeDy < 0) {

                            edgeLowPt = inPolygon[q];edgeDx = -edgeDx;
                            edgeHighPt = inPolygon[p];edgeDy = -edgeDy;
                        }
                        if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;

                        if (inPt.y === edgeLowPt.y) {

                            if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
                            // continue;				// no intersection or edgeLowPt => doesn't count !!!
                        } else {

                            var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                            if (perpEdge === 0) return true; // inPt is on contour ?
                            if (perpEdge < 0) continue;
                            inside = !inside; // true intersection left of inPt
                        }
                    } else {

                        // parallel or collinear
                        if (inPt.y !== edgeLowPt.y) continue; // parallel
                        // edge lies on the same horizontal line as inPt
                        if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
                        // continue;
                    }
                }

                return inside;
            }

            var isClockWise = ShapeUtils.isClockWise;

            var subPaths = this.subPaths;
            if (subPaths.length === 0) return [];

            if (noHoles === true) return toShapesNoHoles(subPaths);

            var solid,
                tmpPath,
                tmpShape,
                shapes = [];

            if (subPaths.length === 1) {

                tmpPath = subPaths[0];
                tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
                return shapes;
            }

            var holesFirst = !isClockWise(subPaths[0].getPoints());
            holesFirst = isCCW ? !holesFirst : holesFirst;

            // console.log("Holes first", holesFirst);

            var betterShapeHoles = [];
            var newShapes = [];
            var newShapeHoles = [];
            var mainIdx = 0;
            var tmpPoints;

            newShapes[mainIdx] = undefined;
            newShapeHoles[mainIdx] = [];

            for (var i = 0, l = subPaths.length; i < l; i++) {

                tmpPath = subPaths[i];
                tmpPoints = tmpPath.getPoints();
                solid = isClockWise(tmpPoints);
                solid = isCCW ? !solid : solid;

                if (solid) {

                    if (!holesFirst && newShapes[mainIdx]) mainIdx++;

                    newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
                    newShapes[mainIdx].s.curves = tmpPath.curves;

                    if (holesFirst) mainIdx++;
                    newShapeHoles[mainIdx] = [];

                    //console.log('cw', i);
                } else {

                    newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });

                    //console.log('ccw', i);
                }
            }

            // only Holes? -> probably all Shapes with wrong orientation
            if (!newShapes[0]) return toShapesNoHoles(subPaths);

            if (newShapes.length > 1) {

                var ambiguous = false;
                var toChange = [];

                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {

                    betterShapeHoles[sIdx] = [];
                }

                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {

                    var sho = newShapeHoles[sIdx];

                    for (var hIdx = 0; hIdx < sho.length; hIdx++) {

                        var ho = sho[hIdx];
                        var hole_unassigned = true;

                        for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {

                            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {

                                if (sIdx !== s2Idx) toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
                                if (hole_unassigned) {

                                    hole_unassigned = false;
                                    betterShapeHoles[s2Idx].push(ho);
                                } else {

                                    ambiguous = true;
                                }
                            }
                        }
                        if (hole_unassigned) {

                            betterShapeHoles[sIdx].push(ho);
                        }
                    }
                }
                // console.log("ambiguous: ", ambiguous);
                if (toChange.length > 0) {

                    // console.log("to change: ", toChange);
                    if (!ambiguous) newShapeHoles = betterShapeHoles;
                }
            }

            var tmpHoles;

            for (var i = 0, il = newShapes.length; i < il; i++) {

                tmpShape = newShapes[i].s;
                shapes.push(tmpShape);
                tmpHoles = newShapeHoles[i];

                for (var j = 0, jl = tmpHoles.length; j < jl; j++) {

                    tmpShape.holes.push(tmpHoles[j].h);
                }
            }

            //console.log("shape", shapes);

            return shapes;
        }

    });

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author mrdoob / http://mrdoob.com/
     */

    function Font(data) {

        this.data = data;
    }

    Object.assign(Font.prototype, {

        isFont: true,

        generateShapes: function generateShapes(text, size, divisions) {

            function createPaths(text) {

                var chars = String(text).split('');
                var scale = size / data.resolution;
                var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;

                var offsetX = 0,
                    offsetY = 0;

                var paths = [];

                for (var i = 0; i < chars.length; i++) {

                    var char = chars[i];

                    if (char === '\n') {

                        offsetX = 0;
                        offsetY -= line_height;
                    } else {

                        var ret = createPath(char, scale, offsetX, offsetY);
                        offsetX += ret.offsetX;
                        paths.push(ret.path);
                    }
                }

                return paths;
            }

            function createPath(c, scale, offsetX, offsetY) {

                var glyph = data.glyphs[c] || data.glyphs['?'];

                if (!glyph) return;

                var path = new ShapePath();

                var pts = [];
                var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

                if (glyph.o) {

                    var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

                    for (var i = 0, l = outline.length; i < l;) {

                        var action = outline[i++];

                        switch (action) {

                            case 'm':
                                // moveTo

                                x = outline[i++] * scale + offsetX;
                                y = outline[i++] * scale + offsetY;

                                path.moveTo(x, y);

                                break;

                            case 'l':
                                // lineTo

                                x = outline[i++] * scale + offsetX;
                                y = outline[i++] * scale + offsetY;

                                path.lineTo(x, y);

                                break;

                            case 'q':
                                // quadraticCurveTo

                                cpx = outline[i++] * scale + offsetX;
                                cpy = outline[i++] * scale + offsetY;
                                cpx1 = outline[i++] * scale + offsetX;
                                cpy1 = outline[i++] * scale + offsetY;

                                path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);

                                laste = pts[pts.length - 1];

                                if (laste) {

                                    cpx0 = laste.x;
                                    cpy0 = laste.y;

                                    for (var i2 = 1; i2 <= divisions; i2++) {

                                        var t = i2 / divisions;
                                        QuadraticBezier(t, cpx0, cpx1, cpx);
                                        QuadraticBezier(t, cpy0, cpy1, cpy);
                                    }
                                }

                                break;

                            case 'b':
                                // bezierCurveTo

                                cpx = outline[i++] * scale + offsetX;
                                cpy = outline[i++] * scale + offsetY;
                                cpx1 = outline[i++] * scale + offsetX;
                                cpy1 = outline[i++] * scale + offsetY;
                                cpx2 = outline[i++] * scale + offsetX;
                                cpy2 = outline[i++] * scale + offsetY;

                                path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);

                                laste = pts[pts.length - 1];

                                if (laste) {

                                    cpx0 = laste.x;
                                    cpy0 = laste.y;

                                    for (var i2 = 1; i2 <= divisions; i2++) {

                                        var t = i2 / divisions;
                                        CubicBezier(t, cpx0, cpx1, cpx2, cpx);
                                        CubicBezier(t, cpy0, cpy1, cpy2, cpy);
                                    }
                                }

                                break;

                        }
                    }
                }

                return { offsetX: glyph.ha * scale, path: path };
            }

            //

            if (size === undefined) size = 100;
            if (divisions === undefined) divisions = 4;

            var data = this.data;

            var paths = createPaths(text);
            var shapes = [];

            for (var p = 0, pl = paths.length; p < pl; p++) {

                Array.prototype.push.apply(shapes, paths[p].toShapes());
            }

            return shapes;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function FontLoader(manager) {

        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    }

    Object.assign(FontLoader.prototype, {

        load: function load(url, onLoad, onProgress, onError) {

            var scope = this;

            var loader = new FileLoader(this.manager);
            loader.load(url, function (text) {

                var json;

                try {

                    json = JSON.parse(text);
                } catch (e) {

                    console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                    json = JSON.parse(text.substring(65, text.length - 2));
                }

                var font = scope.parse(json);

                if (onLoad) onLoad(font);
            }, onProgress, onError);
        },

        parse: function parse(json) {

            return new Font(json);
        }

    });

    var context;

    var AudioContext = {

        getContext: function getContext() {

            if (context === undefined) {

                context = new (window.AudioContext || window.webkitAudioContext)();
            }

            return context;
        },

        setContext: function setContext(value) {

            context = value;
        }

    };

    /**
     * @author Reece Aaron Lecrivain / http://reecenotes.com/
     */

    function AudioLoader(manager) {

        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    }

    Object.assign(AudioLoader.prototype, {

        load: function load(url, onLoad, onProgress, onError) {

            var loader = new FileLoader(this.manager);
            loader.setResponseType('arraybuffer');
            loader.load(url, function (buffer) {

                var context = AudioContext.getContext();

                context.decodeAudioData(buffer, function (audioBuffer) {

                    onLoad(audioBuffer);
                });
            }, onProgress, onError);
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function StereoCamera() {

        this.type = 'StereoCamera';

        this.aspect = 1;

        this.eyeSep = 0.064;

        this.cameraL = new PerspectiveCamera();
        this.cameraL.layers.enable(1);
        this.cameraL.matrixAutoUpdate = false;

        this.cameraR = new PerspectiveCamera();
        this.cameraR.layers.enable(2);
        this.cameraR.matrixAutoUpdate = false;
    }

    Object.assign(StereoCamera.prototype, {

        update: function () {

            var instance, focus, fov, aspect, near, far, zoom, eyeSep;

            var eyeRight = new Matrix4();
            var eyeLeft = new Matrix4();

            return function update(camera) {

                var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

                if (needsUpdate) {

                    instance = this;
                    focus = camera.focus;
                    fov = camera.fov;
                    aspect = camera.aspect * this.aspect;
                    near = camera.near;
                    far = camera.far;
                    zoom = camera.zoom;

                    // Off-axis stereoscopic effect based on
                    // http://paulbourke.net/stereographics/stereorender/

                    var projectionMatrix = camera.projectionMatrix.clone();
                    eyeSep = this.eyeSep / 2;
                    var eyeSepOnProjection = eyeSep * near / focus;
                    var ymax = near * Math.tan(_Math.DEG2RAD * fov * 0.5) / zoom;
                    var xmin, xmax;

                    // translate xOffset

                    eyeLeft.elements[12] = -eyeSep;
                    eyeRight.elements[12] = eyeSep;

                    // for left eye

                    xmin = -ymax * aspect + eyeSepOnProjection;
                    xmax = ymax * aspect + eyeSepOnProjection;

                    projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                    projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);

                    this.cameraL.projectionMatrix.copy(projectionMatrix);

                    // for right eye

                    xmin = -ymax * aspect - eyeSepOnProjection;
                    xmax = ymax * aspect - eyeSepOnProjection;

                    projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                    projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);

                    this.cameraR.projectionMatrix.copy(projectionMatrix);
                }

                this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
                this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
            };
        }()

    });

    /**
     * Camera for rendering cube maps
     *	- renders scene into axis-aligned cube
     *
     * @author alteredq / http://alteredqualia.com/
     */

    function CubeCamera(near, far, cubeResolution) {

        Object3D.call(this);

        this.type = 'CubeCamera';

        var fov = 90,
            aspect = 1;

        var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
        cameraPX.up.set(0, -1, 0);
        cameraPX.lookAt(new Vector3(1, 0, 0));
        this.add(cameraPX);

        var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
        cameraNX.up.set(0, -1, 0);
        cameraNX.lookAt(new Vector3(-1, 0, 0));
        this.add(cameraNX);

        var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
        cameraPY.up.set(0, 0, 1);
        cameraPY.lookAt(new Vector3(0, 1, 0));
        this.add(cameraPY);

        var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
        cameraNY.up.set(0, 0, -1);
        cameraNY.lookAt(new Vector3(0, -1, 0));
        this.add(cameraNY);

        var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraPZ.up.set(0, -1, 0);
        cameraPZ.lookAt(new Vector3(0, 0, 1));
        this.add(cameraPZ);

        var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraNZ.up.set(0, -1, 0);
        cameraNZ.lookAt(new Vector3(0, 0, -1));
        this.add(cameraNZ);

        var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

        this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
        this.renderTarget.texture.name = "CubeCamera";

        this.updateCubeMap = function (renderer, scene) {

            if (this.parent === null) this.updateMatrixWorld();

            var renderTarget = this.renderTarget;
            var generateMipmaps = renderTarget.texture.generateMipmaps;

            renderTarget.texture.generateMipmaps = false;

            renderTarget.activeCubeFace = 0;
            renderer.render(scene, cameraPX, renderTarget);

            renderTarget.activeCubeFace = 1;
            renderer.render(scene, cameraNX, renderTarget);

            renderTarget.activeCubeFace = 2;
            renderer.render(scene, cameraPY, renderTarget);

            renderTarget.activeCubeFace = 3;
            renderer.render(scene, cameraNY, renderTarget);

            renderTarget.activeCubeFace = 4;
            renderer.render(scene, cameraPZ, renderTarget);

            renderTarget.texture.generateMipmaps = generateMipmaps;

            renderTarget.activeCubeFace = 5;
            renderer.render(scene, cameraNZ, renderTarget);

            renderer.setRenderTarget(null);
        };
    }

    CubeCamera.prototype = Object.create(Object3D.prototype);
    CubeCamera.prototype.constructor = CubeCamera;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function ArrayCamera(array) {

        PerspectiveCamera.call(this);

        this.enabled = false;
        this.cameras = array || [];
    }

    ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {

        constructor: ArrayCamera,

        isArrayCamera: true

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function AudioListener() {

        Object3D.call(this);

        this.type = 'AudioListener';

        this.context = AudioContext.getContext();

        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);

        this.filter = null;
    }

    AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {

        constructor: AudioListener,

        getInput: function getInput() {

            return this.gain;
        },

        removeFilter: function removeFilter() {

            if (this.filter !== null) {

                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
                this.gain.connect(this.context.destination);
                this.filter = null;
            }
        },

        getFilter: function getFilter() {

            return this.filter;
        },

        setFilter: function setFilter(value) {

            if (this.filter !== null) {

                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
            } else {

                this.gain.disconnect(this.context.destination);
            }

            this.filter = value;
            this.gain.connect(this.filter);
            this.filter.connect(this.context.destination);
        },

        getMasterVolume: function getMasterVolume() {

            return this.gain.gain.value;
        },

        setMasterVolume: function setMasterVolume(value) {

            this.gain.gain.value = value;
        },

        updateMatrixWorld: function () {

            var position = new Vector3();
            var quaternion = new Quaternion();
            var scale = new Vector3();

            var orientation = new Vector3();

            return function updateMatrixWorld(force) {

                Object3D.prototype.updateMatrixWorld.call(this, force);

                var listener = this.context.listener;
                var up = this.up;

                this.matrixWorld.decompose(position, quaternion, scale);

                orientation.set(0, 0, -1).applyQuaternion(quaternion);

                if (listener.positionX) {

                    listener.positionX.setValueAtTime(position.x, this.context.currentTime);
                    listener.positionY.setValueAtTime(position.y, this.context.currentTime);
                    listener.positionZ.setValueAtTime(position.z, this.context.currentTime);
                    listener.forwardX.setValueAtTime(orientation.x, this.context.currentTime);
                    listener.forwardY.setValueAtTime(orientation.y, this.context.currentTime);
                    listener.forwardZ.setValueAtTime(orientation.z, this.context.currentTime);
                    listener.upX.setValueAtTime(up.x, this.context.currentTime);
                    listener.upY.setValueAtTime(up.y, this.context.currentTime);
                    listener.upZ.setValueAtTime(up.z, this.context.currentTime);
                } else {

                    listener.setPosition(position.x, position.y, position.z);
                    listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
                }
            };
        }()

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Reece Aaron Lecrivain / http://reecenotes.com/
     */

    function Audio(listener) {

        Object3D.call(this);

        this.type = 'Audio';

        this.context = listener.context;

        this.gain = this.context.createGain();
        this.gain.connect(listener.getInput());

        this.autoplay = false;

        this.buffer = null;
        this.loop = false;
        this.startTime = 0;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.sourceType = 'empty';

        this.filters = [];
    }

    Audio.prototype = Object.assign(Object.create(Object3D.prototype), {

        constructor: Audio,

        getOutput: function getOutput() {

            return this.gain;
        },

        setNodeSource: function setNodeSource(audioNode) {

            this.hasPlaybackControl = false;
            this.sourceType = 'audioNode';
            this.source = audioNode;
            this.connect();

            return this;
        },

        setBuffer: function setBuffer(audioBuffer) {

            this.buffer = audioBuffer;
            this.sourceType = 'buffer';

            if (this.autoplay) this.play();

            return this;
        },

        play: function play() {

            if (this.isPlaying === true) {

                console.warn('THREE.Audio: Audio is already playing.');
                return;
            }

            if (this.hasPlaybackControl === false) {

                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }

            var source = this.context.createBufferSource();

            source.buffer = this.buffer;
            source.loop = this.loop;
            source.onended = this.onEnded.bind(this);
            source.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
            source.start(0, this.startTime);

            this.isPlaying = true;

            this.source = source;

            return this.connect();
        },

        pause: function pause() {

            if (this.hasPlaybackControl === false) {

                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }

            this.source.stop();
            this.startTime = this.context.currentTime;
            this.isPlaying = false;

            return this;
        },

        stop: function stop() {

            if (this.hasPlaybackControl === false) {

                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }

            this.source.stop();
            this.startTime = 0;
            this.isPlaying = false;

            return this;
        },

        connect: function connect() {

            if (this.filters.length > 0) {

                this.source.connect(this.filters[0]);

                for (var i = 1, l = this.filters.length; i < l; i++) {

                    this.filters[i - 1].connect(this.filters[i]);
                }

                this.filters[this.filters.length - 1].connect(this.getOutput());
            } else {

                this.source.connect(this.getOutput());
            }

            return this;
        },

        disconnect: function disconnect() {

            if (this.filters.length > 0) {

                this.source.disconnect(this.filters[0]);

                for (var i = 1, l = this.filters.length; i < l; i++) {

                    this.filters[i - 1].disconnect(this.filters[i]);
                }

                this.filters[this.filters.length - 1].disconnect(this.getOutput());
            } else {

                this.source.disconnect(this.getOutput());
            }

            return this;
        },

        getFilters: function getFilters() {

            return this.filters;
        },

        setFilters: function setFilters(value) {

            if (!value) value = [];

            if (this.isPlaying === true) {

                this.disconnect();
                this.filters = value;
                this.connect();
            } else {

                this.filters = value;
            }

            return this;
        },

        getFilter: function getFilter() {

            return this.getFilters()[0];
        },

        setFilter: function setFilter(filter) {

            return this.setFilters(filter ? [filter] : []);
        },

        setPlaybackRate: function setPlaybackRate(value) {

            if (this.hasPlaybackControl === false) {

                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }

            this.playbackRate = value;

            if (this.isPlaying === true) {

                this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime);
            }

            return this;
        },

        getPlaybackRate: function getPlaybackRate() {

            return this.playbackRate;
        },

        onEnded: function onEnded() {

            this.isPlaying = false;
        },

        getLoop: function getLoop() {

            if (this.hasPlaybackControl === false) {

                console.warn('THREE.Audio: this Audio has no playback control.');
                return false;
            }

            return this.loop;
        },

        setLoop: function setLoop(value) {

            if (this.hasPlaybackControl === false) {

                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }

            this.loop = value;

            if (this.isPlaying === true) {

                this.source.loop = this.loop;
            }

            return this;
        },

        getVolume: function getVolume() {

            return this.gain.gain.value;
        },

        setVolume: function setVolume(value) {

            this.gain.gain.value = value;

            return this;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function PositionalAudio(listener) {

        Audio.call(this, listener);

        this.panner = this.context.createPanner();
        this.panner.connect(this.gain);
    }

    PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {

        constructor: PositionalAudio,

        getOutput: function getOutput() {

            return this.panner;
        },

        getRefDistance: function getRefDistance() {

            return this.panner.refDistance;
        },

        setRefDistance: function setRefDistance(value) {

            this.panner.refDistance = value;
        },

        getRolloffFactor: function getRolloffFactor() {

            return this.panner.rolloffFactor;
        },

        setRolloffFactor: function setRolloffFactor(value) {

            this.panner.rolloffFactor = value;
        },

        getDistanceModel: function getDistanceModel() {

            return this.panner.distanceModel;
        },

        setDistanceModel: function setDistanceModel(value) {

            this.panner.distanceModel = value;
        },

        getMaxDistance: function getMaxDistance() {

            return this.panner.maxDistance;
        },

        setMaxDistance: function setMaxDistance(value) {

            this.panner.maxDistance = value;
        },

        updateMatrixWorld: function () {

            var position = new Vector3();

            return function updateMatrixWorld(force) {

                Object3D.prototype.updateMatrixWorld.call(this, force);

                position.setFromMatrixPosition(this.matrixWorld);

                this.panner.setPosition(position.x, position.y, position.z);
            };
        }()

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function AudioAnalyser(audio, fftSize) {

        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

        this.data = new Uint8Array(this.analyser.frequencyBinCount);

        audio.getOutput().connect(this.analyser);
    }

    Object.assign(AudioAnalyser.prototype, {

        getFrequencyData: function getFrequencyData() {

            this.analyser.getByteFrequencyData(this.data);

            return this.data;
        },

        getAverageFrequency: function getAverageFrequency() {

            var value = 0,
                data = this.getFrequencyData();

            for (var i = 0; i < data.length; i++) {

                value += data[i];
            }

            return value / data.length;
        }

    });

    /**
     *
     * Buffered scene graph property that allows weighted accumulation.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function PropertyMixer(binding, typeName, valueSize) {

        this.binding = binding;
        this.valueSize = valueSize;

        var bufferType = Float64Array,
            mixFunction;

        switch (typeName) {

            case 'quaternion':
                mixFunction = this._slerp;
                break;

            case 'string':
            case 'bool':
                bufferType = Array;
                mixFunction = this._select;
                break;

            default:
                mixFunction = this._lerp;

        }

        this.buffer = new bufferType(valueSize * 4);
        // layout: [ incoming | accu0 | accu1 | orig ]
        //
        // interpolators can use .buffer as their .result
        // the data then goes to 'incoming'
        //
        // 'accu0' and 'accu1' are used frame-interleaved for
        // the cumulative result and are compared to detect
        // changes
        //
        // 'orig' stores the original state of the property

        this._mixBufferRegion = mixFunction;

        this.cumulativeWeight = 0;

        this.useCount = 0;
        this.referenceCount = 0;
    }

    Object.assign(PropertyMixer.prototype, {

        // accumulate data in the 'incoming' region into 'accu<i>'
        accumulate: function accumulate(accuIndex, weight) {

            // note: happily accumulating nothing when weight = 0, the caller knows
            // the weight and shouldn't have made the call in the first place

            var buffer = this.buffer,
                stride = this.valueSize,
                offset = accuIndex * stride + stride,
                currentWeight = this.cumulativeWeight;

            if (currentWeight === 0) {

                // accuN := incoming * weight

                for (var i = 0; i !== stride; ++i) {

                    buffer[offset + i] = buffer[i];
                }

                currentWeight = weight;
            } else {

                // accuN := accuN + incoming * weight

                currentWeight += weight;
                var mix = weight / currentWeight;
                this._mixBufferRegion(buffer, offset, 0, mix, stride);
            }

            this.cumulativeWeight = currentWeight;
        },

        // apply the state of 'accu<i>' to the binding when accus differ
        apply: function apply(accuIndex) {

            var stride = this.valueSize,
                buffer = this.buffer,
                offset = accuIndex * stride + stride,
                weight = this.cumulativeWeight,
                binding = this.binding;

            this.cumulativeWeight = 0;

            if (weight < 1) {

                // accuN := accuN + original * ( 1 - cumulativeWeight )

                var originalValueOffset = stride * 3;

                this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
            }

            for (var i = stride, e = stride + stride; i !== e; ++i) {

                if (buffer[i] !== buffer[i + stride]) {

                    // value has changed -> update scene graph

                    binding.setValue(buffer, offset);
                    break;
                }
            }
        },

        // remember the state of the bound property and copy it to both accus
        saveOriginalState: function saveOriginalState() {

            var binding = this.binding;

            var buffer = this.buffer,
                stride = this.valueSize,
                originalValueOffset = stride * 3;

            binding.getValue(buffer, originalValueOffset);

            // accu[0..1] := orig -- initially detect changes against the original
            for (var i = stride, e = originalValueOffset; i !== e; ++i) {

                buffer[i] = buffer[originalValueOffset + i % stride];
            }

            this.cumulativeWeight = 0;
        },

        // apply the state previously taken via 'saveOriginalState' to the binding
        restoreOriginalState: function restoreOriginalState() {

            var originalValueOffset = this.valueSize * 3;
            this.binding.setValue(this.buffer, originalValueOffset);
        },

        // mix functions

        _select: function _select(buffer, dstOffset, srcOffset, t, stride) {

            if (t >= 0.5) {

                for (var i = 0; i !== stride; ++i) {

                    buffer[dstOffset + i] = buffer[srcOffset + i];
                }
            }
        },

        _slerp: function _slerp(buffer, dstOffset, srcOffset, t) {

            Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
        },

        _lerp: function _lerp(buffer, dstOffset, srcOffset, t, stride) {

            var s = 1 - t;

            for (var i = 0; i !== stride; ++i) {

                var j = dstOffset + i;

                buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
            }
        }

    });

    /**
     *
     * A reference to a real property in the scene graph.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function Composite(targetGroup, path, optionalParsedPath) {

        var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);

        this._targetGroup = targetGroup;
        this._bindings = targetGroup.subscribe_(path, parsedPath);
    }

    Object.assign(Composite.prototype, {

        getValue: function getValue(array, offset) {

            this.bind(); // bind all binding

            var firstValidIndex = this._targetGroup.nCachedObjects_,
                binding = this._bindings[firstValidIndex];

            // and only call .getValue on the first
            if (binding !== undefined) binding.getValue(array, offset);
        },

        setValue: function setValue(array, offset) {

            var bindings = this._bindings;

            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {

                bindings[i].setValue(array, offset);
            }
        },

        bind: function bind() {

            var bindings = this._bindings;

            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {

                bindings[i].bind();
            }
        },

        unbind: function unbind() {

            var bindings = this._bindings;

            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {

                bindings[i].unbind();
            }
        }

    });

    function PropertyBinding(rootNode, path, parsedPath) {

        this.path = path;
        this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);

        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;

        this.rootNode = rootNode;
    }

    Object.assign(PropertyBinding, {

        Composite: Composite,

        create: function create(root, path, parsedPath) {

            if (!(root && root.isAnimationObjectGroup)) {

                return new PropertyBinding(root, path, parsedPath);
            } else {

                return new PropertyBinding.Composite(root, path, parsedPath);
            }
        },

        parseTrackName: function () {

            // Parent directories, delimited by '/' or ':'. Currently unused, but must
            // be matched to parse the rest of the track name.
            var directoryRe = /((?:[\w-]+[\/:])*)/;

            // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
            var nodeRe = /([\w-\.]+)?/;

            // Object on target node, and accessor. Name may contain only word
            // characters. Accessor may contain any character except closing bracket.
            var objectRe = /(?:\.([\w-]+)(?:\[(.+)\])?)?/;

            // Property and accessor. May contain only word characters. Accessor may
            // contain any non-bracket characters.
            var propertyRe = /\.([\w-]+)(?:\[(.+)\])?/;

            var trackRe = new RegExp('' + '^' + directoryRe.source + nodeRe.source + objectRe.source + propertyRe.source + '$');

            var supportedObjectNames = ['material', 'materials', 'bones'];

            return function (trackName) {

                var matches = trackRe.exec(trackName);

                if (!matches) {

                    throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
                }

                var results = {
                    // directoryName: matches[ 1 ], // (tschw) currently unused
                    nodeName: matches[2],
                    objectName: matches[3],
                    objectIndex: matches[4],
                    propertyName: matches[5], // required
                    propertyIndex: matches[6]
                };

                var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

                if (lastDot !== undefined && lastDot !== -1) {

                    var objectName = results.nodeName.substring(lastDot + 1);

                    // Object names must be checked against a whitelist. Otherwise, there
                    // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
                    // 'bar' could be the objectName, or part of a nodeName (which can
                    // include '.' characters).
                    if (supportedObjectNames.indexOf(objectName) !== -1) {

                        results.nodeName = results.nodeName.substring(0, lastDot);
                        results.objectName = objectName;
                    }
                }

                if (results.propertyName === null || results.propertyName.length === 0) {

                    throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
                }

                return results;
            };
        }(),

        findNode: function findNode(root, nodeName) {

            if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {

                return root;
            }

            // search into skeleton bones.
            if (root.skeleton) {

                var searchSkeleton = function searchSkeleton(skeleton) {

                    for (var i = 0; i < skeleton.bones.length; i++) {

                        var bone = skeleton.bones[i];

                        if (bone.name === nodeName) {

                            return bone;
                        }
                    }

                    return null;
                };

                var bone = searchSkeleton(root.skeleton);

                if (bone) {

                    return bone;
                }
            }

            // search into node subtree.
            if (root.children) {

                var searchNodeSubtree = function searchNodeSubtree(children) {

                    for (var i = 0; i < children.length; i++) {

                        var childNode = children[i];

                        if (childNode.name === nodeName || childNode.uuid === nodeName) {

                            return childNode;
                        }

                        var result = searchNodeSubtree(childNode.children);

                        if (result) return result;
                    }

                    return null;
                };

                var subTreeNode = searchNodeSubtree(root.children);

                if (subTreeNode) {

                    return subTreeNode;
                }
            }

            return null;
        }

    });

    Object.assign(PropertyBinding.prototype, { // prototype, continued

        // these are used to "bind" a nonexistent property
        _getValue_unavailable: function _getValue_unavailable() {},
        _setValue_unavailable: function _setValue_unavailable() {},

        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },

        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },

        GetterByBindingType: [function getValue_direct(buffer, offset) {

            buffer[offset] = this.node[this.propertyName];
        }, function getValue_array(buffer, offset) {

            var source = this.resolvedProperty;

            for (var i = 0, n = source.length; i !== n; ++i) {

                buffer[offset++] = source[i];
            }
        }, function getValue_arrayElement(buffer, offset) {

            buffer[offset] = this.resolvedProperty[this.propertyIndex];
        }, function getValue_toArray(buffer, offset) {

            this.resolvedProperty.toArray(buffer, offset);
        }],

        SetterByBindingTypeAndVersioning: [[
        // Direct

        function setValue_direct(buffer, offset) {

            this.node[this.propertyName] = buffer[offset];
        }, function setValue_direct_setNeedsUpdate(buffer, offset) {

            this.node[this.propertyName] = buffer[offset];
            this.targetObject.needsUpdate = true;
        }, function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {

            this.node[this.propertyName] = buffer[offset];
            this.targetObject.matrixWorldNeedsUpdate = true;
        }], [

        // EntireArray

        function setValue_array(buffer, offset) {

            var dest = this.resolvedProperty;

            for (var i = 0, n = dest.length; i !== n; ++i) {

                dest[i] = buffer[offset++];
            }
        }, function setValue_array_setNeedsUpdate(buffer, offset) {

            var dest = this.resolvedProperty;

            for (var i = 0, n = dest.length; i !== n; ++i) {

                dest[i] = buffer[offset++];
            }

            this.targetObject.needsUpdate = true;
        }, function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {

            var dest = this.resolvedProperty;

            for (var i = 0, n = dest.length; i !== n; ++i) {

                dest[i] = buffer[offset++];
            }

            this.targetObject.matrixWorldNeedsUpdate = true;
        }], [

        // ArrayElement

        function setValue_arrayElement(buffer, offset) {

            this.resolvedProperty[this.propertyIndex] = buffer[offset];
        }, function setValue_arrayElement_setNeedsUpdate(buffer, offset) {

            this.resolvedProperty[this.propertyIndex] = buffer[offset];
            this.targetObject.needsUpdate = true;
        }, function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {

            this.resolvedProperty[this.propertyIndex] = buffer[offset];
            this.targetObject.matrixWorldNeedsUpdate = true;
        }], [

        // HasToFromArray

        function setValue_fromArray(buffer, offset) {

            this.resolvedProperty.fromArray(buffer, offset);
        }, function setValue_fromArray_setNeedsUpdate(buffer, offset) {

            this.resolvedProperty.fromArray(buffer, offset);
            this.targetObject.needsUpdate = true;
        }, function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {

            this.resolvedProperty.fromArray(buffer, offset);
            this.targetObject.matrixWorldNeedsUpdate = true;
        }]],

        getValue: function getValue_unbound(targetArray, offset) {

            this.bind();
            this.getValue(targetArray, offset);

            // Note: This class uses a State pattern on a per-method basis:
            // 'bind' sets 'this.getValue' / 'setValue' and shadows the
            // prototype version of these methods with one that represents
            // the bound state. When the property is not found, the methods
            // become no-ops.
        },

        setValue: function getValue_unbound(sourceArray, offset) {

            this.bind();
            this.setValue(sourceArray, offset);
        },

        // create getter / setter pair for a property in the scene graph
        bind: function bind() {

            var targetObject = this.node,
                parsedPath = this.parsedPath,
                objectName = parsedPath.objectName,
                propertyName = parsedPath.propertyName,
                propertyIndex = parsedPath.propertyIndex;

            if (!targetObject) {

                targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;

                this.node = targetObject;
            }

            // set fail state so we can just 'return' on error
            this.getValue = this._getValue_unavailable;
            this.setValue = this._setValue_unavailable;

            // ensure there is a value node
            if (!targetObject) {

                console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
                return;
            }

            if (objectName) {

                var objectIndex = parsedPath.objectIndex;

                // special cases were we need to reach deeper into the hierarchy to get the face materials....
                switch (objectName) {

                    case 'materials':

                        if (!targetObject.material) {

                            console.error('  can not bind to material as node does not have a material', this);
                            return;
                        }

                        if (!targetObject.material.materials) {

                            console.error('  can not bind to material.materials as node.material does not have a materials array', this);
                            return;
                        }

                        targetObject = targetObject.material.materials;

                        break;

                    case 'bones':

                        if (!targetObject.skeleton) {

                            console.error('  can not bind to bones as node does not have a skeleton', this);
                            return;
                        }

                        // potential future optimization: skip this if propertyIndex is already an integer
                        // and convert the integer string to a true integer.

                        targetObject = targetObject.skeleton.bones;

                        // support resolving morphTarget names into indices.
                        for (var i = 0; i < targetObject.length; i++) {

                            if (targetObject[i].name === objectIndex) {

                                objectIndex = i;
                                break;
                            }
                        }

                        break;

                    default:

                        if (targetObject[objectName] === undefined) {

                            console.error('  can not bind to objectName of node, undefined', this);
                            return;
                        }

                        targetObject = targetObject[objectName];

                }

                if (objectIndex !== undefined) {

                    if (targetObject[objectIndex] === undefined) {

                        console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject);
                        return;
                    }

                    targetObject = targetObject[objectIndex];
                }
            }

            // resolve property
            var nodeProperty = targetObject[propertyName];

            if (nodeProperty === undefined) {

                var nodeName = parsedPath.nodeName;

                console.error("  trying to update property for track: " + nodeName + '.' + propertyName + " but it wasn't found.", targetObject);
                return;
            }

            // determine versioning scheme
            var versioning = this.Versioning.None;

            if (targetObject.needsUpdate !== undefined) {
                // material

                versioning = this.Versioning.NeedsUpdate;
                this.targetObject = targetObject;
            } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
                // node transform

                versioning = this.Versioning.MatrixWorldNeedsUpdate;
                this.targetObject = targetObject;
            }

            // determine how the property gets bound
            var bindingType = this.BindingType.Direct;

            if (propertyIndex !== undefined) {

                // access a sub element of the property array (only primitives are supported right now)

                if (propertyName === "morphTargetInfluences") {

                    // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

                    // support resolving morphTarget names into indices.
                    if (!targetObject.geometry) {

                        console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry', this);
                        return;
                    }

                    if (!targetObject.geometry.morphTargets) {

                        console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this);
                        return;
                    }

                    for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {

                        if (targetObject.geometry.morphTargets[i].name === propertyIndex) {

                            propertyIndex = i;
                            break;
                        }
                    }
                }

                bindingType = this.BindingType.ArrayElement;

                this.resolvedProperty = nodeProperty;
                this.propertyIndex = propertyIndex;
            } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {

                // must use copy for Object3D.Euler/Quaternion

                bindingType = this.BindingType.HasFromToArray;

                this.resolvedProperty = nodeProperty;
            } else if (Array.isArray(nodeProperty)) {

                bindingType = this.BindingType.EntireArray;

                this.resolvedProperty = nodeProperty;
            } else {

                this.propertyName = propertyName;
            }

            // select getter / setter
            this.getValue = this.GetterByBindingType[bindingType];
            this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        },

        unbind: function unbind() {

            this.node = null;

            // back to the prototype version of getValue / setValue
            // note: avoiding to mutate the shape of 'this' via 'delete'
            this.getValue = this._getValue_unbound;
            this.setValue = this._setValue_unbound;
        }

    });

    //!\ DECLARE ALIAS AFTER assign prototype !
    Object.assign(PropertyBinding.prototype, {

        // initial state of these methods that calls 'bind'
        _getValue_unbound: PropertyBinding.prototype.getValue,
        _setValue_unbound: PropertyBinding.prototype.setValue

    });

    /**
     *
     * A group of objects that receives a shared animation state.
     *
     * Usage:
     *
     * 	-	Add objects you would otherwise pass as 'root' to the
     * 		constructor or the .clipAction method of AnimationMixer.
     *
     * 	-	Instead pass this object as 'root'.
     *
     * 	-	You can also add and remove objects later when the mixer
     * 		is running.
     *
     * Note:
     *
     *  	Objects of this class appear as one object to the mixer,
     *  	so cache control of the individual objects must be done
     *  	on the group.
     *
     * Limitation:
     *
     * 	- 	The animated properties must be compatible among the
     * 		all objects in the group.
     *
     *  -	A single property can either be controlled through a
     *  	target group or directly, but not both.
     *
     * @author tschw
     */

    function AnimationObjectGroup(var_args) {

        this.uuid = _Math.generateUUID();

        // cached objects followed by the active ones
        this._objects = Array.prototype.slice.call(arguments);

        this.nCachedObjects_ = 0; // threshold
        // note: read by PropertyBinding.Composite

        var indices = {};
        this._indicesByUUID = indices; // for bookkeeping

        for (var i = 0, n = arguments.length; i !== n; ++i) {

            indices[arguments[i].uuid] = i;
        }

        this._paths = []; // inside: string
        this._parsedPaths = []; // inside: { we don't care, here }
        this._bindings = []; // inside: Array< PropertyBinding >
        this._bindingsIndicesByPath = {}; // inside: indices in these arrays

        var scope = this;

        this.stats = {

            objects: {
                get total() {
                    return scope._objects.length;
                },
                get inUse() {
                    return this.total - scope.nCachedObjects_;
                }
            },

            get bindingsPerObject() {
                return scope._bindings.length;
            }

        };
    }

    Object.assign(AnimationObjectGroup.prototype, {

        isAnimationObjectGroup: true,

        add: function add(var_args) {

            var objects = this._objects,
                nObjects = objects.length,
                nCachedObjects = this.nCachedObjects_,
                indicesByUUID = this._indicesByUUID,
                paths = this._paths,
                parsedPaths = this._parsedPaths,
                bindings = this._bindings,
                nBindings = bindings.length;

            for (var i = 0, n = arguments.length; i !== n; ++i) {

                var object = arguments[i],
                    uuid = object.uuid,
                    index = indicesByUUID[uuid],
                    knownObject = undefined;

                if (index === undefined) {

                    // unknown object -> add it to the ACTIVE region

                    index = nObjects++;
                    indicesByUUID[uuid] = index;
                    objects.push(object);

                    // accounting is done, now do the same for all bindings

                    for (var j = 0, m = nBindings; j !== m; ++j) {

                        bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
                    }
                } else if (index < nCachedObjects) {

                    knownObject = objects[index];

                    // move existing object to the ACTIVE region

                    var firstActiveIndex = --nCachedObjects,
                        lastCachedObject = objects[firstActiveIndex];

                    indicesByUUID[lastCachedObject.uuid] = index;
                    objects[index] = lastCachedObject;

                    indicesByUUID[uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = object;

                    // accounting is done, now do the same for all bindings

                    for (var j = 0, m = nBindings; j !== m; ++j) {

                        var bindingsForPath = bindings[j],
                            lastCached = bindingsForPath[firstActiveIndex],
                            binding = bindingsForPath[index];

                        bindingsForPath[index] = lastCached;

                        if (binding === undefined) {

                            // since we do not bother to create new bindings
                            // for objects that are cached, the binding may
                            // or may not exist

                            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
                        }

                        bindingsForPath[firstActiveIndex] = binding;
                    }
                } else if (objects[index] !== knownObject) {

                    console.error("Different objects with the same UUID " + "detected. Clean the caches or recreate your " + "infrastructure when reloading scenes...");
                } // else the object is already where we want it to be
            } // for arguments

            this.nCachedObjects_ = nCachedObjects;
        },

        remove: function remove(var_args) {

            var objects = this._objects,
                nCachedObjects = this.nCachedObjects_,
                indicesByUUID = this._indicesByUUID,
                bindings = this._bindings,
                nBindings = bindings.length;

            for (var i = 0, n = arguments.length; i !== n; ++i) {

                var object = arguments[i],
                    uuid = object.uuid,
                    index = indicesByUUID[uuid];

                if (index !== undefined && index >= nCachedObjects) {

                    // move existing object into the CACHED region

                    var lastCachedIndex = nCachedObjects++,
                        firstActiveObject = objects[lastCachedIndex];

                    indicesByUUID[firstActiveObject.uuid] = index;
                    objects[index] = firstActiveObject;

                    indicesByUUID[uuid] = lastCachedIndex;
                    objects[lastCachedIndex] = object;

                    // accounting is done, now do the same for all bindings

                    for (var j = 0, m = nBindings; j !== m; ++j) {

                        var bindingsForPath = bindings[j],
                            firstActive = bindingsForPath[lastCachedIndex],
                            binding = bindingsForPath[index];

                        bindingsForPath[index] = firstActive;
                        bindingsForPath[lastCachedIndex] = binding;
                    }
                }
            } // for arguments

            this.nCachedObjects_ = nCachedObjects;
        },

        // remove & forget
        uncache: function uncache(var_args) {

            var objects = this._objects,
                nObjects = objects.length,
                nCachedObjects = this.nCachedObjects_,
                indicesByUUID = this._indicesByUUID,
                bindings = this._bindings,
                nBindings = bindings.length;

            for (var i = 0, n = arguments.length; i !== n; ++i) {

                var object = arguments[i],
                    uuid = object.uuid,
                    index = indicesByUUID[uuid];

                if (index !== undefined) {

                    delete indicesByUUID[uuid];

                    if (index < nCachedObjects) {

                        // object is cached, shrink the CACHED region

                        var firstActiveIndex = --nCachedObjects,
                            lastCachedObject = objects[firstActiveIndex],
                            lastIndex = --nObjects,
                            lastObject = objects[lastIndex];

                        // last cached object takes this object's place
                        indicesByUUID[lastCachedObject.uuid] = index;
                        objects[index] = lastCachedObject;

                        // last object goes to the activated slot and pop
                        indicesByUUID[lastObject.uuid] = firstActiveIndex;
                        objects[firstActiveIndex] = lastObject;
                        objects.pop();

                        // accounting is done, now do the same for all bindings

                        for (var j = 0, m = nBindings; j !== m; ++j) {

                            var bindingsForPath = bindings[j],
                                lastCached = bindingsForPath[firstActiveIndex],
                                last = bindingsForPath[lastIndex];

                            bindingsForPath[index] = lastCached;
                            bindingsForPath[firstActiveIndex] = last;
                            bindingsForPath.pop();
                        }
                    } else {

                        // object is active, just swap with the last and pop

                        var lastIndex = --nObjects,
                            lastObject = objects[lastIndex];

                        indicesByUUID[lastObject.uuid] = index;
                        objects[index] = lastObject;
                        objects.pop();

                        // accounting is done, now do the same for all bindings

                        for (var j = 0, m = nBindings; j !== m; ++j) {

                            var bindingsForPath = bindings[j];

                            bindingsForPath[index] = bindingsForPath[lastIndex];
                            bindingsForPath.pop();
                        }
                    } // cached or active
                } // if object is known
            } // for arguments

            this.nCachedObjects_ = nCachedObjects;
        },

        // Internal interface used by befriended PropertyBinding.Composite:

        subscribe_: function subscribe_(path, parsedPath) {

            // returns an array of bindings for the given path that is changed
            // according to the contained objects in the group

            var indicesByPath = this._bindingsIndicesByPath,
                index = indicesByPath[path],
                bindings = this._bindings;

            if (index !== undefined) return bindings[index];

            var paths = this._paths,
                parsedPaths = this._parsedPaths,
                objects = this._objects,
                nObjects = objects.length,
                nCachedObjects = this.nCachedObjects_,
                bindingsForPath = new Array(nObjects);

            index = bindings.length;

            indicesByPath[path] = index;

            paths.push(path);
            parsedPaths.push(parsedPath);
            bindings.push(bindingsForPath);

            for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {

                var object = objects[i];
                bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
            }

            return bindingsForPath;
        },

        unsubscribe_: function unsubscribe_(path) {

            // tells the group to forget about a property path and no longer
            // update the array previously obtained with 'subscribe_'

            var indicesByPath = this._bindingsIndicesByPath,
                index = indicesByPath[path];

            if (index !== undefined) {

                var paths = this._paths,
                    parsedPaths = this._parsedPaths,
                    bindings = this._bindings,
                    lastBindingsIndex = bindings.length - 1,
                    lastBindings = bindings[lastBindingsIndex],
                    lastBindingsPath = path[lastBindingsIndex];

                indicesByPath[lastBindingsPath] = index;

                bindings[index] = lastBindings;
                bindings.pop();

                parsedPaths[index] = parsedPaths[lastBindingsIndex];
                parsedPaths.pop();

                paths[index] = paths[lastBindingsIndex];
                paths.pop();
            }
        }

    });

    /**
     *
     * Action provided by AnimationMixer for scheduling clip playback on specific
     * objects.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     *
     */

    function AnimationAction(mixer, clip, localRoot) {

        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot || null;

        var tracks = clip.tracks,
            nTracks = tracks.length,
            interpolants = new Array(nTracks);

        var interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        };

        for (var i = 0; i !== nTracks; ++i) {

            var interpolant = tracks[i].createInterpolant(null);
            interpolants[i] = interpolant;
            interpolant.settings = interpolantSettings;
        }

        this._interpolantSettings = interpolantSettings;

        this._interpolants = interpolants; // bound by the mixer

        // inside: PropertyMixer (managed by the mixer)
        this._propertyBindings = new Array(nTracks);

        this._cacheIndex = null; // for the memory manager
        this._byClipCacheIndex = null; // for the memory manager

        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;

        this.loop = LoopRepeat;
        this._loopCount = -1;

        // global mixer time when the action is to be started
        // it's set back to 'null' upon start of the action
        this._startTime = null;

        // scaled local time of the action
        // gets clamped or wrapped to 0..clip.duration according to loop
        this.time = 0;

        this.timeScale = 1;
        this._effectiveTimeScale = 1;

        this.weight = 1;
        this._effectiveWeight = 1;

        this.repetitions = Infinity; // no. of repetitions when looping

        this.paused = false; // true -> zero effective time scale
        this.enabled = true; // false -> zero effective weight

        this.clampWhenFinished = false; // keep feeding the last frame?

        this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
        this.zeroSlopeAtEnd = true; // clips for start, loop and end
    }

    Object.assign(AnimationAction.prototype, {

        // State & Scheduling

        play: function play() {

            this._mixer._activateAction(this);

            return this;
        },

        stop: function stop() {

            this._mixer._deactivateAction(this);

            return this.reset();
        },

        reset: function reset() {

            this.paused = false;
            this.enabled = true;

            this.time = 0; // restart clip
            this._loopCount = -1; // forget previous loops
            this._startTime = null; // forget scheduling

            return this.stopFading().stopWarping();
        },

        isRunning: function isRunning() {

            return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        },

        // return true when play has been called
        isScheduled: function isScheduled() {

            return this._mixer._isActiveAction(this);
        },

        startAt: function startAt(time) {

            this._startTime = time;

            return this;
        },

        setLoop: function setLoop(mode, repetitions) {

            this.loop = mode;
            this.repetitions = repetitions;

            return this;
        },

        // Weight

        // set the weight stopping any scheduled fading
        // although .enabled = false yields an effective weight of zero, this
        // method does *not* change .enabled, because it would be confusing
        setEffectiveWeight: function setEffectiveWeight(weight) {

            this.weight = weight;

            // note: same logic as when updated at runtime
            this._effectiveWeight = this.enabled ? weight : 0;

            return this.stopFading();
        },

        // return the weight considering fading and .enabled
        getEffectiveWeight: function getEffectiveWeight() {

            return this._effectiveWeight;
        },

        fadeIn: function fadeIn(duration) {

            return this._scheduleFading(duration, 0, 1);
        },

        fadeOut: function fadeOut(duration) {

            return this._scheduleFading(duration, 1, 0);
        },

        crossFadeFrom: function crossFadeFrom(fadeOutAction, duration, warp) {

            fadeOutAction.fadeOut(duration);
            this.fadeIn(duration);

            if (warp) {

                var fadeInDuration = this._clip.duration,
                    fadeOutDuration = fadeOutAction._clip.duration,
                    startEndRatio = fadeOutDuration / fadeInDuration,
                    endStartRatio = fadeInDuration / fadeOutDuration;

                fadeOutAction.warp(1.0, startEndRatio, duration);
                this.warp(endStartRatio, 1.0, duration);
            }

            return this;
        },

        crossFadeTo: function crossFadeTo(fadeInAction, duration, warp) {

            return fadeInAction.crossFadeFrom(this, duration, warp);
        },

        stopFading: function stopFading() {

            var weightInterpolant = this._weightInterpolant;

            if (weightInterpolant !== null) {

                this._weightInterpolant = null;
                this._mixer._takeBackControlInterpolant(weightInterpolant);
            }

            return this;
        },

        // Time Scale Control

        // set the time scale stopping any scheduled warping
        // although .paused = true yields an effective time scale of zero, this
        // method does *not* change .paused, because it would be confusing
        setEffectiveTimeScale: function setEffectiveTimeScale(timeScale) {

            this.timeScale = timeScale;
            this._effectiveTimeScale = this.paused ? 0 : timeScale;

            return this.stopWarping();
        },

        // return the time scale considering warping and .paused
        getEffectiveTimeScale: function getEffectiveTimeScale() {

            return this._effectiveTimeScale;
        },

        setDuration: function setDuration(duration) {

            this.timeScale = this._clip.duration / duration;

            return this.stopWarping();
        },

        syncWith: function syncWith(action) {

            this.time = action.time;
            this.timeScale = action.timeScale;

            return this.stopWarping();
        },

        halt: function halt(duration) {

            return this.warp(this._effectiveTimeScale, 0, duration);
        },

        warp: function warp(startTimeScale, endTimeScale, duration) {

            var mixer = this._mixer,
                now = mixer.time,
                interpolant = this._timeScaleInterpolant,
                timeScale = this.timeScale;

            if (interpolant === null) {

                interpolant = mixer._lendControlInterpolant();
                this._timeScaleInterpolant = interpolant;
            }

            var times = interpolant.parameterPositions,
                values = interpolant.sampleValues;

            times[0] = now;
            times[1] = now + duration;

            values[0] = startTimeScale / timeScale;
            values[1] = endTimeScale / timeScale;

            return this;
        },

        stopWarping: function stopWarping() {

            var timeScaleInterpolant = this._timeScaleInterpolant;

            if (timeScaleInterpolant !== null) {

                this._timeScaleInterpolant = null;
                this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
            }

            return this;
        },

        // Object Accessors

        getMixer: function getMixer() {

            return this._mixer;
        },

        getClip: function getClip() {

            return this._clip;
        },

        getRoot: function getRoot() {

            return this._localRoot || this._mixer._root;
        },

        // Interna

        _update: function _update(time, deltaTime, timeDirection, accuIndex) {

            // called by the mixer

            if (!this.enabled) {

                // call ._updateWeight() to update ._effectiveWeight

                this._updateWeight(time);
                return;
            }

            var startTime = this._startTime;

            if (startTime !== null) {

                // check for scheduled start of action

                var timeRunning = (time - startTime) * timeDirection;
                if (timeRunning < 0 || timeDirection === 0) {

                    return; // yet to come / don't decide when delta = 0
                }

                // start

                this._startTime = null; // unschedule
                deltaTime = timeDirection * timeRunning;
            }

            // apply time scale and advance time

            deltaTime *= this._updateTimeScale(time);
            var clipTime = this._updateTime(deltaTime);

            // note: _updateTime may disable the action resulting in
            // an effective weight of 0

            var weight = this._updateWeight(time);

            if (weight > 0) {

                var interpolants = this._interpolants;
                var propertyMixers = this._propertyBindings;

                for (var j = 0, m = interpolants.length; j !== m; ++j) {

                    interpolants[j].evaluate(clipTime);
                    propertyMixers[j].accumulate(accuIndex, weight);
                }
            }
        },

        _updateWeight: function _updateWeight(time) {

            var weight = 0;

            if (this.enabled) {

                weight = this.weight;
                var interpolant = this._weightInterpolant;

                if (interpolant !== null) {

                    var interpolantValue = interpolant.evaluate(time)[0];

                    weight *= interpolantValue;

                    if (time > interpolant.parameterPositions[1]) {

                        this.stopFading();

                        if (interpolantValue === 0) {

                            // faded out, disable
                            this.enabled = false;
                        }
                    }
                }
            }

            this._effectiveWeight = weight;
            return weight;
        },

        _updateTimeScale: function _updateTimeScale(time) {

            var timeScale = 0;

            if (!this.paused) {

                timeScale = this.timeScale;

                var interpolant = this._timeScaleInterpolant;

                if (interpolant !== null) {

                    var interpolantValue = interpolant.evaluate(time)[0];

                    timeScale *= interpolantValue;

                    if (time > interpolant.parameterPositions[1]) {

                        this.stopWarping();

                        if (timeScale === 0) {

                            // motion has halted, pause
                            this.paused = true;
                        } else {

                            // warp done - apply final time scale
                            this.timeScale = timeScale;
                        }
                    }
                }
            }

            this._effectiveTimeScale = timeScale;
            return timeScale;
        },

        _updateTime: function _updateTime(deltaTime) {

            var time = this.time + deltaTime;

            if (deltaTime === 0) return time;

            var duration = this._clip.duration,
                loop = this.loop,
                loopCount = this._loopCount;

            if (loop === LoopOnce) {

                if (loopCount === -1) {
                    // just started

                    this._loopCount = 0;
                    this._setEndings(true, true, false);
                }

                handle_stop: {

                    if (time >= duration) {

                        time = duration;
                    } else if (time < 0) {

                        time = 0;
                    } else break handle_stop;

                    if (this.clampWhenFinished) this.paused = true;else this.enabled = false;

                    this._mixer.dispatchEvent({
                        type: 'finished', action: this,
                        direction: deltaTime < 0 ? -1 : 1
                    });
                }
            } else {
                // repetitive Repeat or PingPong

                var pingPong = loop === LoopPingPong;

                if (loopCount === -1) {
                    // just started

                    if (deltaTime >= 0) {

                        loopCount = 0;

                        this._setEndings(true, this.repetitions === 0, pingPong);
                    } else {

                        // when looping in reverse direction, the initial
                        // transition through zero counts as a repetition,
                        // so leave loopCount at -1

                        this._setEndings(this.repetitions === 0, true, pingPong);
                    }
                }

                if (time >= duration || time < 0) {
                    // wrap around

                    var loopDelta = Math.floor(time / duration); // signed
                    time -= duration * loopDelta;

                    loopCount += Math.abs(loopDelta);

                    var pending = this.repetitions - loopCount;

                    if (pending < 0) {
                        // have to stop (switch state, clamp time, fire event)

                        if (this.clampWhenFinished) this.paused = true;else this.enabled = false;

                        time = deltaTime > 0 ? duration : 0;

                        this._mixer.dispatchEvent({
                            type: 'finished', action: this,
                            direction: deltaTime > 0 ? 1 : -1
                        });
                    } else {
                        // keep running

                        if (pending === 0) {
                            // entering the last round

                            var atStart = deltaTime < 0;
                            this._setEndings(atStart, !atStart, pingPong);
                        } else {

                            this._setEndings(false, false, pingPong);
                        }

                        this._loopCount = loopCount;

                        this._mixer.dispatchEvent({
                            type: 'loop', action: this, loopDelta: loopDelta
                        });
                    }
                }

                if (pingPong && (loopCount & 1) === 1) {
                    // invert time for the "pong round"

                    this.time = time;
                    return duration - time;
                }
            }

            this.time = time;
            return time;
        },

        _setEndings: function _setEndings(atStart, atEnd, pingPong) {

            var settings = this._interpolantSettings;

            if (pingPong) {

                settings.endingStart = ZeroSlopeEnding;
                settings.endingEnd = ZeroSlopeEnding;
            } else {

                // assuming for LoopOnce atStart == atEnd == true

                if (atStart) {

                    settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
                } else {

                    settings.endingStart = WrapAroundEnding;
                }

                if (atEnd) {

                    settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
                } else {

                    settings.endingEnd = WrapAroundEnding;
                }
            }
        },

        _scheduleFading: function _scheduleFading(duration, weightNow, weightThen) {

            var mixer = this._mixer,
                now = mixer.time,
                interpolant = this._weightInterpolant;

            if (interpolant === null) {

                interpolant = mixer._lendControlInterpolant();
                this._weightInterpolant = interpolant;
            }

            var times = interpolant.parameterPositions,
                values = interpolant.sampleValues;

            times[0] = now;values[0] = weightNow;
            times[1] = now + duration;values[1] = weightThen;

            return this;
        }

    });

    /**
     *
     * Player for AnimationClips.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function AnimationMixer(root) {

        this._root = root;
        this._initMemoryManager();
        this._accuIndex = 0;

        this.time = 0;

        this.timeScale = 1.0;
    }

    Object.assign(AnimationMixer.prototype, EventDispatcher.prototype, {

        _bindAction: function _bindAction(action, prototypeAction) {

            var root = action._localRoot || this._root,
                tracks = action._clip.tracks,
                nTracks = tracks.length,
                bindings = action._propertyBindings,
                interpolants = action._interpolants,
                rootUuid = root.uuid,
                bindingsByRoot = this._bindingsByRootAndName,
                bindingsByName = bindingsByRoot[rootUuid];

            if (bindingsByName === undefined) {

                bindingsByName = {};
                bindingsByRoot[rootUuid] = bindingsByName;
            }

            for (var i = 0; i !== nTracks; ++i) {

                var track = tracks[i],
                    trackName = track.name,
                    binding = bindingsByName[trackName];

                if (binding !== undefined) {

                    bindings[i] = binding;
                } else {

                    binding = bindings[i];

                    if (binding !== undefined) {

                        // existing binding, make sure the cache knows

                        if (binding._cacheIndex === null) {

                            ++binding.referenceCount;
                            this._addInactiveBinding(binding, rootUuid, trackName);
                        }

                        continue;
                    }

                    var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;

                    binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());

                    ++binding.referenceCount;
                    this._addInactiveBinding(binding, rootUuid, trackName);

                    bindings[i] = binding;
                }

                interpolants[i].resultBuffer = binding.buffer;
            }
        },

        _activateAction: function _activateAction(action) {

            if (!this._isActiveAction(action)) {

                if (action._cacheIndex === null) {

                    // this action has been forgotten by the cache, but the user
                    // appears to be still using it -> rebind

                    var rootUuid = (action._localRoot || this._root).uuid,
                        clipUuid = action._clip.uuid,
                        actionsForClip = this._actionsByClip[clipUuid];

                    this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);

                    this._addInactiveAction(action, clipUuid, rootUuid);
                }

                var bindings = action._propertyBindings;

                // increment reference counts / sort out state
                for (var i = 0, n = bindings.length; i !== n; ++i) {

                    var binding = bindings[i];

                    if (binding.useCount++ === 0) {

                        this._lendBinding(binding);
                        binding.saveOriginalState();
                    }
                }

                this._lendAction(action);
            }
        },

        _deactivateAction: function _deactivateAction(action) {

            if (this._isActiveAction(action)) {

                var bindings = action._propertyBindings;

                // decrement reference counts / sort out state
                for (var i = 0, n = bindings.length; i !== n; ++i) {

                    var binding = bindings[i];

                    if (--binding.useCount === 0) {

                        binding.restoreOriginalState();
                        this._takeBackBinding(binding);
                    }
                }

                this._takeBackAction(action);
            }
        },

        // Memory manager

        _initMemoryManager: function _initMemoryManager() {

            this._actions = []; // 'nActiveActions' followed by inactive ones
            this._nActiveActions = 0;

            this._actionsByClip = {};
            // inside:
            // {
            // 		knownActions: Array< AnimationAction >	- used as prototypes
            // 		actionByRoot: AnimationAction			- lookup
            // }


            this._bindings = []; // 'nActiveBindings' followed by inactive ones
            this._nActiveBindings = 0;

            this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


            this._controlInterpolants = []; // same game as above
            this._nActiveControlInterpolants = 0;

            var scope = this;

            this.stats = {

                actions: {
                    get total() {
                        return scope._actions.length;
                    },
                    get inUse() {
                        return scope._nActiveActions;
                    }
                },
                bindings: {
                    get total() {
                        return scope._bindings.length;
                    },
                    get inUse() {
                        return scope._nActiveBindings;
                    }
                },
                controlInterpolants: {
                    get total() {
                        return scope._controlInterpolants.length;
                    },
                    get inUse() {
                        return scope._nActiveControlInterpolants;
                    }
                }

            };
        },

        // Memory management for AnimationAction objects

        _isActiveAction: function _isActiveAction(action) {

            var index = action._cacheIndex;
            return index !== null && index < this._nActiveActions;
        },

        _addInactiveAction: function _addInactiveAction(action, clipUuid, rootUuid) {

            var actions = this._actions,
                actionsByClip = this._actionsByClip,
                actionsForClip = actionsByClip[clipUuid];

            if (actionsForClip === undefined) {

                actionsForClip = {

                    knownActions: [action],
                    actionByRoot: {}

                };

                action._byClipCacheIndex = 0;

                actionsByClip[clipUuid] = actionsForClip;
            } else {

                var knownActions = actionsForClip.knownActions;

                action._byClipCacheIndex = knownActions.length;
                knownActions.push(action);
            }

            action._cacheIndex = actions.length;
            actions.push(action);

            actionsForClip.actionByRoot[rootUuid] = action;
        },

        _removeInactiveAction: function _removeInactiveAction(action) {

            var actions = this._actions,
                lastInactiveAction = actions[actions.length - 1],
                cacheIndex = action._cacheIndex;

            lastInactiveAction._cacheIndex = cacheIndex;
            actions[cacheIndex] = lastInactiveAction;
            actions.pop();

            action._cacheIndex = null;

            var clipUuid = action._clip.uuid,
                actionsByClip = this._actionsByClip,
                actionsForClip = actionsByClip[clipUuid],
                knownActionsForClip = actionsForClip.knownActions,
                lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
                byClipCacheIndex = action._byClipCacheIndex;

            lastKnownAction._byClipCacheIndex = byClipCacheIndex;
            knownActionsForClip[byClipCacheIndex] = lastKnownAction;
            knownActionsForClip.pop();

            action._byClipCacheIndex = null;

            var actionByRoot = actionsForClip.actionByRoot,
                rootUuid = (action._localRoot || this._root).uuid;

            delete actionByRoot[rootUuid];

            if (knownActionsForClip.length === 0) {

                delete actionsByClip[clipUuid];
            }

            this._removeInactiveBindingsForAction(action);
        },

        _removeInactiveBindingsForAction: function _removeInactiveBindingsForAction(action) {

            var bindings = action._propertyBindings;
            for (var i = 0, n = bindings.length; i !== n; ++i) {

                var binding = bindings[i];

                if (--binding.referenceCount === 0) {

                    this._removeInactiveBinding(binding);
                }
            }
        },

        _lendAction: function _lendAction(action) {

            // [ active actions |  inactive actions  ]
            // [  active actions >| inactive actions ]
            //                 s        a
            //                  <-swap->
            //                 a        s

            var actions = this._actions,
                prevIndex = action._cacheIndex,
                lastActiveIndex = this._nActiveActions++,
                firstInactiveAction = actions[lastActiveIndex];

            action._cacheIndex = lastActiveIndex;
            actions[lastActiveIndex] = action;

            firstInactiveAction._cacheIndex = prevIndex;
            actions[prevIndex] = firstInactiveAction;
        },

        _takeBackAction: function _takeBackAction(action) {

            // [  active actions  | inactive actions ]
            // [ active actions |< inactive actions  ]
            //        a        s
            //         <-swap->
            //        s        a

            var actions = this._actions,
                prevIndex = action._cacheIndex,
                firstInactiveIndex = --this._nActiveActions,
                lastActiveAction = actions[firstInactiveIndex];

            action._cacheIndex = firstInactiveIndex;
            actions[firstInactiveIndex] = action;

            lastActiveAction._cacheIndex = prevIndex;
            actions[prevIndex] = lastActiveAction;
        },

        // Memory management for PropertyMixer objects

        _addInactiveBinding: function _addInactiveBinding(binding, rootUuid, trackName) {

            var bindingsByRoot = this._bindingsByRootAndName,
                bindingByName = bindingsByRoot[rootUuid],
                bindings = this._bindings;

            if (bindingByName === undefined) {

                bindingByName = {};
                bindingsByRoot[rootUuid] = bindingByName;
            }

            bindingByName[trackName] = binding;

            binding._cacheIndex = bindings.length;
            bindings.push(binding);
        },

        _removeInactiveBinding: function _removeInactiveBinding(binding) {

            var bindings = this._bindings,
                propBinding = binding.binding,
                rootUuid = propBinding.rootNode.uuid,
                trackName = propBinding.path,
                bindingsByRoot = this._bindingsByRootAndName,
                bindingByName = bindingsByRoot[rootUuid],
                lastInactiveBinding = bindings[bindings.length - 1],
                cacheIndex = binding._cacheIndex;

            lastInactiveBinding._cacheIndex = cacheIndex;
            bindings[cacheIndex] = lastInactiveBinding;
            bindings.pop();

            delete bindingByName[trackName];

            remove_empty_map: {

                for (var _ in bindingByName) {
                    break remove_empty_map;
                }delete bindingsByRoot[rootUuid];
            }
        },

        _lendBinding: function _lendBinding(binding) {

            var bindings = this._bindings,
                prevIndex = binding._cacheIndex,
                lastActiveIndex = this._nActiveBindings++,
                firstInactiveBinding = bindings[lastActiveIndex];

            binding._cacheIndex = lastActiveIndex;
            bindings[lastActiveIndex] = binding;

            firstInactiveBinding._cacheIndex = prevIndex;
            bindings[prevIndex] = firstInactiveBinding;
        },

        _takeBackBinding: function _takeBackBinding(binding) {

            var bindings = this._bindings,
                prevIndex = binding._cacheIndex,
                firstInactiveIndex = --this._nActiveBindings,
                lastActiveBinding = bindings[firstInactiveIndex];

            binding._cacheIndex = firstInactiveIndex;
            bindings[firstInactiveIndex] = binding;

            lastActiveBinding._cacheIndex = prevIndex;
            bindings[prevIndex] = lastActiveBinding;
        },

        // Memory management of Interpolants for weight and time scale

        _lendControlInterpolant: function _lendControlInterpolant() {

            var interpolants = this._controlInterpolants,
                lastActiveIndex = this._nActiveControlInterpolants++,
                interpolant = interpolants[lastActiveIndex];

            if (interpolant === undefined) {

                interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);

                interpolant.__cacheIndex = lastActiveIndex;
                interpolants[lastActiveIndex] = interpolant;
            }

            return interpolant;
        },

        _takeBackControlInterpolant: function _takeBackControlInterpolant(interpolant) {

            var interpolants = this._controlInterpolants,
                prevIndex = interpolant.__cacheIndex,
                firstInactiveIndex = --this._nActiveControlInterpolants,
                lastActiveInterpolant = interpolants[firstInactiveIndex];

            interpolant.__cacheIndex = firstInactiveIndex;
            interpolants[firstInactiveIndex] = interpolant;

            lastActiveInterpolant.__cacheIndex = prevIndex;
            interpolants[prevIndex] = lastActiveInterpolant;
        },

        _controlInterpolantsResultBuffer: new Float32Array(1),

        // return an action for a clip optionally using a custom root target
        // object (this method allocates a lot of dynamic memory in case a
        // previously unknown clip/root combination is specified)
        clipAction: function clipAction(clip, optionalRoot) {

            var root = optionalRoot || this._root,
                rootUuid = root.uuid,
                clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
                clipUuid = clipObject !== null ? clipObject.uuid : clip,
                actionsForClip = this._actionsByClip[clipUuid],
                prototypeAction = null;

            if (actionsForClip !== undefined) {

                var existingAction = actionsForClip.actionByRoot[rootUuid];

                if (existingAction !== undefined) {

                    return existingAction;
                }

                // we know the clip, so we don't have to parse all
                // the bindings again but can just copy
                prototypeAction = actionsForClip.knownActions[0];

                // also, take the clip from the prototype action
                if (clipObject === null) clipObject = prototypeAction._clip;
            }

            // clip must be known when specified via string
            if (clipObject === null) return null;

            // allocate all resources required to run it
            var newAction = new AnimationAction(this, clipObject, optionalRoot);

            this._bindAction(newAction, prototypeAction);

            // and make the action known to the memory manager
            this._addInactiveAction(newAction, clipUuid, rootUuid);

            return newAction;
        },

        // get an existing action
        existingAction: function existingAction(clip, optionalRoot) {

            var root = optionalRoot || this._root,
                rootUuid = root.uuid,
                clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
                clipUuid = clipObject ? clipObject.uuid : clip,
                actionsForClip = this._actionsByClip[clipUuid];

            if (actionsForClip !== undefined) {

                return actionsForClip.actionByRoot[rootUuid] || null;
            }

            return null;
        },

        // deactivates all previously scheduled actions
        stopAllAction: function stopAllAction() {

            var actions = this._actions,
                nActions = this._nActiveActions,
                bindings = this._bindings,
                nBindings = this._nActiveBindings;

            this._nActiveActions = 0;
            this._nActiveBindings = 0;

            for (var i = 0; i !== nActions; ++i) {

                actions[i].reset();
            }

            for (var i = 0; i !== nBindings; ++i) {

                bindings[i].useCount = 0;
            }

            return this;
        },

        // advance the time and update apply the animation
        update: function update(deltaTime) {

            deltaTime *= this.timeScale;

            var actions = this._actions,
                nActions = this._nActiveActions,
                time = this.time += deltaTime,
                timeDirection = Math.sign(deltaTime),
                accuIndex = this._accuIndex ^= 1;

            // run active actions

            for (var i = 0; i !== nActions; ++i) {

                var action = actions[i];

                action._update(time, deltaTime, timeDirection, accuIndex);
            }

            // update scene graph

            var bindings = this._bindings,
                nBindings = this._nActiveBindings;

            for (var i = 0; i !== nBindings; ++i) {

                bindings[i].apply(accuIndex);
            }

            return this;
        },

        // return this mixer's root target object
        getRoot: function getRoot() {

            return this._root;
        },

        // free all resources specific to a particular clip
        uncacheClip: function uncacheClip(clip) {

            var actions = this._actions,
                clipUuid = clip.uuid,
                actionsByClip = this._actionsByClip,
                actionsForClip = actionsByClip[clipUuid];

            if (actionsForClip !== undefined) {

                // note: just calling _removeInactiveAction would mess up the
                // iteration state and also require updating the state we can
                // just throw away

                var actionsToRemove = actionsForClip.knownActions;

                for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {

                    var action = actionsToRemove[i];

                    this._deactivateAction(action);

                    var cacheIndex = action._cacheIndex,
                        lastInactiveAction = actions[actions.length - 1];

                    action._cacheIndex = null;
                    action._byClipCacheIndex = null;

                    lastInactiveAction._cacheIndex = cacheIndex;
                    actions[cacheIndex] = lastInactiveAction;
                    actions.pop();

                    this._removeInactiveBindingsForAction(action);
                }

                delete actionsByClip[clipUuid];
            }
        },

        // free all resources specific to a particular root target object
        uncacheRoot: function uncacheRoot(root) {

            var rootUuid = root.uuid,
                actionsByClip = this._actionsByClip;

            for (var clipUuid in actionsByClip) {

                var actionByRoot = actionsByClip[clipUuid].actionByRoot,
                    action = actionByRoot[rootUuid];

                if (action !== undefined) {

                    this._deactivateAction(action);
                    this._removeInactiveAction(action);
                }
            }

            var bindingsByRoot = this._bindingsByRootAndName,
                bindingByName = bindingsByRoot[rootUuid];

            if (bindingByName !== undefined) {

                for (var trackName in bindingByName) {

                    var binding = bindingByName[trackName];
                    binding.restoreOriginalState();
                    this._removeInactiveBinding(binding);
                }
            }
        },

        // remove a targeted clip from the cache
        uncacheAction: function uncacheAction(clip, optionalRoot) {

            var action = this.existingAction(clip, optionalRoot);

            if (action !== null) {

                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Uniform(value) {

        if (typeof value === 'string') {

            console.warn('THREE.Uniform: Type parameter is no longer needed.');
            value = arguments[1];
        }

        this.value = value;
    }

    Uniform.prototype.clone = function () {

        return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InstancedBufferGeometry() {

        BufferGeometry.call(this);

        this.type = 'InstancedBufferGeometry';
        this.maxInstancedCount = undefined;
    }

    InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {

        constructor: InstancedBufferGeometry,

        isInstancedBufferGeometry: true,

        addGroup: function addGroup(start, count, materialIndex) {

            this.groups.push({

                start: start,
                count: count,
                materialIndex: materialIndex

            });
        },

        copy: function copy(source) {

            var index = source.index;

            if (index !== null) {

                this.setIndex(index.clone());
            }

            var attributes = source.attributes;

            for (var name in attributes) {

                var attribute = attributes[name];
                this.addAttribute(name, attribute.clone());
            }

            var groups = source.groups;

            for (var i = 0, l = groups.length; i < l; i++) {

                var group = groups[i];
                this.addGroup(group.start, group.count, group.materialIndex);
            }

            return this;
        }

    });

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {

        this.uuid = _Math.generateUUID();

        this.data = interleavedBuffer;
        this.itemSize = itemSize;
        this.offset = offset;

        this.normalized = normalized === true;
    }

    Object.defineProperties(InterleavedBufferAttribute.prototype, {

        count: {

            get: function get() {

                return this.data.count;
            }

        },

        array: {

            get: function get() {

                return this.data.array;
            }

        }

    });

    Object.assign(InterleavedBufferAttribute.prototype, {

        isInterleavedBufferAttribute: true,

        setX: function setX(index, x) {

            this.data.array[index * this.data.stride + this.offset] = x;

            return this;
        },

        setY: function setY(index, y) {

            this.data.array[index * this.data.stride + this.offset + 1] = y;

            return this;
        },

        setZ: function setZ(index, z) {

            this.data.array[index * this.data.stride + this.offset + 2] = z;

            return this;
        },

        setW: function setW(index, w) {

            this.data.array[index * this.data.stride + this.offset + 3] = w;

            return this;
        },

        getX: function getX(index) {

            return this.data.array[index * this.data.stride + this.offset];
        },

        getY: function getY(index) {

            return this.data.array[index * this.data.stride + this.offset + 1];
        },

        getZ: function getZ(index) {

            return this.data.array[index * this.data.stride + this.offset + 2];
        },

        getW: function getW(index) {

            return this.data.array[index * this.data.stride + this.offset + 3];
        },

        setXY: function setXY(index, x, y) {

            index = index * this.data.stride + this.offset;

            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;

            return this;
        },

        setXYZ: function setXYZ(index, x, y, z) {

            index = index * this.data.stride + this.offset;

            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            this.data.array[index + 2] = z;

            return this;
        },

        setXYZW: function setXYZW(index, x, y, z, w) {

            index = index * this.data.stride + this.offset;

            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            this.data.array[index + 2] = z;
            this.data.array[index + 3] = w;

            return this;
        }

    });

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InterleavedBuffer(array, stride) {

        this.uuid = _Math.generateUUID();

        this.array = array;
        this.stride = stride;
        this.count = array !== undefined ? array.length / stride : 0;

        this.dynamic = false;
        this.updateRange = { offset: 0, count: -1 };

        this.onUploadCallback = function () {};

        this.version = 0;
    }

    Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {

        set: function set(value) {

            if (value === true) this.version++;
        }

    });

    Object.assign(InterleavedBuffer.prototype, {

        isInterleavedBuffer: true,

        setArray: function setArray(array) {

            if (Array.isArray(array)) {

                throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
            }

            this.count = array !== undefined ? array.length / this.stride : 0;
            this.array = array;
        },

        setDynamic: function setDynamic(value) {

            this.dynamic = value;

            return this;
        },

        copy: function copy(source) {

            this.array = new source.array.constructor(source.array);
            this.count = source.count;
            this.stride = source.stride;
            this.dynamic = source.dynamic;

            return this;
        },

        copyAt: function copyAt(index1, attribute, index2) {

            index1 *= this.stride;
            index2 *= attribute.stride;

            for (var i = 0, l = this.stride; i < l; i++) {

                this.array[index1 + i] = attribute.array[index2 + i];
            }

            return this;
        },

        set: function set(value, offset) {

            if (offset === undefined) offset = 0;

            this.array.set(value, offset);

            return this;
        },

        clone: function clone() {

            return new this.constructor().copy(this);
        },

        onUpload: function onUpload(callback) {

            this.onUploadCallback = callback;

            return this;
        }

    });

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {

        InterleavedBuffer.call(this, array, stride);

        this.meshPerAttribute = meshPerAttribute || 1;
    }

    InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {

        constructor: InstancedInterleavedBuffer,

        isInstancedInterleavedBuffer: true,

        copy: function copy(source) {

            InterleavedBuffer.prototype.copy.call(this, source);

            this.meshPerAttribute = source.meshPerAttribute;

            return this;
        }

    });

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InstancedBufferAttribute(array, itemSize, meshPerAttribute) {

        BufferAttribute.call(this, array, itemSize);

        this.meshPerAttribute = meshPerAttribute || 1;
    }

    InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {

        constructor: InstancedBufferAttribute,

        isInstancedBufferAttribute: true,

        copy: function copy(source) {

            BufferAttribute.prototype.copy.call(this, source);

            this.meshPerAttribute = source.meshPerAttribute;

            return this;
        }

    });

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author bhouston / http://clara.io/
     * @author stephomi / http://stephaneginier.com/
     */

    function Raycaster(origin, direction, near, far) {

        this.ray = new Ray(origin, direction);
        // direction is assumed to be normalized (for accurate distance calculations)

        this.near = near || 0;
        this.far = far || Infinity;

        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: { threshold: 1 },
            Sprite: {}
        };

        Object.defineProperties(this.params, {
            PointCloud: {
                get: function get() {
                    console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
                    return this.Points;
                }
            }
        });
    }

    function ascSort(a, b) {

        return a.distance - b.distance;
    }

    function _intersectObject(object, raycaster, intersects, recursive) {

        if (object.visible === false) return;

        object.raycast(raycaster, intersects);

        if (recursive === true) {

            var children = object.children;

            for (var i = 0, l = children.length; i < l; i++) {

                _intersectObject(children[i], raycaster, intersects, true);
            }
        }
    }

    Object.assign(Raycaster.prototype, {

        linePrecision: 1,

        set: function set(origin, direction) {

            // direction is assumed to be normalized (for accurate distance calculations)

            this.ray.set(origin, direction);
        },

        setFromCamera: function setFromCamera(coords, camera) {

            if (camera && camera.isPerspectiveCamera) {

                this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            } else if (camera && camera.isOrthographicCamera) {

                // remark 2017.05.11 : 正交投影，采用camera.near，camera.far求取z值会少交到数据，例如camera.near = -100, camera.far = 100，z = 0 则会少一半数据。
                //this.ray.origin.set(coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far )).unproject(camera); // set origin in plane of camera
                this.ray.origin.set(coords.x, coords.y, -1).unproject(camera); // set origin in plane of camera
                this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            } else {

                console.error('THREE.Raycaster: Unsupported camera type.');
            }
        },

        intersectObject: function intersectObject(object, recursive) {

            var intersects = [];

            _intersectObject(object, this, intersects, recursive);

            intersects.sort(ascSort);

            return intersects;
        },

        intersectObjects: function intersectObjects(objects, recursive) {

            var intersects = [];

            if (Array.isArray(objects) === false) {

                console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
                return intersects;
            }

            for (var i = 0, l = objects.length; i < l; i++) {

                _intersectObject(objects[i], this, intersects, recursive);
            }

            intersects.sort(ascSort);

            return intersects;
        }

    });

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function Clock(autoStart) {

        this.autoStart = autoStart !== undefined ? autoStart : true;

        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;

        this.running = false;
    }

    Object.assign(Clock.prototype, {

        start: function start() {

            this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732

            this.oldTime = this.startTime;
            this.elapsedTime = 0;
            this.running = true;
        },

        stop: function stop() {

            this.getElapsedTime();
            this.running = false;
        },

        getElapsedTime: function getElapsedTime() {

            this.getDelta();
            return this.elapsedTime;
        },

        getDelta: function getDelta() {

            var diff = 0;

            if (this.autoStart && !this.running) {

                this.start();
                return 0;
            }

            if (this.running) {

                var newTime = (typeof performance === 'undefined' ? Date : performance).now();

                diff = (newTime - this.oldTime) / 1000;
                this.oldTime = newTime;

                this.elapsedTime += diff;
            }

            return diff;
        }

    });

    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     *
     * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
     *
     * The poles (phi) are at the positive and negative y axis.
     * The equator starts at positive z.
     */

    function Spherical(radius, phi, theta) {

        this.radius = radius !== undefined ? radius : 1.0;
        this.phi = phi !== undefined ? phi : 0; // up / down towards top and bottom pole
        this.theta = theta !== undefined ? theta : 0; // around the equator of the sphere

        return this;
    }

    Object.assign(Spherical.prototype, {

        set: function set(radius, phi, theta) {

            this.radius = radius;
            this.phi = phi;
            this.theta = theta;

            return this;
        },

        clone: function clone() {

            return new this.constructor().copy(this);
        },

        copy: function copy(other) {

            this.radius = other.radius;
            this.phi = other.phi;
            this.theta = other.theta;

            return this;
        },

        // restrict phi to be betwee EPS and PI-EPS
        makeSafe: function makeSafe() {

            var EPS = 0.000001;
            this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));

            return this;
        },

        setFromVector3: function setFromVector3(vec3) {

            this.radius = vec3.length();

            if (this.radius === 0) {

                this.theta = 0;
                this.phi = 0;
            } else {

                this.theta = Math.atan2(vec3.x, vec3.z); // equator angle around y-up axis
                this.phi = Math.acos(_Math.clamp(vec3.y / this.radius, -1, 1)); // polar angle
            }

            return this;
        }

    });

    /**
     * @author Mugen87 / https://github.com/Mugen87
     *
     * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
     *
     */

    function Cylindrical(radius, theta, y) {

        this.radius = radius !== undefined ? radius : 1.0; // distance from the origin to a point in the x-z plane
        this.theta = theta !== undefined ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
        this.y = y !== undefined ? y : 0; // height above the x-z plane

        return this;
    }

    Object.assign(Cylindrical.prototype, {

        set: function set(radius, theta, y) {

            this.radius = radius;
            this.theta = theta;
            this.y = y;

            return this;
        },

        clone: function clone() {

            return new this.constructor().copy(this);
        },

        copy: function copy(other) {

            this.radius = other.radius;
            this.theta = other.theta;
            this.y = other.y;

            return this;
        },

        setFromVector3: function setFromVector3(vec3) {

            this.radius = Math.sqrt(vec3.x * vec3.x + vec3.z * vec3.z);
            this.theta = Math.atan2(vec3.x, vec3.z);
            this.y = vec3.y;

            return this;
        }

    });

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function MorphBlendMesh(geometry, material) {

        Mesh.call(this, geometry, material);

        this.animationsMap = {};
        this.animationsList = [];

        // prepare default animation
        // (all frames played together in 1 second)

        var numFrames = this.geometry.morphTargets.length;

        var name = "__default";

        var startFrame = 0;
        var endFrame = numFrames - 1;

        var fps = numFrames / 1;

        this.createAnimation(name, startFrame, endFrame, fps);
        this.setAnimationWeight(name, 1);
    }

    MorphBlendMesh.prototype = Object.create(Mesh.prototype);
    MorphBlendMesh.prototype.constructor = MorphBlendMesh;

    MorphBlendMesh.prototype.createAnimation = function (name, start, end, fps) {

        var animation = {

            start: start,
            end: end,

            length: end - start + 1,

            fps: fps,
            duration: (end - start) / fps,

            lastFrame: 0,
            currentFrame: 0,

            active: false,

            time: 0,
            direction: 1,
            weight: 1,

            directionBackwards: false,
            mirroredLoop: false

        };

        this.animationsMap[name] = animation;
        this.animationsList.push(animation);
    };

    MorphBlendMesh.prototype.autoCreateAnimations = function (fps) {

        var pattern = /([a-z]+)_?(\d+)/i;

        var firstAnimation,
            frameRanges = {};

        var geometry = this.geometry;

        for (var i = 0, il = geometry.morphTargets.length; i < il; i++) {

            var morph = geometry.morphTargets[i];
            var chunks = morph.name.match(pattern);

            if (chunks && chunks.length > 1) {

                var name = chunks[1];

                if (!frameRanges[name]) frameRanges[name] = { start: Infinity, end: -Infinity };

                var range = frameRanges[name];

                if (i < range.start) range.start = i;
                if (i > range.end) range.end = i;

                if (!firstAnimation) firstAnimation = name;
            }
        }

        for (var name in frameRanges) {

            var range = frameRanges[name];
            this.createAnimation(name, range.start, range.end, fps);
        }

        this.firstAnimation = firstAnimation;
    };

    MorphBlendMesh.prototype.setAnimationDirectionForward = function (name) {

        var animation = this.animationsMap[name];

        if (animation) {

            animation.direction = 1;
            animation.directionBackwards = false;
        }
    };

    MorphBlendMesh.prototype.setAnimationDirectionBackward = function (name) {

        var animation = this.animationsMap[name];

        if (animation) {

            animation.direction = -1;
            animation.directionBackwards = true;
        }
    };

    MorphBlendMesh.prototype.setAnimationFPS = function (name, fps) {

        var animation = this.animationsMap[name];

        if (animation) {

            animation.fps = fps;
            animation.duration = (animation.end - animation.start) / animation.fps;
        }
    };

    MorphBlendMesh.prototype.setAnimationDuration = function (name, duration) {

        var animation = this.animationsMap[name];

        if (animation) {

            animation.duration = duration;
            animation.fps = (animation.end - animation.start) / animation.duration;
        }
    };

    MorphBlendMesh.prototype.setAnimationWeight = function (name, weight) {

        var animation = this.animationsMap[name];

        if (animation) {

            animation.weight = weight;
        }
    };

    MorphBlendMesh.prototype.setAnimationTime = function (name, time) {

        var animation = this.animationsMap[name];

        if (animation) {

            animation.time = time;
        }
    };

    MorphBlendMesh.prototype.getAnimationTime = function (name) {

        var time = 0;

        var animation = this.animationsMap[name];

        if (animation) {

            time = animation.time;
        }

        return time;
    };

    MorphBlendMesh.prototype.getAnimationDuration = function (name) {

        var duration = -1;

        var animation = this.animationsMap[name];

        if (animation) {

            duration = animation.duration;
        }

        return duration;
    };

    MorphBlendMesh.prototype.playAnimation = function (name) {

        var animation = this.animationsMap[name];

        if (animation) {

            animation.time = 0;
            animation.active = true;
        } else {

            console.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
        }
    };

    MorphBlendMesh.prototype.stopAnimation = function (name) {

        var animation = this.animationsMap[name];

        if (animation) {

            animation.active = false;
        }
    };

    MorphBlendMesh.prototype.update = function (delta) {

        for (var i = 0, il = this.animationsList.length; i < il; i++) {

            var animation = this.animationsList[i];

            if (!animation.active) continue;

            var frameTime = animation.duration / animation.length;

            animation.time += animation.direction * delta;

            if (animation.mirroredLoop) {

                if (animation.time > animation.duration || animation.time < 0) {

                    animation.direction *= -1;

                    if (animation.time > animation.duration) {

                        animation.time = animation.duration;
                        animation.directionBackwards = true;
                    }

                    if (animation.time < 0) {

                        animation.time = 0;
                        animation.directionBackwards = false;
                    }
                }
            } else {

                animation.time = animation.time % animation.duration;

                if (animation.time < 0) animation.time += animation.duration;
            }

            var keyframe = animation.start + _Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
            var weight = animation.weight;

            if (keyframe !== animation.currentFrame) {

                this.morphTargetInfluences[animation.lastFrame] = 0;
                this.morphTargetInfluences[animation.currentFrame] = 1 * weight;

                this.morphTargetInfluences[keyframe] = 0;

                animation.lastFrame = animation.currentFrame;
                animation.currentFrame = keyframe;
            }

            var mix = animation.time % frameTime / frameTime;

            if (animation.directionBackwards) mix = 1 - mix;

            if (animation.currentFrame !== animation.lastFrame) {

                this.morphTargetInfluences[animation.currentFrame] = mix * weight;
                this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
            } else {

                this.morphTargetInfluences[animation.currentFrame] = weight;
            }
        }
    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function ImmediateRenderObject(material) {

        Object3D.call(this);

        this.material = material;
        this.render = function (renderCallback) {};
    }

    ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
    ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

    ImmediateRenderObject.prototype.isImmediateRenderObject = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
    */

    function VertexNormalsHelper(object, size, hex, linewidth) {

        this.object = object;

        this.size = size !== undefined ? size : 1;

        var color = hex !== undefined ? hex : 0xff0000;

        var width = linewidth !== undefined ? linewidth : 1;

        //

        var nNormals = 0;

        var objGeometry = this.object.geometry;

        if (objGeometry && objGeometry.isGeometry) {

            nNormals = objGeometry.faces.length * 3;
        } else if (objGeometry && objGeometry.isBufferGeometry) {

            nNormals = objGeometry.attributes.normal.count;
        }

        //

        var geometry = new BufferGeometry();

        var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);

        geometry.addAttribute('position', positions);

        LineSegments.call(this, geometry, new LineBasicMaterial({ color: color, linewidth: width }));

        //

        this.matrixAutoUpdate = false;

        this.update();
    }

    VertexNormalsHelper.prototype = Object.create(LineSegments.prototype);
    VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

    VertexNormalsHelper.prototype.update = function () {

        var v1 = new Vector3();
        var v2 = new Vector3();
        var normalMatrix = new Matrix3();

        return function update() {

            var keys = ['a', 'b', 'c'];

            this.object.updateMatrixWorld(true);

            normalMatrix.getNormalMatrix(this.object.matrixWorld);

            var matrixWorld = this.object.matrixWorld;

            var position = this.geometry.attributes.position;

            //

            var objGeometry = this.object.geometry;

            if (objGeometry && objGeometry.isGeometry) {

                var vertices = objGeometry.vertices;

                var faces = objGeometry.faces;

                var idx = 0;

                for (var i = 0, l = faces.length; i < l; i++) {

                    var face = faces[i];

                    for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {

                        var vertex = vertices[face[keys[j]]];

                        var normal = face.vertexNormals[j];

                        v1.copy(vertex).applyMatrix4(matrixWorld);

                        v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);

                        position.setXYZ(idx, v1.x, v1.y, v1.z);

                        idx = idx + 1;

                        position.setXYZ(idx, v2.x, v2.y, v2.z);

                        idx = idx + 1;
                    }
                }
            } else if (objGeometry && objGeometry.isBufferGeometry) {

                var objPos = objGeometry.attributes.position;

                var objNorm = objGeometry.attributes.normal;

                var idx = 0;

                // for simplicity, ignore index and drawcalls, and render every normal

                for (var j = 0, jl = objPos.count; j < jl; j++) {

                    v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);

                    v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));

                    v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);

                    position.setXYZ(idx, v1.x, v1.y, v1.z);

                    idx = idx + 1;

                    position.setXYZ(idx, v2.x, v2.y, v2.z);

                    idx = idx + 1;
                }
            }

            position.needsUpdate = true;
        };
    }();

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
    */

    function SpotLightHelper(light) {

        Object3D.call(this);

        this.light = light;
        this.light.updateMatrixWorld();

        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;

        var geometry = new BufferGeometry();

        var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];

        for (var i = 0, j = 1, l = 32; i < l; i++, j++) {

            var p1 = i / l * Math.PI * 2;
            var p2 = j / l * Math.PI * 2;

            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
        }

        geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));

        var material = new LineBasicMaterial({ fog: false });

        this.cone = new LineSegments(geometry, material);
        this.add(this.cone);

        this.update();
    }

    SpotLightHelper.prototype = Object.create(Object3D.prototype);
    SpotLightHelper.prototype.constructor = SpotLightHelper;

    SpotLightHelper.prototype.dispose = function () {

        this.cone.geometry.dispose();
        this.cone.material.dispose();
    };

    SpotLightHelper.prototype.update = function () {

        var vector = new Vector3();
        var vector2 = new Vector3();

        return function update() {

            var coneLength = this.light.distance ? this.light.distance : 1000;
            var coneWidth = coneLength * Math.tan(this.light.angle);

            this.cone.scale.set(coneWidth, coneWidth, coneLength);

            vector.setFromMatrixPosition(this.light.matrixWorld);
            vector2.setFromMatrixPosition(this.light.target.matrixWorld);

            this.cone.lookAt(vector2.sub(vector));

            this.cone.material.color.copy(this.light.color);
        };
    }();

    /**
     * @author Sean Griffin / http://twitter.com/sgrif
     * @author Michael Guerrero / http://realitymeltdown.com
     * @author mrdoob / http://mrdoob.com/
     * @author ikerr / http://verold.com
     * @author Mugen87 / https://github.com/Mugen87
     */

    function SkeletonHelper(object) {

        this.bones = this.getBoneList(object);

        var geometry = new BufferGeometry();

        var vertices = [];
        var colors = [];

        var color1 = new Color(0, 0, 1);
        var color2 = new Color(0, 1, 0);

        for (var i = 0; i < this.bones.length; i++) {

            var bone = this.bones[i];

            if (bone.parent && bone.parent.isBone) {

                vertices.push(0, 0, 0);
                vertices.push(0, 0, 0);
                colors.push(color1.r, color1.g, color1.b);
                colors.push(color2.r, color2.g, color2.b);
            }
        }

        geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));

        var material = new LineBasicMaterial({ vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true });

        LineSegments.call(this, geometry, material);

        this.root = object;

        this.matrix = object.matrixWorld;
        this.matrixAutoUpdate = false;

        this.update();
    }

    SkeletonHelper.prototype = Object.create(LineSegments.prototype);
    SkeletonHelper.prototype.constructor = SkeletonHelper;

    SkeletonHelper.prototype.getBoneList = function (object) {

        var boneList = [];

        if (object && object.isBone) {

            boneList.push(object);
        }

        for (var i = 0; i < object.children.length; i++) {

            boneList.push.apply(boneList, this.getBoneList(object.children[i]));
        }

        return boneList;
    };

    SkeletonHelper.prototype.update = function () {

        var vector = new Vector3();

        var boneMatrix = new Matrix4();
        var matrixWorldInv = new Matrix4();

        return function update() {

            var geometry = this.geometry;
            var position = geometry.getAttribute('position');

            matrixWorldInv.getInverse(this.root.matrixWorld);

            for (var i = 0, j = 0; i < this.bones.length; i++) {

                var bone = this.bones[i];

                if (bone.parent && bone.parent.isBone) {

                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
                    vector.setFromMatrixPosition(boneMatrix);
                    position.setXYZ(j, vector.x, vector.y, vector.z);

                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
                    vector.setFromMatrixPosition(boneMatrix);
                    position.setXYZ(j + 1, vector.x, vector.y, vector.z);

                    j += 2;
                }
            }

            geometry.getAttribute('position').needsUpdate = true;
        };
    }();

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function PointLightHelper(light, sphereSize) {

        this.light = light;
        this.light.updateMatrixWorld();

        var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
        var material = new MeshBasicMaterial({ wireframe: true, fog: false });
        material.color.copy(this.light.color);

        Mesh.call(this, geometry, material);

        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = false;

        /*
        var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
        var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
        		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
        this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
        		var d = light.distance;
        		if ( d === 0.0 ) {
        			this.lightDistance.visible = false;
        		} else {
        			this.lightDistance.scale.set( d, d, d );
        		}
        		this.add( this.lightDistance );
        */
    }

    PointLightHelper.prototype = Object.create(Mesh.prototype);
    PointLightHelper.prototype.constructor = PointLightHelper;

    PointLightHelper.prototype.dispose = function () {

        this.geometry.dispose();
        this.material.dispose();
    };

    PointLightHelper.prototype.update = function () {

        this.material.color.copy(this.light.color);

        /*
        var d = this.light.distance;
        		if ( d === 0.0 ) {
        			this.lightDistance.visible = false;
        		} else {
        			this.lightDistance.visible = true;
        	this.lightDistance.scale.set( d, d, d );
        		}
        */
    };

    /**
     * @author abelnation / http://github.com/abelnation
     * @author Mugen87 / http://github.com/Mugen87
     * @author WestLangley / http://github.com/WestLangley
     */

    function RectAreaLightHelper(light) {

        Object3D.call(this);

        this.light = light;
        this.light.updateMatrixWorld();

        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;

        var material = new LineBasicMaterial({ color: light.color });

        var geometry = new BufferGeometry();

        geometry.addAttribute('position', new BufferAttribute(new Float32Array(5 * 3), 3));

        this.add(new Line(geometry, material));

        this.update();
    }

    RectAreaLightHelper.prototype = Object.create(Object3D.prototype);
    RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

    RectAreaLightHelper.prototype.dispose = function () {

        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
    };

    RectAreaLightHelper.prototype.update = function () {

        var line = this.children[0];

        // update material

        line.material.color.copy(this.light.color);

        // calculate new dimensions of the helper

        var hx = this.light.width * 0.5;
        var hy = this.light.height * 0.5;

        var position = line.geometry.attributes.position;
        var array = position.array;

        // update vertices

        array[0] = hx;array[1] = -hy;array[2] = 0;
        array[3] = hx;array[4] = hy;array[5] = 0;
        array[6] = -hx;array[7] = hy;array[8] = 0;
        array[9] = -hx;array[10] = -hy;array[11] = 0;
        array[12] = hx;array[13] = -hy;array[14] = 0;

        position.needsUpdate = true;
    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */

    function HemisphereLightHelper(light, size) {

        Object3D.call(this);

        this.light = light;
        this.light.updateMatrixWorld();

        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;

        var geometry = new OctahedronBufferGeometry(size);
        geometry.rotateY(Math.PI * 0.5);

        var material = new MeshBasicMaterial({ vertexColors: VertexColors, wireframe: true });

        var position = geometry.getAttribute('position');
        var colors = new Float32Array(position.count * 3);

        geometry.addAttribute('color', new BufferAttribute(colors, 3));

        this.add(new Mesh(geometry, material));

        this.update();
    }

    HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
    HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

    HemisphereLightHelper.prototype.dispose = function () {

        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
    };

    HemisphereLightHelper.prototype.update = function () {

        var vector = new Vector3();

        var color1 = new Color();
        var color2 = new Color();

        return function update() {

            var mesh = this.children[0];

            var colors = mesh.geometry.getAttribute('color');

            color1.copy(this.light.color);
            color2.copy(this.light.groundColor);

            for (var i = 0, l = colors.count; i < l; i++) {

                var color = i < l / 2 ? color1 : color2;

                colors.setXYZ(i, color.r, color.g, color.b);
            }

            mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());

            colors.needsUpdate = true;
        };
    }();

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function GridHelper(size, divisions, color1, color2) {

        size = size || 10;
        divisions = divisions || 10;
        color1 = new Color(color1 !== undefined ? color1 : 0x444444);
        color2 = new Color(color2 !== undefined ? color2 : 0x888888);

        var center = divisions / 2;
        var step = size / divisions;
        var halfSize = size / 2;

        var vertices = [],
            colors = [];

        for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {

            vertices.push(-halfSize, 0, k, halfSize, 0, k);
            vertices.push(k, 0, -halfSize, k, 0, halfSize);

            var color = i === center ? color1 : color2;

            color.toArray(colors, j);j += 3;
            color.toArray(colors, j);j += 3;
            color.toArray(colors, j);j += 3;
            color.toArray(colors, j);j += 3;
        }

        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));

        var material = new LineBasicMaterial({ vertexColors: VertexColors });

        LineSegments.call(this, geometry, material);
    }

    GridHelper.prototype = Object.create(LineSegments.prototype);
    GridHelper.prototype.constructor = GridHelper;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / http://github.com/Mugen87
     * @author Hectate / http://www.github.com/Hectate
     */

    function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {

        radius = radius || 10;
        radials = radials || 16;
        circles = circles || 8;
        divisions = divisions || 64;
        color1 = new Color(color1 !== undefined ? color1 : 0x444444);
        color2 = new Color(color2 !== undefined ? color2 : 0x888888);

        var vertices = [];
        var colors = [];

        var x, z;
        var v, i, j, r, color;

        // create the radials

        for (i = 0; i <= radials; i++) {

            v = i / radials * (Math.PI * 2);

            x = Math.sin(v) * radius;
            z = Math.cos(v) * radius;

            vertices.push(0, 0, 0);
            vertices.push(x, 0, z);

            color = i & 1 ? color1 : color2;

            colors.push(color.r, color.g, color.b);
            colors.push(color.r, color.g, color.b);
        }

        // create the circles

        for (i = 0; i <= circles; i++) {

            color = i & 1 ? color1 : color2;

            r = radius - radius / circles * i;

            for (j = 0; j < divisions; j++) {

                // first vertex

                v = j / divisions * (Math.PI * 2);

                x = Math.sin(v) * r;
                z = Math.cos(v) * r;

                vertices.push(x, 0, z);
                colors.push(color.r, color.g, color.b);

                // second vertex

                v = (j + 1) / divisions * (Math.PI * 2);

                x = Math.sin(v) * r;
                z = Math.cos(v) * r;

                vertices.push(x, 0, z);
                colors.push(color.r, color.g, color.b);
            }
        }

        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));

        var material = new LineBasicMaterial({ vertexColors: VertexColors });

        LineSegments.call(this, geometry, material);
    }

    PolarGridHelper.prototype = Object.create(LineSegments.prototype);
    PolarGridHelper.prototype.constructor = PolarGridHelper;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
    */

    function FaceNormalsHelper(object, size, hex, linewidth) {

        // FaceNormalsHelper only supports THREE.Geometry

        this.object = object;

        this.size = size !== undefined ? size : 1;

        var color = hex !== undefined ? hex : 0xffff00;

        var width = linewidth !== undefined ? linewidth : 1;

        //

        var nNormals = 0;

        var objGeometry = this.object.geometry;

        if (objGeometry && objGeometry.isGeometry) {

            nNormals = objGeometry.faces.length;
        } else {

            console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
        }

        //

        var geometry = new BufferGeometry();

        var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);

        geometry.addAttribute('position', positions);

        LineSegments.call(this, geometry, new LineBasicMaterial({ color: color, linewidth: width }));

        //

        this.matrixAutoUpdate = false;
        this.update();
    }

    FaceNormalsHelper.prototype = Object.create(LineSegments.prototype);
    FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

    FaceNormalsHelper.prototype.update = function () {

        var v1 = new Vector3();
        var v2 = new Vector3();
        var normalMatrix = new Matrix3();

        return function update() {

            this.object.updateMatrixWorld(true);

            normalMatrix.getNormalMatrix(this.object.matrixWorld);

            var matrixWorld = this.object.matrixWorld;

            var position = this.geometry.attributes.position;

            //

            var objGeometry = this.object.geometry;

            var vertices = objGeometry.vertices;

            var faces = objGeometry.faces;

            var idx = 0;

            for (var i = 0, l = faces.length; i < l; i++) {

                var face = faces[i];

                var normal = face.normal;

                v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);

                v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);

                position.setXYZ(idx, v1.x, v1.y, v1.z);

                idx = idx + 1;

                position.setXYZ(idx, v2.x, v2.y, v2.z);

                idx = idx + 1;
            }

            position.needsUpdate = true;
        };
    }();

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     */

    function DirectionalLightHelper(light, size) {

        Object3D.call(this);

        this.light = light;
        this.light.updateMatrixWorld();

        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;

        if (size === undefined) size = 1;

        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));

        var material = new LineBasicMaterial({ fog: false });

        this.add(new Line(geometry, material));

        geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));

        this.add(new Line(geometry, material));

        this.update();
    }

    DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
    DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

    DirectionalLightHelper.prototype.dispose = function () {

        var lightPlane = this.children[0];
        var targetLine = this.children[1];

        lightPlane.geometry.dispose();
        lightPlane.material.dispose();
        targetLine.geometry.dispose();
        targetLine.material.dispose();
    };

    DirectionalLightHelper.prototype.update = function () {

        var v1 = new Vector3();
        var v2 = new Vector3();
        var v3 = new Vector3();

        return function update() {

            v1.setFromMatrixPosition(this.light.matrixWorld);
            v2.setFromMatrixPosition(this.light.target.matrixWorld);
            v3.subVectors(v2, v1);

            var lightPlane = this.children[0];
            var targetLine = this.children[1];

            lightPlane.lookAt(v3);
            lightPlane.material.color.copy(this.light.color);

            targetLine.lookAt(v3);
            targetLine.scale.z = v3.length();
        };
    }();

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author Mugen87 / https://github.com/Mugen87
     *
     *	- shows frustum, line of sight and up of the camera
     *	- suitable for fast updates
     * 	- based on frustum visualization in lightgl.js shadowmap example
     *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
     */

    function CameraHelper(camera) {

        var geometry = new BufferGeometry();
        var material = new LineBasicMaterial({ color: 0xffffff, vertexColors: FaceColors });

        var vertices = [];
        var colors = [];

        var pointMap = {};

        // colors

        var colorFrustum = new Color(0xffaa00);
        var colorCone = new Color(0xff0000);
        var colorUp = new Color(0x00aaff);
        var colorTarget = new Color(0xffffff);
        var colorCross = new Color(0x333333);

        // near

        addLine("n1", "n2", colorFrustum);
        addLine("n2", "n4", colorFrustum);
        addLine("n4", "n3", colorFrustum);
        addLine("n3", "n1", colorFrustum);

        // far

        addLine("f1", "f2", colorFrustum);
        addLine("f2", "f4", colorFrustum);
        addLine("f4", "f3", colorFrustum);
        addLine("f3", "f1", colorFrustum);

        // sides

        addLine("n1", "f1", colorFrustum);
        addLine("n2", "f2", colorFrustum);
        addLine("n3", "f3", colorFrustum);
        addLine("n4", "f4", colorFrustum);

        // cone

        addLine("p", "n1", colorCone);
        addLine("p", "n2", colorCone);
        addLine("p", "n3", colorCone);
        addLine("p", "n4", colorCone);

        // up

        addLine("u1", "u2", colorUp);
        addLine("u2", "u3", colorUp);
        addLine("u3", "u1", colorUp);

        // target

        addLine("c", "t", colorTarget);
        addLine("p", "c", colorCross);

        // cross

        addLine("cn1", "cn2", colorCross);
        addLine("cn3", "cn4", colorCross);

        addLine("cf1", "cf2", colorCross);
        addLine("cf3", "cf4", colorCross);

        function addLine(a, b, color) {

            addPoint(a, color);
            addPoint(b, color);
        }

        function addPoint(id, color) {

            vertices.push(0, 0, 0);
            colors.push(color.r, color.g, color.b);

            if (pointMap[id] === undefined) {

                pointMap[id] = [];
            }

            pointMap[id].push(vertices.length / 3 - 1);
        }

        geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));

        LineSegments.call(this, geometry, material);

        this.camera = camera;
        if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();

        this.matrix = camera.matrixWorld;
        this.matrixAutoUpdate = false;

        this.pointMap = pointMap;

        this.update();
    }

    CameraHelper.prototype = Object.create(LineSegments.prototype);
    CameraHelper.prototype.constructor = CameraHelper;

    CameraHelper.prototype.update = function () {

        var geometry, pointMap;

        var vector = new Vector3();
        var camera = new Camera();

        function setPoint(point, x, y, z) {

            vector.set(x, y, z).unproject(camera);

            var points = pointMap[point];

            if (points !== undefined) {

                var position = geometry.getAttribute('position');

                for (var i = 0, l = points.length; i < l; i++) {

                    position.setXYZ(points[i], vector.x, vector.y, vector.z);
                }
            }
        }

        return function update() {

            geometry = this.geometry;
            pointMap = this.pointMap;

            var w = 1,
                h = 1;

            // we need just camera projection matrix
            // world matrix must be identity

            camera.projectionMatrix.copy(this.camera.projectionMatrix);

            // center / target

            setPoint("c", 0, 0, -1);
            setPoint("t", 0, 0, 1);

            // near

            setPoint("n1", -w, -h, -1);
            setPoint("n2", w, -h, -1);
            setPoint("n3", -w, h, -1);
            setPoint("n4", w, h, -1);

            // far

            setPoint("f1", -w, -h, 1);
            setPoint("f2", w, -h, 1);
            setPoint("f3", -w, h, 1);
            setPoint("f4", w, h, 1);

            // up

            setPoint("u1", w * 0.7, h * 1.1, -1);
            setPoint("u2", -w * 0.7, h * 1.1, -1);
            setPoint("u3", 0, h * 2, -1);

            // cross

            setPoint("cf1", -w, 0, 1);
            setPoint("cf2", w, 0, 1);
            setPoint("cf3", 0, -h, 1);
            setPoint("cf4", 0, h, 1);

            setPoint("cn1", -w, 0, -1);
            setPoint("cn2", w, 0, -1);
            setPoint("cn3", 0, -h, -1);
            setPoint("cn4", 0, h, -1);

            geometry.getAttribute('position').needsUpdate = true;
        };
    }();

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / http://github.com/Mugen87
     */

    function BoxHelper(object, color) {

        this.object = object;

        if (color === undefined) color = 0xffff00;

        var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var positions = new Float32Array(8 * 3);

        var geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.addAttribute('position', new BufferAttribute(positions, 3));

        LineSegments.call(this, geometry, new LineBasicMaterial({ color: color }));

        this.matrixAutoUpdate = false;

        this.update();
    }

    BoxHelper.prototype = Object.create(LineSegments.prototype);
    BoxHelper.prototype.constructor = BoxHelper;

    BoxHelper.prototype.update = function () {

        var box = new Box3();

        return function update(object) {

            if (object !== undefined) {

                console.warn('THREE.BoxHelper: .update() has no longer arguments.');
            }

            if (this.object !== undefined) {

                box.setFromObject(this.object);
            }

            if (box.isEmpty()) return;

            var min = box.min;
            var max = box.max;

            /*
              5____4
            1/___0/|
            | 6__|_7
            2/___3/
            		0: max.x, max.y, max.z
            1: min.x, max.y, max.z
            2: min.x, min.y, max.z
            3: max.x, min.y, max.z
            4: max.x, max.y, min.z
            5: min.x, max.y, min.z
            6: min.x, min.y, min.z
            7: max.x, min.y, min.z
            */

            var position = this.geometry.attributes.position;
            var array = position.array;

            array[0] = max.x;array[1] = max.y;array[2] = max.z;
            array[3] = min.x;array[4] = max.y;array[5] = max.z;
            array[6] = min.x;array[7] = min.y;array[8] = max.z;
            array[9] = max.x;array[10] = min.y;array[11] = max.z;
            array[12] = max.x;array[13] = max.y;array[14] = min.z;
            array[15] = min.x;array[16] = max.y;array[17] = min.z;
            array[18] = min.x;array[19] = min.y;array[20] = min.z;
            array[21] = max.x;array[22] = min.y;array[23] = min.z;

            position.needsUpdate = true;

            this.geometry.computeBoundingSphere();
        };
    }();

    BoxHelper.prototype.setFromObject = function (object) {

        this.object = object;
        this.update();

        return this;
    };

    /**
     * @author WestLangley / http://github.com/WestLangley
     * @author zz85 / http://github.com/zz85
     * @author bhouston / http://clara.io
     *
     * Creates an arrow for visualizing directions
     *
     * Parameters:
     *  dir - Vector3
     *  origin - Vector3
     *  length - Number
     *  color - color in hex value
     *  headLength - Number
     *  headWidth - Number
     */

    var lineGeometry;
    var coneGeometry;

    function ArrowHelper(dir, origin, length, color, headLength, headWidth) {

        // dir is assumed to be normalized

        Object3D.call(this);

        if (color === undefined) color = 0xffff00;
        if (length === undefined) length = 1;
        if (headLength === undefined) headLength = 0.2 * length;
        if (headWidth === undefined) headWidth = 0.2 * headLength;

        if (lineGeometry === undefined) {

            lineGeometry = new BufferGeometry();
            lineGeometry.addAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

            coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
            coneGeometry.translate(0, -0.5, 0);
        }

        this.position.copy(origin);

        this.line = new Line(lineGeometry, new LineBasicMaterial({ color: color }));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);

        this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({ color: color }));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);

        this.setDirection(dir);
        this.setLength(length, headLength, headWidth);
    }

    ArrowHelper.prototype = Object.create(Object3D.prototype);
    ArrowHelper.prototype.constructor = ArrowHelper;

    ArrowHelper.prototype.setDirection = function () {

        var axis = new Vector3();
        var radians;

        return function setDirection(dir) {

            // dir is assumed to be normalized

            if (dir.y > 0.99999) {

                this.quaternion.set(0, 0, 0, 1);
            } else if (dir.y < -0.99999) {

                this.quaternion.set(1, 0, 0, 0);
            } else {

                axis.set(dir.z, 0, -dir.x).normalize();

                radians = Math.acos(dir.y);

                this.quaternion.setFromAxisAngle(axis, radians);
            }
        };
    }();

    ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {

        if (headLength === undefined) headLength = 0.2 * length;
        if (headWidth === undefined) headWidth = 0.2 * headLength;

        this.line.scale.set(1, Math.max(0, length - headLength), 1);
        this.line.updateMatrix();

        this.cone.scale.set(headWidth, headLength, headWidth);
        this.cone.position.y = length;
        this.cone.updateMatrix();
    };

    ArrowHelper.prototype.setColor = function (color) {

        this.line.material.color.copy(color);
        this.cone.material.color.copy(color);
    };

    /**
     * @author sroucheray / http://sroucheray.org/
     * @author mrdoob / http://mrdoob.com/
     */

    function AxisHelper(size) {

        size = size || 1;

        var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];

        var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];

        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));

        var material = new LineBasicMaterial({ vertexColors: VertexColors });

        LineSegments.call(this, geometry, material);
    }

    AxisHelper.prototype = Object.create(LineSegments.prototype);
    AxisHelper.prototype.constructor = AxisHelper;

    /**
     * @author zz85 https://github.com/zz85
     *
     * Centripetal CatmullRom Curve - which is useful for avoiding
     * cusps and self-intersections in non-uniform catmull rom curves.
     * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
     *
     * curve.type accepts centripetal(default), chordal and catmullrom
     * curve.tension is used for catmullrom which defaults to 0.5
     */

    /*
    Based on an optimized c++ solution in
     - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
     - http://ideone.com/NoEbVM
    
    This CubicPoly class could be used for reusing some variables and calculations,
    but for three.js curve use, it could be possible inlined and flatten into a single function call
    which can be placed in CurveUtils.
    */

    function CubicPoly() {

        var c0 = 0,
            c1 = 0,
            c2 = 0,
            c3 = 0;

        /*
         * Compute coefficients for a cubic polynomial
         *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
         * such that
         *   p(0) = x0, p(1) = x1
         *  and
         *   p'(0) = t0, p'(1) = t1.
         */
        function init(x0, x1, t0, t1) {

            c0 = x0;
            c1 = t0;
            c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
            c3 = 2 * x0 - 2 * x1 + t0 + t1;
        }

        return {

            initCatmullRom: function initCatmullRom(x0, x1, x2, x3, tension) {

                init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
            },

            initNonuniformCatmullRom: function initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {

                // compute tangents when parameterized in [t1,t2]
                var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
                var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;

                // rescale tangents for parametrization in [0,1]
                t1 *= dt1;
                t2 *= dt1;

                init(x1, x2, t1, t2);
            },

            calc: function calc(t) {

                var t2 = t * t;
                var t3 = t2 * t;
                return c0 + c1 * t + c2 * t2 + c3 * t3;
            }

        };
    }

    //

    var tmp = new Vector3();
    var px = new CubicPoly();
    var py = new CubicPoly();
    var pz = new CubicPoly();

    function CatmullRomCurve3(p /* array of Vector3 */) {

        Curve.call(this);

        this.points = p || [];
        this.closed = false;
    }

    CatmullRomCurve3.prototype = Object.create(Curve.prototype);
    CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

    CatmullRomCurve3.prototype.getPoint = function (t) {

        var points = this.points;
        var l = points.length;

        if (l < 2) console.log('duh, you need at least 2 points');

        var point = (l - (this.closed ? 0 : 1)) * t;
        var intPoint = Math.floor(point);
        var weight = point - intPoint;

        if (this.closed) {

            intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
        } else if (weight === 0 && intPoint === l - 1) {

            intPoint = l - 2;
            weight = 1;
        }

        var p0, p1, p2, p3; // 4 points

        if (this.closed || intPoint > 0) {

            p0 = points[(intPoint - 1) % l];
        } else {

            // extrapolate first point
            tmp.subVectors(points[0], points[1]).add(points[0]);
            p0 = tmp;
        }

        p1 = points[intPoint % l];
        p2 = points[(intPoint + 1) % l];

        if (this.closed || intPoint + 2 < l) {

            p3 = points[(intPoint + 2) % l];
        } else {

            // extrapolate last point
            tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
            p3 = tmp;
        }

        if (this.type === undefined || this.type === 'centripetal' || this.type === 'chordal') {

            // init Centripetal / Chordal Catmull-Rom
            var pow = this.type === 'chordal' ? 0.5 : 0.25;
            var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
            var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
            var dt2 = Math.pow(p2.distanceToSquared(p3), pow);

            // safety check for repeated points
            if (dt1 < 1e-4) dt1 = 1.0;
            if (dt0 < 1e-4) dt0 = dt1;
            if (dt2 < 1e-4) dt2 = dt1;

            px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
            pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        } else if (this.type === 'catmullrom') {

            var tension = this.tension !== undefined ? this.tension : 0.5;
            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension);
            py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension);
            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);
        }

        return new Vector3(px.calc(weight), py.calc(weight), pz.calc(weight));
    };

    function CubicBezierCurve3(v0, v1, v2, v3) {

        Curve.call(this);

        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    }

    CubicBezierCurve3.prototype = Object.create(Curve.prototype);
    CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

    CubicBezierCurve3.prototype.getPoint = function (t) {

        var v0 = this.v0,
            v1 = this.v1,
            v2 = this.v2,
            v3 = this.v3;

        return new Vector3(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
    };

    function QuadraticBezierCurve3(v0, v1, v2) {

        Curve.call(this);

        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
    }

    QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
    QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

    QuadraticBezierCurve3.prototype.getPoint = function (t) {

        var v0 = this.v0,
            v1 = this.v1,
            v2 = this.v2;

        return new Vector3(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
    };

    function LineCurve3(v1, v2) {

        Curve.call(this);

        this.v1 = v1;
        this.v2 = v2;
    }

    LineCurve3.prototype = Object.create(Curve.prototype);
    LineCurve3.prototype.constructor = LineCurve3;

    LineCurve3.prototype.getPoint = function (t) {

        if (t === 1) {

            return this.v2.clone();
        }

        var vector = new Vector3();

        vector.subVectors(this.v2, this.v1); // diff
        vector.multiplyScalar(t);
        vector.add(this.v1);

        return vector;
    };

    function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {

        EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    }

    ArcCurve.prototype = Object.create(EllipseCurve.prototype);
    ArcCurve.prototype.constructor = ArcCurve;

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    var SceneUtils = {

        createMultiMaterialObject: function createMultiMaterialObject(geometry, materials) {

            var group = new Group();

            for (var i = 0, l = materials.length; i < l; i++) {

                group.add(new Mesh(geometry, materials[i]));
            }

            return group;
        },

        detach: function detach(child, parent, scene) {

            child.applyMatrix(parent.matrixWorld);
            parent.remove(child);
            scene.add(child);
        },

        attach: function attach(child, scene, parent) {

            var matrixWorldInverse = new Matrix4();
            matrixWorldInverse.getInverse(parent.matrixWorld);
            child.applyMatrix(matrixWorldInverse);

            scene.remove(child);
            parent.add(child);
        }

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Face4(a, b, c, d, normal, color, materialIndex) {

        console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
        return new Face3(a, b, c, normal, color, materialIndex);
    }

    var LineStrip = 0;

    var LinePieces = 1;

    function MeshFaceMaterial(materials) {

        console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
        return materials;
    }

    function MultiMaterial(materials) {

        if (materials === undefined) materials = [];

        console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
        materials.isMultiMaterial = true;
        materials.materials = materials;
        materials.clone = function () {

            return materials.slice();
        };
        return materials;
    }

    function PointCloud(geometry, material) {

        console.warn('THREE.PointCloud has been renamed to THREE.Points.');
        return new Points(geometry, material);
    }

    function Particle(material) {

        console.warn('THREE.Particle has been renamed to THREE.Sprite.');
        return new Sprite(material);
    }

    function ParticleSystem(geometry, material) {

        console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
        return new Points(geometry, material);
    }

    function PointCloudMaterial(parameters) {

        console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
        return new PointsMaterial(parameters);
    }

    function ParticleBasicMaterial(parameters) {

        console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
        return new PointsMaterial(parameters);
    }

    function ParticleSystemMaterial(parameters) {

        console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
        return new PointsMaterial(parameters);
    }

    function Vertex(x, y, z) {

        console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
        return new Vector3(x, y, z);
    }

    //

    function DynamicBufferAttribute(array, itemSize) {

        console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');
        return new BufferAttribute(array, itemSize).setDynamic(true);
    }

    function Int8Attribute(array, itemSize) {

        console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
        return new Int8BufferAttribute(array, itemSize);
    }

    function Uint8Attribute(array, itemSize) {

        console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
        return new Uint8BufferAttribute(array, itemSize);
    }

    function Uint8ClampedAttribute(array, itemSize) {

        console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
        return new Uint8ClampedBufferAttribute(array, itemSize);
    }

    function Int16Attribute(array, itemSize) {

        console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
        return new Int16BufferAttribute(array, itemSize);
    }

    function Uint16Attribute(array, itemSize) {

        console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
        return new Uint16BufferAttribute(array, itemSize);
    }

    function Int32Attribute(array, itemSize) {

        console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
        return new Int32BufferAttribute(array, itemSize);
    }

    function Uint32Attribute(array, itemSize) {

        console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
        return new Uint32BufferAttribute(array, itemSize);
    }

    function Float32Attribute(array, itemSize) {

        console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
        return new Float32BufferAttribute(array, itemSize);
    }

    function Float64Attribute(array, itemSize) {

        console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
        return new Float64BufferAttribute(array, itemSize);
    }

    //

    Curve.create = function (construct, getPoint) {

        console.log('THREE.Curve.create() has been deprecated');

        construct.prototype = Object.create(Curve.prototype);
        construct.prototype.constructor = construct;
        construct.prototype.getPoint = getPoint;

        return construct;
    };

    //

    function ClosedSplineCurve3(points) {

        console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');

        CatmullRomCurve3.call(this, points);
        this.type = 'catmullrom';
        this.closed = true;
    }

    ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);

    //

    function SplineCurve3(points) {

        console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');

        CatmullRomCurve3.call(this, points);
        this.type = 'catmullrom';
    }

    SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);

    //

    function Spline(points) {

        console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');

        CatmullRomCurve3.call(this, points);
        this.type = 'catmullrom';
    }

    Spline.prototype = Object.create(CatmullRomCurve3.prototype);

    Object.assign(Spline.prototype, {

        initFromArray: function initFromArray(a) {

            console.error('THREE.Spline: .initFromArray() has been removed.');
        },
        getControlPointsArray: function getControlPointsArray(optionalTarget) {

            console.error('THREE.Spline: .getControlPointsArray() has been removed.');
        },
        reparametrizeByArcLength: function reparametrizeByArcLength(samplingCoef) {

            console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
        }

    });

    //
    function BoundingBoxHelper(object, color) {

        console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
        return new BoxHelper(object, color);
    }

    function EdgesHelper(object, hex) {

        console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
        return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({ color: hex !== undefined ? hex : 0xffffff }));
    }

    GridHelper.prototype.setColors = function () {

        console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
    };

    function WireframeHelper(object, hex) {

        console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
        return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({ color: hex !== undefined ? hex : 0xffffff }));
    }

    //

    function XHRLoader(manager) {

        console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
        return new FileLoader(manager);
    }

    function BinaryTextureLoader(manager) {

        console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
        return new DataTextureLoader(manager);
    }

    //

    Object.assign(Box2.prototype, {

        center: function center(optionalTarget) {

            console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
            return this.getCenter(optionalTarget);
        },
        empty: function empty() {

            console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
            return this.isEmpty();
        },
        isIntersectionBox: function isIntersectionBox(box) {

            console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(box);
        },
        size: function size(optionalTarget) {

            console.warn('THREE.Box2: .size() has been renamed to .getSize().');
            return this.getSize(optionalTarget);
        }
    });

    Object.assign(Box3.prototype, {

        center: function center(optionalTarget) {

            console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
            return this.getCenter(optionalTarget);
        },
        empty: function empty() {

            console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
            return this.isEmpty();
        },
        isIntersectionBox: function isIntersectionBox(box) {

            console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(box);
        },
        isIntersectionSphere: function isIntersectionSphere(sphere) {

            console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
            return this.intersectsSphere(sphere);
        },
        size: function size(optionalTarget) {

            console.warn('THREE.Box3: .size() has been renamed to .getSize().');
            return this.getSize(optionalTarget);
        }
    });

    Line3.prototype.center = function (optionalTarget) {

        console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
        return this.getCenter(optionalTarget);
    };

    _Math.random16 = function () {

        console.warn('THREE.Math.random16() has been deprecated. Use Math.random() instead.');
        return Math.random();
    };

    Object.assign(Matrix3.prototype, {

        flattenToArrayOffset: function flattenToArrayOffset(array, offset) {

            console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
            return this.toArray(array, offset);
        },
        multiplyVector3: function multiplyVector3(vector) {

            console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
            return vector.applyMatrix3(this);
        },
        multiplyVector3Array: function multiplyVector3Array(a) {

            console.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
            return this.applyToVector3Array(a);
        },
        applyToBuffer: function applyToBuffer(buffer, offset, length) {

            console.warn('THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');
            return this.applyToBufferAttribute(buffer);
        },
        applyToVector3Array: function applyToVector3Array(array, offset, length) {

            console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
        }

    });

    Object.assign(Matrix4.prototype, {

        extractPosition: function extractPosition(m) {

            console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
            return this.copyPosition(m);
        },
        flattenToArrayOffset: function flattenToArrayOffset(array, offset) {

            console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
            return this.toArray(array, offset);
        },
        getPosition: function () {

            var v1;

            return function getPosition() {

                if (v1 === undefined) v1 = new Vector3();
                console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
                return v1.setFromMatrixColumn(this, 3);
            };
        }(),
        setRotationFromQuaternion: function setRotationFromQuaternion(q) {

            console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
            return this.makeRotationFromQuaternion(q);
        },
        multiplyToArray: function multiplyToArray() {

            console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
        },
        multiplyVector3: function multiplyVector3(vector) {

            console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
            return vector.applyMatrix4(this);
        },
        multiplyVector4: function multiplyVector4(vector) {

            console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
            return vector.applyMatrix4(this);
        },
        multiplyVector3Array: function multiplyVector3Array(a) {

            console.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
            return this.applyToVector3Array(a);
        },
        rotateAxis: function rotateAxis(v) {

            console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
            v.transformDirection(this);
        },
        crossVector: function crossVector(vector) {

            console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
            return vector.applyMatrix4(this);
        },
        translate: function translate() {

            console.error('THREE.Matrix4: .translate() has been removed.');
        },
        rotateX: function rotateX() {

            console.error('THREE.Matrix4: .rotateX() has been removed.');
        },
        rotateY: function rotateY() {

            console.error('THREE.Matrix4: .rotateY() has been removed.');
        },
        rotateZ: function rotateZ() {

            console.error('THREE.Matrix4: .rotateZ() has been removed.');
        },
        rotateByAxis: function rotateByAxis() {

            console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
        },
        applyToBuffer: function applyToBuffer(buffer, offset, length) {

            console.warn('THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');
            return this.applyToBufferAttribute(buffer);
        },
        applyToVector3Array: function applyToVector3Array(array, offset, length) {

            console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
        },
        makeFrustum: function makeFrustum(left, right, bottom, top, near, far) {

            console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
            return this.makePerspective(left, right, top, bottom, near, far);
        }

    });

    Plane.prototype.isIntersectionLine = function (line) {

        console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
        return this.intersectsLine(line);
    };

    Quaternion.prototype.multiplyVector3 = function (vector) {

        console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
        return vector.applyQuaternion(this);
    };

    Object.assign(Ray.prototype, {

        isIntersectionBox: function isIntersectionBox(box) {

            console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(box);
        },
        isIntersectionPlane: function isIntersectionPlane(plane) {

            console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
            return this.intersectsPlane(plane);
        },
        isIntersectionSphere: function isIntersectionSphere(sphere) {

            console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
            return this.intersectsSphere(sphere);
        }

    });

    Object.assign(Shape.prototype, {

        extrude: function extrude(options) {

            console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
            return new ExtrudeGeometry(this, options);
        },
        makeGeometry: function makeGeometry(options) {

            console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
            return new ShapeGeometry(this, options);
        }

    });

    Object.assign(Vector2.prototype, {

        fromAttribute: function fromAttribute(attribute, index, offset) {

            console.error('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
            return this.fromBufferAttribute(attribute, index, offset);
        }

    });

    Object.assign(Vector3.prototype, {

        setEulerFromRotationMatrix: function setEulerFromRotationMatrix() {

            console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
        },
        setEulerFromQuaternion: function setEulerFromQuaternion() {

            console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
        },
        getPositionFromMatrix: function getPositionFromMatrix(m) {

            console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
            return this.setFromMatrixPosition(m);
        },
        getScaleFromMatrix: function getScaleFromMatrix(m) {

            console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
            return this.setFromMatrixScale(m);
        },
        getColumnFromMatrix: function getColumnFromMatrix(index, matrix) {

            console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
            return this.setFromMatrixColumn(matrix, index);
        },
        applyProjection: function applyProjection(m) {

            console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
            return this.applyMatrix4(m);
        },
        fromAttribute: function fromAttribute(attribute, index, offset) {

            console.error('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
            return this.fromBufferAttribute(attribute, index, offset);
        }

    });

    Object.assign(Vector4.prototype, {

        fromAttribute: function fromAttribute(attribute, index, offset) {

            console.error('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
            return this.fromBufferAttribute(attribute, index, offset);
        }

    });

    //

    Geometry.prototype.computeTangents = function () {

        console.warn('THREE.Geometry: .computeTangents() has been removed.');
    };

    Object.assign(Object3D.prototype, {

        getChildByName: function getChildByName(name) {

            console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
            return this.getObjectByName(name);
        },
        renderDepth: function renderDepth() {

            console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
        },
        translate: function translate(distance, axis) {

            console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
            return this.translateOnAxis(axis, distance);
        }

    });

    Object.defineProperties(Object3D.prototype, {

        eulerOrder: {
            get: function get() {

                console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
                return this.rotation.order;
            },
            set: function set(value) {

                console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
                this.rotation.order = value;
            }
        },
        useQuaternion: {
            get: function get() {

                console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
            },
            set: function set() {

                console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
            }
        }

    });

    Object.defineProperties(LOD.prototype, {

        objects: {
            get: function get() {

                console.warn('THREE.LOD: .objects has been renamed to .levels.');
                return this.levels;
            }
        }

    });

    Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {

        get: function get() {

            console.warn('THREE.Skeleton: useVertexTexture has been removed.');
        },
        set: function set() {

            console.warn('THREE.Skeleton: useVertexTexture has been removed.');
        }

    });

    Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {

        get: function get() {

            console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
            return this.arcLengthDivisions;
        },
        set: function set(value) {

            console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
            this.arcLengthDivisions = value;
        }

    });

    //

    PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {

        console.warn("THREE.PerspectiveCamera.setLens is deprecated. " + "Use .setFocalLength and .filmGauge for a photographic setup.");

        if (filmGauge !== undefined) this.filmGauge = filmGauge;
        this.setFocalLength(focalLength);
    };

    //

    Object.defineProperties(Light.prototype, {
        onlyShadow: {
            set: function set() {

                console.warn('THREE.Light: .onlyShadow has been removed.');
            }
        },
        shadowCameraFov: {
            set: function set(value) {

                console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
                this.shadow.camera.fov = value;
            }
        },
        shadowCameraLeft: {
            set: function set(value) {

                console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
                this.shadow.camera.left = value;
            }
        },
        shadowCameraRight: {
            set: function set(value) {

                console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
                this.shadow.camera.right = value;
            }
        },
        shadowCameraTop: {
            set: function set(value) {

                console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
                this.shadow.camera.top = value;
            }
        },
        shadowCameraBottom: {
            set: function set(value) {

                console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
                this.shadow.camera.bottom = value;
            }
        },
        shadowCameraNear: {
            set: function set(value) {

                console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
                this.shadow.camera.near = value;
            }
        },
        shadowCameraFar: {
            set: function set(value) {

                console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
                this.shadow.camera.far = value;
            }
        },
        shadowCameraVisible: {
            set: function set() {

                console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
            }
        },
        shadowBias: {
            set: function set(value) {

                console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
                this.shadow.bias = value;
            }
        },
        shadowDarkness: {
            set: function set() {

                console.warn('THREE.Light: .shadowDarkness has been removed.');
            }
        },
        shadowMapWidth: {
            set: function set(value) {

                console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
                this.shadow.mapSize.width = value;
            }
        },
        shadowMapHeight: {
            set: function set(value) {

                console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
                this.shadow.mapSize.height = value;
            }
        }
    });

    //

    Object.defineProperties(BufferAttribute.prototype, {

        length: {
            get: function get() {

                console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
                return this.array.length;
            }
        }

    });

    Object.assign(BufferGeometry.prototype, {

        addIndex: function addIndex(index) {

            console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
            this.setIndex(index);
        },
        addDrawCall: function addDrawCall(start, count, indexOffset) {

            if (indexOffset !== undefined) {

                console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
            }
            console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
            this.addGroup(start, count);
        },
        clearDrawCalls: function clearDrawCalls() {

            console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
            this.clearGroups();
        },
        computeTangents: function computeTangents() {

            console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
        },
        computeOffsets: function computeOffsets() {

            console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
        }

    });

    Object.defineProperties(BufferGeometry.prototype, {

        drawcalls: {
            get: function get() {

                console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
                return this.groups;
            }
        },
        offsets: {
            get: function get() {

                console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
                return this.groups;
            }
        }

    });

    //

    Object.defineProperties(Uniform.prototype, {

        dynamic: {
            set: function set() {

                console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
            }
        },
        onUpdate: {
            value: function value() {

                console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
                return this;
            }
        }

    });

    //

    Object.defineProperties(Material.prototype, {

        wrapAround: {
            get: function get() {

                console.warn('THREE.Material: .wrapAround has been removed.');
            },
            set: function set() {

                console.warn('THREE.Material: .wrapAround has been removed.');
            }
        },
        wrapRGB: {
            get: function get() {

                console.warn('THREE.Material: .wrapRGB has been removed.');
                return new Color();
            }
        }

    });

    Object.defineProperties(MeshPhongMaterial.prototype, {

        metal: {
            get: function get() {

                console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
                return false;
            },
            set: function set() {

                console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
            }
        }

    });

    Object.defineProperties(ShaderMaterial.prototype, {

        derivatives: {
            get: function get() {

                console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
                return this.extensions.derivatives;
            },
            set: function set(value) {

                console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
                this.extensions.derivatives = value;
            }
        }

    });

    //

    Object.assign(WebGLRenderer.prototype, {

        getCurrentRenderTarget: function getCurrentRenderTarget() {

            console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
            return this.getRenderTarget();
        },

        supportsFloatTextures: function supportsFloatTextures() {

            console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
            return this.extensions.get('OES_texture_float');
        },
        supportsHalfFloatTextures: function supportsHalfFloatTextures() {

            console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
            return this.extensions.get('OES_texture_half_float');
        },
        supportsStandardDerivatives: function supportsStandardDerivatives() {

            console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
            return this.extensions.get('OES_standard_derivatives');
        },
        supportsCompressedTextureS3TC: function supportsCompressedTextureS3TC() {

            console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
            return this.extensions.get('WEBGL_compressed_texture_s3tc');
        },
        supportsCompressedTexturePVRTC: function supportsCompressedTexturePVRTC() {

            console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
            return this.extensions.get('WEBGL_compressed_texture_pvrtc');
        },
        supportsBlendMinMax: function supportsBlendMinMax() {

            console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
            return this.extensions.get('EXT_blend_minmax');
        },
        supportsVertexTextures: function supportsVertexTextures() {

            console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
            return this.capabilities.vertexTextures;
        },
        supportsInstancedArrays: function supportsInstancedArrays() {

            console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
            return this.extensions.get('ANGLE_instanced_arrays');
        },
        enableScissorTest: function enableScissorTest(boolean) {

            console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
            this.setScissorTest(boolean);
        },
        initMaterial: function initMaterial() {

            console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
        },
        addPrePlugin: function addPrePlugin() {

            console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
        },
        addPostPlugin: function addPostPlugin() {

            console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
        },
        updateShadowMap: function updateShadowMap() {

            console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
        }

    });

    Object.defineProperties(WebGLRenderer.prototype, {

        shadowMapEnabled: {
            get: function get() {

                return this.shadowMap.enabled;
            },
            set: function set(value) {

                console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
                this.shadowMap.enabled = value;
            }
        },
        shadowMapType: {
            get: function get() {

                return this.shadowMap.type;
            },
            set: function set(value) {

                console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
                this.shadowMap.type = value;
            }
        },
        shadowMapCullFace: {
            get: function get() {

                return this.shadowMap.cullFace;
            },
            set: function set(value) {

                console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');
                this.shadowMap.cullFace = value;
            }
        }
    });

    Object.defineProperties(WebGLShadowMap.prototype, {

        cullFace: {
            get: function get() {

                return this.renderReverseSided ? CullFaceFront : CullFaceBack;
            },
            set: function set(cullFace) {

                var value = cullFace !== CullFaceBack;
                console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + ".");
                this.renderReverseSided = value;
            }
        }

    });

    //

    Object.defineProperties(WebGLRenderTarget.prototype, {

        wrapS: {
            get: function get() {

                console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
                return this.texture.wrapS;
            },
            set: function set(value) {

                console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
                this.texture.wrapS = value;
            }
        },
        wrapT: {
            get: function get() {

                console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
                return this.texture.wrapT;
            },
            set: function set(value) {

                console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
                this.texture.wrapT = value;
            }
        },
        magFilter: {
            get: function get() {

                console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
                return this.texture.magFilter;
            },
            set: function set(value) {

                console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
                this.texture.magFilter = value;
            }
        },
        minFilter: {
            get: function get() {

                console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
                return this.texture.minFilter;
            },
            set: function set(value) {

                console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
                this.texture.minFilter = value;
            }
        },
        anisotropy: {
            get: function get() {

                console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
                return this.texture.anisotropy;
            },
            set: function set(value) {

                console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
                this.texture.anisotropy = value;
            }
        },
        offset: {
            get: function get() {

                console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
                return this.texture.offset;
            },
            set: function set(value) {

                console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
                this.texture.offset = value;
            }
        },
        repeat: {
            get: function get() {

                console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
                return this.texture.repeat;
            },
            set: function set(value) {

                console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
                this.texture.repeat = value;
            }
        },
        format: {
            get: function get() {

                console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
                return this.texture.format;
            },
            set: function set(value) {

                console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
                this.texture.format = value;
            }
        },
        type: {
            get: function get() {

                console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
                return this.texture.type;
            },
            set: function set(value) {

                console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
                this.texture.type = value;
            }
        },
        generateMipmaps: {
            get: function get() {

                console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
                return this.texture.generateMipmaps;
            },
            set: function set(value) {

                console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
                this.texture.generateMipmaps = value;
            }
        }

    });

    //

    Audio.prototype.load = function (file) {

        console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
        var scope = this;
        var audioLoader = new AudioLoader();
        audioLoader.load(file, function (buffer) {

            scope.setBuffer(buffer);
        });
        return this;
    };

    AudioAnalyser.prototype.getData = function () {

        console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
        return this.getFrequencyData();
    };

    //

    var GeometryUtils = {

        merge: function merge(geometry1, geometry2, materialIndexOffset) {

            console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
            var matrix;

            if (geometry2.isMesh) {

                geometry2.matrixAutoUpdate && geometry2.updateMatrix();

                matrix = geometry2.matrix;
                geometry2 = geometry2.geometry;
            }

            geometry1.merge(geometry2, matrix, materialIndexOffset);
        },

        center: function center(geometry) {

            console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
            return geometry.center();
        }

    };

    var ImageUtils = {

        crossOrigin: undefined,

        loadTexture: function loadTexture(url, mapping, onLoad, onError) {

            console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');

            var loader = new TextureLoader();
            loader.setCrossOrigin(this.crossOrigin);

            var texture = loader.load(url, onLoad, undefined, onError);

            if (mapping) texture.mapping = mapping;

            return texture;
        },

        loadTextureCube: function loadTextureCube(urls, mapping, onLoad, onError) {

            console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');

            var loader = new CubeTextureLoader();
            loader.setCrossOrigin(this.crossOrigin);

            var texture = loader.load(urls, onLoad, undefined, onError);

            if (mapping) texture.mapping = mapping;

            return texture;
        },

        loadCompressedTexture: function loadCompressedTexture() {

            console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
        },

        loadCompressedTextureCube: function loadCompressedTextureCube() {

            console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
        }

    };

    //

    function Projector() {

        console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');

        this.projectVector = function (vector, camera) {

            console.warn('THREE.Projector: .projectVector() is now vector.project().');
            vector.project(camera);
        };

        this.unprojectVector = function (vector, camera) {

            console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
            vector.unproject(camera);
        };

        this.pickingRay = function () {

            console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
        };
    }

    //

    function CanvasRenderer() {

        console.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');

        this.domElement = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
        this.clear = function () {};
        this.render = function () {};
        this.setClearColor = function () {};
        this.setSize = function () {};
    }

    /**
     * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most
     * recently used items while discarding least recently used items when its limit
     * is reached.
     *
     * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>
     * See README.md for details.
     *
     * Illustration of the design:
     *
     *       entry             entry             entry             entry
     *       ______            ______            ______            ______
     *      | head |.newer => |      |.newer => |      |.newer => | tail |
     *      |  A   |          |  B   |          |  C   |          |  D   |
     *      |______| <= older.|______| <= older.|______| <= older.|______|
     *
     *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added
     */

    var NEWER = Symbol('newer');
    var OLDER = Symbol('older');

    function LRUMap(limit, entries) {
        if (typeof limit !== 'number') {
            // called as (entries)
            entries = limit;
            limit = 0;
        }

        this.size = 0;
        this.limit = limit;
        this.oldest = this.newest = undefined;
        this._keymap = new Map();

        if (entries) {
            this.assign(entries);
            if (limit < 1) {
                this.limit = this.size;
            }
        }
    }

    function Entry(key, value) {
        this.key = key;
        this.value = value;
        this[NEWER] = undefined;
        this[OLDER] = undefined;
    }

    LRUMap.prototype._markEntryAsUsed = function (entry) {
        if (entry === this.newest) {
            // Already the most recenlty used entry, so no need to update the list
            return;
        }
        // HEAD--------------TAIL
        //   <.older   .newer>
        //  <--- add direction --
        //   A  B  C  <D>  E
        if (entry[NEWER]) {
            if (entry === this.oldest) {
                this.oldest = entry[NEWER];
            }
            entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.
        }
        if (entry[OLDER]) {
            entry[OLDER][NEWER] = entry[NEWER]; // C. --> E
        }
        entry[NEWER] = undefined; // D --x
        entry[OLDER] = this.newest; // D. --> E
        if (this.newest) {
            this.newest[NEWER] = entry; // E. <-- D
        }
        this.newest = entry;
    };

    LRUMap.prototype.assign = function (entries) {
        var entry = void 0,
            limit = this.limit || Number.MAX_VALUE;
        this._keymap.clear();
        var it = entries[Symbol.iterator]();
        for (var itv = it.next(); !itv.done; itv = it.next()) {
            var e = new Entry(itv.value[0], itv.value[1]);
            this._keymap.set(e.key, e);
            if (!entry) {
                this.oldest = e;
            } else {
                entry[NEWER] = e;
                e[OLDER] = entry;
            }
            entry = e;
            if (limit-- == 0) {
                throw new Error('overflow');
            }
        }
        this.newest = entry;
        this.size = this._keymap.size;
    };

    LRUMap.prototype.get = function (key) {
        // First, find our cache entry
        var entry = this._keymap.get(key);
        if (!entry) return; // Not cached. Sorry.
        // As <key> was found in the cache, register it as being requested recently
        this._markEntryAsUsed(entry);
        return entry.value;
    };

    LRUMap.prototype.set = function (key, value) {
        var entry = this._keymap.get(key);

        if (entry) {
            // update existing
            entry.value = value;
            this._markEntryAsUsed(entry);
            return this;
        }

        // new entry
        this._keymap.set(key, entry = new Entry(key, value));

        if (this.newest) {
            // link previous tail to the new tail (entry)
            this.newest[NEWER] = entry;
            entry[OLDER] = this.newest;
        } else {
            // we're first in -- yay
            this.oldest = entry;
        }

        // add new entry to the end of the linked list -- it's now the freshest entry.
        this.newest = entry;
        ++this.size;
        if (this.size > this.limit) {
            // we hit the limit -- remove the head
            this.shift();
        }

        return this;
    };

    LRUMap.prototype.shift = function () {
        // todo: handle special case when limit == 1
        var entry = this.oldest;
        if (entry) {
            if (this.oldest[NEWER]) {
                // advance the list
                this.oldest = this.oldest[NEWER];
                this.oldest[OLDER] = undefined;
            } else {
                // the cache is exhausted
                this.oldest = undefined;
                this.newest = undefined;
            }
            // Remove last strong reference to <entry> and remove links from the purged
            // entry being returned:
            entry[NEWER] = entry[OLDER] = undefined;
            this._keymap.delete(entry.key);
            --this.size;
            return [entry.key, entry.value];
        }
    };

    // ----------------------------------------------------------------------------
    // Following code is optional and can be removed without breaking the core
    // functionality.

    LRUMap.prototype.find = function (key) {
        var e = this._keymap.get(key);
        return e ? e.value : undefined;
    };

    LRUMap.prototype.has = function (key) {
        return this._keymap.has(key);
    };

    LRUMap.prototype['delete'] = function (key) {
        var entry = this._keymap.get(key);
        if (!entry) return;
        this._keymap.delete(entry.key);
        if (entry[NEWER] && entry[OLDER]) {
            // relink the older entry with the newer entry
            entry[OLDER][NEWER] = entry[NEWER];
            entry[NEWER][OLDER] = entry[OLDER];
        } else if (entry[NEWER]) {
            // remove the link to us
            entry[NEWER][OLDER] = undefined;
            // link the newer entry to head
            this.oldest = entry[NEWER];
        } else if (entry[OLDER]) {
            // remove the link to us
            entry[OLDER][NEWER] = undefined;
            // link the newer entry to head
            this.newest = entry[OLDER];
        } else {
            // if(entry[OLDER] === undefined && entry.newer === undefined) {
            this.oldest = this.newest = undefined;
        }

        this.size--;
        return entry.value;
    };

    LRUMap.prototype.clear = function () {
        // Not clearing links should be safe, as we don't expose live links to user
        this.oldest = this.newest = undefined;
        this.size = 0;
        this._keymap.clear();
    };

    function EntryIterator(oldestEntry) {
        this.entry = oldestEntry;
    }
    EntryIterator.prototype[Symbol.iterator] = function () {
        return this;
    };
    EntryIterator.prototype.next = function () {
        var ent = this.entry;
        if (ent) {
            this.entry = ent[NEWER];
            return { done: false, value: [ent.key, ent.value] };
        } else {
            return { done: true, value: undefined };
        }
    };

    function KeyIterator(oldestEntry) {
        this.entry = oldestEntry;
    }
    KeyIterator.prototype[Symbol.iterator] = function () {
        return this;
    };
    KeyIterator.prototype.next = function () {
        var ent = this.entry;
        if (ent) {
            this.entry = ent[NEWER];
            return { done: false, value: ent.key };
        } else {
            return { done: true, value: undefined };
        }
    };

    function ValueIterator(oldestEntry) {
        this.entry = oldestEntry;
    }
    ValueIterator.prototype[Symbol.iterator] = function () {
        return this;
    };
    ValueIterator.prototype.next = function () {
        var ent = this.entry;
        if (ent) {
            this.entry = ent[NEWER];
            return { done: false, value: ent.value };
        } else {
            return { done: true, value: undefined };
        }
    };

    LRUMap.prototype.keys = function () {
        return new KeyIterator(this.oldest);
    };

    LRUMap.prototype.values = function () {
        return new ValueIterator(this.oldest);
    };

    LRUMap.prototype.entries = function () {
        return this;
    };

    LRUMap.prototype[Symbol.iterator] = function () {
        return new EntryIterator(this.oldest);
    };

    LRUMap.prototype.forEach = function (fun, thisObj) {
        if ((typeof thisObj === "undefined" ? "undefined" : _typeof(thisObj)) !== 'object') {
            thisObj = this;
        }
        var entry = this.oldest;
        while (entry) {
            fun.call(thisObj, entry.value, entry.key, this);
            entry = entry[NEWER];
        }
    };

    /** Returns a JSON (array) representation */
    LRUMap.prototype.toJSON = function () {
        var s = new Array(this.size),
            i = 0,
            entry = this.oldest;
        while (entry) {
            s[i++] = { key: entry.key, value: entry.value };
            entry = entry[NEWER];
        }
        return s;
    };

    /** Returns a String representation */
    LRUMap.prototype.toString = function () {
        var s = '',
            entry = this.oldest;
        while (entry) {
            s += String(entry.key) + ':' + entry.value;
            entry = entry[NEWER];
            if (entry) {
                s += ' < ';
            }
        }
        return s;
    };

    function WebGLGeometriesEx(gl, attributes, infoMemory, maxDrawCacheNum) {

        var geometries = new LRUMap(maxDrawCacheNum);

        var wireframeAttributes = {};

        // limit use of memory to only hold commonly-used geometries,
        // dispose infrequent geometries. - xiaojian
        geometries.shift = function () {

            var entry = LRUMap.prototype.shift.call(this);
            var id = entry[0];
            var buffergeometry = entry[1];

            dispose(id, buffergeometry);
        };

        function dispose(id, buffergeometry) {

            if (buffergeometry.index !== null) {

                attributes.remove(buffergeometry.index);
            }

            for (var name in buffergeometry.attributes) {

                attributes.remove(buffergeometry.attributes[name]);
            }

            // geometry.removeEventListener( 'dispose', onGeometryDispose );

            // delete geometries[ id ];

            // TODO Remove duplicate code

            var attribute = wireframeAttributes[id];

            if (attribute) {

                attributes.remove(attribute);
                delete wireframeAttributes[id];
            }

            attribute = wireframeAttributes[buffergeometry.id];

            if (attribute) {

                attributes.remove(attribute);
                delete wireframeAttributes[buffergeometry.id];
            }

            //

            infoMemory.geometries--;
        }

        // function onGeometryDispose( event ) {
        //
        //     var geometry = event.target;
        //     var buffergeometry = geometries[ geometry.id ];
        //
        //     if ( buffergeometry.index !== null ) {
        //
        //         attributes.remove( buffergeometry.index );
        //
        //     }
        //
        //     for ( var name in buffergeometry.attributes ) {
        //
        //         attributes.remove( buffergeometry.attributes[ name ] );
        //
        //     }
        //
        //     geometry.removeEventListener( 'dispose', onGeometryDispose );
        //
        //     delete geometries[ geometry.id ];
        //
        //     // TODO Remove duplicate code
        //
        //     var attribute = wireframeAttributes[ geometry.id ];
        //
        //     if ( attribute ) {
        //
        //         attributes.remove( attribute );
        //         delete wireframeAttributes[ geometry.id ];
        //
        //     }
        //
        //     attribute = wireframeAttributes[ buffergeometry.id ];
        //
        //     if ( attribute ) {
        //
        //         attributes.remove( attribute );
        //         delete wireframeAttributes[ buffergeometry.id ];
        //
        //     }
        //
        //     //
        //
        //     infoMemory.geometries --;
        //
        // }

        function get(object, geometry) {

            // var buffergeometry = geometries[ geometry.id ];
            //
            // if ( buffergeometry ) return buffergeometry;

            // var geometry = object.geometry;

            var key = geometry.id;

            if (geometries.has(key)) {
                return geometries.get(key);
            }

            // do not add listener, dispose directly
            // geometry.addEventListener( 'dispose', onGeometryDispose );

            var buffergeometry;

            if (geometry.isBufferGeometry) {

                buffergeometry = geometry;
            } else if (geometry.isGeometry) {

                if (geometry._bufferGeometry === undefined) {

                    geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
                }

                buffergeometry = geometry._bufferGeometry;
            }

            // geometries[ geometry.id ] = buffergeometry;
            geometries.set(key, buffergeometry);

            infoMemory.geometries++;

            return buffergeometry;
        }

        function update(geometry) {

            var index = geometry.index;
            var geometryAttributes = geometry.attributes;

            if (index !== null) {

                attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
            }

            for (var name in geometryAttributes) {

                attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
            }

            // morph targets

            var morphAttributes = geometry.morphAttributes;

            for (var name in morphAttributes) {

                var array = morphAttributes[name];

                for (var i = 0, l = array.length; i < l; i++) {

                    attributes.update(array[i], gl.ARRAY_BUFFER);
                }
            }
        }

        function getWireframeAttribute(geometry) {

            var attribute = wireframeAttributes[geometry.id];

            if (attribute) return attribute;

            var indices = [];

            var geometryIndex = geometry.index;
            var geometryAttributes = geometry.attributes;

            // console.time( 'wireframe' );

            if (geometryIndex !== null) {

                var array = geometryIndex.array;

                for (var i = 0, l = array.length; i < l; i += 3) {

                    var a = array[i + 0];
                    var b = array[i + 1];
                    var c = array[i + 2];

                    indices.push(a, b, b, c, c, a);
                }
            } else {

                var array = geometryAttributes.position.array;

                for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {

                    var a = i + 0;
                    var b = i + 1;
                    var c = i + 2;

                    indices.push(a, b, b, c, c, a);
                }
            }

            // console.timeEnd( 'wireframe' );

            attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);

            attributes.update(attribute, gl.ELEMENT_ARRAY_BUFFER);

            wireframeAttributes[geometry.id] = attribute;

            return attribute;
        }

        return {

            get: get,
            update: update,

            getWireframeAttribute: getWireframeAttribute

        };
    }

    function WebGLRendererByIncrement(parameters) {
        console.log('THREE.WebGLRenderer', REVISION);

        parameters = parameters || {};

        var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
            _context = parameters.context !== undefined ? parameters.context : null,
            _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
            _depth = parameters.depth !== undefined ? parameters.depth : true,
            _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
            _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
            _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
            _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
            _maxDrawCacheNum = parameters.maxDrawCacheNum;

        var lights = [];

        var currentRenderList = null;

        var morphInfluences = new Float32Array(8);

        var sprites = [];
        var lensFlares = [];

        // public properties

        this.domElement = _canvas;
        this.context = null;

        // clearing

        this.autoClear = true;
        this.autoClearColor = true;
        this.autoClearDepth = true;
        this.autoClearStencil = true;

        // scene graph

        this.sortObjects = true;

        // user-defined clipping

        this.clippingPlanes = [];
        this.localClippingEnabled = false;

        // physically based shading

        this.gammaFactor = 2.0; // for backwards compatibility
        this.gammaInput = false;
        this.gammaOutput = false;

        // physical lights

        this.physicallyCorrectLights = false;

        // tone mapping

        this.toneMapping = LinearToneMapping;
        this.toneMappingExposure = 1.0;
        this.toneMappingWhitePoint = 1.0;

        // morphs

        this.maxMorphTargets = 8;
        this.maxMorphNormals = 4;

        // internal properties

        var _this = this,


        // internal state cache

        _currentProgram = null,
            _currentRenderTarget = null,
            _currentFramebuffer = null,
            _currentMaterialId = -1,
            _currentGeometryProgram = '',
            _currentCamera = null,
            _currentScissor = new Vector4(),
            _currentScissorTest = null,
            _currentViewport = new Vector4(),


        //

        _usedTextureUnits = 0,


        //

        _clearColor = new Color(0x000000),
            _clearAlpha = 0,
            _width = _canvas.width,
            _height = _canvas.height,
            _pixelRatio = 1,
            _scissor = new Vector4(0, 0, _width, _height),
            _scissorTest = false,
            _viewport = new Vector4(0, 0, _width, _height),


        // frustum

        _frustum = new Frustum(),


        // clipping

        _clipping = new WebGLClipping(),
            _clippingEnabled = false,
            _localClippingEnabled = false,


        // camera matrices cache

        _projScreenMatrix = new Matrix4(),
            _vector3 = new Vector3(),
            _matrix4 = new Matrix4(),
            _matrix42 = new Matrix4(),


        // light arrays cache

        _lights = {

            hash: '',

            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],

            shadows: []

        },


        // info

        _infoMemory = {
            geometries: 0,
            textures: 0
        },
            _infoRender = {

            frame: 0,
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0

        };

        this.info = {

            render: _infoRender,
            memory: _infoMemory,
            programs: null

        };

        // initialize

        var _gl;

        try {

            var contextAttributes = {
                alpha: _alpha,
                depth: _depth,
                stencil: _stencil,
                antialias: _antialias,
                premultipliedAlpha: _premultipliedAlpha,
                preserveDrawingBuffer: _preserveDrawingBuffer
            };

            _gl = _context || _canvas.getContext('webgl', contextAttributes) || _canvas.getContext('experimental-webgl', contextAttributes);

            if (_gl === null) {

                if (_canvas.getContext('webgl') !== null) {

                    throw 'Error creating WebGL context with your selected attributes.';
                } else {

                    throw 'Error creating WebGL context.';
                }
            }

            // Some experimental-webgl implementations do not have getShaderPrecisionFormat

            if (_gl.getShaderPrecisionFormat === undefined) {

                _gl.getShaderPrecisionFormat = function () {

                    return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
                };
            }

            _canvas.addEventListener('webglcontextlost', onContextLost, false);
        } catch (error) {

            console.error('THREE.WebGLRenderer: ' + error);
        }

        var extensions = new WebGLExtensions(_gl);

        extensions.get('WEBGL_depth_texture');
        extensions.get('OES_texture_float');
        extensions.get('OES_texture_float_linear');
        extensions.get('OES_texture_half_float');
        extensions.get('OES_texture_half_float_linear');
        extensions.get('OES_standard_derivatives');
        extensions.get('ANGLE_instanced_arrays');

        if (extensions.get('OES_element_index_uint')) {

            BufferGeometry.MaxIndex = 4294967296;
        }

        var capabilities = new WebGLCapabilities(_gl, extensions, parameters);

        var state = new WebGLState(_gl, extensions, paramThreeToGL);

        var properties = new WebGLProperties();
        var textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, _infoMemory);
        var attributes = new WebGLAttributes(_gl);

        // ------ Modified 支持 LRU Begin ------
        // var geometries = new WebGLGeometriesEx( _gl, attributes, _infoMemory, _maxDrawCacheNum );

        var geometries;
        if (_maxDrawCacheNum !== undefined) {
            geometries = new WebGLGeometriesEx(_gl, attributes, _infoMemory, _maxDrawCacheNum);
        } else {
            geometries = new WebGLGeometries(_gl, attributes, _infoMemory);
        }

        // ------ Modified 支持 LRU End  ------

        var objects = new WebGLObjects(_gl, geometries, _infoRender);
        var programCache = new WebGLPrograms(this, capabilities);
        var lightCache = new WebGLLights();
        var renderLists = new WebGLRenderLists();

        this.info.programs = programCache.programs;

        var bufferRenderer = new WebGLBufferRenderer(_gl, extensions, _infoRender);
        var indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, _infoRender);

        //

        var backgroundPlaneCamera, backgroundPlaneMesh;
        var backgroundBoxCamera, backgroundBoxMesh;

        //

        function getTargetPixelRatio() {

            return _currentRenderTarget === null ? _pixelRatio : 1;
        }

        function setDefaultGLState() {

            state.init();

            state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));

            state.buffers.color.setClear(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha);
        }

        function resetGLState() {

            _currentProgram = null;
            _currentCamera = null;

            _currentGeometryProgram = '';
            _currentMaterialId = -1;

            state.reset();
        }

        setDefaultGLState();

        this.context = _gl;
        this.capabilities = capabilities;
        this.extensions = extensions;
        this.properties = properties;
        this.state = state;

        // shadow map

        var shadowMap = new WebGLShadowMap(this, _lights, objects, capabilities);

        this.shadowMap = shadowMap;

        // Plugins

        var spritePlugin = new SpritePlugin(this, sprites);
        var lensFlarePlugin = new LensFlarePlugin(this, lensFlares);

        // API

        this.getContext = function () {

            return _gl;
        };

        this.getContextAttributes = function () {

            return _gl.getContextAttributes();
        };

        this.forceContextLoss = function () {

            var extension = extensions.get('WEBGL_lose_context');
            if (extension) extension.loseContext();
        };

        this.getMaxAnisotropy = function () {

            return capabilities.getMaxAnisotropy();
        };

        this.getPrecision = function () {

            return capabilities.precision;
        };

        this.getPixelRatio = function () {

            return _pixelRatio;
        };

        this.setPixelRatio = function (value) {

            if (value === undefined) return;

            _pixelRatio = value;

            this.setSize(_viewport.z, _viewport.w, false);
        };

        this.getSize = function () {

            return {
                width: _width,
                height: _height
            };
        };

        this.setSize = function (width, height, updateStyle) {

            _width = width;
            _height = height;

            _canvas.width = width * _pixelRatio;
            _canvas.height = height * _pixelRatio;

            if (updateStyle !== false) {

                _canvas.style.width = width + 'px';
                _canvas.style.height = height + 'px';
            }

            this.setViewport(0, 0, width, height);
        };

        this.setViewport = function (x, y, width, height) {

            state.viewport(_viewport.set(x, y, width, height));
        };

        this.setScissor = function (x, y, width, height) {

            state.scissor(_scissor.set(x, y, width, height));
        };

        this.setScissorTest = function (boolean) {

            state.setScissorTest(_scissorTest = boolean);
        };

        // Clearing

        this.getClearColor = function () {

            return _clearColor;
        };

        this.setClearColor = function (color, alpha) {

            _clearColor.set(color);

            _clearAlpha = alpha !== undefined ? alpha : 1;

            state.buffers.color.setClear(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha);
        };

        this.getClearAlpha = function () {

            return _clearAlpha;
        };

        this.setClearAlpha = function (alpha) {

            _clearAlpha = alpha;

            state.buffers.color.setClear(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha);
        };

        this.clear = function (color, depth, stencil) {

            var bits = 0;

            if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
            if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
            if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;

            _gl.clear(bits);
        };

        this.clearColor = function () {

            this.clear(true, false, false);
        };

        this.clearDepth = function () {

            this.clear(false, true, false);
        };

        this.clearStencil = function () {

            this.clear(false, false, true);
        };

        this.clearTarget = function (renderTarget, color, depth, stencil) {

            this.setRenderTarget(renderTarget);
            this.clear(color, depth, stencil);
        };

        // Reset

        this.resetGLState = resetGLState;

        this.dispose = function () {

            _canvas.removeEventListener('webglcontextlost', onContextLost, false);

            renderLists.dispose();
        };

        // Events

        function onContextLost(event) {

            event.preventDefault();

            resetGLState();
            setDefaultGLState();

            properties.clear();
            objects.clear();
        }

        function onMaterialDispose(event) {

            var material = event.target;

            material.removeEventListener('dispose', onMaterialDispose);

            deallocateMaterial(material);
        }

        // Buffer deallocation

        function deallocateMaterial(material) {

            releaseMaterialProgramReference(material);

            properties.remove(material);
        }

        function releaseMaterialProgramReference(material) {

            var programInfo = properties.get(material).program;

            material.program = undefined;

            if (programInfo !== undefined) {

                programCache.releaseProgram(programInfo);
            }
        }

        // Buffer rendering

        this.renderBufferImmediate = function (object, program, material) {

            state.initAttributes();

            var buffers = properties.get(object);

            if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
            if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
            if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
            if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();

            var programAttributes = program.getAttributes();

            if (object.hasPositions) {

                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);

                state.enableAttribute(programAttributes.position);
                _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
            }

            if (object.hasNormals) {

                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);

                if (!material.isMeshPhongMaterial && !material.isMeshStandardMaterial && !material.isMeshNormalMaterial && material.shading === FlatShading) {

                    for (var i = 0, l = object.count * 3; i < l; i += 9) {

                        var array = object.normalArray;

                        var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
                        var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
                        var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;

                        array[i + 0] = nx;
                        array[i + 1] = ny;
                        array[i + 2] = nz;

                        array[i + 3] = nx;
                        array[i + 4] = ny;
                        array[i + 5] = nz;

                        array[i + 6] = nx;
                        array[i + 7] = ny;
                        array[i + 8] = nz;
                    }
                }

                _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);

                state.enableAttribute(programAttributes.normal);

                _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
            }

            if (object.hasUvs && material.map) {

                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);

                state.enableAttribute(programAttributes.uv);

                _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
            }

            if (object.hasColors && material.vertexColors !== NoColors) {

                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);

                state.enableAttribute(programAttributes.color);

                _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
            }

            state.disableUnusedAttributes();

            _gl.drawArrays(_gl.TRIANGLES, 0, object.count);

            object.count = 0;
        };

        function absNumericalSort(a, b) {

            return Math.abs(b[0]) - Math.abs(a[0]);
        }

        this.renderBufferDirect = function (camera, fog, geometry, material, object, group) {

            state.setMaterial(material);

            var program = setProgram(camera, fog, material, object);
            //var geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );
            var geometryProgram = geometry.id;
            geometryProgram += '_';
            geometryProgram += program.id;
            geometryProgram += '_';
            geometryProgram += material.wireframe === true;

            var updateBuffers = false;

            if (geometryProgram !== _currentGeometryProgram) {

                _currentGeometryProgram = geometryProgram;
                updateBuffers = true;
            }

            // morph targets

            var morphTargetInfluences = object.morphTargetInfluences;

            if (morphTargetInfluences !== undefined) {

                // TODO Remove allocations

                var activeInfluences = [];

                for (var i = 0, l = morphTargetInfluences.length; i < l; i++) {

                    var influence = morphTargetInfluences[i];
                    activeInfluences.push([influence, i]);
                }

                activeInfluences.sort(absNumericalSort);

                if (activeInfluences.length > 8) {

                    activeInfluences.length = 8;
                }

                var morphAttributes = geometry.morphAttributes;

                for (var i = 0, l = activeInfluences.length; i < l; i++) {

                    var influence = activeInfluences[i];
                    morphInfluences[i] = influence[0];

                    if (influence[0] !== 0) {

                        var index = influence[1];

                        if (material.morphTargets === true && morphAttributes.position) geometry.addAttribute('morphTarget' + i, morphAttributes.position[index]);
                        if (material.morphNormals === true && morphAttributes.normal) geometry.addAttribute('morphNormal' + i, morphAttributes.normal[index]);
                    } else {

                        if (material.morphTargets === true) geometry.removeAttribute('morphTarget' + i);
                        if (material.morphNormals === true) geometry.removeAttribute('morphNormal' + i);
                    }
                }

                for (var i = activeInfluences.length, il = morphInfluences.length; i < il; i++) {

                    morphInfluences[i] = 0.0;
                }

                program.getUniforms().setValue(_gl, 'morphTargetInfluences', morphInfluences);

                updateBuffers = true;
            }

            //

            var index = geometry.index;
            var position = geometry.attributes.position;
            var rangeFactor = 1;

            if (material.wireframe === true) {

                index = geometries.getWireframeAttribute(geometry);
                rangeFactor = 2;
            }

            var renderer = bufferRenderer;

            if (index !== null) {

                renderer = indexedBufferRenderer;
                renderer.setIndex(index);
            }

            if (updateBuffers) {

                setupVertexAttributes(material, program, geometry);

                if (index !== null) {

                    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
                }
            }

            //

            var dataCount = 0;

            if (index !== null) {

                dataCount = index.count;
            } else if (position !== undefined) {

                dataCount = position.count;
            }

            var rangeStart = geometry.drawRange.start * rangeFactor;
            var rangeCount = geometry.drawRange.count * rangeFactor;

            var groupStart = group !== null ? group.start * rangeFactor : 0;
            var groupCount = group !== null ? group.count * rangeFactor : Infinity;

            var drawStart = Math.max(rangeStart, groupStart);
            var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;

            var drawCount = Math.max(0, drawEnd - drawStart + 1);

            if (drawCount === 0) return;

            //

            if (object.isMesh) {

                if (material.wireframe === true) {

                    state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                    renderer.setMode(_gl.LINES);
                } else {

                    switch (object.drawMode) {

                        case TrianglesDrawMode:
                            renderer.setMode(_gl.TRIANGLES);
                            break;

                        case TriangleStripDrawMode:
                            renderer.setMode(_gl.TRIANGLE_STRIP);
                            break;

                        case TriangleFanDrawMode:
                            renderer.setMode(_gl.TRIANGLE_FAN);
                            break;

                    }
                }
            } else if (object.isLine) {

                var lineWidth = material.linewidth;

                if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

                state.setLineWidth(lineWidth * getTargetPixelRatio());

                if (object.isLineSegments) {

                    renderer.setMode(_gl.LINES);
                } else if (object.isLineLoop) {

                    renderer.setMode(_gl.LINE_LOOP);
                } else {

                    renderer.setMode(_gl.LINE_STRIP);
                }
            } else if (object.isPoints) {

                renderer.setMode(_gl.POINTS);
            }

            if (geometry && geometry.isInstancedBufferGeometry) {

                if (geometry.maxInstancedCount > 0) {

                    renderer.renderInstances(geometry, drawStart, drawCount);
                }
            } else {

                renderer.render(drawStart, drawCount);
            }
        };

        function setupVertexAttributes(material, program, geometry, startIndex) {

            if (geometry && geometry.isInstancedBufferGeometry) {

                if (extensions.get('ANGLE_instanced_arrays') === null) {

                    console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                    return;
                }
            }

            if (startIndex === undefined) startIndex = 0;

            state.initAttributes();

            var geometryAttributes = geometry.attributes;

            var programAttributes = program.getAttributes();

            var materialDefaultAttributeValues = material.defaultAttributeValues;

            for (var name in programAttributes) {

                var programAttribute = programAttributes[name];

                if (programAttribute >= 0) {

                    var geometryAttribute = geometryAttributes[name];

                    if (geometryAttribute !== undefined) {

                        var normalized = geometryAttribute.normalized;
                        var size = geometryAttribute.itemSize;

                        var attributeProperties = attributes.get(geometryAttribute);

                        var buffer = attributeProperties.buffer;
                        var type = attributeProperties.type;
                        var bytesPerElement = attributeProperties.bytesPerElement;

                        if (geometryAttribute.isInterleavedBufferAttribute) {

                            var data = geometryAttribute.data;
                            var stride = data.stride;
                            var offset = geometryAttribute.offset;

                            if (data && data.isInstancedInterleavedBuffer) {

                                state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

                                if (geometry.maxInstancedCount === undefined) {

                                    geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                                }
                            } else {

                                state.enableAttribute(programAttribute);
                            }

                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                            _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, (startIndex * stride + offset) * bytesPerElement);
                        } else {

                            if (geometryAttribute.isInstancedBufferAttribute) {

                                state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

                                if (geometry.maxInstancedCount === undefined) {

                                    geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                                }
                            } else {

                                state.enableAttribute(programAttribute);
                            }

                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                            _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement);
                        }
                    } else if (materialDefaultAttributeValues !== undefined) {

                        var value = materialDefaultAttributeValues[name];

                        if (value !== undefined) {

                            switch (value.length) {

                                case 2:
                                    _gl.vertexAttrib2fv(programAttribute, value);
                                    break;

                                case 3:
                                    _gl.vertexAttrib3fv(programAttribute, value);
                                    break;

                                case 4:
                                    _gl.vertexAttrib4fv(programAttribute, value);
                                    break;

                                default:
                                    _gl.vertexAttrib1fv(programAttribute, value);

                            }
                        }
                    }
                }
            }

            state.disableUnusedAttributes();
        }

        // Compile

        this.compile = function (scene, camera) {

            lights = [];

            scene.traverse(function (object) {

                if (object.isLight) {

                    lights.push(object);
                }
            });

            setupLights(lights, camera);

            scene.traverse(function (object) {

                if (object.material) {

                    if (Array.isArray(object.material)) {

                        for (var i = 0; i < object.material.length; i++) {

                            initMaterial(object.material[i], scene.fog, object);
                        }
                    } else {

                        initMaterial(object.material, scene.fog, object);
                    }
                }
            });
        };

        // Rendering

        this.render = function (scene, camera, renderTarget, forceClear) {

            if (_orderedRenderer === null) {
                console.error('THREE.WebGLRenderer.render: OrderedRenderer is not set.');
                return;
            }

            if (camera !== undefined && camera.isCamera !== true) {

                console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
                return;
            }

            // reset caching for this frame

            _currentGeometryProgram = '';
            _currentMaterialId = -1;
            _currentCamera = null;

            // update scene graph

            if (scene.autoUpdate === true) scene.updateMatrixWorld();

            // update camera matrices and frustum

            camera.onBeforeRender(_this);

            if (camera.parent === null) camera.updateMatrixWorld();

            camera.matrixWorldInverse.getInverse(camera.matrixWorld);

            _localClippingEnabled = this.localClippingEnabled;
            _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);

            _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            _frustum.setFromMatrix(_projScreenMatrix);

            _infoRender.frame++;
            _infoRender.calls = 0;
            _infoRender.vertices = 0;
            _infoRender.faces = 0;
            _infoRender.points = 0;

            _orderedRenderer.update(_frustum, _projScreenMatrix);

            return _orderedRenderer.render(this, scene, camera, lights, renderTarget, forceClear, state);
        };

        /*
         // TODO Duplicated code (Frustum)
        		 var _sphere = new Sphere();
        		 function isObjectViewable( object ) {
        		 var geometry = object.geometry;
        		 if ( geometry.boundingSphere === null )
         geometry.computeBoundingSphere();
        		 _sphere.copy( geometry.boundingSphere ).
         applyMatrix4( object.matrixWorld );
        		 return isSphereViewable( _sphere );
        		 }
        		 function isSpriteViewable( sprite ) {
        		 _sphere.center.set( 0, 0, 0 );
         _sphere.radius = 0.7071067811865476;
         _sphere.applyMatrix4( sprite.matrixWorld );
        		 return isSphereViewable( _sphere );
        		 }
        		 function isSphereViewable( sphere ) {
        		 if ( ! _frustum.intersectsSphere( sphere ) ) return false;
        		 var numPlanes = _clipping.numPlanes;
        		 if ( numPlanes === 0 ) return true;
        		 var planes = _this.clippingPlanes,
        		 center = sphere.center,
         negRad = - sphere.radius,
         i = 0;
        		 do {
        		 // out when deeper than radius in the negative halfspace
         if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;
        		 } while ( ++ i !== numPlanes );
        		 return true;
        		 }
         */

        function initMaterial(material, fog, object) {

            var materialProperties = properties.get(material);

            var parameters = programCache.getParameters(material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object);

            var code = programCache.getProgramCode(material, parameters);

            var program = materialProperties.program;
            var programChange = true;

            if (program === undefined) {

                // new material
                material.addEventListener('dispose', onMaterialDispose);
            } else if (program.code !== code) {

                // changed glsl or parameters
                releaseMaterialProgramReference(material);
            } else if (parameters.shaderID !== undefined) {

                // same glsl and uniform list
                return;
            } else {

                // only rebuild uniform list
                programChange = false;
            }

            if (programChange) {

                if (parameters.shaderID) {

                    var shader = ShaderLib[parameters.shaderID];

                    materialProperties.__webglShader = {
                        name: material.type,
                        uniforms: UniformsUtils.clone(shader.uniforms),
                        vertexShader: shader.vertexShader,
                        fragmentShader: shader.fragmentShader
                    };
                } else {

                    materialProperties.__webglShader = {
                        name: material.type,
                        uniforms: material.uniforms,
                        vertexShader: material.vertexShader,
                        fragmentShader: material.fragmentShader
                    };
                }

                material.__webglShader = materialProperties.__webglShader;

                program = programCache.acquireProgram(material, parameters, code);

                materialProperties.program = program;
                material.program = program;
            }

            var programAttributes = program.getAttributes();

            if (material.morphTargets) {

                material.numSupportedMorphTargets = 0;

                for (var i = 0; i < _this.maxMorphTargets; i++) {

                    if (programAttributes['morphTarget' + i] >= 0) {

                        material.numSupportedMorphTargets++;
                    }
                }
            }

            if (material.morphNormals) {

                material.numSupportedMorphNormals = 0;

                for (var i = 0; i < _this.maxMorphNormals; i++) {

                    if (programAttributes['morphNormal' + i] >= 0) {

                        material.numSupportedMorphNormals++;
                    }
                }
            }

            var uniforms = materialProperties.__webglShader.uniforms;

            if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {

                materialProperties.numClippingPlanes = _clipping.numPlanes;
                materialProperties.numIntersection = _clipping.numIntersection;
                uniforms.clippingPlanes = _clipping.uniform;
            }

            materialProperties.fog = fog;

            // store the light setup it was created for

            materialProperties.lightsHash = _lights.hash;

            if (material.lights) {

                // wire up the material to this renderer's lighting state

                uniforms.ambientLightColor.value = _lights.ambient;
                uniforms.directionalLights.value = _lights.directional;
                uniforms.spotLights.value = _lights.spot;
                uniforms.rectAreaLights.value = _lights.rectArea;
                uniforms.pointLights.value = _lights.point;
                uniforms.hemisphereLights.value = _lights.hemi;

                uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
                uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
                uniforms.spotShadowMap.value = _lights.spotShadowMap;
                uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
                uniforms.pointShadowMap.value = _lights.pointShadowMap;
                uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
                // TODO (abelnation): add area lights shadow info to uniforms
            }

            var progUniforms = materialProperties.program.getUniforms(),
                uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);

            materialProperties.uniformsList = uniformsList;
        }

        function setProgram(camera, fog, material, object) {

            _usedTextureUnits = 0;

            var materialProperties = properties.get(material);

            if (_clippingEnabled) {

                if (_localClippingEnabled || camera !== _currentCamera) {

                    var useCache = camera === _currentCamera && material.id === _currentMaterialId;

                    // we might want to call this function with some ClippingGroup
                    // object instead of the material, once it becomes feasible
                    // (#8465, #8379)
                    _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
                }
            }

            if (material.needsUpdate === false) {

                if (materialProperties.program === undefined) {

                    material.needsUpdate = true;
                } else if (material.fog && materialProperties.fog !== fog) {

                    material.needsUpdate = true;
                } else if (material.lights && materialProperties.lightsHash !== _lights.hash) {

                    material.needsUpdate = true;
                } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {

                    material.needsUpdate = true;
                }
            }

            if (material.needsUpdate) {

                initMaterial(material, fog, object);
                material.needsUpdate = false;
            }

            var refreshProgram = false;
            var refreshMaterial = false;
            var refreshLights = false;

            var program = materialProperties.program,
                p_uniforms = program.getUniforms(),
                m_uniforms = materialProperties.__webglShader.uniforms;

            if (program.id !== _currentProgram) {

                _gl.useProgram(program.program);
                _currentProgram = program.id;

                refreshProgram = true;
                refreshMaterial = true;
                refreshLights = true;
            }

            if (material.id !== _currentMaterialId) {

                _currentMaterialId = material.id;

                refreshMaterial = true;
            }

            if (refreshProgram || camera !== _currentCamera) {

                p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

                if (capabilities.logarithmicDepthBuffer) {

                    p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
                }

                if (camera !== _currentCamera) {

                    _currentCamera = camera;

                    // lighting uniforms depend on the camera so enforce an update
                    // now, in case this material supports lights - or later, when
                    // the next material that does gets activated:

                    refreshMaterial = true; // set to true on material change
                    refreshLights = true; // remains set until update done
                }

                // load material specific uniforms
                // (shader material also gets them for the sake of genericity)

                if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {

                    var uCamPos = p_uniforms.map.cameraPosition;

                    if (uCamPos !== undefined) {

                        uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
                    }
                }

                if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {

                    p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
                }

                p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
                p_uniforms.setValue(_gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint);
            }

            // skinning uniforms must be set even if material didn't change
            // auto-setting of texture unit for bone texture must go before other textures
            // not sure why, but otherwise weird things happen

            if (material.skinning) {

                p_uniforms.setOptional(_gl, object, 'bindMatrix');
                p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');

                var skeleton = object.skeleton;

                if (skeleton) {

                    var bones = skeleton.bones;

                    if (capabilities.floatVertexTextures) {

                        if (skeleton.boneTexture === undefined) {

                            // layout (1 matrix = 4 pixels)
                            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                            //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
                            //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
                            //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
                            //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


                            var size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix
                            size = _Math.nextPowerOfTwo(Math.ceil(size));
                            size = Math.max(size, 4);

                            var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
                            boneMatrices.set(skeleton.boneMatrices); // copy current values

                            var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);

                            skeleton.boneMatrices = boneMatrices;
                            skeleton.boneTexture = boneTexture;
                            skeleton.boneTextureSize = size;
                        }

                        p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture);
                        p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
                    } else {

                        p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
                    }
                }
            }

            if (refreshMaterial) {

                if (material.lights) {

                    // the current material requires lighting info

                    // note: all lighting uniforms are always set correctly
                    // they simply reference the renderer's state for their
                    // values
                    //
                    // use the current material's .needsUpdate flags to set
                    // the GL state when required

                    markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
                }

                // refresh uniforms common to several materials

                if (fog && material.fog) {

                    refreshUniformsFog(m_uniforms, fog);
                }

                if (material.isMeshBasicMaterial || material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isMeshNormalMaterial || material.isMeshDepthMaterial) {

                    refreshUniformsCommon(m_uniforms, material);
                }

                // refresh single material specific uniforms

                if (material.isLineBasicMaterial) {

                    refreshUniformsLine(m_uniforms, material);
                } else if (material.isLineDashedMaterial) {

                    refreshUniformsLine(m_uniforms, material);
                    refreshUniformsDash(m_uniforms, material);
                } else if (material.isPointsMaterial) {

                    refreshUniformsPoints(m_uniforms, material);
                } else if (material.isMeshLambertMaterial) {

                    refreshUniformsLambert(m_uniforms, material);
                } else if (material.isMeshToonMaterial) {

                    refreshUniformsToon(m_uniforms, material);
                } else if (material.isMeshPhongMaterial) {

                    refreshUniformsPhong(m_uniforms, material);
                } else if (material.isMeshPhysicalMaterial) {

                    refreshUniformsPhysical(m_uniforms, material);
                } else if (material.isMeshStandardMaterial) {

                    refreshUniformsStandard(m_uniforms, material);
                } else if (material.isMeshDepthMaterial) {

                    if (material.displacementMap) {

                        m_uniforms.displacementMap.value = material.displacementMap;
                        m_uniforms.displacementScale.value = material.displacementScale;
                        m_uniforms.displacementBias.value = material.displacementBias;
                    }
                } else if (material.isMeshNormalMaterial) {

                    refreshUniformsNormal(m_uniforms, material);
                }

                // RectAreaLight Texture
                // TODO (mrdoob): Find a nicer implementation

                if (m_uniforms.ltcMat !== undefined) m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE;
                if (m_uniforms.ltcMag !== undefined) m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE;

                WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
            }

            // common matrices

            p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
            p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
            p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);

            return program;
        }

        // Uniforms (refresh uniforms objects)

        function refreshUniformsCommon(uniforms, material) {

            uniforms.opacity.value = material.opacity;

            uniforms.diffuse.value = material.color;

            if (material.emissive) {

                uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
            }

            uniforms.map.value = material.map;
            uniforms.specularMap.value = material.specularMap;
            uniforms.alphaMap.value = material.alphaMap;

            if (material.lightMap) {

                uniforms.lightMap.value = material.lightMap;
                uniforms.lightMapIntensity.value = material.lightMapIntensity;
            }

            if (material.aoMap) {

                uniforms.aoMap.value = material.aoMap;
                uniforms.aoMapIntensity.value = material.aoMapIntensity;
            }

            // uv repeat and offset setting priorities
            // 1. color map
            // 2. specular map
            // 3. normal map
            // 4. bump map
            // 5. alpha map
            // 6. emissive map

            var uvScaleMap;

            if (material.map) {

                uvScaleMap = material.map;
            } else if (material.specularMap) {

                uvScaleMap = material.specularMap;
            } else if (material.displacementMap) {

                uvScaleMap = material.displacementMap;
            } else if (material.normalMap) {

                uvScaleMap = material.normalMap;
            } else if (material.bumpMap) {

                uvScaleMap = material.bumpMap;
            } else if (material.roughnessMap) {

                uvScaleMap = material.roughnessMap;
            } else if (material.metalnessMap) {

                uvScaleMap = material.metalnessMap;
            } else if (material.alphaMap) {

                uvScaleMap = material.alphaMap;
            } else if (material.emissiveMap) {

                uvScaleMap = material.emissiveMap;
            }

            if (uvScaleMap !== undefined) {

                // backwards compatibility
                if (uvScaleMap.isWebGLRenderTarget) {

                    uvScaleMap = uvScaleMap.texture;
                }

                var offset = uvScaleMap.offset;
                var repeat = uvScaleMap.repeat;

                uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
                uniforms.rotateMatrix.value.copy(uvScaleMap.rotateMatrix); // xmh add
            }

            uniforms.envMap.value = material.envMap;

            // don't flip CubeTexture envMaps, flip everything else:
            //  WebGLRenderTargetCube will be flipped for backwards compatibility
            //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
            // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
            uniforms.flipEnvMap.value = !(material.envMap && material.envMap.isCubeTexture) ? 1 : -1;

            uniforms.reflectivity.value = material.reflectivity;
            uniforms.refractionRatio.value = material.refractionRatio;
        }

        function refreshUniformsLine(uniforms, material) {

            uniforms.diffuse.value = material.color;
            uniforms.opacity.value = material.opacity;
        }

        function refreshUniformsDash(uniforms, material) {

            uniforms.dashSize.value = material.dashSize;
            uniforms.totalSize.value = material.dashSize + material.gapSize;
            uniforms.scale.value = material.scale;
        }

        function refreshUniformsPoints(uniforms, material) {

            uniforms.diffuse.value = material.color;
            uniforms.opacity.value = material.opacity;
            uniforms.size.value = material.size * _pixelRatio;
            uniforms.scale.value = _height * 0.5;

            uniforms.map.value = material.map;

            if (material.map !== null) {

                var offset = material.map.offset;
                var repeat = material.map.repeat;

                uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
            }
        }

        function refreshUniformsFog(uniforms, fog) {

            uniforms.fogColor.value = fog.color;

            if (fog.isFog) {

                uniforms.fogNear.value = fog.near;
                uniforms.fogFar.value = fog.far;
            } else if (fog.isFogExp2) {

                uniforms.fogDensity.value = fog.density;
            }
        }

        function refreshUniformsLambert(uniforms, material) {

            if (material.emissiveMap) {

                uniforms.emissiveMap.value = material.emissiveMap;
            }
        }

        function refreshUniformsPhong(uniforms, material) {

            uniforms.specular.value = material.specular;
            uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

            if (material.emissiveMap) {

                uniforms.emissiveMap.value = material.emissiveMap;
            }

            if (material.bumpMap) {

                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
            }

            if (material.normalMap) {

                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
            }

            if (material.displacementMap) {

                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }

        function refreshUniformsToon(uniforms, material) {

            refreshUniformsPhong(uniforms, material);

            if (material.gradientMap) {

                uniforms.gradientMap.value = material.gradientMap;
            }
        }

        function refreshUniformsStandard(uniforms, material) {

            uniforms.roughness.value = material.roughness;
            uniforms.metalness.value = material.metalness;

            if (material.roughnessMap) {

                uniforms.roughnessMap.value = material.roughnessMap;
            }

            if (material.metalnessMap) {

                uniforms.metalnessMap.value = material.metalnessMap;
            }

            if (material.emissiveMap) {

                uniforms.emissiveMap.value = material.emissiveMap;
            }

            if (material.bumpMap) {

                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
            }

            if (material.normalMap) {

                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
            }

            if (material.displacementMap) {

                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }

            if (material.envMap) {

                //uniforms.envMap.value = material.envMap; // part of uniforms common
                uniforms.envMapIntensity.value = material.envMapIntensity;
            }
        }

        function refreshUniformsPhysical(uniforms, material) {

            uniforms.clearCoat.value = material.clearCoat;
            uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

            refreshUniformsStandard(uniforms, material);
        }

        function refreshUniformsNormal(uniforms, material) {

            if (material.bumpMap) {

                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
            }

            if (material.normalMap) {

                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
            }

            if (material.displacementMap) {

                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }

        // If uniforms are marked as clean, they don't need to be loaded to the GPU.

        function markUniformsLightsNeedsUpdate(uniforms, value) {

            uniforms.ambientLightColor.needsUpdate = value;

            uniforms.directionalLights.needsUpdate = value;
            uniforms.pointLights.needsUpdate = value;
            uniforms.spotLights.needsUpdate = value;
            uniforms.rectAreaLights.needsUpdate = value;
            uniforms.hemisphereLights.needsUpdate = value;
        }

        // Lighting

        function setupLights(lights, camera) {

            var l,
                ll,
                light,
                shadow,
                r = 0,
                g = 0,
                b = 0,
                color,
                intensity,
                distance,
                shadowMap,
                viewMatrix = camera.matrixWorldInverse,
                directionalLength = 0,
                pointLength = 0,
                spotLength = 0,
                rectAreaLength = 0,
                hemiLength = 0;

            for (l = 0, ll = lights.length; l < ll; l++) {

                light = lights[l];

                color = light.color;
                intensity = light.intensity;
                distance = light.distance;

                shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

                if (light.isAmbientLight) {

                    r += color.r * intensity;
                    g += color.g * intensity;
                    b += color.b * intensity;
                } else if (light.isDirectionalLight) {

                    var uniforms = lightCache.get(light);

                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    _vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(_vector3);
                    uniforms.direction.transformDirection(viewMatrix);

                    uniforms.shadow = light.castShadow;

                    if (light.castShadow) {

                        shadow = light.shadow;

                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                    }

                    _lights.directionalShadowMap[directionalLength] = shadowMap;
                    _lights.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                    _lights.directional[directionalLength] = uniforms;

                    directionalLength++;
                } else if (light.isSpotLight) {

                    var uniforms = lightCache.get(light);

                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);

                    uniforms.color.copy(color).multiplyScalar(intensity);
                    uniforms.distance = distance;

                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    _vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(_vector3);
                    uniforms.direction.transformDirection(viewMatrix);

                    uniforms.coneCos = Math.cos(light.angle);
                    uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                    uniforms.decay = light.distance === 0 ? 0.0 : light.decay;

                    uniforms.shadow = light.castShadow;

                    if (light.castShadow) {

                        shadow = light.shadow;

                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                    }

                    _lights.spotShadowMap[spotLength] = shadowMap;
                    _lights.spotShadowMatrix[spotLength] = light.shadow.matrix;
                    _lights.spot[spotLength] = uniforms;

                    spotLength++;
                } else if (light.isRectAreaLight) {

                    var uniforms = lightCache.get(light);

                    // (a) intensity controls irradiance of entire light
                    uniforms.color.copy(color).multiplyScalar(intensity / (light.width * light.height));

                    // (b) intensity controls the radiance per light area
                    // uniforms.color.copy( color ).multiplyScalar( intensity );

                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);

                    // extract local rotation of light to derive width/height half vectors
                    _matrix42.identity();
                    _matrix4.copy(light.matrixWorld);
                    _matrix4.premultiply(viewMatrix);
                    _matrix42.extractRotation(_matrix4);

                    uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                    uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);

                    uniforms.halfWidth.applyMatrix4(_matrix42);
                    uniforms.halfHeight.applyMatrix4(_matrix42);

                    // TODO (abelnation): RectAreaLight distance?
                    // uniforms.distance = distance;

                    _lights.rectArea[rectAreaLength] = uniforms;

                    rectAreaLength++;
                } else if (light.isPointLight) {

                    var uniforms = lightCache.get(light);

                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);

                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    uniforms.distance = light.distance;
                    uniforms.decay = light.distance === 0 ? 0.0 : light.decay;

                    uniforms.shadow = light.castShadow;

                    if (light.castShadow) {

                        shadow = light.shadow;

                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                    }

                    _lights.pointShadowMap[pointLength] = shadowMap;
                    _lights.pointShadowMatrix[pointLength] = light.shadow.matrix;
                    _lights.point[pointLength] = uniforms;

                    pointLength++;
                } else if (light.isHemisphereLight) {

                    var uniforms = lightCache.get(light);

                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.direction.normalize();

                    uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                    uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);

                    _lights.hemi[hemiLength] = uniforms;

                    hemiLength++;
                }
            }

            _lights.ambient[0] = r;
            _lights.ambient[1] = g;
            _lights.ambient[2] = b;

            _lights.directional.length = directionalLength;
            _lights.spot.length = spotLength;
            _lights.rectArea.length = rectAreaLength;
            _lights.point.length = pointLength;
            _lights.hemi.length = hemiLength;

            // TODO (sam-g-steel) why aren't we using join
            _lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + _lights.shadows.length;
        }

        // GL state setting

        this.setFaceCulling = function (cullFace, frontFaceDirection) {

            state.setCullFace(cullFace);
            state.setFlipSided(frontFaceDirection === FrontFaceDirectionCW);
        };

        // Textures

        function allocTextureUnit() {

            var textureUnit = _usedTextureUnits;

            if (textureUnit >= capabilities.maxTextures) {

                console.warn('WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);
            }

            _usedTextureUnits += 1;

            return textureUnit;
        }

        this.allocTextureUnit = allocTextureUnit;

        // this.setTexture2D = setTexture2D;
        this.setTexture2D = function () {

            var warned = false;

            // backwards compatibility: peel texture.texture
            return function setTexture2D(texture, slot) {

                if (texture && texture.isWebGLRenderTarget) {

                    if (!warned) {

                        console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
                        warned = true;
                    }

                    texture = texture.texture;
                }

                textures.setTexture2D(texture, slot);
            };
        }();

        this.setTexture = function () {

            var warned = false;

            return function setTexture(texture, slot) {

                if (!warned) {

                    console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");
                    warned = true;
                }

                textures.setTexture2D(texture, slot);
            };
        }();

        this.setTextureCube = function () {

            var warned = false;

            return function setTextureCube(texture, slot) {

                // backwards compatibility: peel texture.texture
                if (texture && texture.isWebGLRenderTargetCube) {

                    if (!warned) {

                        console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                        warned = true;
                    }

                    texture = texture.texture;
                }

                // currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
                // TODO: unify these code paths
                if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {

                    // CompressedTexture can have Array in image :/

                    // this function alone should take care of cube textures
                    textures.setTextureCube(texture, slot);
                } else {

                    // assumed: texture property of THREE.WebGLRenderTargetCube

                    textures.setTextureCubeDynamic(texture, slot);
                }
            };
        }();

        this.getRenderTarget = function () {

            return _currentRenderTarget;
        };

        this.setRenderTarget = function (renderTarget) {

            _currentRenderTarget = renderTarget;

            if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {

                textures.setupRenderTarget(renderTarget);
            }

            var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
            var framebuffer;

            if (renderTarget) {

                var renderTargetProperties = properties.get(renderTarget);

                if (isCube) {

                    framebuffer = renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];
                } else {

                    framebuffer = renderTargetProperties.__webglFramebuffer;
                }

                _currentScissor.copy(renderTarget.scissor);
                _currentScissorTest = renderTarget.scissorTest;

                _currentViewport.copy(renderTarget.viewport);
            } else {

                framebuffer = null;

                _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
                _currentScissorTest = _scissorTest;

                _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
            }

            if (_currentFramebuffer !== framebuffer) {

                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                _currentFramebuffer = framebuffer;
            }

            state.scissor(_currentScissor);
            state.setScissorTest(_currentScissorTest);

            state.viewport(_currentViewport);

            if (isCube) {

                var textureProperties = properties.get(renderTarget.texture);
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
            }
        };

        this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer) {

            if ((renderTarget && renderTarget.isWebGLRenderTarget) === false) {

                console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
                return;
            }

            var framebuffer = properties.get(renderTarget).__webglFramebuffer;

            if (framebuffer) {

                var restore = false;

                if (framebuffer !== _currentFramebuffer) {

                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

                    restore = true;
                }

                try {

                    var texture = renderTarget.texture;
                    var textureFormat = texture.format;
                    var textureType = texture.type;

                    if (textureFormat !== RGBAFormat && paramThreeToGL(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {

                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                        return;
                    }

                    if (textureType !== UnsignedByteType && paramThreeToGL(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // IE11, Edge and Chrome Mac < 52 (#9513)
                    !(textureType === FloatType && (extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
                    !(textureType === HalfFloatType && extensions.get('EXT_color_buffer_half_float'))) {

                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                        return;
                    }

                    if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {

                        // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

                        if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {

                            _gl.readPixels(x, y, width, height, paramThreeToGL(textureFormat), paramThreeToGL(textureType), buffer);
                        }
                    } else {

                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
                    }
                } finally {

                    if (restore) {

                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
                    }
                }
            }
        };

        // Map three.js constants to WebGL constants

        function paramThreeToGL(p) {

            var extension;

            if (p === RepeatWrapping) return _gl.REPEAT;
            if (p === ClampToEdgeWrapping) return _gl.CLAMP_TO_EDGE;
            if (p === MirroredRepeatWrapping) return _gl.MIRRORED_REPEAT;

            if (p === NearestFilter) return _gl.NEAREST;
            if (p === NearestMipMapNearestFilter) return _gl.NEAREST_MIPMAP_NEAREST;
            if (p === NearestMipMapLinearFilter) return _gl.NEAREST_MIPMAP_LINEAR;

            if (p === LinearFilter) return _gl.LINEAR;
            if (p === LinearMipMapNearestFilter) return _gl.LINEAR_MIPMAP_NEAREST;
            if (p === LinearMipMapLinearFilter) return _gl.LINEAR_MIPMAP_LINEAR;

            if (p === UnsignedByteType) return _gl.UNSIGNED_BYTE;
            if (p === UnsignedShort4444Type) return _gl.UNSIGNED_SHORT_4_4_4_4;
            if (p === UnsignedShort5551Type) return _gl.UNSIGNED_SHORT_5_5_5_1;
            if (p === UnsignedShort565Type) return _gl.UNSIGNED_SHORT_5_6_5;

            if (p === ByteType) return _gl.BYTE;
            if (p === ShortType) return _gl.SHORT;
            if (p === UnsignedShortType) return _gl.UNSIGNED_SHORT;
            if (p === IntType) return _gl.INT;
            if (p === UnsignedIntType) return _gl.UNSIGNED_INT;
            if (p === FloatType) return _gl.FLOAT;

            if (p === HalfFloatType) {

                extension = extensions.get('OES_texture_half_float');

                if (extension !== null) return extension.HALF_FLOAT_OES;
            }

            if (p === AlphaFormat) return _gl.ALPHA;
            if (p === RGBFormat) return _gl.RGB;
            if (p === RGBAFormat) return _gl.RGBA;
            if (p === LuminanceFormat) return _gl.LUMINANCE;
            if (p === LuminanceAlphaFormat) return _gl.LUMINANCE_ALPHA;
            if (p === DepthFormat) return _gl.DEPTH_COMPONENT;
            if (p === DepthStencilFormat) return _gl.DEPTH_STENCIL;

            if (p === AddEquation) return _gl.FUNC_ADD;
            if (p === SubtractEquation) return _gl.FUNC_SUBTRACT;
            if (p === ReverseSubtractEquation) return _gl.FUNC_REVERSE_SUBTRACT;

            if (p === ZeroFactor) return _gl.ZERO;
            if (p === OneFactor) return _gl.ONE;
            if (p === SrcColorFactor) return _gl.SRC_COLOR;
            if (p === OneMinusSrcColorFactor) return _gl.ONE_MINUS_SRC_COLOR;
            if (p === SrcAlphaFactor) return _gl.SRC_ALPHA;
            if (p === OneMinusSrcAlphaFactor) return _gl.ONE_MINUS_SRC_ALPHA;
            if (p === DstAlphaFactor) return _gl.DST_ALPHA;
            if (p === OneMinusDstAlphaFactor) return _gl.ONE_MINUS_DST_ALPHA;

            if (p === DstColorFactor) return _gl.DST_COLOR;
            if (p === OneMinusDstColorFactor) return _gl.ONE_MINUS_DST_COLOR;
            if (p === SrcAlphaSaturateFactor) return _gl.SRC_ALPHA_SATURATE;

            if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {

                extension = extensions.get('WEBGL_compressed_texture_s3tc');

                if (extension !== null) {

                    if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                }
            }

            if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {

                extension = extensions.get('WEBGL_compressed_texture_pvrtc');

                if (extension !== null) {

                    if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                }
            }

            if (p === RGB_ETC1_Format) {

                extension = extensions.get('WEBGL_compressed_texture_etc1');

                if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
            }

            if (p === MinEquation || p === MaxEquation) {

                extension = extensions.get('EXT_blend_minmax');

                if (extension !== null) {

                    if (p === MinEquation) return extension.MIN_EXT;
                    if (p === MaxEquation) return extension.MAX_EXT;
                }
            }

            if (p === UnsignedInt248Type) {

                extension = extensions.get('WEBGL_depth_texture');

                if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
            }

            return 0;
        }

        this.updateObject = function (object) {
            return objects.update(object);
        };

        var _orderedRenderer = null;

        this.setRenderer = function (renderer) {
            _orderedRenderer = renderer;
        };

        this.getRenderer = function () {
            return _orderedRenderer;
        };

        this.destroy = function () {
            // WebGLObjects has no method to clear the cached geometries, so recreate it.
            //objects = new THREE.WebGLObjects(_gl, properties, this.info);
            _orderedRenderer.destroy();
            properties.clear();
        };

        // 重置增量绘制状态
        this.resetIncrementRender = function () {
            _orderedRenderer.restart();
        };

        // 设置过滤对象
        this.setFilterObject = function (filterObject) {

            _orderedRenderer.setFilter(filterObject);
        };

        // 设置是否更新对象列表
        this.setObjectListUpdateState = function (isUpdate) {
            _orderedRenderer.updateObjectList(isUpdate);
        };

        this.computeSelectionBBox = function () {

            return _orderedRenderer.computeSelectionBBox();
        };

        this.computeRenderObjectsBox = function () {
            return _orderedRenderer.computeRenderObjectsBox();
        };

        this.setRenderTicket = function (ticket) {
            objects._renderTicket = ticket;
        };

        this.setupLights = function (lights, camera) {
            setupLights(lights, camera);
        };
    }

    //
    Object.assign(WebGLRendererByIncrement.prototype, {

        getCurrentRenderTarget: function getCurrentRenderTarget() {

            console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
            return this.getRenderTarget();
        },

        supportsFloatTextures: function supportsFloatTextures() {

            console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
            return this.extensions.get('OES_texture_float');
        },
        supportsHalfFloatTextures: function supportsHalfFloatTextures() {

            console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
            return this.extensions.get('OES_texture_half_float');
        },
        supportsStandardDerivatives: function supportsStandardDerivatives() {

            console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
            return this.extensions.get('OES_standard_derivatives');
        },
        supportsCompressedTextureS3TC: function supportsCompressedTextureS3TC() {

            console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
            return this.extensions.get('WEBGL_compressed_texture_s3tc');
        },
        supportsCompressedTexturePVRTC: function supportsCompressedTexturePVRTC() {

            console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
            return this.extensions.get('WEBGL_compressed_texture_pvrtc');
        },
        supportsBlendMinMax: function supportsBlendMinMax() {

            console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
            return this.extensions.get('EXT_blend_minmax');
        },
        supportsVertexTextures: function supportsVertexTextures() {

            console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
            return this.capabilities.vertexTextures;
        },
        supportsInstancedArrays: function supportsInstancedArrays() {

            console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
            return this.extensions.get('ANGLE_instanced_arrays');
        },
        enableScissorTest: function enableScissorTest(boolean) {

            console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
            this.setScissorTest(boolean);
        },
        initMaterial: function initMaterial() {

            console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
        },
        addPrePlugin: function addPrePlugin() {

            console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
        },
        addPostPlugin: function addPostPlugin() {

            console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
        },
        updateShadowMap: function updateShadowMap() {

            console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
        }

    });

    Object.defineProperties(WebGLRendererByIncrement.prototype, {

        shadowMapEnabled: {
            get: function get() {

                return this.shadowMap.enabled;
            },
            set: function set(value) {

                console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
                this.shadowMap.enabled = value;
            }
        },
        shadowMapType: {
            get: function get() {

                return this.shadowMap.type;
            },
            set: function set(value) {

                console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
                this.shadowMap.type = value;
            }
        },
        shadowMapCullFace: {
            get: function get() {

                return this.shadowMap.cullFace;
            },
            set: function set(value) {

                console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');
                this.shadowMap.cullFace = value;
            }
        }
    });

    exports.LRUMap = LRUMap;
    exports.WebGLRendererByIncrement = WebGLRendererByIncrement;

    exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
    exports.WebGLRenderTarget = WebGLRenderTarget;
    exports.WebGLRenderer = WebGLRenderer;
    exports.ShaderLib = ShaderLib;
    exports.UniformsLib = UniformsLib;
    exports.UniformsUtils = UniformsUtils;
    exports.ShaderChunk = ShaderChunk;
    exports.FogExp2 = FogExp2;
    exports.Fog = Fog;
    exports.Scene = Scene;
    exports.LensFlare = LensFlare;
    exports.Sprite = Sprite;
    exports.LOD = LOD;
    exports.SkinnedMesh = SkinnedMesh;
    exports.Skeleton = Skeleton;
    exports.Bone = Bone;
    exports.Mesh = Mesh;
    exports.LineSegments = LineSegments;
    exports.LineLoop = LineLoop;
    exports.Line = Line;
    exports.Points = Points;
    exports.Group = Group;
    exports.VideoTexture = VideoTexture;
    exports.DataTexture = DataTexture;
    exports.CompressedTexture = CompressedTexture;
    exports.CubeTexture = CubeTexture;
    exports.CanvasTexture = CanvasTexture;
    exports.DepthTexture = DepthTexture;
    exports.Texture = Texture;
    exports.CompressedTextureLoader = CompressedTextureLoader;
    exports.DataTextureLoader = DataTextureLoader;
    exports.CubeTextureLoader = CubeTextureLoader;
    exports.TextureLoader = TextureLoader;
    exports.ObjectLoader = ObjectLoader;
    exports.MaterialLoader = MaterialLoader;
    exports.BufferGeometryLoader = BufferGeometryLoader;
    exports.DefaultLoadingManager = DefaultLoadingManager;
    exports.LoadingManager = LoadingManager;
    exports.JSONLoader = JSONLoader;
    exports.ImageLoader = ImageLoader;
    exports.FontLoader = FontLoader;
    exports.FileLoader = FileLoader;
    exports.Loader = Loader;
    exports.Cache = Cache;
    exports.AudioLoader = AudioLoader;
    exports.SpotLightShadow = SpotLightShadow;
    exports.SpotLight = SpotLight;
    exports.PointLight = PointLight;
    exports.RectAreaLight = RectAreaLight;
    exports.HemisphereLight = HemisphereLight;
    exports.DirectionalLightShadow = DirectionalLightShadow;
    exports.DirectionalLight = DirectionalLight;
    exports.AmbientLight = AmbientLight;
    exports.LightShadow = LightShadow;
    exports.Light = Light;
    exports.StereoCamera = StereoCamera;
    exports.PerspectiveCamera = PerspectiveCamera;
    exports.OrthographicCamera = OrthographicCamera;
    exports.CubeCamera = CubeCamera;
    exports.ArrayCamera = ArrayCamera;
    exports.Camera = Camera;
    exports.AudioListener = AudioListener;
    exports.PositionalAudio = PositionalAudio;
    exports.AudioContext = AudioContext;
    exports.AudioAnalyser = AudioAnalyser;
    exports.Audio = Audio;
    exports.VectorKeyframeTrack = VectorKeyframeTrack;
    exports.StringKeyframeTrack = StringKeyframeTrack;
    exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
    exports.NumberKeyframeTrack = NumberKeyframeTrack;
    exports.ColorKeyframeTrack = ColorKeyframeTrack;
    exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
    exports.PropertyMixer = PropertyMixer;
    exports.PropertyBinding = PropertyBinding;
    exports.KeyframeTrack = KeyframeTrack;
    exports.AnimationUtils = AnimationUtils;
    exports.AnimationObjectGroup = AnimationObjectGroup;
    exports.AnimationMixer = AnimationMixer;
    exports.AnimationClip = AnimationClip;
    exports.Uniform = Uniform;
    exports.InstancedBufferGeometry = InstancedBufferGeometry;
    exports.BufferGeometry = BufferGeometry;
    exports.GeometryIdCount = GeometryIdCount;
    exports.Geometry = Geometry;
    exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
    exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
    exports.InterleavedBuffer = InterleavedBuffer;
    exports.InstancedBufferAttribute = InstancedBufferAttribute;
    exports.Face3 = Face3;
    exports.Object3D = Object3D;
    exports.Raycaster = Raycaster;
    exports.Layers = Layers;
    exports.EventDispatcher = EventDispatcher;
    exports.Clock = Clock;
    exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
    exports.LinearInterpolant = LinearInterpolant;
    exports.DiscreteInterpolant = DiscreteInterpolant;
    exports.CubicInterpolant = CubicInterpolant;
    exports.Interpolant = Interpolant;
    exports.Triangle = Triangle;
    exports.Math = _Math;
    exports.Spherical = Spherical;
    exports.Cylindrical = Cylindrical;
    exports.Plane = Plane;
    exports.Frustum = Frustum;
    exports.Sphere = Sphere;
    exports.Ray = Ray;
    exports.Matrix4 = Matrix4;
    exports.Matrix3 = Matrix3;
    exports.Box3 = Box3;
    exports.Box2 = Box2;
    exports.Line3 = Line3;
    exports.Euler = Euler;
    exports.Vector4 = Vector4;
    exports.Vector3 = Vector3;
    exports.Vector2 = Vector2;
    exports.Quaternion = Quaternion;
    exports.Color = Color;
    exports.MorphBlendMesh = MorphBlendMesh;
    exports.ImmediateRenderObject = ImmediateRenderObject;
    exports.VertexNormalsHelper = VertexNormalsHelper;
    exports.SpotLightHelper = SpotLightHelper;
    exports.SkeletonHelper = SkeletonHelper;
    exports.PointLightHelper = PointLightHelper;
    exports.RectAreaLightHelper = RectAreaLightHelper;
    exports.HemisphereLightHelper = HemisphereLightHelper;
    exports.GridHelper = GridHelper;
    exports.PolarGridHelper = PolarGridHelper;
    exports.FaceNormalsHelper = FaceNormalsHelper;
    exports.DirectionalLightHelper = DirectionalLightHelper;
    exports.CameraHelper = CameraHelper;
    exports.BoxHelper = BoxHelper;
    exports.ArrowHelper = ArrowHelper;
    exports.AxisHelper = AxisHelper;
    exports.CatmullRomCurve3 = CatmullRomCurve3;
    exports.CubicBezierCurve3 = CubicBezierCurve3;
    exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
    exports.LineCurve3 = LineCurve3;
    exports.ArcCurve = ArcCurve;
    exports.EllipseCurve = EllipseCurve;
    exports.SplineCurve = SplineCurve;
    exports.CubicBezierCurve = CubicBezierCurve;
    exports.QuadraticBezierCurve = QuadraticBezierCurve;
    exports.LineCurve = LineCurve;
    exports.Shape = Shape;
    exports.Path = Path;
    exports.ShapePath = ShapePath;
    exports.Font = Font;
    exports.CurvePath = CurvePath;
    exports.Curve = Curve;
    exports.ShapeUtils = ShapeUtils;
    exports.SceneUtils = SceneUtils;
    exports.WireframeGeometry = WireframeGeometry;
    exports.ParametricGeometry = ParametricGeometry;
    exports.ParametricBufferGeometry = ParametricBufferGeometry;
    exports.TetrahedronGeometry = TetrahedronGeometry;
    exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
    exports.OctahedronGeometry = OctahedronGeometry;
    exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
    exports.IcosahedronGeometry = IcosahedronGeometry;
    exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
    exports.DodecahedronGeometry = DodecahedronGeometry;
    exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
    exports.PolyhedronGeometry = PolyhedronGeometry;
    exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
    exports.TubeGeometry = TubeGeometry;
    exports.TubeBufferGeometry = TubeBufferGeometry;
    exports.TorusKnotGeometry = TorusKnotGeometry;
    exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
    exports.TorusGeometry = TorusGeometry;
    exports.TorusBufferGeometry = TorusBufferGeometry;
    exports.TextGeometry = TextGeometry;
    exports.TextBufferGeometry = TextBufferGeometry;
    exports.SphereGeometry = SphereGeometry;
    exports.SphereBufferGeometry = SphereBufferGeometry;
    exports.RingGeometry = RingGeometry;
    exports.RingBufferGeometry = RingBufferGeometry;
    exports.PlaneGeometry = PlaneGeometry;
    exports.PlaneBufferGeometry = PlaneBufferGeometry;
    exports.LatheGeometry = LatheGeometry;
    exports.LatheBufferGeometry = LatheBufferGeometry;
    exports.ShapeGeometry = ShapeGeometry;
    exports.ShapeBufferGeometry = ShapeBufferGeometry;
    exports.ExtrudeGeometry = ExtrudeGeometry;
    exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
    exports.EdgesGeometry = EdgesGeometry;
    exports.ConeGeometry = ConeGeometry;
    exports.ConeBufferGeometry = ConeBufferGeometry;
    exports.CylinderGeometry = CylinderGeometry;
    exports.CylinderBufferGeometry = CylinderBufferGeometry;
    exports.CircleGeometry = CircleGeometry;
    exports.CircleBufferGeometry = CircleBufferGeometry;
    exports.BoxGeometry = BoxGeometry;
    exports.BoxBufferGeometry = BoxBufferGeometry;
    exports.ShadowMaterial = ShadowMaterial;
    exports.SpriteMaterial = SpriteMaterial;
    exports.RawShaderMaterial = RawShaderMaterial;
    exports.ShaderMaterial = ShaderMaterial;
    exports.PointsMaterial = PointsMaterial;
    exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
    exports.MeshStandardMaterial = MeshStandardMaterial;
    exports.MeshPhongMaterial = MeshPhongMaterial;
    exports.MeshToonMaterial = MeshToonMaterial;
    exports.MeshNormalMaterial = MeshNormalMaterial;
    exports.MeshLambertMaterial = MeshLambertMaterial;
    exports.MeshDepthMaterial = MeshDepthMaterial;
    exports.MeshBasicMaterial = MeshBasicMaterial;
    exports.LineDashedMaterial = LineDashedMaterial;
    exports.LineBasicMaterial = LineBasicMaterial;
    exports.Material = Material;
    exports.Float64BufferAttribute = Float64BufferAttribute;
    exports.Float32BufferAttribute = Float32BufferAttribute;
    exports.Uint32BufferAttribute = Uint32BufferAttribute;
    exports.Int32BufferAttribute = Int32BufferAttribute;
    exports.Uint16BufferAttribute = Uint16BufferAttribute;
    exports.Int16BufferAttribute = Int16BufferAttribute;
    exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
    exports.Uint8BufferAttribute = Uint8BufferAttribute;
    exports.Int8BufferAttribute = Int8BufferAttribute;
    exports.BufferAttribute = BufferAttribute;
    exports.REVISION = REVISION;
    exports.MOUSE = MOUSE;
    exports.CullFaceNone = CullFaceNone;
    exports.CullFaceBack = CullFaceBack;
    exports.CullFaceFront = CullFaceFront;
    exports.CullFaceFrontBack = CullFaceFrontBack;
    exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
    exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
    exports.BasicShadowMap = BasicShadowMap;
    exports.PCFShadowMap = PCFShadowMap;
    exports.PCFSoftShadowMap = PCFSoftShadowMap;
    exports.FrontSide = FrontSide;
    exports.BackSide = BackSide;
    exports.DoubleSide = DoubleSide;
    exports.FlatShading = FlatShading;
    exports.SmoothShading = SmoothShading;
    exports.NoColors = NoColors;
    exports.FaceColors = FaceColors;
    exports.VertexColors = VertexColors;
    exports.NoBlending = NoBlending;
    exports.NormalBlending = NormalBlending;
    exports.AdditiveBlending = AdditiveBlending;
    exports.SubtractiveBlending = SubtractiveBlending;
    exports.MultiplyBlending = MultiplyBlending;
    exports.CustomBlending = CustomBlending;
    exports.AddEquation = AddEquation;
    exports.SubtractEquation = SubtractEquation;
    exports.ReverseSubtractEquation = ReverseSubtractEquation;
    exports.MinEquation = MinEquation;
    exports.MaxEquation = MaxEquation;
    exports.ZeroFactor = ZeroFactor;
    exports.OneFactor = OneFactor;
    exports.SrcColorFactor = SrcColorFactor;
    exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
    exports.SrcAlphaFactor = SrcAlphaFactor;
    exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
    exports.DstAlphaFactor = DstAlphaFactor;
    exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
    exports.DstColorFactor = DstColorFactor;
    exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
    exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
    exports.NeverDepth = NeverDepth;
    exports.AlwaysDepth = AlwaysDepth;
    exports.LessDepth = LessDepth;
    exports.LessEqualDepth = LessEqualDepth;
    exports.EqualDepth = EqualDepth;
    exports.GreaterEqualDepth = GreaterEqualDepth;
    exports.GreaterDepth = GreaterDepth;
    exports.NotEqualDepth = NotEqualDepth;
    exports.MultiplyOperation = MultiplyOperation;
    exports.MixOperation = MixOperation;
    exports.AddOperation = AddOperation;
    exports.NoToneMapping = NoToneMapping;
    exports.LinearToneMapping = LinearToneMapping;
    exports.ReinhardToneMapping = ReinhardToneMapping;
    exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
    exports.CineonToneMapping = CineonToneMapping;
    exports.UVMapping = UVMapping;
    exports.CubeReflectionMapping = CubeReflectionMapping;
    exports.CubeRefractionMapping = CubeRefractionMapping;
    exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
    exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
    exports.SphericalReflectionMapping = SphericalReflectionMapping;
    exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
    exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
    exports.RepeatWrapping = RepeatWrapping;
    exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
    exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
    exports.NearestFilter = NearestFilter;
    exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
    exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
    exports.LinearFilter = LinearFilter;
    exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
    exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
    exports.UnsignedByteType = UnsignedByteType;
    exports.ByteType = ByteType;
    exports.ShortType = ShortType;
    exports.UnsignedShortType = UnsignedShortType;
    exports.IntType = IntType;
    exports.UnsignedIntType = UnsignedIntType;
    exports.FloatType = FloatType;
    exports.HalfFloatType = HalfFloatType;
    exports.UnsignedShort4444Type = UnsignedShort4444Type;
    exports.UnsignedShort5551Type = UnsignedShort5551Type;
    exports.UnsignedShort565Type = UnsignedShort565Type;
    exports.UnsignedInt248Type = UnsignedInt248Type;
    exports.AlphaFormat = AlphaFormat;
    exports.RGBFormat = RGBFormat;
    exports.RGBAFormat = RGBAFormat;
    exports.LuminanceFormat = LuminanceFormat;
    exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
    exports.RGBEFormat = RGBEFormat;
    exports.DepthFormat = DepthFormat;
    exports.DepthStencilFormat = DepthStencilFormat;
    exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
    exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
    exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
    exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
    exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
    exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
    exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
    exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
    exports.RGB_ETC1_Format = RGB_ETC1_Format;
    exports.LoopOnce = LoopOnce;
    exports.LoopRepeat = LoopRepeat;
    exports.LoopPingPong = LoopPingPong;
    exports.InterpolateDiscrete = InterpolateDiscrete;
    exports.InterpolateLinear = InterpolateLinear;
    exports.InterpolateSmooth = InterpolateSmooth;
    exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
    exports.ZeroSlopeEnding = ZeroSlopeEnding;
    exports.WrapAroundEnding = WrapAroundEnding;
    exports.TrianglesDrawMode = TrianglesDrawMode;
    exports.TriangleStripDrawMode = TriangleStripDrawMode;
    exports.TriangleFanDrawMode = TriangleFanDrawMode;
    exports.LinearEncoding = LinearEncoding;
    exports.sRGBEncoding = sRGBEncoding;
    exports.GammaEncoding = GammaEncoding;
    exports.RGBEEncoding = RGBEEncoding;
    exports.LogLuvEncoding = LogLuvEncoding;
    exports.RGBM7Encoding = RGBM7Encoding;
    exports.RGBM16Encoding = RGBM16Encoding;
    exports.RGBDEncoding = RGBDEncoding;
    exports.BasicDepthPacking = BasicDepthPacking;
    exports.RGBADepthPacking = RGBADepthPacking;
    exports.CubeGeometry = BoxGeometry;
    exports.Face4 = Face4;
    exports.LineStrip = LineStrip;
    exports.LinePieces = LinePieces;
    exports.MeshFaceMaterial = MeshFaceMaterial;
    exports.MultiMaterial = MultiMaterial;
    exports.PointCloud = PointCloud;
    exports.Particle = Particle;
    exports.ParticleSystem = ParticleSystem;
    exports.PointCloudMaterial = PointCloudMaterial;
    exports.ParticleBasicMaterial = ParticleBasicMaterial;
    exports.ParticleSystemMaterial = ParticleSystemMaterial;
    exports.Vertex = Vertex;
    exports.DynamicBufferAttribute = DynamicBufferAttribute;
    exports.Int8Attribute = Int8Attribute;
    exports.Uint8Attribute = Uint8Attribute;
    exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
    exports.Int16Attribute = Int16Attribute;
    exports.Uint16Attribute = Uint16Attribute;
    exports.Int32Attribute = Int32Attribute;
    exports.Uint32Attribute = Uint32Attribute;
    exports.Float32Attribute = Float32Attribute;
    exports.Float64Attribute = Float64Attribute;
    exports.ClosedSplineCurve3 = ClosedSplineCurve3;
    exports.SplineCurve3 = SplineCurve3;
    exports.Spline = Spline;
    exports.BoundingBoxHelper = BoundingBoxHelper;
    exports.EdgesHelper = EdgesHelper;
    exports.WireframeHelper = WireframeHelper;
    exports.XHRLoader = XHRLoader;
    exports.BinaryTextureLoader = BinaryTextureLoader;
    exports.GeometryUtils = GeometryUtils;
    exports.ImageUtils = ImageUtils;
    exports.Projector = Projector;
    exports.CanvasRenderer = CanvasRenderer;

    Object.defineProperty(exports, '__esModule', { value: true });
});

/**
 * @require /libsH5/js/libs/three.min.js
 */

/**
 * @namespace CLOUD
 * @property {string}  Version                - 版本
 * @require /libsH5/js/libs/three.min.js
 */

CLOUD.Version = "20170809";

/**
 * @namespace CLOUD.GlobalData
 * @property {number}  SceneSize                - 场景大小
 * @property {string}  TextureResRoot           - 纹理资源路径
 * @property {boolean}  EnableTextureMapping    - 是否启用纹理贴图
 * @property {object}  SelectionColor           - 默认构件选中颜色
 * @property {boolean}  DisableAntialias        - 是否禁用反走样
 * @property {boolean}  EnableDemolishByDClick  - 是否允许双击半透明
 * @property {boolean}  UseMpkWorker            - 是否使用Worker
 * @property {string}  MpkWorkerUrl             - Worker导入库地址
 * @property {string}  ZipResourcePostfix       - 数据资源文件后缀
 * @property {boolean}  UseLayerData            - 是否使用分层数据
 * @property {boolean}  IncrementRender         - 是否开启增量绘制
 * @property {number}  LimitFrameTime           - 每帧允许的最大绘制时间
 * @property {number}  maxObjectNumInPool       - 对象池大小
 * @property {number}  maxDrawCacheNum          - 绘制列表最大缓存数目，大于该数目，会回收缓存资源
 * @property {number}  OctantDepth              - 八叉树深度
 * @property {number}  MaximumDepth             - 八叉树最大深度
 * @property {number}  TargetDistance           -
 * @property {number}  ConcurrencyRequestCount  - 最大请求数 (HTTP, web worker, etc. )
 * @property {boolean}  ShowOctant              - 是否绘制八叉树节点
 * @property {boolean}  DisableOctant           - 是否禁止八叉树裁剪数据
 * @property {boolean}  DirectionalLight        - 是否使用平行光源
 * @property {boolean}  Hover                   - 是否启用hover
 * @property {boolean}  ReverseWheelDirection   - 是否反转鼠标滚轮方向
 * @property {number}  MovementSpeedRate        - 相机移动速度倍率
 * @property {boolean}  DEBUG                   - 是否允许调试 (输出日志信息等)
 */
CLOUD.GlobalData = {
    SceneSize: 1000,

    TextureResRoot: 'images/',

    EnableTextureMapping: false,

    SelectionColor: { color: 0x003BBD, side: THREE.DoubleSide /*, opacity: 0.5, transparent: true*/ },

    DisableAntialias: false,
    EnableDemolishByDClick: false,
    IsMobile: false,

    UseMpkWorker: false,
    MpkWorkerUrl: "../libs/mpkWorker.min.js",

    ZipResourcePostfix: "",
    UseLayerData: false,

    IncrementRender: true,
    LimitFrameTime: 250,

    maxObjectNumInPool: 60000,
    maxDrawCacheNum: 40000,

    OctantDepth: 15,
    MaximumDepth: 0,
    TargetDistance: 10000,
    ConcurrencyRequestCount: 8, // Limitation of concurrency request (HTTP, web worker, etc. ) count
    ShowOctant: false,
    EnableOctant: true,

    DirectionalLight: false,
    IBL: false,
    ToneMapping: 4, // 0-4
    LightIntensityFactor: 2.5,

    Hover: false,

    ReverseWheelDirection: false,
    MovementSpeedRate: 1.0,

    OcclusionTranslucentEnabled: false,
    OcclusionOpacity: 0.5,
    OcclusionDistanceToCamera: 1000, // mm

    WireFrame: false,

    DisablePick: false,

    DEBUG: false
};

/**
 * 视角枚举
 * @readonly
 * @enum {number}
 */
CLOUD.EnumStandardView = {
    ISO: 0,
    Top: 1,
    Bottom: 2,
    Front: 3,
    Back: 4,
    Right: 5,
    Left: 6,
    SouthEast: 7,
    SouthWest: 8,
    NorthEast: 9,
    NorthWest: 10,
    BottomFront: 11,
    BottomBack: 12,
    BottomRight: 13,
    BottomLeft: 14,
    BottomSouthEast: 15,
    BottomSouthWest: 16,
    BottomNorthEast: 17,
    BottomNorthWest: 18,
    RoofFront: 19,
    RoofBack: 20,
    RoofRight: 21,
    RoofLeft: 22,
    RoofSouthEast: 23,
    RoofSouthWest: 24,
    RoofNorthEast: 25,
    RoofNorthWest: 26,
    TopTurnRight: 27,
    TopTurnBack: 28,
    TopTurnLeft: 29,
    BottomTurnRight: 30,
    BottomTurnBack: 31,
    BottomTurnLeft: 32,
    FrontTurnRight: 33,
    FrontTurnTop: 34,
    FrontTurnLeft: 35,
    RightTurnBack: 36,
    RightTurnTop: 37,
    RightTurnFront: 38,
    BackTurnRight: 39,
    BackTurnTop: 40,
    BackTurnLeft: 41,
    LeftTurnFront: 42,
    LeftTurnTop: 43,
    LeftTurnBack: 44
};

/**
 * 构件选中事件枚举
 * @readonly
 * @enum {number}
 */
CLOUD.OPSELECTIONTYPE = {
    Clear: 0,
    Add: 1,
    Remove: 2
};

/**
 * 事件枚举
 * @readonly
 * @enum {number}
 */
CLOUD.EVENTS = {

    ON_LOAD_START: 0,
    ON_LOAD_PROGRESS: 1,
    ON_LOAD_COMPLETE: 2,
    ON_LOAD_EMPTY_SCENE: 3,
    ON_LOAD_CONFIG_FINISH: 4,
    ON_LOAD_INVALID_SCENE: 5,

    ON_EDITOR_ENTER: 40,
    ON_EDITOR_EXIST: 41,
    ON_EDITOR_BEGIN: 42,
    ON_EDITOR_END: 43,
    ON_EDITOR_UPDATEUI: 44,

    ON_EDITOR_KEYDOWN: 50,
    ON_EDITOR_KEYUP: 51,

    // the returned event object contains one attribute:
    //           selectionList - Array of current selected object Ids
    ON_SELECTION_CHANGED: 100,

    // triggered when single click mouse no matter if object is selected
    // the returned event object contains two attributes:
    //           screenPos: screen position of the mouse click, for example, {x: 100, y: 200}
    //           intersectInfo: contains five attributes:
    //                 selectedObjectId : selected object id, null if no object selected
    //                 modelId: model Id of the selected object
    //                 point: the pick point on the selected object
    //                 worldPosition: world position of the pick point on the selected object
    //                 worldBoundingBox: bounding box of the selected object in world space
    ON_CLICK_PICK: 101,

    ON_VERSION_NO_MATCH: 200
};

/**
 * 渲染事件类型枚举
 * @readonly
 * @enum {number}
 */
CLOUD.EnumRenderType = {
    RENDER: 0,
    RENDER_FINISHED: 1,
    RESIZE: 2
};

CLOUD.PrimitiveCount = {
    vertexCount: 0,
    triangleCount: 0
};

/**
 * 构件绕点旋转模式
 * @readonly
 * @enum {Number}
 */
CLOUD.PointRotateMode = {
    /** 绕鼠标按下位置对应的构件旋转 */
    MOUSEPOINT: 0,
    /** 绕选中的构件旋转 */
    SELECTION: 1,
    /** 绕场景中心旋转 */
    CENTER: 2,
    /** 绕相机旋转 */
    CAMERA: 3
};

/**
 * 隔离条件类型枚举
 * @readonly
 * @enum {number}
 */
CLOUD.EnumConditionType = {
    HIDDEN_OTHERS: 0,
    TRANSLUCENT_OTHERS: 1,
    OVERRIDE: 2
};

/**
 * 基于ID的过滤器类型枚举
 * @readonly
 * @enum {number}
 */
CLOUD.EnumIdBasedType = {
    FILE_VISIBLE: 0,
    FILE_HIDDEN: 1,
    SELECTED: 2,
    VISIBLE: 3,
    HIDDEN: 4,
    TRANSLUCENT: 5,
    TRANSLUCENT_OTHERS: 6
};

/**
 * 用户自定义类型枚举
 * @readonly
 * @enum {number}
 */
CLOUD.EnumUserType = {
    /** 隐藏 */
    HIDDEN_DATA: 0,
    /** 更改材质 */
    OVERRIDE_DATA: 1
};

/**
 * 隔离状态枚举
 * @readonly
 * @enum {number}
 */
CLOUD.EnumIsolateState = {
    /** 隐藏自己 */
    HIDDEN: 0,
    /** 隐藏其它 */
    HIDDEN_OTHERS: 1,
    /** 半透明自己 */
    TRANSLUCENT: 2,
    /** 半透明其它 */
    TRANSLUCENT_OTHERS: 3
};

/**
 * 场景状态枚举
 * @readonly
 * @enum {number}
 */
CLOUD.EnumSceneState = {
    DISABLED: 0,
    TRANSLUCENT: 1,
    HIDDEN: 2
};

/**
 * 场景浏览模式
 * @readonly
 * @enum {string}
 */
CLOUD.EditorMode = {
    /** 自由旋转模式 */
    ORBIT: 'orbit',
    /** 单选模式 */
    PICK: 'pick',
    /** 框选模式 */
    PICK_BY_RECT: 'pickByRect',
    /** 平移模式 */
    PAN: 'pan',
    /** 缩放模式 */
    ZOOM: 'zoom',
    /** 框选缩放模式 */
    ZOOM_BY_RECT: 'zoomByRect',
    /** 飞行模式 */
    FLY: 'fly',
    /** 行走模式 */
    WALK: 'walk',
    /** 切面模式 */
    CLIP_BY_BOX: 'clipByBox',
    /** 切面补面模式 */
    CLIP_FILL: 'fillClip'
};

/**
 * 相机移动方向
 * @readonly
 * @enum {number}
 */
CLOUD.MoveDirection = {
    NONE: 0,
    UP: 0x0001,
    DOWN: 0x0002,
    LEFT: 0x0004,
    RIGHT: 0x0008,
    FORWARD: 0x0010,
    BACK: 0x0020
};

/**
 * 通用函数
 *
 * @namespace CLOUD.Utils
 */
CLOUD.Utils = {
    /**
     * 根据数组构造THREE.Box3对象
     *
     * @param {Array} arr - 6个float值构成的数组，前3个值对应 min，后3个值对应 max
     * @param {THREE.Box3} [optionalbox] - 如果指定，则optionalbox即为返回值
     * @returns {THREE.Box3} 如果 arr 不是数组类型，则返回 null
     */
    box3FromArray: function box3FromArray(arr, optionalbox) {
        if (arr instanceof Array) {
            var bbox = optionalbox || new THREE.Box3();
            bbox.min.fromArray(arr, 0);
            bbox.max.fromArray(arr, 3);
            return bbox;
        }
        return null;
    },

    /**
     * 根据点数组计算包围盒
     *
     * @param {Array} points - 点数组，每项由3个float值构成
     * @returns {THREE.Box3} 点数组构成的包围盒
     */
    computeBBox: function computeBBox(points) {
        var bbox = new THREE.Box3();
        var v1 = new THREE.Vector3();

        for (var ii = 0, len = points.length; ii < len; ++ii) {
            v1.fromArray(points[ii], 0);
            bbox.expandByPoint(v1);
        }

        return bbox;
    },

    /**
     * 合并包围盒
     *
     * @param {Array} boxs - 包围盒数组，每项可以为 Object 类型（{min : {x:x, y:y, z:z}, max : {x:x, y:y, z:z}}） 或者 THREE.Box3 类型
     *
     */
    mergeBBox: function mergeBBox(boxs) {

        if (boxs.length < 1) return null;

        var bBox = new THREE.Box3();
        var max = new THREE.Vector3();
        var min = new THREE.Vector3();
        var box = new THREE.Box3();

        for (var i = 0, len = boxs.length; i < len; i++) {
            max.set(boxs[i].max.x, boxs[i].max.y, boxs[i].max.z);
            min.set(boxs[i].min.x, boxs[i].min.y, boxs[i].min.z);
            box.set(min, max);
            bBox.union(box);
        }

        return bBox;
    },

    parseTransform: function parseTransform(node, objJson, trf) {
        var updateMatrix = false;

        if (objJson.rotation) {
            node.rotation.fromArray(objJson.rotation);
            updateMatrix = true;
        }

        if (objJson.position) {
            node.position.fromArray(objJson.position);
            updateMatrix = true;
        }

        if (objJson.scale) {
            node.scale.fromArray(objJson.scale);
            updateMatrix = true;
        }

        if (objJson.quaternion) {
            node.quaternion.fromArray(objJson.quaternion);
            updateMatrix = true;
        }

        if (updateMatrix) {
            node.updateMatrix();
        }

        if (objJson.matrix) {
            node.matrix.fromArray(objJson.matrix);
        }

        if (trf) {
            var localTrf = node.matrix.clone();
            localTrf.multiplyMatrices(trf, node.matrix);
            node.matrix = localTrf;
        }

        node.matrixAutoUpdate = false;

        if (node.boundingBox !== undefined) node.boundingBox = CLOUD.Utils.box3FromArray(objJson.bbox);
    },

    isMobileDevice: function isMobileDevice() {

        // userAgent 可能会被更改
        // var uA = navigator.userAgent;
        // if (uA.indexOf('Android') > -1 || uA.indexOf('iPhone') > -1 || uA.indexOf('Windows Phone')) {
        //     return true;
        // }

        var platform = navigator.platform; // iPad, iPhone, Linux armv7, Win, Mac

        // 暂不考虑 Linux
        if (platform.indexOf('Win') !== 0 && platform.indexOf('Mac') !== 0) {

            return true;
        }

        return false;
    },

    isEmptyObject: function isEmptyObject(obj) {

        if (!obj) {
            return true;
        }

        if (obj.length > 0) {
            return false;
        }

        if (obj.length === 0) {
            return true;
        }

        for (var key in obj) {

            if (obj.hasOwnProperty(key)) {
                return false;
            }
        }

        return true;
    },

    /**
     * 查找一个数落在数组中的位置
     *
     * @param {Array} arr - 数字数组(从小到大的排序)
     * @param {Number} val - 查找的数字
     * @returns {Number} 在数组中的索引
     */
    findRange: function findRange(arr, val) {

        if (val < Math.min.apply(null, arr)) {
            return 0;
        }

        if (val > Math.max.apply(null, arr)) {
            return arr.length - 1;
        }

        var idx = 0;

        for (var i = 0, len = arr.length; i < len; ++i) {

            if (arr[i] > val) {
                idx = i - 1;
                break;
            }
        }

        return idx;
    }
};

CLOUD.DomUtil = {
    /**
     * split string on whitespace
     * @param {String} str
     * @returns {Array} words
     */
    splitStr: function splitStr(str) {
        return str.trim().split(/\s+/g);
    },

    /**
     * get the container offset relative to client
     * @param {object} domElement
     * @returns {object}
     */
    getContainerOffsetToClient: function getContainerOffsetToClient(domElement) {
        var offsetObj;

        // 获取相对于视口(客户区域)的偏移量
        var getOffsetSum = function getOffsetSum(ele) {
            var top = 0,
                left = 0;

            // 遍历父元素,获取相对与document的偏移量
            while (ele) {
                top += ele.offsetTop;
                left += ele.offsetLeft;
                ele = ele.offsetParent;
            }

            // 只处理document的滚动条(一般也用不着内部滚动条)
            var body = document.body,
                docElem = document.documentElement;

            //获取页面的scrollTop,scrollLeft(兼容性写法)
            var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
                scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;

            // 减掉滚动距离，获得相对于客户区域的偏移量
            top -= scrollTop;
            left -= scrollLeft;

            return {
                top: top,
                left: left
            };
        };

        // 获取相对于视口(客户区域)的偏移量(viewpoint), 不加页面的滚动量(scroll)
        var getOffsetRect = function getOffsetRect(ele) {
            // getBoundingClientRect返回一个矩形对象，包含四个属性：left、top、right和bottom。分别表示元素各边与页面上边和左边的距离。
            //注意：IE、Firefox3+、Opera9.5、Chrome、Safari支持，在IE中，默认坐标从(2,2)开始计算，导致最终距离比其他浏览器多出两个像素，我们需要做个兼容。
            var box = ele.getBoundingClientRect();
            var body = document.body,
                docElem = document.documentElement;

            //获取页面的scrollTop,scrollLeft(兼容性写法)
            //var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
            //    scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
            var clientTop = docElem.clientTop || body.clientTop,
                clientLeft = docElem.clientLeft || body.clientLeft;
            var top = box.top - clientTop,
                left = box.left - clientLeft;

            return {
                //Math.round 兼容火狐浏览器bug
                top: Math.round(top),
                left: Math.round(left)
            };
        };

        //获取元素相对于页面的偏移
        var getOffset = function getOffset(ele) {
            if (ele.getBoundingClientRect) {
                return getOffsetRect(ele);
            } else {
                return getOffsetSum(ele);
            }
        };

        if (domElement != document) {

            // 这种方式的目的是为了让外部直接传入clientX,clientY,然后计算出相对父容器的offsetX,offsetY值,
            // 即 offsetX = clientX - offsetV.left, offsetY = clientY - offsetV.top
            var offsetV = getOffset(domElement);

            // domElement.offsetLeft（offsetTop）是相对父容器的偏移量，如果用相对坐标表示，直接传回0
            //offset	: [ domElement.offsetLeft,  domElement.offsetTop ]
            offsetObj = {
                width: domElement.offsetWidth,
                height: domElement.offsetHeight,
                left: offsetV.left,
                top: offsetV.top
            };
        } else {

            offsetObj = {
                width: window.innerWidth,
                height: window.innerHeight,
                left: 0,
                top: 0
            };
        }

        return offsetObj;
    },

    /**
     * set css class name
     * @param {String} id
     * @param {String} cssName
     */
    setClassName: function setClassName(id, cssName) {
        var dom = document.getElementById(id);
        if (dom) {
            dom.className = cssName;
        }
    },

    /**
     * add css class name
     * @param {String} id
     * @param {String} cssName
     */
    addClassName: function addClassName(id, cssName) {
        var a, b, c;
        var i, j;
        var s = /\s+/;
        var dom = document.getElementById(id);
        if (dom) {

            b = dom;

            if (cssName && typeof cssName == "string") {
                a = cssName.split(s);

                // 如果节点是元素节点，则 nodeType 属性将返回 1。
                // 如果节点是属性节点，则 nodeType 属性将返回 2。
                if (b.nodeType === 1) {
                    if (!b.className && a.length === 1) {
                        b.className = cssName;
                    } else {
                        c = " " + b.className + " ";

                        for (i = 0, j = a.length; i < j; ++i) {
                            c.indexOf(" " + a[i] + " ") < 0 && (c += a[0] + " ");
                        }

                        b.className = String.trim(c);
                    }
                }
            }
        }
    },

    /**
     * remove css class name
     * @param {String} id
     * @param {String} cssName
     */
    removeClassName: function removeClassName(id, className) {
        var a, b, c;
        var i, j;
        var s = /\s+/;
        var dom = document.getElementById(id);
        if (dom) {
            c = dom;

            if (className && typeof className == "string") {
                a = (className || "").split(s);

                if (c.nodeType === 1 && c.className) {
                    b = (" " + c.className + " ").replace(O, " ");
                    for (i = 0, j = a.length; i < j; i++) {
                        while (b.indexOf(" " + a[i] + " ") >= 0) {
                            b = b.replace(" " + a[i] + " ", " ");
                        }
                    }
                    c.className = className ? String.trim(b) : "";
                }
            }
        }
    },

    /**
     * show or hide element
     * @param {String} id
     * @param {Boolean} isShow
     */
    showOrHideElement: function showOrHideElement(id, isShow) {
        var dom = document.getElementById(id);
        if (dom) {
            if (isShow) {
                dom.style.display = "";
            } else {
                dom.style.display = "none";
            }
        }
    },
    getStyleString: function getStyleString(style) {

        var elements = [];

        for (var key in style) {

            var val = style[key];

            elements.push(key);
            elements.push(':');
            elements.push(val);
            elements.push('; ');
        }

        return elements.join('');
    },
    cloneStyle: function cloneStyle(style) {

        var clone = {};

        for (var key in style) {
            clone[key] = style[key];
        }

        return clone;
    },
    removeStyleAttribute: function removeStyleAttribute(style, attrs) {

        if (!Array.isArray(attrs)) {
            attrs = [attrs];
        }

        attrs.forEach(function (key) {
            if (key in style) {
                delete style[key];
            }
        });
    },
    trimRight: function trimRight(text) {

        if (text.length === 0) {
            return "";
        }

        var lastNonSpace = text.length - 1;

        for (var i = lastNonSpace; i >= 0; --i) {
            if (text.charAt(i) !== ' ') {
                lastNonSpace = i;
                break;
            }
        }

        return text.substr(0, lastNonSpace + 1);
    },
    trimLeft: function trimLeft(text) {

        if (text.length === 0) {
            return "";
        }

        var firstNonSpace = 0;

        for (var i = 0; i < text.length; ++i) {
            if (text.charAt(i) !== ' ') {
                firstNonSpace = i;
                break;
            }
        }

        return text.substr(firstNonSpace);
    },
    matchesSelector: function matchesSelector(domElem, selector) {

        if (domElem.matches) {
            return domElem.matches(selector);
        }

        if (domElem.matchesSelector) {
            return domElem.matchesSelector(selector);
        }

        if (domElem.webkitMatchesSelector) {
            return domElem.webkitMatchesSelector(selector);
        }

        if (domElem.msMatchesSelector) {
            return domElem.msMatchesSelector(selector);
        }

        if (domElem.mozMatchesSelector) {
            return domElem.mozMatchesSelector(selector);
        }

        if (domElem.oMatchesSelector) {
            return domElem.oMatchesSelector(selector);
        }

        if (domElem.querySelectorAll) {

            var matches = (domElem.document || domElem.ownerDocument).querySelectorAll(selector),
                i = 0;

            while (matches[i] && matches[i] !== element) {
                i++;
            }return matches[i] ? true : false;
        }

        return false;
    },
    toTranslate3d: function toTranslate3d(x, y) {

        return 'translate3d(' + x + 'px,' + y + 'px,0)';
    },
    setCursorStyle: function setCursorStyle(element, direction) {

        var cursor;

        switch (direction) {
            case 'n':
            case 's':
                cursor = 'ns-resize';
                break;
            case 'w':
            case 'e':
                cursor = 'ew-resize';
                break;
            case 'ne':
            case 'sw':
                cursor = 'nesw-resize';
                break;
            case 'nw':
            case 'se':
                cursor = 'nwse-resize';
                break;
        }

        element.style.cursor = cursor;
    }
};
CLOUD.GeomUtil = {

    // createInstancedBufferGeometry: function (mesh, objJSON) {
    //     var instances = objJSON.count;
    //
    //     // 转换buffer
    //     var geometry = new THREE.InstancedBufferGeometry();
    //     geometry.maxInstancedCount = instances;
    //     geometry.addAttribute('position', mesh.getAttribute("position"));
    //     geometry.setIndex(mesh.index);
    //
    //     var transformMatrixs = [];
    //     var userIds = [];
    //     var bboxs = [];
    //     var items = objJSON.items;
    //
    //     for (var key in items) {
    //         var item = items[key];
    //         transformMatrixs.push(item.worldMatrix);
    //         userIds.push(item.userId);
    //         bboxs.push(CLOUD.Utils.box3FromArray(item.bbox));
    //     }
    //
    //     var componentV1 = new THREE.InstancedBufferAttribute(new Float32Array(instances * 4), 4, 1);
    //     for (var i = 0, ul = componentV1.count; i < ul; i++) {
    //         componentV1.setXYZW(i, transformMatrixs[i][0], transformMatrixs[i][1], transformMatrixs[i][2], transformMatrixs[i][3]);
    //     }
    //     geometry.addAttribute('componentV1', componentV1);
    //
    //     var componentV2 = new THREE.InstancedBufferAttribute(new Float32Array(instances * 4), 4, 1);
    //     for (var i = 0, ul = componentV2.count; i < ul; i++) {
    //         componentV2.setXYZW(i, transformMatrixs[i][4], transformMatrixs[i][5], transformMatrixs[i][6], transformMatrixs[i][7]);
    //     }
    //     geometry.addAttribute('componentV2', componentV2);
    //
    //     var componentV3 = new THREE.InstancedBufferAttribute(new Float32Array(instances * 4), 4, 1);
    //     for (var i = 0, ul = componentV3.count; i < ul; i++) {
    //         componentV3.setXYZW(i, transformMatrixs[i][8], transformMatrixs[i][9], transformMatrixs[i][10], transformMatrixs[i][11]);
    //     }
    //     geometry.addAttribute('componentV3', componentV3);
    //
    //     var componentV4 = new THREE.InstancedBufferAttribute(new Float32Array(instances * 4), 4, 1);
    //     for (var i = 0, ul = componentV4.count; i < ul; i++) {
    //         componentV4.setXYZW(i, transformMatrixs[i][12], transformMatrixs[i][13], transformMatrixs[i][14], transformMatrixs[i][15]);
    //     }
    //     geometry.addAttribute('componentV4', componentV4);
    //
    //     // 计算法线，
    //     // 注意：在shader中处理时，应用于法线向量的变换矩阵是顶点变换矩阵的逆转置矩阵
    //     if (geometry.attributes.normal === undefined) {
    //         geometry.computeVertexNormals();
    //     }
    //
    //     geometry.boundingBox = CLOUD.Utils.box3FromArray(objJSON.bbox);
    //
    //     var extProperty = {
    //         bboxs: bboxs,
    //         userIds: userIds,
    //         transformMatrixs: transformMatrixs
    //     };
    //
    //     geometry.extProperty = extProperty;
    //
    //     return geometry;
    // },

    // parseNodeProperties: function (object, objJSON, nodeId, trf) {
    //
    //     //object.name = nodeId;
    //
    //     if (objJSON.userId)
    //         object.name = objJSON.userId;
    //     else
    //         object.name = nodeId;
    //
    //     CLOUD.Utils.parseTransform(object, objJSON, trf);
    // },

    // parseSceneNode: function (object, objJSON, modelManager, level) {
    //
    //     object.sceneId = objJSON.sceneId;
    //
    //     // set world bbox
    //     object.worldBoundingBox = object.boundingBox.clone();
    //     object.worldBoundingBox.applyMatrix4(modelManager.getGlobalTransform());
    //     object.level = objJSON.level;
    //     if (objJSON.order) {
    //         object.out = 1;
    //     }
    //
    //     if (CLOUD.GlobalData.ShowSubSceneBox) {
    //         var clr = 0xff;
    //         clr = clr << (level * 5);
    //
    //         var boxNode = new CLOUD.BBoxNode(object.boundingBox, clr);
    //         CLOUD.Utils.parseTransform(boxNode, objJSON);
    //         object.add(boxNode);
    //     }
    // },

    // parseCylinderNode: function () {
    //
    //     var reg = new RegExp("'", "g");
    //     var startPt = new THREE.Vector3();
    //     var endPt = new THREE.Vector3();
    //     var dir = new THREE.Vector3();
    //     var unitY = new THREE.Vector3(0, 1, 0);
    //
    //     return function (geometryNode, params) {
    //         if (params instanceof Object) {
    //
    //         }
    //         else {
    //             params = params.replace(reg, '"');
    //             params = JSON.parse(params);
    //         }
    //
    //
    //         startPt.fromArray(params.startPt);
    //         endPt.fromArray(params.endPt);
    //
    //         dir.subVectors(endPt, startPt);
    //
    //         var len = dir.length();
    //         dir.normalize();
    //
    //         var radius = params.radius;
    //         if (radius <= 1)
    //             radius = 100;
    //         geometryNode.scale.set(radius, len, radius);
    //         geometryNode.quaternion.setFromUnitVectors(unitY, dir);
    //         geometryNode.position.copy(startPt).addScaledVector(dir, len * 0.5);
    //         geometryNode.updateMatrix();
    //         geometryNode.matrixAutoUpdate = false;
    //     }
    //
    // }(),

    // parseBoxNode: function () {
    //
    //     var _boundingBox = new THREE.Box3();
    //     var _trf = new THREE.Matrix4();
    //
    //     return function (object, objJSON) {
    //         CLOUD.Utils.parseTransform(object, objJSON);
    //
    //         CLOUD.Utils.box3FromArray(objJSON.bbox, _boundingBox)
    //         var boxSize = _boundingBox.getSize();
    //         var center = _boundingBox.getCenter();
    //
    //         _trf.identity();
    //         _trf.scale(boxSize);
    //         _trf.setPosition(center);
    //
    //         object.matrix.multiply(_trf);
    //         object.matrixAutoUpdate = false;
    //     };
    //
    // }(),

    // parseHermitePipe: function (objJSON) {
    //     var reg = new RegExp("'", "g");
    //     var params = objJSON.params;
    //     params = params.replace(reg, '"');
    //     params = JSON.parse(params);
    //     var points = [];
    //
    //     for (var ii = 0, len = params.ctrlPts.length / 3; ii < len; ++ii) {
    //         var pt = new THREE.Vector3();
    //         pt.fromArray(params.ctrlPts, ii * 3);
    //         points.push(pt);
    //     }
    //
    //     var extrudePath = new THREE.CatmullRomCurve3(points);
    //     var tube = new THREE.TubeGeometry(extrudePath, 5, params.radius, 6, false);
    //     var bufferObj = new THREE.BufferGeometry();
    //     bufferObj.fromGeometry(tube);
    //
    //     return bufferObj;
    // },

    // parsePGeomNodeInstance: function (client, objJSON, matObj, trf, unloadable) {
    //
    //     var object = null;
    //
    //     if (objJSON.geomType == "pipe" || objJSON.geomType == "tube") {
    //
    //         var geometry = CLOUD.GeomUtil.UnitCylinderInstance;
    //         object = new THREE.Mesh(geometry, matObj);
    //
    //         if (!object) {
    //             return null;
    //         }
    //
    //
    //         CLOUD.GeomUtil.parseCylinderNode(object, objJSON.params);
    //
    //     }
    //     else if (objJSON.geomType == "box") {
    //
    //         var geometry = CLOUD.GeomUtil.UnitBoxInstance;
    //         object = new THREE.Mesh(geometry, matObj);
    //
    //         if (!object) {
    //             return null;
    //         }
    //         CLOUD.GeomUtil.parseBoxNode(object, objJSON);
    //
    //     }
    //     else if (objJSON.geomType == "hermitepipe") {
    //         var geometry = CLOUD.GeomUtil.parseHermitePipe(objJSON);
    //         object = new THREE.Mesh(geometry, matObj);
    //
    //         if (!object) {
    //             return null;
    //         }
    //     }
    //     else {
    //         CLOUD.Logger.log("unknonw geometry!");
    //         return object;
    //     }
    //
    //     if (trf) {
    //         var localTrf = trf.clone();
    //         localTrf.multiply(object.matrix);
    //         object.matrix = localTrf;
    //         object.matrixAutoUpdate = false;
    //     }
    //
    //     return object;
    // },

    EmptyGeometry: new THREE.Geometry(),
    UnitCylinderInstance: new THREE.CylinderBufferGeometry(1, 1, 1, 8, 1, false),
    UnitBoxInstance: new THREE.BoxBufferGeometry(1, 1, 1),

    initializeUnitInstances: function initializeUnitInstances() {
        if (!CLOUD.GeomUtil.UnitCylinderInstance.boundingBox) CLOUD.GeomUtil.UnitCylinderInstance.computeBoundingBox();
        if (!CLOUD.GeomUtil.UnitBoxInstance.boundingBox) CLOUD.GeomUtil.UnitBoxInstance.computeBoundingBox();
    },

    destroyUnitInstances: function destroyUnitInstances() {
        CLOUD.GeomUtil.UnitCylinderInstance.dispose();
        CLOUD.GeomUtil.UnitBoxInstance.dispose();
    },

    // 遍历父节点获得当前mesh的世界矩阵
    getWorldMatrixOfMesh: function getWorldMatrixOfMesh(mesh) {

        var matList = [];
        var parent = mesh.parent;

        while (parent) {

            matList.push(parent.matrix);
            parent = parent.parent;
        }

        var matTmp = new THREE.Matrix4();

        if (matList.length > 0) {
            matTmp = matList[matList.length - 1];

            for (var i = matList.length - 2; i >= 0; --i) {
                matTmp.multiply(matList[i]);
            }
        }

        var objMatrixWorld = new THREE.Matrix4();
        objMatrixWorld.multiplyMatrices(matTmp, mesh.matrix);

        return objMatrixWorld;
    },

    getWorldPositionOfMesh: function getWorldPositionOfMesh(position, sceneMatrix) {

        if (!sceneMatrix) {
            sceneMatrix = new THREE.Matrix4();
        }

        var inverseScaleMatrix = new THREE.Matrix4();
        inverseScaleMatrix.getInverse(sceneMatrix);

        // 计算世界坐标下的位置
        var worldPosition = position.clone();
        worldPosition.applyMatrix4(inverseScaleMatrix);

        return worldPosition;
    },

    getBoundingBoxWorldOfMesh: function getBoundingBoxWorldOfMesh(mesh, sceneMatrix) {

        // 计算世界坐标下的包围盒
        var bBox = mesh.boundingBox;
        if (!bBox) {
            if (!mesh.geometry.boundingBox) {
                mesh.geometry.computeBoundingBox();
            }
            bBox = mesh.geometry.boundingBox;
        }

        var boundingBox = bBox.clone();

        boundingBox.applyMatrix4(mesh.matrixWorld);
        var inverseScaleMatrix = new THREE.Matrix4();
        inverseScaleMatrix.getInverse(sceneMatrix);
        boundingBox.applyMatrix4(inverseScaleMatrix);

        return boundingBox;
    }

};

CLOUD.MaterialUtil = {

    DefaultMaterial: new THREE.MeshPhongMaterial({ color: 0x0000ff, side: THREE.DoubleSide }),

    createInstancePhongMaterial: function createInstancePhongMaterial(matObj) {
        // 复制一份，不影响其他模型的使用
        // 不复制一份，有模型绘制不出
        var material = matObj.clone();
        // material.type = "phong_instanced";
        // material.uniforms = CLOUD.ShaderMaterial.ShaderLib.phong_cust_clip.uniforms;
        // material.vertexShader = "#define USE_CUST_INSTANCED \n" + CLOUD.ShaderMaterial.ShaderLib.phong_cust_clip.vertexShader;
        // material.fragmentShader = "#define USE_CUST_INSTANCED \n" + CLOUD.ShaderMaterial.ShaderLib.phong_cust_clip.fragmentShader;
        return material;
    },

    updateBasicMaterial: function updateBasicMaterial(material, instanced) {

        // if (instanced) {
        //     material.vertexShader = "#define USE_CUST_INSTANCED \n" + CLOUD.ShaderMaterial.ShaderLib.base_cust_clip.vertexShader;
        //     material.fragmentShader = "#define USE_CUST_INSTANCED \n" + CLOUD.ShaderMaterial.ShaderLib.base_cust_clip.fragmentShader;
        // } else {
        //     material.vertexShader = CLOUD.ShaderMaterial.ShaderLib.base_cust_clip.vertexShader;
        //     material.fragmentShader = CLOUD.ShaderMaterial.ShaderLib.base_cust_clip.fragmentShader;
        // }

        material.needsUpdate = true;
    },

    setMatrixUniform: function setMatrixUniform(transform) {
        CLOUD.ShaderMaterial.ShaderLib.base_cust_clip.uniforms.transformMatrix.value = transform;
    },

    createPhongMaterial: function createPhongMaterial(params) {
        // var material = new THREE.MeshPhongMaterial(obj);
        // // material.type = 'phong_cust_clip';
        // // material.uniforms = CLOUD.ShaderMaterial.ShaderLib.phong_cust_clip.uniforms;
        // // material.vertexShader = CLOUD.ShaderMaterial.ShaderLib.phong_cust_clip.vertexShader;
        // // material.fragmentShader = CLOUD.ShaderMaterial.ShaderLib.phong_cust_clip.fragmentShader;
        // return material;

        var material = new THREE.MeshPhongMaterial(params);
        material.type = 'FillFacePhong';
        material.uniforms = THREE.UniformsUtils.merge([THREE.ShaderLib.fillFacePhong.uniforms]);
        material.vertexShader = THREE.ShaderLib.fillFacePhong.vertexShader;
        material.fragmentShader = THREE.ShaderLib.fillFacePhong.fragmentShader;
        material.side = THREE.DoubleSide;

        return material;
    },

    createHighlightMaterial: function createHighlightMaterial() {
        return this.createPhongMaterial(CLOUD.GlobalData.SelectionColor);
    },

    getMaterialParameters: function getMaterialParameters(material) {

        var materialParameters = {};

        if (material.hasOwnProperty('color')) {
            materialParameters.color = material.color;
        }

        if (material.hasOwnProperty('opacity')) {
            materialParameters.opacity = material.opacity;

            if (material.opacity < 1.0) {
                materialParameters.transparent = true;
            }
        }

        if (material.hasOwnProperty('side')) {
            materialParameters.side = material.side;
        }

        if (material.hasOwnProperty('emissive')) {
            materialParameters.emissive = material.emissive;
        }

        if (material.hasOwnProperty('specular')) {
            materialParameters.specular = material.specular;
        }

        if (material.hasOwnProperty('shininess')) {
            materialParameters.shininess = material.shininess;
        }

        if (material.hasOwnProperty('map')) {
            materialParameters.map = material.map;
        }

        if (material.hasOwnProperty('iblProbe')) {
            materialParameters.iblProbe = material.iblProbe;
        }

        return materialParameters;
    },

    nextHighestPowerOfTwo: function nextHighestPowerOfTwo(x) {
        --x;

        for (var i = 1; i < 32; i <<= 1) {
            x = x | x >> i;
        }

        return x + 1;
    },

    ensurePowerOfTwo: function ensurePowerOfTwo(image) {

        if (!THREE.Math.isPowerOfTwo(image.width) || !THREE.Math.isPowerOfTwo(image.height)) {
            var canvas = document.createElement("canvas");
            canvas.width = CLOUD.MaterialUtil.nextHighestPowerOfTwo(image.width);
            canvas.height = CLOUD.MaterialUtil.nextHighestPowerOfTwo(image.height);

            var ctx = canvas.getContext("2d");
            ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
            return canvas;
        }

        return image;
    }
};
CLOUD.CameraInfo = function (position, target, up, version) {
    "use strict";

    this.position = position;
    this.target = target;
    this.up = up;

    // 0：老版本, 1: 新版版
    this.version = version === undefined ? 1 : version; // 用于兼容处理
};

CLOUD.CameraUtil = {

    // 创建相机信息
    createCameraInfo: function createCameraInfo(cameraControl) {
        var camera = cameraControl.camera;
        var camInfo = new CameraInfo(camera.position, camera.target, camera.up);
        return JSON.stringify(camInfo);
    },

    // camera = {"position":"26513.603437903, -14576.4810728955, 15107.6582255056","direction":"-220.050259546712, 169.277369901229, -125.801809656091","up":"0, 0, 304.8"}
    transformCamera: function transformCamera(camera, scene) {

        var position = new THREE.Vector3();

        var str2float = function str2float(strarr) {
            return [parseFloat(strarr[0]), parseFloat(strarr[1]), parseFloat(strarr[2])];
        };

        position.fromArray(str2float(camera.position.split(",")));
        var dir = new THREE.Vector3();
        dir.fromArray(str2float(camera.direction.split(",")));
        var up = new THREE.Vector3();
        up.fromArray(str2float(camera.up.split(",")));

        var target = new THREE.Vector3();
        target.addVectors(position, dir);

        position.applyMatrix4(scene.rootNode.matrix);
        target.applyMatrix4(scene.rootNode.matrix);

        var rotMat = new THREE.Matrix4();
        rotMat.makeRotationFromEuler(scene.rootNode.rotation);
        up.applyMatrix4(rotMat);
        up.normalize();

        return new CLOUD.CameraInfo(position, target, up);
    },

    parseCameraInfo: function parseCameraInfo(jsonStr) {

        var jsonObj = JSON.parse(jsonStr);

        var position = new THREE.Vector3();
        position.x = jsonObj.position.x;
        position.y = jsonObj.position.y;
        position.z = jsonObj.position.z;

        var target = new THREE.Vector3();
        target.x = jsonObj.target.x;
        target.y = jsonObj.target.y;
        target.z = jsonObj.target.z;

        var up = new THREE.Vector3();
        up.x = jsonObj.up.x;
        up.y = jsonObj.up.y;
        up.z = jsonObj.up.z;

        // 老版本数据 jsonObj.version === undefined
        var version = jsonObj.version === undefined ? 0 : jsonObj.version; // 注意：这里和构造函数的默认值不同

        return new CLOUD.CameraInfo(position, target, up, version);
    },

    /**
     * 局部坐标(相对于canvas)转正规化坐标
     *
     * @param {object} point - 局部坐标(相对于canvas) {x:0, y:0, z:0}
     * @param {Number} width - canvas区域宽度
     * @param {Number} height - canvas区域高度
     * @return {object} 正规化坐标[-1, 1] {x:0, y:0, z:0}
     */
    canvasToNormalized: function canvasToNormalized(point, width, height) {

        var result = { x: 0, y: 0, z: 0 };

        result.x = point.x / width * 2 - 1;
        result.y = -point.y / height * 2 + 1;
        result.z = point.z || 0;

        return result;
    },

    /**
     * 正规化坐标转局部坐标(相对于canvas)
     *
     * @param {object} point - 正规化坐标[-1, 1] {x:0, y:0, z:0}
     * @param {Number} width - canvas区域宽度
     * @param {Number} height - canvas区域高度
     * @return {object} 局部坐标(相对于canvas) {x:0, y:0, z:0}
     */
    normalizedToCanvas: function normalizedToCanvas(point, width, height) {

        var result = { x: 0, y: 0, z: 0 };

        result.x = Math.floor(0.5 * (point.x + 1) * width + 0.5);
        result.y = Math.floor(-0.5 * (point.y - 1) * height + 0.5);
        result.z = point.z || 0;

        return result;
    },

    /**
     * 绘图空间坐标(场景变换后)转客户坐标(相对于canvas)
     *
     * @param {object} camera - 相机对象
     * @param {object} point - 世界坐标(场景变换后) {x:0, y:0, z:0}
     * @param {Number} width - canvas区域宽度
     * @param {Number} height - canvas区域高度
     * @return {object} 客户坐标(相对于canvas) {x:0, y:0, z:0}
     */
    drawingToCanvas: function drawingToCanvas(camera, point, width, height) {

        var normalizedPoint = new THREE.Vector3(point.x, point.y, point.z);
        normalizedPoint.project(camera);

        // 裁剪不在相机范围的值
        if (Math.abs(normalizedPoint.z) > 1) {
            console.log("The point is not in the camera frustum!");
            return null;
        }

        var result = this.normalizedToCanvas(normalizedPoint, width, height);

        return result;
    },

    /**
     * 客户坐标(相对于canvas)转绘图空间(场景变换后)
     *
     * @param {object} camera - 相机对象
     * @param {object} point - 客户坐标((相对于canvas) {x:0, y:0, z:0}
     * @param {Number} width - canvas区域宽度
     * @param {Number} height - canvas区域高度
     * @return {object} 绘图空间坐标(场景变换后) {x:0, y:0, z:0}
     */
    canvasToDrawing: function canvasToDrawing(camera, point, width, height) {

        // 转正规化坐标
        var normalizedPoint = this.canvasToNormalized(point, width, height);

        var result = new THREE.Vector3(normalizedPoint.x, normalizedPoint.y, normalizedPoint.z);
        result.unproject(camera);

        return { x: result.x, y: result.y, z: result.z };
    },

    intersectBoxByRay: function intersectBoxByRay(ray, box) {

        var tmin, tmax, tymin, tymax, tzmin, tzmax;

        var invdirx = 1 / ray.direction.x,
            invdiry = 1 / ray.direction.y,
            invdirz = 1 / ray.direction.z;

        var origin = ray.origin;

        if (invdirx >= 0) {

            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
        } else {

            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
        }

        if (invdiry >= 0) {

            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
        } else {

            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
        }

        if (tmin > tymax || tymin > tmax) return null;

        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN

        if (tymin > tmin || tmin !== tmin) tmin = tymin;

        if (tymax < tmax || tmax !== tmax) tmax = tymax;

        if (invdirz >= 0) {

            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
        } else {

            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
        }

        if (tmin > tzmax || tzmin > tmax) return null;

        if (tzmin > tmin || tmin !== tmin) tmin = tzmin;

        if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

        //return point closest to the ray (positive side)

        if (tmax < 0) return null;

        return tmin >= 0 ? tmin : tmax;
    },

    intersectObject: function intersectObject(object, raycaster, intersects, recursive) {

        if (!object.visible) {
            return;
        }

        var hit = object.raycast(raycaster, intersects);

        if (recursive === true && object.children) {
            // Group
            var children = object.children;
            if (children.length > 0 && !hit) return;

            for (var i = 0, l = children.length; i < l; i++) {
                CLOUD.CameraUtil.intersectObject(children[i], raycaster, intersects, true);
            }
        }
    },

    intersectObjectWithFrustum: function () {

        var box = new THREE.Box3();

        return function (object, frustum) {

            if (object.boundingBox && !(object instanceof THREE.Mesh)) {

                box.copy(object.boundingBox);
            } else {

                var geometry = object.geometry;

                if (geometry.boundingBox === null) {
                    geometry.computeBoundingBox();
                }

                box.copy(geometry.boundingBox);
            }

            box.applyMatrix4(object.matrixWorld);

            return frustum.intersectsBox(box);
        };
    }()
};
CLOUD.Logger = {

    log: function log() {

        if (CLOUD.GlobalData.DEBUG) {
            console.log.apply(console, arguments);
        }
    },

    debug: function debug() {

        if (CLOUD.GlobalData.DEBUG) {
            console.debug.apply(console, arguments);
        }
    },

    warn: function warn() {

        if (CLOUD.GlobalData.DEBUG) {
            console.warn.apply(console, arguments);
        }
    },

    error: function error() {

        if (CLOUD.GlobalData.DEBUG) {
            console.error.apply(console, arguments);
        }
    },

    time: function time() {

        if (CLOUD.GlobalData.DEBUG) {
            console.time.apply(console, arguments);
        }
    },

    timeEnd: function timeEnd() {

        if (CLOUD.GlobalData.DEBUG) {
            console.timeEnd.apply(console, arguments);
        }
    }

};

CLOUD.UIHelper = {

    debugInfoDiv: null,
    lastDebugInfoDivShow: null,

    showPickedInformation: function showPickedInformation(evt) {

        var divWidth = 340,
            divHeight = 320;
        var scope = this;

        function hideDiv() {

            var info = scope.debugInfoDiv;

            if (info && info.style.display !== "none") {
                info.style.display = "none";
                //info.parentNode.removeChild(info);

                if (scope.lastDebugInfoDivShow) {
                    info.removeEventListener('dblclick', hideDiv, false);
                    scope.lastDebugInfoDivShow = false;
                }
            }
        }

        function adjustLocation(div, posX, posY) {

            if (!div) return;

            if (div.style.display != "none") {
                var oLeft, oTop;

                var tmpX = posX + divWidth;
                var tmpY = posY + divHeight;

                if (posX !== undefined && posY !== undefined) {
                    if (window.innerWidth) {

                        if (tmpX > window.innerWidth) {
                            oLeft = window.pageXOffset + (posX - divWidth) + "px";
                        } else {
                            oLeft = window.pageXOffset + posX + "px";
                        }

                        if (tmpY > window.innerHeight) {
                            oTop = window.pageYOffset + (posY - divHeight) + "px";
                        } else {
                            oTop = window.pageYOffset + posY + "px";
                        }

                        //oLeft = window.pageXOffset + posX + "px";
                        //oTop = window.pageYOffset + posY + "px";
                    } else {
                        var dde = document.documentElement;
                        oLeft = dde.scrollLeft + posX + "px";
                        oTop = dde.scrollTop + posY + "px";
                    }
                } else {
                    // 居中
                    if (window.innerWidth) {
                        oLeft = window.pageXOffset + (window.innerWidth - divWidth) / 2 + "px";
                        oTop = window.pageYOffset + (window.innerHeight - divHeight) / 2 + "px";
                    } else {
                        var dde = document.documentElement;
                        oLeft = dde.scrollLeft + (dde.offsetWidth - divWidth) / 2 + "px";
                        oTop = dde.scrollTop + (dde.offsetHeight - divHeight) / 2 + "px";
                    }
                }

                div.style.left = oLeft;
                div.style.top = oTop;
            }
        }

        if (!evt || !evt.intersectInfo) {
            hideDiv();
            return;
        }

        var intersect = evt.intersectInfo;

        var cx = evt.screenPos.x,
            cy = evt.screenPos.y;

        if (!this.debugInfoDiv) {
            this.debugInfoDiv = document.createElement("div");
            this.debugInfoDiv.id = "debugPickedInfo";
            this.debugInfoDiv.style.display = "block";
            this.debugInfoDiv.style.position = "absolute";
            this.debugInfoDiv.style.width = divWidth + "px";
            this.debugInfoDiv.style.height = divHeight + "px";
            this.debugInfoDiv.style.backgroundColor = "#ffffdd";
            this.debugInfoDiv.style.borderWidth = "2px";
            this.debugInfoDiv.style.borderStyle = "solid";
            this.debugInfoDiv.style.opacity = "0.8";

            document.body.appendChild(this.debugInfoDiv);
        }

        this.debugInfoDiv.style.display = "";

        // 支持面板一直显示
        if (!this.lastDebugInfoDivShow) {
            this.lastDebugInfoDivShow = true;
            this.debugInfoDiv.addEventListener('dblclick', hideDiv, false);
        }

        var axisGridInfo = intersect.axisGridInfo;
        var position = intersect.worldPosition;

        // 加些样式
        var html = "";
        html += "<span>&#9830;&nbsp;&nbsp;Base Information</span><ul style='width:340px;list-style:none'>";
        html += "<li style='border-left:1px solid #ccc;border-top:1px solid #ccc;border-bottom: 1px solid #ccc;float:left;width:80px;height:66px;text-align:left;line-height:66px'>ID</li>";
        html += "<li style='border:1px solid #ccc;float:left;width:200px;height:66px;text-align:left;'>" + intersect.selectedObjectId + "</li>";
        html += "</ul>";

        html += "</br><span>&#9830;&nbsp;&nbsp;Position</span><ul style='width:340px;list-style:none'>";
        html += "<li style='border-left:1px solid #ccc;border-top:1px solid #ccc;float:left;width:80px;height:33px;text-align:left;line-height:33px'>X</li>";
        html += "<li style='border-left:1px solid #ccc;border-top:1px solid #ccc;float:left;width:200px;height:33px;text-align:left;line-height:33px;border-right: 1px solid #ccc'>" + position.x + "</li>";
        html += "<li style='border-left:1px solid #ccc;border-top:1px solid #ccc;float:left;width:80px;height:33px;text-align:left;line-height:33px'>Y</li>";
        html += "<li style='border-left:1px solid #ccc;border-top:1px solid #ccc;float:left;width:200px;height:33px;text-align:left;line-height:33px;border-right: 1px solid #ccc'>" + position.y + "</li>";
        html += "<li style='border-left:1px solid #ccc;border-top:1px solid #ccc;float:left;width:80px;height:33px;text-align:left;line-height:33px;border-bottom: 1px solid #ccc'>Z</li>";
        html += "<li style='border:1px solid #ccc;float:left;width:200px;height:33px;text-align:left;line-height:33px'>" + position.z + "</li>";
        html += "</ul>";

        if (axisGridInfo) {

            html += "</br><span>&#9830;&nbsp;&nbsp;Axis Grid Information</span><ul style='width:340px;list-style:none'>";
            html += "<li style='border-left:1px solid #ccc;border-top:1px solid #ccc;float:left;width:80px;height:33px;text-align:left;line-height:33px'>distanceX</li>";
            html += "<li style='border-left:1px solid #ccc;border-top:1px solid #ccc;float:left;width:200px;height:33px;text-align:left;line-height:33px;border-right: 1px solid #ccc'>(" + axisGridInfo.numeralName + ", " + axisGridInfo.offsetX + ")</li>";
            html += "<li style='border-left:1px solid #ccc;border-top:1px solid #ccc;float:left;width:80px;height:33px;text-align:left;line-height:33px;border-bottom: 1px solid #ccc'>distanceY</li>";
            html += "<li style='border:1px solid #ccc;float:left;width:200px;height:33px;text-align:left;line-height:33px'>(" + axisGridInfo.abcName + ", " + axisGridInfo.offsetY + ")</li>";
            html += "</ul>";
        } else {

            html += "</br><span>&#9830;&nbsp;&nbsp;Axis Grid Information</span><ul style='width:340px;list-style:none'>";
            html += "<li style='border-left:1px solid #ccc;border-top:1px solid #ccc;float:left;width:80px;height:33px;text-align:left;line-height:33px;border-bottom: 1px solid #ccc'>message</li>";
            html += "<li style='border:1px solid #ccc;float:left;width:200px;height:33px;text-align:left;line-height:33px'><span style='color: red'> not exist axis grid!!!</span></li>";
            html += "</ul>";
        }

        this.debugInfoDiv.innerHTML = html + "<br /><br />";

        adjustLocation(this.debugInfoDiv, cx, cy);
    }
};
CLOUD.OctantNeighborUtil = function (camera, root) {
    this.camera = camera;
    this.root = root; // octree root node

    // flag to search neighbor octant of the direct neighbor octant
    this.searchNeighborOfNeighbor = false;
    // flag to get the child octant of neighbor octant if the neighbor is not leaf node
    this.containChildOfNeighbor = false;

    // octant list which contains camera, from leaf to root
    this.containedOctants = [];

    // nIndex index in containedOctants
    this.father = function (nIndex) {
        nIndex++;
        if (nIndex < this.containedOctants.length) {
            return this.containedOctants[nIndex];
        }

        return null;
    };

    this.adjFace = function (I, sonType) {
        return faceAdjTable[I * 8 + sonType];
    };

    this.adjEdge = function (I, sonType) {
        return edgeAdjTable[I * 8 + sonType];
    };

    this.adjVertex = function (I, sonType) {
        return I == sonType;
    };

    this.refelectFace = function (I, sonType) {
        return faceRefTable[I * 8 + sonType];
    };

    this.refelectEdge = function (I, sonType) {
        return edgeRefTable[I * 8 + sonType];
    };

    this.refelectVertex = function (I, sonType) {
        return this.OctType.MAXTYPEID - sonType;
    };

    this.common_face_edge = function (I, sonType) {
        return edgeOfComFaceTable[I * 8 + sonType];
    };

    this.common_face_vertex = function (I, sonType) {
        return vertOfComFaceTable[I * 8 + sonType];
    };

    this.common_edge = function (I, sonType) {
        return commonEdgeTable[I * 8 + sonType];
    };

    // get child node of 'octant' in direction 'sonType'
    this.son = function (octant, sonType) {
        var i;
        var length = octant.childOctants.length;
        for (i = 0; i < length; i++) {
            if (octant.childOctants[i].octType == sonType) {
                return octant.childOctants[i];
            }
        }

        return null;
    };

    // direction
    this.FaceType = {
        L: 0,
        R: 1,
        D: 2,
        U: 3,
        B: 4,
        F: 5,
        UNKNOWN: 6
    };

    this.EdgeType = {
        LD: 0,
        LU: 1,
        LB: 2,
        LF: 3,
        RD: 4,
        RU: 5,
        RB: 6,
        RF: 7,
        DB: 8,
        DF: 9,
        UB: 10,
        UF: 11,
        UNKNOWN: 12
    };

    this.OctType = { // also VertexType
        RUF: 0,
        LUF: 1,
        RDF: 2,
        LDF: 3,
        RUB: 4,
        LUB: 5,
        RDB: 6,
        LDB: 7,
        MAXTYPEID: 7
    };

    //
    // ADJ table
    //
    // Face table
    //                    RUF    LUF    RDF    LDF    RUB    LUB    RDB    LDB
    var faceAdjTable = [false, true, false, true, false, true, false, true, // L
    true, false, true, false, true, false, true, false, // R
    false, false, true, true, false, false, true, true, // D
    true, true, false, false, true, true, false, false, // U
    false, false, false, false, true, true, true, true, // B
    true, true, true, true, false, false, false, false]; // F

    // Edge table
    var edgeAdjTable = [false, false, false, true, false, false, false, true, // LD
    false, true, false, false, false, true, false, false, // LU
    false, false, false, false, false, true, false, true, // LB
    false, true, false, true, false, false, false, false, // LF
    false, false, true, false, false, false, true, false, // RD
    true, false, false, false, true, false, false, false, // RU
    false, false, false, false, true, false, true, false, // RB
    true, false, true, false, false, false, false, false, // RF
    false, false, false, false, false, false, true, true, // DB
    false, false, true, true, false, false, false, false, // DF
    false, false, false, false, true, true, false, false, // UB
    true, true, false, false, false, false, false, false]; // UF

    //
    // REFLECT table
    //
    // Face table
    //                   RUF LUF RDF LDF RUB LUB RDB LDB
    var faceRefTable = [1, 0, 3, 2, 5, 4, 7, 6, // L
    1, 0, 3, 2, 5, 4, 7, 6, // R
    2, 3, 0, 1, 6, 7, 4, 5, // D
    2, 3, 0, 1, 6, 7, 4, 5, // U
    4, 5, 6, 7, 0, 1, 2, 3, // B
    4, 5, 6, 7, 0, 1, 2, 3]; // F

    // Edge table
    //                   0   1   2   3   4   5   6   7
    //                  RUF LUF RDF LDF RUB LUB RDB LDB
    var edgeRefTable = [3, 2, 1, 0, 7, 6, 5, 4, // LD  0
    3, 2, 1, 0, 7, 6, 5, 4, // LU  1
    5, 4, 7, 6, 1, 0, 3, 2, // LB  2
    5, 4, 7, 6, 1, 0, 3, 2, // LF  3
    3, 2, 1, 0, 7, 6, 5, 4, // RD  4
    3, 2, 1, 0, 7, 6, 5, 4, // RU  5
    5, 4, 7, 6, 1, 0, 3, 2, // RB  6
    5, 4, 7, 6, 1, 0, 3, 2, // RF  7
    6, 7, 4, 5, 2, 3, 0, 1, // DB  8
    6, 7, 4, 5, 2, 3, 0, 1, // DF  9
    6, 7, 4, 5, 2, 3, 0, 1, // UB  10
    6, 7, 4, 5, 2, 3, 0, 1]; // UF  11

    // Common Face table
    //
    // Edge table
    //                        RUF LUF RDF LDF RUB LUB RDB LDB
    var edgeOfComFaceTable = [6, 0, 2, 6, 6, 0, 2, 6, // LD  0
    3, 6, 6, 0, 3, 6, 6, 0, // LU  1
    6, 0, 6, 0, 4, 6, 4, 6, // LB  2
    5, 6, 5, 6, 6, 0, 6, 0, // LF  3
    1, 6, 6, 2, 1, 6, 6, 2, // RD  4
    6, 3, 1, 6, 6, 3, 1, 6, // RU  5
    1, 6, 1, 6, 6, 4, 6, 4, // RB  6
    6, 5, 6, 5, 1, 6, 1, 6, // RF  7
    6, 6, 2, 2, 4, 4, 6, 6, // DB  8
    5, 5, 6, 6, 6, 6, 2, 2, // DF  9
    3, 3, 6, 6, 6, 6, 4, 4, // UB  10
    6, 6, 5, 5, 3, 3, 6, 6]; // UF  11

    // Vertex table
    //                        RUF LUF RDF LDF RUB LUB RDB LDB
    var vertOfComFaceTable = [6, 6, 6, 5, 6, 3, 1, 6, // RUF
    6, 6, 5, 6, 3, 6, 6, 0, // LUF
    6, 5, 6, 6, 1, 6, 6, 2, // RDF
    5, 6, 6, 6, 6, 0, 2, 6, // LDF
    6, 3, 1, 6, 6, 6, 6, 4, // RUB
    3, 6, 6, 0, 6, 6, 4, 6, // LUB
    1, 6, 6, 2, 6, 4, 6, 6, // RDB
    6, 0, 2, 6, 1, 6, 6, 6]; // LDB

    // Common Edge table
    //                      0   1   2   3   4   5   6   7
    //                     RUF LUF RDF LDF RUB LUB RDB LDB
    var commonEdgeTable = [12, 11, 7, 12, 5, 12, 12, 12, // RUF
    11, 12, 12, 3, 12, 1, 12, 12, // LUF
    7, 12, 12, 9, 12, 12, 4, 12, // RDF
    12, 3, 9, 12, 12, 12, 12, 0, // LDF
    5, 12, 12, 12, 12, 10, 6, 12, // RUB
    12, 1, 12, 12, 10, 12, 12, 2, // LUB
    12, 12, 4, 12, 6, 12, 12, 8, // RDB
    12, 12, 12, 0, 12, 2, 8, 12]; // LDB
};

// Locate a face-neighbor of node P, of size greater than
// or equal to P, in direction I. If such a node does not
// exist, then return NIL.
CLOUD.OctantNeighborUtil.prototype.findFaceNeighborImpl = function (nIndex, I) {

    var ret = { node: null, cont: false };

    var ancestors = this.containedOctants;
    var P = ancestors[nIndex];

    if (nIndex >= ancestors.length) {
        return ret;
    }

    if (this.father(nIndex) && this.adjFace(I, P.octType)) {
        ret = this.findFaceNeighborImpl(nIndex + 1, I);
    } else {
        ret.node = this.father(nIndex);
        ret.cont = true;
    }

    if (ret.cont && ret.node !== null && ret.node.childOctants.length > 0) {
        // get child node
        var Q = this.son(ret.node, this.refelectFace(I, P.octType));
        if (Q) {
            return { node: Q, cont: true };
        } else {
            return { node: ret.node, cont: false };
        }
    }

    return ret;
};

CLOUD.OctantNeighborUtil.prototype.findFaceNeighbor = function (nIndex, I) {

    var ret = this.findFaceNeighborImpl(nIndex, I);

    if (ret.node && !ret.node.isRoot()) {
        return ret.node;
    }

    return null;
};

// Locate an edge-neighbor of node P, of size greater
// than or equal to P, in direction I. If such a node
// does not exist, then return NIL.
CLOUD.OctantNeighborUtil.prototype.findEdgeNeighborImpl = function (nIndex, I) {

    var ret = { node: null, cont: false };

    var ancestors = this.containedOctants;
    var P = ancestors[nIndex];

    if (nIndex >= ancestors.length) {
        return ret;
    }

    if (this.father(nIndex)) {
        if (this.adjEdge(I, P.octType)) {
            ret = this.findEdgeNeighborImpl(nIndex + 1, I);
        } else if (this.common_face_edge(I, P.octType) !== this.FaceType.UNKNOWN) {
            ret = this.findFaceNeighborImpl(nIndex + 1, this.common_face_edge(I, P.octType));
        } else {
            ret.node = this.father(nIndex);
            ret.cont = true;
        }
    }

    if (ret.cont && ret.node !== null && ret.node.childOctants.length > 0) {
        // get child node
        var Q = this.son(ret.node, this.refelectEdge(I, P.octType));
        if (Q) {
            return { node: Q, cont: true };
        } else {
            return { node: ret.node, cont: false };
        }
    }

    return ret;
};

CLOUD.OctantNeighborUtil.prototype.findEdgeNeighbor = function (nIndex, I) {

    var ret = this.findEdgeNeighborImpl(nIndex, I);

    if (ret.node && !ret.node.isRoot()) {
        return ret.node;
    }

    return null;
};

// Locate a vertex-neighbor of node P, of size greater than
// or equal to P, in direction I. If such a node does not
// exist, then return NIL.
CLOUD.OctantNeighborUtil.prototype.findVertexNeighborImpl = function (nIndex, I) {

    var ret = { node: null, cont: false };
    var ancestors = this.containedOctants;
    var P = ancestors[nIndex];

    if (nIndex >= ancestors.length) {
        return ret;
    }

    if (this.father(nIndex)) {
        if (this.adjVertex(I, P.octType)) {
            ret = this.findVertexNeighborImpl(nIndex + 1, I);
        } else if (this.common_edge(I, P.octType) !== this.EdgeType.UNKNOWN) {
            ret = this.findVertexNeighborImpl(nIndex + 1, this.common_edge(I, P.octType));
        } else if (this.common_face_vertex(I, P.octType) != this.FaceType.UNKNOWN) {
            ret = this.findVertexNeighborImpl(nIndex + 1, this.common_face_vertex(I, P.octType));
        } else {
            ret.node = this.father(nIndex);
            ret.cont = true;
        }
    }

    if (ret.cont && ret.node !== null && ret.node.childOctants.length > 0) {
        // get child node
        var Q = this.son(ret.node, this.refelectVertex(I, P.octType));
        if (Q) {
            return { node: Q, cont: true };
        } else {
            return { node: ret.node, cont: false };
        }
    }

    return ret;
};

CLOUD.OctantNeighborUtil.prototype.findVertexNeighbor = function (nIndex, I) {

    var ret = this.findVertexNeighborImpl(nIndex, I);

    if (ret.node && !ret.node.isRoot()) {
        return ret.node;
    }

    return null;
};

// 查找包含照相机的八叉树最深层叶子节点，如果该叶子节点为空，则使用父节点或
// 中央点离照相机最近的八叉树节点
// 结果是从叶子节点到父节点，一直到根节点的数组，保持在containedOctants中
CLOUD.OctantNeighborUtil.prototype.findContainNode = function (octant) {
    var node;
    var camera = this.camera;
    var cameraPos = camera.position;

    var cameraOutsideOctant = cameraPos.x < octant.min.x || cameraPos.x > octant.max.x || cameraPos.y < octant.min.y || cameraPos.y > octant.max.y || cameraPos.z < octant.min.z || cameraPos.z > octant.max.z;

    if (!cameraOutsideOctant) {
        //如果该节点是叶子节点，则返回
        if (octant.childOctants.length != 0) {
            // 继续查找子节点
            var i;
            var length;
            for (i = 0, length = octant.childOctants.length; i < length; ++i) {
                node = octant.childOctants[i];
                if (this.findContainNode(node)) {
                    break;
                }
            }
        }

        this.containedOctants.push(octant);
        /*
        // 没有子节点包含照相机，说明子节点塌陷了，根据子节点中心离照相机的距离来确定
        var distance = 0;
        var minDistanceNode = 0;
        for (i = 0, length = octant.childOctants.length; i < length; ++i) {
            node = octant.childOctants[i];
              var camToOctantDir = new THREE.Vector3(node.center.x - cameraPos.x,
                node.center.y - cameraPos.y, node.center.z - cameraPos.z);
            var d = camToOctantDir.lengthSq();
            if (i == 0) {
                distance = d;
            }
            else if (distance > d){
                distance = d;
                minDistanceNode = i;
            }
        }
        */
        return true;
    }

    return false;
};

// octants是包含camera的八叉树叶子节点数组，第一个元素是叶子节点，然后是父节点，最后是根节点
// 根据camera的方向，得到和octant相邻的八叉树节点
CLOUD.OctantNeighborUtil.prototype.findNeighborNode = function () {
    var searchNeighborOfNeighbor = this.searchNeighborOfNeighbor;
    var containChildOfNeighbor = this.containChildOfNeighbor;

    var camera = this.camera;
    var octants = this.containedOctants;

    var OctType = this.OctType;
    var EdgeType = this.EdgeType;

    var neighborOctants = [];
    var oct;

    if (octants.length == 0) {
        return neighborOctants; // return empty neighbor list
    }

    var frustum = camera.frustum;
    var i, j, k;
    var dx, dy, dz;

    var min;
    var max;
    var octant = octants[0];
    min = octant.min;
    max = octant.max;

    // follow the camera direction and get neighbor face octant
    var target = camera.target;
    var cameraPos = camera.position;
    var camDir = new THREE.Vector3(target.x - cameraPos.x, target.y - cameraPos.y, target.z - cameraPos.z);

    var cameraRay = new THREE.Ray(cameraPos, camDir);
    var intersectFaces = [];

    // faces: left, right, down, up, back, front

    var box3 = new THREE.Box3(min, max);
    var intersectPoint = cameraRay.intersectBox(box3);

    // get intersect face by camera dir
    if (intersectPoint) {
        // check if the intersect point is in the box plane
        if (intersectPoint.y == min.y || intersectPoint.y == max.y) {
            // Up/Down face intersectPoint.y == max.y or min.y
            if (intersectPoint.x <= max.x && intersectPoint.x >= min.x && intersectPoint.z <= max.z && intersectPoint.z >= min.z) {
                if (intersectPoint.y == min.y) {
                    intersectFaces.push(2);
                } else {
                    intersectFaces.push(3);
                }
            }
        } else if (intersectPoint.z == min.z || intersectPoint.z == max.z) {
            // Front/Back face
            if (intersectPoint.x <= max.x && intersectPoint.x >= min.x && intersectPoint.y <= max.y && intersectPoint.y >= min.y) {
                if (intersectPoint.z == min.z) {
                    intersectFaces.push(4);
                } else {
                    intersectFaces.push(5);
                }
            }
        } else if (intersectPoint.x == min.x || intersectPoint.x == max.x) {
            // Left/Right face
            if (intersectPoint.z <= max.z && intersectPoint.z >= min.z && intersectPoint.y <= max.y && intersectPoint.y >= min.y) {
                if (intersectPoint.x == min.x) {
                    intersectFaces.push(0);
                } else {
                    intersectFaces.push(1);
                }
            }
        }
    }

    if (intersectFaces.length == 0) {
        // something goes wrong
        return neighborOctants;
    }

    // get intersect faces by frustum
    // 1, construct outer box from faces

    dx = max.x - min.x;
    dy = max.y - min.y;
    dz = max.z - min.z;
    if (dy > dx) dx = dy;
    if (dz > dx) dx = dz;
    var octLength = dx;
    var tmpBoxCenter = new THREE.Vector3();
    for (i = 0; i < 6; i++) {
        if (i == intersectFaces[0]) {
            continue;
        }
        tmpBoxCenter.copy(octant.center);
        switch (i) {
            case 0:
                tmpBoxCenter.x -= octLength;
                break;
            case 1:
                tmpBoxCenter.x += octLength;
                break;
            case 2:
                tmpBoxCenter.y -= octLength;
                break;
            case 3:
                tmpBoxCenter.y += octLength;
                break;
            case 4:
                tmpBoxCenter.z -= octLength;
                break;
            case 5:
                tmpBoxCenter.z += octLength;
                break;
        }

        var halfLength = octLength / 2.0;
        var tmpBox3 = new THREE.Box3(new THREE.Vector3(tmpBoxCenter.x - halfLength, tmpBoxCenter.y - halfLength, tmpBoxCenter.z - halfLength), new THREE.Vector3(tmpBoxCenter.x + halfLength, tmpBoxCenter.y + halfLength, tmpBoxCenter.z + halfLength));

        if (frustum.intersectsBox(tmpBox3)) {
            intersectFaces.push(i);
        }
    }

    if (intersectFaces.length > 1) {
        intersectFaces.sort();
    }

    // RUF : 0,     LUF : 1,      RDF : 2,     LDF : 3,
    // RUB : 4,     LUB : 5,      RDB : 6,     LDB : 7,
    if (intersectFaces.length > 2) {
        // find neighbor from vertex
        var vertex = 0;
        for (i = 0; i < intersectFaces.length; i++) {
            for (j = i + 1; j < intersectFaces.length; j++) {
                for (k = j + 1; k < intersectFaces.length; k++) {
                    if (intersectFaces[i] == 1 && intersectFaces[j] == 3 && intersectFaces[k] == 5) {
                        vertex = OctType.RUF;
                    } else if (intersectFaces[i] == 0 && intersectFaces[j] == 3 && intersectFaces[k] == 5) {
                        vertex = OctType.LUF;
                    } else if (intersectFaces[i] == 1 && intersectFaces[j] == 2 && intersectFaces[k] == 5) {
                        vertex = OctType.RDF;
                    } else if (intersectFaces[i] == 0 && intersectFaces[j] == 2 && intersectFaces[k] == 5) {
                        vertex = OctType.LDF;
                    } else if (intersectFaces[i] == 1 && intersectFaces[j] == 3 && intersectFaces[k] == 4) {
                        vertex = OctType.RUB;
                    } else if (intersectFaces[i] == 0 && intersectFaces[j] == 3 && intersectFaces[k] == 4) {
                        vertex = OctType.LUB;
                    } else if (intersectFaces[i] == 1 && intersectFaces[j] == 2 && intersectFaces[k] == 4) {
                        vertex = OctType.RDB;
                    } else if (intersectFaces[i] == 0 && intersectFaces[j] == 2 && intersectFaces[k] == 4) {
                        vertex = OctType.LDB;
                    } else {
                        continue;
                    } //these faces have no common edge
                    oct = this.findVertexNeighbor(0, vertex);
                    if (oct) {
                        neighborOctants.push(oct);
                        if (containChildOfNeighbor) {
                            this.getChildOfOctant(oct, 2, vertex, neighborOctants);
                        }
                        if (searchNeighborOfNeighbor) {
                            oct = this.getNeighborOfSecondLevel(oct, 2, vertex);
                            if (oct) {
                                neighborOctants.push(oct);
                            }
                        }
                    }
                }
            }
        }
    }

    // LD = 0; LU = 1; LB = 2; LF = 3; RD = 4; RU = 5;
    // RB = 6; RF = 7; DB = 8; DF = 9; UB = 10; UF = 11;
    if (intersectFaces.length > 1) {
        // find neighbor from edge
        var edge = 0;
        for (i = 0; i < intersectFaces.length; i++) {
            for (j = i + 1; j < intersectFaces.length; j++) {
                if (intersectFaces[i] == 0 && intersectFaces[j] == 2) {
                    edge = EdgeType.LD;
                } else if (intersectFaces[i] == 0 && intersectFaces[j] == 3) {
                    edge = EdgeType.LU;
                } else if (intersectFaces[i] == 0 && intersectFaces[j] == 4) {
                    edge = EdgeType.LB;
                } else if (intersectFaces[i] == 0 && intersectFaces[j] == 5) {
                    edge = EdgeType.LF;
                } else if (intersectFaces[i] == 1 && intersectFaces[j] == 2) {
                    edge = EdgeType.RD;
                } else if (intersectFaces[i] == 1 && intersectFaces[j] == 3) {
                    edge = EdgeType.RU;
                } else if (intersectFaces[i] == 1 && intersectFaces[j] == 4) {
                    edge = EdgeType.RB;
                } else if (intersectFaces[i] == 1 && intersectFaces[j] == 5) {
                    edge = EdgeType.RF;
                } else if (intersectFaces[i] == 2 && intersectFaces[j] == 4) {
                    edge = EdgeType.DB;
                } else if (intersectFaces[i] == 2 && intersectFaces[j] == 5) {
                    edge = EdgeType.DF;
                } else if (intersectFaces[i] == 3 && intersectFaces[j] == 4) {
                    edge = EdgeType.UB;
                } else if (intersectFaces[i] == 3 && intersectFaces[j] == 5) {
                    edge = EdgeType.UF;
                } else {
                    continue;
                } //these faces have no common edge
                oct = this.findEdgeNeighbor(0, edge);
                if (oct) {
                    neighborOctants.push(oct);
                    if (containChildOfNeighbor) {
                        this.getChildOfOctant(oct, 1, edge, neighborOctants);
                    }
                    if (searchNeighborOfNeighbor) {
                        oct = this.getNeighborOfSecondLevel(oct, 1, edge);
                        if (oct) {
                            neighborOctants.push(oct);
                        }
                    }
                }
            }
        }
    }

    for (i = 0; i < intersectFaces.length; i++) {
        // find neighbor from face
        oct = this.findFaceNeighbor(0, intersectFaces[i]);
        if (oct) {
            neighborOctants.push(oct);
            if (containChildOfNeighbor) {
                this.getChildOfOctant(oct, 0, intersectFaces[i], neighborOctants);
            }
            if (searchNeighborOfNeighbor) {
                oct = this.getNeighborOfSecondLevel(oct, 0, intersectFaces[i]);
                if (oct) {
                    neighborOctants.push(oct);
                }
            }
        }
    }

    neighborOctants.sort(function (a, b) {
        if (a.octantId < b.octantId) {
            return -1;
        } else {
            return 1;
        }
    });

    return neighborOctants;
};

// kind: 0 - face, 1 - edge, 2 - vertex
// I: camera direction to search, need to reverse
CLOUD.OctantNeighborUtil.prototype.getChildOfOctant = function (octant, kind, I, neighborOctants) {
    var childNum = octant.childOctants.length;
    if (childNum == 0 || octant.depth < 4) {
        return;
    }

    var faceType = this.FaceType;
    var faceDir = [];
    switch (kind) {
        case 0:
            // face
            faceDir.push(I % 2 == 0 ? I + 1 : I - 1);
            break;
        case 1:
            // edge
            var edgeType = this.EdgeType;
            switch (I) {
                case edgeType.LD:
                    faceDir.push(faceType.R);faceDir.push(faceType.U);
                    break;
                case edgeType.LU:
                    faceDir.push(faceType.R);faceDir.push(faceType.D);
                    break;
                case edgeType.LB:
                    faceDir.push(faceType.R);faceDir.push(faceType.F);
                    break;
                case edgeType.LF:
                    faceDir.push(faceType.R);faceDir.push(faceType.B);
                    break;
                case edgeType.RD:
                    faceDir.push(faceType.L);faceDir.push(faceType.U);
                    break;
                case edgeType.RU:
                    faceDir.push(faceType.L);faceDir.push(faceType.D);
                    break;
                case edgeType.RB:
                    faceDir.push(faceType.L);faceDir.push(faceType.F);
                    break;
                case edgeType.RF:
                    faceDir.push(faceType.L);faceDir.push(faceType.B);
                    break;
                case edgeType.DB:
                    faceDir.push(faceType.U);faceDir.push(faceType.F);
                    break;
                case edgeType.DF:
                    faceDir.push(faceType.U);faceDir.push(faceType.B);
                    break;
                case edgeType.UB:
                    faceDir.push(faceType.D);faceDir.push(faceType.F);
                    break;
                case edgeType.UF:
                    faceDir.push(faceType.D);faceDir.push(faceType.B);
                    break;
            }
            break;
        case 2:
            //vertex
            var octType = this.OctType;
            switch (I) {
                case octType.RUF:
                    faceDir.push(faceType.L);faceDir.push(faceType.D);faceDir.push(faceType.B);
                    break;
                case octType.LUF:
                    faceDir.push(faceType.R);faceDir.push(faceType.D);faceDir.push(faceType.B);
                    break;
                case octType.RDF:
                    faceDir.push(faceType.L);faceDir.push(faceType.U);faceDir.push(faceType.B);
                    break;
                case octType.LDF:
                    faceDir.push(faceType.R);faceDir.push(faceType.U);faceDir.push(faceType.B);
                    break;
                case octType.RUB:
                    faceDir.push(faceType.L);faceDir.push(faceType.D);faceDir.push(faceType.F);
                    break;
                case octType.LUB:
                    faceDir.push(faceType.R);faceDir.push(faceType.D);faceDir.push(faceType.F);
                    break;
                case octType.RDB:
                    faceDir.push(faceType.L);faceDir.push(faceType.U);faceDir.push(faceType.F);
                    break;
                case octType.LDB:
                    faceDir.push(faceType.R);faceDir.push(faceType.U);faceDir.push(faceType.F);
                    break;
            }
            break;
    }

    // get child octants in each face direction
    for (var i = 0; i < faceDir.length; i++) {
        this.getFaceChildOfOctant(octant, faceDir[i], neighborOctants);
    }
};

CLOUD.OctantNeighborUtil.prototype.getFaceChildOfOctant = function (octant, faceDir, neighborOctants) {
    var curOct;
    var reflectFace;
    for (var i = 0, length = octant.childOctants.length; i < length; i++) {
        curOct = octant.childOctants[i];
        if (this.adjFace(faceDir, curOct.octType)) {
            neighborOctants.push(curOct);
            this.getFaceChildOfOctant(curOct, faceDir, neighborOctants);
        } else {
            reflectFace = this.refelectFace(faceDir, curOct.octType);
            for (var j = 0; j < length; j++) {
                if (octant.childOctants[j].octType == reflectFace) {
                    break;
                }
            }

            if (j == length) {
                neighborOctants.push(curOct);
                this.getFaceChildOfOctant(curOct, faceDir, neighborOctants);
            }
        }
    }
};

// kind: 0 - face, 1 - edge, 2 - vertex
// I: direction to search
CLOUD.OctantNeighborUtil.prototype.getNeighborOfSecondLevel = function (octant, kind, I) {
    var curNodeStack = [];
    var ancestorOctants = [];
    var neighborOctants = [];
    neighborOctants[0] = octant;
    this.getAncestorNodes(this.root, neighborOctants, 0, curNodeStack, ancestorOctants);
    var util = new CLOUD.OctantNeighborUtil(this.camera, this.root);
    util.containedOctants = ancestorOctants;

    var oct = null;
    switch (kind) {
        case 0:
            oct = util.findFaceNeighbor(0, I);
            break;
        case 1:
            oct = util.findEdgeNeighbor(0, I);
            break;
        case 2:
            oct = util.findVertexNeighbor(0, I);
            break;
    }

    return oct;
};

CLOUD.OctantNeighborUtil.prototype.getAncestorAndNeighbors = function () {
    this.searchNeighborOfNeighbor = true;
    this.containChildOfNeighbor = true;

    //this.outputOctree(this.root, -1);
    var containedOctants = this.containedOctants;

    this.findContainNode(this.root);
    var neighborOctants = this.findNeighborNode(this.camera, containedOctants);

    // get ancestor nodes of neighbor octants
    var curNodeStack = [];
    var ancestorOctants = [];
    this.getAncestorNodes(this.root, neighborOctants, 0, curNodeStack, ancestorOctants);

    var ancestorAndNeighbors = {};
    var i;
    var length;
    for (i = 0, length = containedOctants.length; i < length; i++) {
        ancestorAndNeighbors[containedOctants[i].octantId] = 1;
    }

    for (i = 0, length = neighborOctants.length; i < length; i++) {
        ancestorAndNeighbors[neighborOctants[i].octantId] = 1;
    }

    for (i = 0, length = ancestorOctants.length; i < length; i++) {
        ancestorAndNeighbors[ancestorOctants[i].octantId] = 1;
    }

    //this.outputOctants(ancestorAndNeighbors, containedOctants[0]);

    return ancestorAndNeighbors;
};

// Get ancestor octree nodes of the nodes in octants
CLOUD.OctantNeighborUtil.prototype.getAncestorNodes = function (root, octants, curIndex, stack, ancestors) {

    var i;
    var length;
    var curNode;
    for (i = 0, length = root.childOctants.length; i < length && curIndex < octants.length; i++) {
        curNode = root.childOctants[i];
        stack.push(curNode);
        if (curNode.octantId == octants[curIndex].octantId) {
            for (var j = stack.length - 1; j >= 0; j--) {
                ancestors.push(stack[j]);
            }
            curIndex++;
        } else if (i == length - 1 || root.childOctants[i + 1].octantId > octants[curIndex].octantId) {
            // search child tree
            curIndex = this.getAncestorNodes(curNode, octants, curIndex, stack, ancestors);
        }
        // else continue to search next child
        stack.pop();
    }

    return curIndex;
};

CLOUD.OctantNeighborUtil.prototype.outputOctants = function (octants, cameraNode) {
    console.group();

    console.log("Node that contains camera: %d", cameraNode.octantId);
    var nodes = "";
    var i = 0;
    for (var o in octants) {
        nodes += o;
        nodes += "  ";
        if (i % 9 == 0) {
            nodes += "\n";
        }
        i++;
    }
    console.log("nodes: %s", nodes);
    console.groupEnd();
};

CLOUD.OctantNeighborUtil.prototype.outputOctree = function (node, parentId) {
    console.group();
    var i;
    var indent = "";
    for (i = 0; i < node.depth; i++) {
        indent += "  ";
    }
    console.log("%sNode id: %i, depth: %i, octType: %i, parent: %i", indent, node.octantId, node.depth, node.octType, parentId);
    console.log("%s  size: %f, center: %f, %f, %f", indent, node.size, node.center.x, node.center.y, node.center.z);
    console.log("%s  child number: %i", indent, node.childOctants.length);
    var children = "";
    for (i = 0; i < node.childOctants.length; i++) {
        children += node.childOctants[i].octantId;
        children += "  ";
    }
    console.log("%s  children: %i", indent, children);
    for (i = 0; i < node.childOctants.length; i++) {
        this.outputOctree(node.childOctants[i], node.octantId);
    }
    console.groupEnd();
};

CLOUD.RenderGroup = function () {

    var opaqueObjects = [];
    var transparentObjects = [];

    var opaqueObjectsLastIndex = -1;
    var transparentObjectsLastIndex = -1;

    var renderingIdx = 0;
    var opaqueFinished = false;
    var transparentFinished = false;
    var timeStart = 0;
    var timeEnd = 0;
    var timeElapse = 0;

    this.getOpaqueObjects = function () {
        return opaqueObjects;
    };

    this.getTransparentObjects = function () {
        return transparentObjects;
    };

    function painterSortStable(a, b) {
        if (a.material.id !== b.material.id) {
            return a.material.id - b.material.id;
        } else {
            return a.id - b.id;
        }
    }

    function reversePainterSortStable(a, b) {
        if (a.z !== b.z) {
            return b.z - a.z;
        } else {
            return a.id - b.id;
        }
    }

    this.destroy = function () {
        opaqueObjects = [];
        transparentObjects = [];
    };

    this.restart = function () {
        renderingIdx = 0;
        opaqueFinished = false;
        transparentFinished = false;
    };

    this.prepare = function () {
        this.restart();
        opaqueObjectsLastIndex = -1;
        transparentObjectsLastIndex = -1;
    };

    this.renderableCount = function () {
        return opaqueObjectsLastIndex + transparentObjectsLastIndex;
    };

    this.pushRenderItem = function (object, geometry, material, z, group) {

        var array, index;
        if (material.transparent) {
            array = transparentObjects;
            index = ++transparentObjectsLastIndex;
        } else {
            array = opaqueObjects;
            index = ++opaqueObjectsLastIndex;
        }

        // recycle existing render item or grow the array
        var renderItem = array[index];
        if (renderItem !== undefined) {

            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.z = z;
            renderItem.group = group;
        } else {
            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                z: z,
                group: group
            };
            // assert( index === array.length );
            //array.push( renderItem );
            array[index] = renderItem;
        }
    };

    this.sortRenderList = function (cullEnd) {

        opaqueObjects.length = opaqueObjectsLastIndex + 1;
        transparentObjects.length = transparentObjectsLastIndex + 1;

        //console.log(opaqueObjects.length + transparentObjects.length);

        if (cullEnd) {
            //console.time("sort");
            opaqueObjects.sort(painterSortStable);
            transparentObjects.sort(reversePainterSortStable);
            //console.timeEnd("sort");
        }
    };

    function renderObjects(renderer, renderList, camera, lights, fog, update) {

        timeStart = Date.now();

        var len = renderList.length;
        var i = renderingIdx;

        for (; i < len; i++) {

            var renderItem = renderList[i];
            var object = renderItem.object;
            var material = renderItem.material;
            var group = renderItem.group;
            var geometry = renderItem.geometry;

            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
            object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

            geometry = renderer.updateObject(object);
            renderer.renderBufferDirect(camera, fog, geometry, material, object, group);

            // if ((i % 5000) === 4999) {
            //
            //     timeEnd = Date.now();
            //     timeElapse = timeEnd - timeStart;
            //
            //     if (timeElapse > CLOUD.GlobalData.LimitFrameTime) {
            //
            //         renderingIdx = i + 1;
            //         return false;
            //     }
            // }

            timeEnd = Date.now();
            timeElapse = timeEnd - timeStart;

            if (timeElapse > CLOUD.GlobalData.LimitFrameTime) {

                //console.log("timeElapse", [timeElapse, i]);

                renderingIdx = i + 1;
                return false;
            }
        }

        renderingIdx = 0;
        return true;
    }

    this.renderOpaqueObjects = function (renderer, camera, lights, fog, update) {

        if (!opaqueFinished) {
            opaqueFinished = renderObjects(renderer, opaqueObjects, camera, lights, fog, update);
        }

        return opaqueFinished;
    };

    this.renderTransparentObjects = function (renderer, camera, lights, fog, update) {

        if (!transparentFinished) {
            transparentFinished = renderObjects(renderer, transparentObjects, camera, lights, fog, update);
        }

        return transparentFinished;
    };
};

CLOUD.OrderedRenderer = function (filter) {

    // increment culling
    var _cullTicket = 0;
    var _isIncrementalCullFinish = false,
        _isIncrementalRenderFinish = false;
    var _countCullingObject = 0;
    var _countScreenCullOff = 0;
    var _timeStartCull = 0;

    var _renderTicket = 0;

    var _renderGroups = [];

    var _frustum = null;
    var _projScreenMatrix = null;

    var _vector3 = new THREE.Vector3();

    var _isUpdateObjectList = true;
    var _dirtyIncrementList = true;

    var _filter = filter;

    this.updateObjectList = function (isUpdate) {
        _isUpdateObjectList = isUpdate;
    };

    this.destroy = function () {

        for (var ii = 0, len = _renderGroups.length; ii < len; ++ii) {
            var group = _renderGroups[ii];
            if (group !== undefined) {
                group.destroy();
            }
        }
    };

    this.restart = function () {

        for (var ii = 0, len = _renderGroups.length; ii < len; ++ii) {
            var group = _renderGroups[ii];
            if (group !== undefined) {
                group.restart();
            }
        }

        _countCullingObject = 0;
        _countScreenCullOff = 0;
        _dirtyIncrementList = true;
        _isIncrementalCullFinish = true;
    };

    this.setFilter = function (filter) {
        // do nothing
        // please remove this method after we remove WebGLRendererByIncrement.setFilterObject()
    };

    function prepareNewFrame() {

        ++_cullTicket;
        if (_cullTicket > 100000) _cullTicket = 0;

        for (var ii = 0, len = _renderGroups.length; ii < len; ++ii) {
            var group = _renderGroups[ii];
            if (group !== undefined) {
                group.prepare();
            }
        }
    }

    function pushRenderItem(object, geometry, material, z) {

        var renderGroup = _renderGroups[object.renderOrder];
        if (renderGroup === undefined) {
            renderGroup = new CLOUD.RenderGroup();
            _renderGroups[object.renderOrder] = renderGroup;
        }

        renderGroup.pushRenderItem(object, geometry, material, z, null);
    }

    function sortRenderList() {

        for (var ii = 0, len = _renderGroups.length; ii < len; ++ii) {
            var group = _renderGroups[ii];
            if (group !== undefined) {
                group.sortRenderList(_isIncrementalCullFinish);
            }
        }
    }

    function projectObject(object, camera) {

        if (object.visible === false || object.alive === false) return true;

        if (object._cullTicket != _cullTicket /*&& (object.channels.mask & camera.channels.mask) !== 0*/) {

                ++_countCullingObject;

                // TODO: incrmental bug fixing
                // if (_countCullingObject % 5000 == 4999) {
                var diff = Date.now() - _timeStartCull;
                if (diff > 30) {
                    return false;
                }

                // }

                object._cullTicket = _cullTicket;

                if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points) {

                    if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {

                        var material = object.material;
                        var geometry = object.geometry;
                        if (material.transparent) {
                            _vector3.setFromMatrixPosition(object.matrixWorld);
                            _vector3.applyMatrix4(_projScreenMatrix);
                            pushRenderItem(object, geometry, material, _vector3.z);
                        } else {
                            pushRenderItem(object, geometry, material, 0);
                        }
                    }
                }
            }

        var children = object.children;
        if (children) {
            for (var i = 0, l = children.length; i < l; i++) {

                if (!projectObject(children[i], camera)) return false;
            }
        }

        return true;
    }

    function projectLights(scene, lights) {

        lights.length = 0;

        var children = scene.children;

        for (var i = 0, l = children.length; i < l; i++) {

            var object = children[i];
            if (object.isLight) {

                lights.push(object);
            }
        }
    }

    function buildObjectList(scene, camera, lights) {

        if (!_isUpdateObjectList) {
            _isIncrementalCullFinish = true;
            return;
        }

        if (_isIncrementalCullFinish) {

            prepareNewFrame();
            projectLights(scene, lights);
        }

        _timeStartCull = Date.now();

        //console.time("projectObject");
        _isIncrementalCullFinish = projectObject(scene, camera);
        //console.timeEnd("projectObject");
        //console.log("screen cull off: " + _screenCullOffCount);
        sortRenderList();
    }

    this.update = function (frustum, projScreenMatrix) {
        _projScreenMatrix = projScreenMatrix;
        _frustum = frustum;
    };

    function updateRenderTicket() {

        if (!_isUpdateObjectList || _dirtyIncrementList) {
            ++_renderTicket;
        }
        //else {
        //    console.log(_renderTicket);
        //}
        if (_renderTicket > 10000) _renderTicket = 0;
    }

    this.render = function (renderer, scene, camera, lights, renderTarget, forceClear, state) {

        updateRenderTicket();

        if (_dirtyIncrementList) {

            CLOUD.Logger.time("build object list");
            buildObjectList(scene, camera, lights);
            CLOUD.Logger.timeEnd("build object list");

            if (!_isIncrementalCullFinish) return false;else {
                forceClear = true;
                _dirtyIncrementList = false;

                //var count = computeRenderableCount();
                //console.log("renderable " + count);
            }

            renderer.setupLights(lights, camera);
            renderer.setRenderTarget(renderTarget);
        }

        CLOUD.Logger.time("increment render object");
        if (renderer.autoClear || forceClear) {
            renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil, _isUpdateObjectList);
        }

        var fog = scene.fog;

        renderer.setRenderTicket(_renderTicket);

        state.setBlending(THREE.NoBlending);

        // TODO: incrmental bug fixing
        //_isIncrementalRenderFinish = true; //

        for (var ii = _renderGroups.length - 1; ii >= 0; --ii) {
            var group = _renderGroups[ii];
            if (group !== undefined) {
                _isIncrementalRenderFinish = group.renderOpaqueObjects(renderer, camera, lights, fog, _isUpdateObjectList);
                if (!_isIncrementalRenderFinish) break;
            }
        }

        if (_isIncrementalRenderFinish) {

            for (var ii = _renderGroups.length - 1; ii >= 0; --ii) {
                var group = _renderGroups[ii];
                if (group !== undefined) {
                    _isIncrementalRenderFinish = group.renderTransparentObjects(renderer, camera, lights, fog);
                    if (!_isIncrementalRenderFinish) break;
                }
            }
        }

        // Ensure depth buffer writing is enabled so it can be cleared on next render
        // state.setDepthTest(true);
        // state.setDepthWrite(true);
        // state.setColorWrite(true);

        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);

        CLOUD.Logger.timeEnd("increment render object");

        return _isIncrementalRenderFinish;
    };

    this.computeSelectionBBox = function () {

        if (_filter._isEmptySelections()) return null;

        _filter._resetBoundingBoxFromSelections();

        for (var ii = _renderGroups.length - 1; ii >= 0; --ii) {
            var group = _renderGroups[ii];
            if (group !== undefined) {
                _filter._calcBoundingBoxFromSelections(group.getOpaqueObjects());
                _filter._calcBoundingBoxFromSelections(group.getTransparentObjects());
            }
        }

        return _filter._getBoundingBoxFromSelections();
    };

    this.computeRenderObjectsBox = function () {
        var box = new THREE.Box3();
        for (var ii = _renderGroups.length - 1; ii >= 0; --ii) {
            var group = _renderGroups[ii];
            if (group !== undefined) {
                var opaqueBox = _filter._getBoundingBoxFromRenderObjects(group.getOpaqueObjects());
                if (!opaqueBox.isEmpty()) {
                    box.expandByPoint(opaqueBox.min);
                    box.expandByPoint(opaqueBox.max);
                }

                var transparentBox = _filter._getBoundingBoxFromRenderObjects(group.getTransparentObjects());
                if (!transparentBox.isEmpty()) {
                    box.expandByPoint(transparentBox.min);
                    box.expandByPoint(transparentBox.max);
                }
            }
        }

        return box;
    };
};
CLOUD.BBoxNode = function (boundingBox, color) {
    "use strict";

    var geometry = new THREE.BufferGeometry();
    geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(72), 3));

    THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({ color: color }));

    if (boundingBox !== undefined) {
        this.updateBBox(boundingBox);
    }
};

CLOUD.BBoxNode.prototype = Object.create(THREE.LineSegments.prototype);
CLOUD.BBoxNode.prototype.constructor = CLOUD.BBoxNode;

CLOUD.BBoxNode.prototype.unload = function () {};

CLOUD.BBoxNode.prototype.updateBBox = function (boundingBox) {
    var min = boundingBox.min;
    var max = boundingBox.max;

    /*
    5____4
    1/___0/|
    | 6__|_7
    2/___3/
    0: max.x, max.y, max.z
    1: min.x, max.y, max.z
    2: min.x, min.y, max.z
    3: max.x, min.y, max.z
    4: max.x, max.y, min.z
    5: min.x, max.y, min.z
    6: min.x, min.y, min.z
    7: max.x, min.y, min.z
    */

    var vertices = this.geometry.attributes.position.array;

    vertices[0] = max.x;vertices[1] = max.y;vertices[2] = max.z;
    vertices[3] = min.x;vertices[4] = max.y;vertices[5] = max.z;

    vertices[6] = min.x;vertices[7] = max.y;vertices[8] = max.z;
    vertices[9] = min.x;vertices[10] = min.y;vertices[11] = max.z;

    vertices[12] = min.x;vertices[13] = min.y;vertices[14] = max.z;
    vertices[15] = max.x;vertices[16] = min.y;vertices[17] = max.z;

    vertices[18] = max.x;vertices[19] = min.y;vertices[20] = max.z;
    vertices[21] = max.x;vertices[22] = max.y;vertices[23] = max.z;

    //

    vertices[24] = max.x;vertices[25] = max.y;vertices[26] = min.z;
    vertices[27] = min.x;vertices[28] = max.y;vertices[29] = min.z;

    vertices[30] = min.x;vertices[31] = max.y;vertices[32] = min.z;
    vertices[33] = min.x;vertices[34] = min.y;vertices[35] = min.z;

    vertices[36] = min.x;vertices[37] = min.y;vertices[38] = min.z;
    vertices[39] = max.x;vertices[40] = min.y;vertices[41] = min.z;

    vertices[42] = max.x;vertices[43] = min.y;vertices[44] = min.z;
    vertices[45] = max.x;vertices[46] = max.y;vertices[47] = min.z;

    //

    vertices[48] = max.x;vertices[49] = max.y;vertices[50] = max.z;
    vertices[51] = max.x;vertices[52] = max.y;vertices[53] = min.z;

    vertices[54] = min.x;vertices[55] = max.y;vertices[56] = max.z;
    vertices[57] = min.x;vertices[58] = max.y;vertices[59] = min.z;

    vertices[60] = min.x;vertices[61] = min.y;vertices[62] = max.z;
    vertices[63] = min.x;vertices[64] = min.y;vertices[65] = min.z;

    vertices[66] = max.x;vertices[67] = min.y;vertices[68] = max.z;
    vertices[69] = max.x;vertices[70] = min.y;vertices[71] = min.z;

    this.geometry.attributes.position.needsUpdate = true;

    this.geometry.computeBoundingBox();
    this.geometry.computeBoundingSphere();
    this.matrixAutoUpdate = false;
};
THREE.CombinedCamera = function (width, height, fov, near, far) {

    THREE.Camera.call(this);

    this.aspect = width / height;
    this.fov = fov;
    this.near = near;
    this.far = far;

    this.left = -width / 2;
    this.right = width / 2;
    this.top = height / 2;
    this.bottom = -height / 2;

    this.cameraOrtho = new THREE.OrthographicCamera(this.left, this.right, this.top, this.bottom, this.near, this.far);
    this.cameraPerspective = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far);

    this.zoom = 1;

    this.toPerspective();
};

THREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.CombinedCamera.prototype.constructor = THREE.CombinedCamera;

THREE.CombinedCamera.prototype.toPerspective = function () {

    this.near = this.cameraPerspective.near;
    this.far = this.cameraPerspective.far;
    this.cameraPerspective.fov = this.fov / this.zoom;
    this.cameraPerspective.updateProjectionMatrix();
    this.projectionMatrix = this.cameraPerspective.projectionMatrix;
    this.isPerspective = true;
};

THREE.CombinedCamera.prototype.toOrthographic = function () {

    // Switches to the Orthographic camera estimating viewport from Perspective

    var fov = this.fov;
    var aspect = this.cameraPerspective.aspect;
    var near = this.cameraPerspective.near;
    var far = this.cameraPerspective.far;

    // The size that we set is the mid plane of the viewing frustum

    var hyperfocus = (near + far) / 2;

    var halfHeight = Math.tan(fov * Math.PI / 180 / 2) * hyperfocus;
    var planeHeight = 2 * halfHeight;
    var planeWidth = planeHeight * aspect;
    var halfWidth = planeWidth / 2;

    halfHeight /= this.zoom;
    halfWidth /= this.zoom;

    this.cameraOrtho.left = -halfWidth;
    this.cameraOrtho.right = halfWidth;
    this.cameraOrtho.top = halfHeight;
    this.cameraOrtho.bottom = -halfHeight;
    this.cameraOrtho.updateProjectionMatrix();

    this.near = this.cameraOrtho.near;
    this.far = this.cameraOrtho.far;
    this.projectionMatrix = this.cameraOrtho.projectionMatrix;

    this.isPerspective = false;
};

THREE.CombinedCamera.prototype.setSize = function (width, height) {

    this.cameraPerspective.aspect = width / height;
    this.left = -width / 2;
    this.right = width / 2;
    this.top = height / 2;
    this.bottom = -height / 2;
    this.aspect = width / height;
};

THREE.CombinedCamera.prototype.setFov = function (fov) {

    this.fov = fov;

    if (this.isPerspective) {

        this.toPerspective();
    } else {

        this.toOrthographic();
    }
};

THREE.CombinedCamera.prototype.setNearFar = function (near, far) {

    if (this.isPerspective) {

        this.cameraPerspective.near = near;
        this.cameraPerspective.far = far;

        this.toPerspective();
    } else {

        this.cameraOrtho.near = near;
        this.cameraOrtho.far = far;

        this.toOrthographic();
    }
};

// For mantaining similar API with PerspectiveCamera

THREE.CombinedCamera.prototype.updateProjectionMatrix = function () {

    if (this.isPerspective) {

        this.toPerspective();
    } else {

        //this.toPerspective();
        this.toOrthographic();
    }
};

/*
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (fullframe) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */
THREE.CombinedCamera.prototype.setLens = function (focalLength, frameHeight) {

    if (frameHeight === undefined) frameHeight = 24;

    var fov = 2 * THREE.Math.radToDeg(Math.atan(frameHeight / (focalLength * 2)));

    this.setFov(fov);

    return fov;
};

THREE.CombinedCamera.prototype.setZoom = function (zoom) {

    this.zoom = zoom;

    if (this.isPerspective) {

        this.toPerspective();
    } else {

        this.toOrthographic();
    }
};

CLOUD.Animation = function () {

    var _scope = this;
    var _object = null;
    var _valuesStart = {};
    var _valuesEnd = {};
    var _duration = 1000;
    var _startTime = null;
    //var _isPlaying = false;
    var _timerId = null;
    var _tolerance = 0.9995;
    var _interpolationFunction = null;

    var _onStartCallbackFired = false;
    var _onStartCallback = null;
    var _onUpdateCallback = null;
    var _onCompleteCallback = null;

    this.from = function (properties) {

        _object = properties;

        // 保存开始值
        for (var field in _object) {
            _valuesStart[field] = _object[field];
        }

        return this;
    };

    this.to = function (properties, duration) {

        if (duration !== undefined) {
            _duration = duration;
        }

        _valuesEnd = properties;
        return this;
    };

    this.onStart = function (callback) {

        _onStartCallback = callback;
        return this;
    };

    this.onUpdate = function (callback) {

        _onUpdateCallback = callback;
        return this;
    };

    this.onComplete = function (callback) {

        _onCompleteCallback = callback;
        return this;
    };

    this.start = function (frameTime) {

        _onStartCallbackFired = false;

        // 连续点击，会生成很多id
        // 先清除之前的id
        if (_timerId) {
            clearInterval(_timerId);
        }

        //_startTime = window.performance.now();
        _startTime = Date.now();

        _interpolationFunction = this.interpolate;

        var animate = function animate() {

            var elapsed;
            var start = _valuesStart;
            var end = _valuesEnd;
            //var time = window.performance.now();
            var time = Date.now();

            if (_onStartCallbackFired === false) {

                if (_onStartCallback !== null) {
                    _onStartCallback.call(_object);
                }

                _onStartCallbackFired = true;
            }

            elapsed = (time - _startTime) / _duration;
            elapsed = elapsed > 1 ? 1 : elapsed;

            _object = _interpolationFunction(start, end, elapsed);

            if (elapsed === 1) {

                // 清除计时器
                clearInterval(_timerId);

                if (_onCompleteCallback !== null) {
                    _onCompleteCallback.call(_object);
                }
            } else {

                if (_onUpdateCallback !== null) {
                    _onUpdateCallback.call(_object, elapsed);
                }
            }
        };

        // 启动计时器
        _timerId = setInterval(animate, frameTime);
    };

    //判断两向量角度是否大于180°，大于180°返回真，否则返回假
    this.isAngleGreaterThanPi = function (start, end, up) {

        // 根据混合积来判断角度
        var dir = new THREE.Vector3();
        dir.crossVectors(start, end);

        var volume = dir.dot(up);

        //dir 与 up 同向 - 小于 180°
        if (volume >= 0) {
            return false;
        }

        return true;
    };

    // 锥形底面圆弧插值
    this.conicInterpolate = function (start, end, interp, percentage, islargeangle) {

        // 场景旋转和相机旋转方向是反的
        var angle = -Math.PI * percentage;

        // 大角度的情况：以小弧度旋转
        if (islargeangle) {
            angle *= -1;
        }

        // 旋转轴
        var axis = new THREE.Vector3();
        axis.addVectors(end, start).normalize();

        // 从 start 开始绕轴 axis 旋转 angle
        var quat = new THREE.Quaternion();
        quat.setFromAxisAngle(axis, angle);

        interp.copy(start);
        interp.applyQuaternion(quat);
    };

    // 球形插值
    this.slerpInterpolate = function (start, end, up, interp, percentage, tolerance, isconic, islargeangle) {
        var unitX = new THREE.Vector3(1, 0, 0);
        var unitZ = new THREE.Vector3(0, 0, 1);
        var middle = new THREE.Vector3(); // 中间量
        var step = 0;
        var cosTheta = start.dot(end);
        // 构造四元数
        var startQuaternion = new THREE.Quaternion(start.x, start.y, start.z, 1).normalize();
        var endQuaternion = new THREE.Quaternion(end.x, end.y, end.z, 1).normalize();
        var midQuaternion = new THREE.Quaternion(0, 0, 0, 1);
        var slerpQuaternion = new THREE.Quaternion(0, 0, 0, 1);

        if (isconic === undefined) {
            isconic = false;
        }

        if (islargeangle === undefined) {
            islargeangle = false;
        }

        // start == end (0度)
        if (tolerance < cosTheta) {
            interp.copy(end);
        } else if (tolerance < Math.abs(cosTheta)) {
            // start == -end (180度)

            //if ( tolerance > Math.abs( start.dot( unitZ )) ) {
            //    //CLOUD.Logger.log("unitZ");
            //    middle.crossVectors(start , unitZ).normalize();
            //} else {
            //    //CLOUD.Logger.log("unitX");
            //    middle.crossVectors(start , unitX).normalize();
            //}

            middle.crossVectors(start, up).normalize();

            // 中间量四元数
            midQuaternion.set(middle.x, middle.y, middle.z, 1).normalize();

            if (percentage < 0.5) {
                step = percentage * 2;
                THREE.Quaternion.slerp(startQuaternion, midQuaternion, slerpQuaternion, step);
                interp.set(slerpQuaternion.x, slerpQuaternion.y, slerpQuaternion.z);
            } else {
                step = (percentage - 0.5) * 2;
                THREE.Quaternion.slerp(midQuaternion, endQuaternion, slerpQuaternion, step);
                interp.set(slerpQuaternion.x, slerpQuaternion.y, slerpQuaternion.z);
            }
        } else {
            // start != abs(end)

            if (isconic) {
                //CLOUD.Logger.log("[slerpInterpolate][isconic]");
                this.conicInterpolate(start, end, interp, percentage, islargeangle);
            } else {
                THREE.Quaternion.slerp(startQuaternion, endQuaternion, slerpQuaternion, percentage);
                interp.set(slerpQuaternion.x, slerpQuaternion.y, slerpQuaternion.z);
            }
        }

        interp.normalize();
    };

    // 线性插值
    this.linearInterpolate = function (start, end, interp, percentage, tolerance) {
        var unitX = new THREE.Vector3(1, 0, 0);
        var unitZ = new THREE.Vector3(0, 0, 1);
        var middle = new THREE.Vector3(); // 中间量
        var step = 0;
        var cosTheta = start.dot(end);

        // start == end (0度)
        if (tolerance < cosTheta) {
            interp.copy(end);
        } else if (tolerance < -cosTheta) {
            // start == -end (180度)

            if (tolerance > Math.abs(start.dot(unitZ))) {
                middle.crossVectors(start, unitZ).normalize();
            } else {
                middle.crossVectors(start, unitX).normalize();
            }

            // 非均匀插值，每段变化角度不一样
            if (percentage < 0.5) {
                step = percentage * 2;
                interp.lerpVectors(start, middle, step);
            } else {
                step = (percentage - 0.5) * 2;
                interp.lerpVectors(middle, end, step);
            }
        } else {
            // start != abs(end)
            interp.lerpVectors(start, end, percentage);
        }

        interp.normalize();
    };

    // 插值处理
    this.interpolate = function (valuesStart, valuesEnd, percentage) {
        var startRightDir = new THREE.Vector3();
        var endRightDir = new THREE.Vector3();

        // 插值结果
        var interpDir = new THREE.Vector3();
        var interpUp = new THREE.Vector3();

        var startDir = valuesStart.animDir;
        var startUp = valuesStart.animUp;
        var endDir = valuesEnd.animDir;
        var endUp = valuesEnd.animUp;

        startRightDir.crossVectors(startDir, startUp);
        endRightDir.crossVectors(endDir, endUp);

        var cosTheta = startRightDir.dot(endRightDir);
        var threshold = _tolerance - 1;

        // 判断方向是否变化，则采用锥形底面圆弧插值
        var dirChange = cosTheta < threshold ? true : false;

        // 判断两向量角度是否大于180
        var isLargeAngle = _scope.isAngleGreaterThanPi(startDir, endDir, startUp);

        // 计算插值量 - dir
        _scope.slerpInterpolate(startDir, endDir, startUp, interpDir, percentage, _tolerance, dirChange, isLargeAngle);

        // 计算插值量 - up
        _scope.linearInterpolate(startUp, endUp, interpUp, percentage, _tolerance);

        return {
            animDir: interpDir,
            animUp: interpUp
        };
    };
};
CLOUD.CameraAnimator = function () {

    var _duration = 500; // 500毫秒
    var _frameTime = 13; // 周期性执行或调用函数之间的时间间隔，以毫秒计
    var _isPlaying = false;
    var _animation = new CLOUD.Animation();

    this.setDuration = function (duration) {
        _duration = duration;
    };

    this.setFrameTime = function (frameTime) {
        _frameTime = frameTime;
    };

    this.setStandardView = function (stdView, viewer, box, margin, callback) {

        _isPlaying = false; // 无动画，将状态置成 false

        var redoRender = function redoRender(viewer, box) {

            // fit all
            var target = viewer.camera.zoomToBBox(box, margin);
            viewer.cameraControl.updateCamera(target);
            viewer.render();

            // 增加回调
            callback && callback();
        };

        var camera = viewer.camera;
        var focal = CLOUD.GlobalData.SceneSize / 2;
        var threshold = 0.9995;

        // 1. 记录动画开始参数
        var startDir = camera.getWorldDirection().clone();
        startDir.normalize();

        var startUp = new THREE.Vector3();
        startUp.copy(camera.realUp || camera.up);
        startUp.normalize();

        // 2. 设置视图模式
        // 场景可能没有加载起来
        // var box = viewer.getScene().getBoundingBox();
        var target = camera.setStandardView(stdView, box);

        // 3. 记录动画结束参数
        var endDir = camera.getWorldDirection().clone();
        endDir.normalize();

        var endUp = new THREE.Vector3();
        endUp.copy(camera.realUp || camera.up);
        endUp.normalize();

        // 开始结束点之间角度
        var cosThetaDir = startDir.dot(endDir);
        var cosThetaUp = startUp.dot(endUp);

        // dir和up都一样, 无动画
        if (threshold < cosThetaDir && threshold < cosThetaUp) {

            // 绘制
            redoRender(viewer, box);

            camera.up.copy(THREE.Object3D.DefaultUp);
        } else {

            _isPlaying = true; // 动画中

            // 启动定时器
            _animation.from({ animDir: startDir, animUp: startUp }).to({
                animDir: endDir,
                animUp: endUp
            }, _duration).onUpdate(function () {
                if (viewer.viewHouse) {
                    viewer.viewHouse.isAnimationFinish = false;
                }

                // 传入更新值,这里的this是 CLOUD.Animation._object
                var interpDir = this.animDir;
                var interpUp = this.animUp;

                viewer.camera.LookAt(target, interpDir, interpUp, focal);

                redoRender(viewer, box);
            }).onComplete(function () {

                if (viewer.viewHouse) {
                    // 处理最后一帧
                    viewer.viewHouse.isAnimationFinish = true; // 标记ViewHouse动画结束
                }

                viewer.camera.LookAt(target, endDir, endUp, focal);

                // 绘制
                redoRender(viewer, box);

                _isPlaying = false; //动画结束
                viewer.camera.up.copy(THREE.Object3D.DefaultUp); // 渲染完成后才可以恢复相机up方向
            }).start(_frameTime);
        }
    };

    this.isPlaying = function () {
        return _isPlaying;
    };
};

/**
 * Created by liuyt-d on 2017/5/17 0017.
 */

CLOUD.PhongLightingMaterial = function (parameters) {

    THREE.ShaderMaterial.call(this);

    this.type = 'PhoneLightingMaterial';

    this.color = new THREE.Color(0xffffff); // diffuse
    this.specular = new THREE.Color(0x111111);
    this.shininess = 30;
    this.emissive = new THREE.Color(0x000000);

    this.defines = {};
    this.uniforms = THREE.UniformsUtils.merge([THREE.UniformsLib["lights"], {
        diffuse: { value: new THREE.Color(0xFF0000) },
        opacity: { value: 1.0 },

        specular: { value: new THREE.Color(0x111111) },
        shininess: { value: 30 },
        emissive: { value: new THREE.Color(0x000000) }
    }]);

    this.vertexShader = ["varying vec3 vViewPosition;", "varying vec3 vNormal;", "void main() {", "   #include <begin_vertex>", "   #include <project_vertex>", "   #include <beginnormal_vertex>", "   #include <defaultnormal_vertex>", "   vNormal = normalize( transformedNormal );", "   vViewPosition = - mvPosition.xyz;", "}"].join("\n");

    this.fragmentShader = ["uniform vec3 diffuse;", "uniform float opacity;", "uniform vec3 specular;", "uniform float shininess;", "uniform vec3 emissive;", "#include <common>", "#include <packing>", "#include <bsdfs>", "#include <lights_pars>", "#include <lights_phong_pars_fragment>", "#include <specularmap_pars_fragment>", "void main() {", "   vec4 diffuseColor = vec4( diffuse, opacity );", "   ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "   vec3 totalEmissiveRadiance = emissive;", "   float specularStrength = 1.0;", "   #include <normal_flip>", "   #include <normal_fragment>", "   #include <lights_phong_fragment>", "   #include <lights_template>", "   vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;", "   gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "   #if defined( TONE_MAPPING )", "       gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );", "   #endif", "   gl_FragColor = linearToOutputTexel( gl_FragColor );", "}"].join("\n");

    this.lights = true; // set to use scene lights

    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    this.defaultAttributeValues = {
        'color': [1, 1, 1],
        'uv': [0, 0],
        'uv2': [0, 0]
    };

    if (parameters !== undefined) {

        if (parameters.attributes !== undefined) {

            console.error('PhoneLightingMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
        }

        this.setValues(parameters);
    }

    this.refreshUniforms();
};

//CLOUD.PhongLightingMaterial.prototype = new THREE.ShaderMaterial;
CLOUD.PhongLightingMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
CLOUD.PhongLightingMaterial.prototype.constructor = CLOUD.PhongLightingMaterial;

CLOUD.PhongLightingMaterial.prototype.isShaderMaterial = true;

CLOUD.PhongLightingMaterial.prototype.copy = function (source) {

    THREE.ShaderMaterial.prototype.copy.call(this, source);

    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.emissive.copy(source.emissive);

    return this;
};

CLOUD.PhongLightingMaterial.prototype.refreshUniforms = function () {
    this.uniforms.diffuse.value.set(this.color);
    this.uniforms.opacity.value = this.opacity;

    this.uniforms.specular.value.set(this.specular);
    this.uniforms.shininess.value = this.shininess;
    this.uniforms.emissive.value.set(this.emissive);
};
/**
 * The object to be held within the Object Pool.
 *
 * @class  CLOUD.MeshEx
 */
CLOUD.MeshEx = function () {

    THREE.Mesh.call(this);

    this.type = 'MeshEx';

    this.matrixAutoUpdate = false; // disable auto update
    this.alive = false; // 是否激活, 默认不激活

    this.geometry = CLOUD.GeomUtil.EmptyGeometry;
    this.material = CLOUD.MaterialUtil.DefaultMaterial;
};

CLOUD.MeshEx.prototype = Object.create(THREE.Mesh.prototype);
CLOUD.MeshEx.prototype.constructor = CLOUD.MeshEx;

/**
 * Sets an object not in use to default values
 */
CLOUD.MeshEx.prototype.init = function (parameters) {

    if (parameters && parameters.parent) {
        parameters.parent.add(this);
    }
};

/**
 * destroy the object
 */
CLOUD.MeshEx.prototype.destroy = function () {

    if (this.parent) {
        this.parent.remove(this);
    }

    if (this.userData) {
        this.userData = null;
    }

    this.geometry = null;
    this.material = null;
};

/**
 * Spawn an object
 */
CLOUD.MeshEx.prototype.spawn = function (parameters) {

    if (parameters.userId !== undefined) {
        this.name = parameters.userId;
    } else if (parameters.nodeId !== undefined) {
        this.name = parameters.nodeId;
    }

    if (parameters.geometry) {
        this.geometry = parameters.geometry;
    }

    if (parameters.material) {
        this.material = parameters.material;
    }

    if (parameters.matrix) {
        this.matrix.copy(parameters.matrix);
        this.updateMatrixWorld(true); //  this.matrixAutoUpdate = false;需要强制更新
    } else {
        this.matrix.identity();
        this.updateMatrixWorld(true); //  this.matrixAutoUpdate = false;需要强制更新
    }

    if (parameters.databagId) {
        this.databagId = parameters.databagId;
    } else {
        this.databagId = "";
    }

    if (parameters.userData) {
        this.userData = parameters.userData;
    } else {
        if (this.userData) {
            this.userData = null;
        }
    }

    if (parameters.renderOrder) {
        this.renderOrder = parameters.renderOrder;
    }

    this.alive = true;

    // 适配Three.js
    this.frustumCulled = false;
    this.material.visible = true;
};

/**
 * Resets the object values to default
 */
CLOUD.MeshEx.prototype.clear = function () {

    this.geometry = CLOUD.GeomUtil.EmptyGeometry;
    this.material = CLOUD.MaterialUtil.DefaultMaterial;
    this.alive = false;
    this.visible = true; // 每次重置为true，以防止隐藏过构件
    // 适配Three.js
    this.frustumCulled = true;
    this.material.visible = false;
};

/**
 * Intersect the mesh boundbox with ray, return the near distance from
 * ray to bounding box.
 * If not intersect, return -1.
 */
CLOUD.MeshEx.prototype.intersectBoxWithDistance = function () {
    var bbox = new THREE.Box3();

    return function (raycaster) {
        var geometry = this.geometry;
        var material = this.material;
        var matrixWorld = this.matrixWorld;

        if (material === undefined) return -1;

        // Checking boundingSphere distance to ray
        if (geometry.boundingBox === null) geometry.computeBoundingBox();

        bbox.copy(geometry.boundingBox);
        bbox.applyMatrix4(matrixWorld);

        return raycaster.ray.intersectBoxWithDistance(bbox);
    };
}();

CLOUD.PointsEx = function (geometry, material) {

    THREE.Points.call(this, geometry, material);

    this.radius = 1;
};

CLOUD.PointsEx.prototype = Object.create(THREE.Points.prototype);
CLOUD.PointsEx.prototype.constructor = CLOUD.PointsEx;

CLOUD.PointsEx.prototype.raycast = function () {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();

    return function raycast(raycaster, intersects) {

        var object = this;
        var geometry = this.geometry;
        var matrixWorld = this.matrixWorld;
        var threshold = this.radius; // 修改1： 使用点的大小

        // Checking boundingSphere distance to ray

        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

        sphere.copy(geometry.boundingSphere);
        sphere.applyMatrix4(matrixWorld);
        sphere.radius += threshold;

        if (raycaster.ray.intersectsSphere(sphere) === false) return;

        inverseMatrix.getInverse(matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

        var scale = this.getWorldScale(); // 修改2: 获得世界系中的缩放比例
        var localThreshold = threshold / ((scale.x + scale.y + scale.z) / 3);
        var localThresholdSq = localThreshold * localThreshold;
        var position = new THREE.Vector3();

        function testPoint(point, index) {

            var rayPointDistanceSq = ray.distanceSqToPoint(point);

            if (rayPointDistanceSq < localThresholdSq) {

                var intersectPoint = ray.closestPointToPoint(point);
                intersectPoint.applyMatrix4(matrixWorld);

                var distance = raycaster.ray.origin.distanceTo(intersectPoint);

                if (distance < raycaster.near || distance > raycaster.far) return;

                intersects.push({

                    distance: distance,
                    distanceToRay: Math.sqrt(rayPointDistanceSq),
                    point: intersectPoint.clone(),
                    index: index,
                    face: null,
                    object: object

                });
            }
        }

        if (geometry.isBufferGeometry) {

            var index = geometry.index;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;

            if (index !== null) {

                var indices = index.array;

                for (var i = 0, il = indices.length; i < il; i++) {

                    var a = indices[i];

                    position.fromArray(positions, a * 3);

                    testPoint(position, a);
                }
            } else {

                for (var i = 0, l = positions.length / 3; i < l; i++) {

                    position.fromArray(positions, i * 3);

                    testPoint(position, i);
                }
            }
        } else {

            var vertices = geometry.vertices;

            for (var i = 0, l = vertices.length; i < l; i++) {

                testPoint(vertices[i], i);
            }
        }
    };
}();

/**
 * 对象池中的对象类型
 *
 * @class  CLOUD.MaterialEx
 */
CLOUD.MaterialEx = function () {

    this.materialDefaultParams = { color: 0xdddddd, opacity: 0.5, transparent: true, side: THREE.DoubleSide };
    this.material = CLOUD.MaterialUtil.createPhongMaterial(this.materialDefaultParams);
};

/**
 * 卸载对象资源
 *
 */
CLOUD.MaterialEx.prototype.destroy = function () {
    this.material = null;
};

/**
 * 重置颜色
 *
 */
CLOUD.MaterialEx.prototype.resetColor = function () {

    this.material.color.setHex(this.materialDefaultParams.color);
    // this.material.needsUpdate = true;
};

/**
 * 重置透明度
 *
 */
CLOUD.MaterialEx.prototype.resetOpacity = function () {

    this.material.opacity = this.materialDefaultParams.opacity;
    // this.material.needsUpdate = true;
};

/**
 * 重置
 *
 */
CLOUD.MaterialEx.prototype.reset = function () {

    this.material.color.setHex(this.materialDefaultParams.color);
    this.material.opacity = this.materialDefaultParams.opacity;
    this.material.transparent = this.materialDefaultParams.transparent;
    this.material.side = this.materialDefaultParams.side;
    this.material.needsUpdate = true;
};

/**
 * Custom Pool object. Holds objects to be managed to prevent
 * garbage collection.
 *
 * @class  CLOUD.ObjectPool
 */
CLOUD.ObjectPool = function (classType, size) {

    this.cls = classType;
    this.size = size || 1000; // Max objects allowed in the pool
    this._pool = [];
    this.counter = 0;
};

/**
 * Populates the pool array with objects
 */
CLOUD.ObjectPool.prototype.init = function (parameters) {

    for (var i = 0, len = this.size; i < len; ++i) {

        // Initialize the objects
        var obj = new this.cls();
        obj.init(parameters);
        this._pool[i] = obj;
    }
};

CLOUD.ObjectPool.prototype.resize = function (size, parameters) {

    this.size = size || 1000;
    this.collect();
    this.init(parameters);
};

/**
 * Grabs the last item in the list and initializes it and
 * pushes it to the front of the array.
 */
CLOUD.ObjectPool.prototype.get = function (parameters) {

    if (this.counter >= this.size) {
        // CLOUD.Logger.log("the pool is full");
        return -1;
    }

    var object = this._pool[this.counter];
    object.spawn(parameters);

    ++this.counter;

    return this.counter - 1;
};

CLOUD.ObjectPool.prototype.clear = function () {

    for (var i = 0, len = this.size; i < len; ++i) {
        this._pool[i].clear();
    }

    this.counter = 0;
};

CLOUD.ObjectPool.prototype.destroy = function () {

    // for (var i = 0, len = this.size; i < len; ++i) {
    //     this._pool[i].destroy();
    // }

    this.collect();
};

/**
 * Allow collection of all objects in the pool
 */
CLOUD.ObjectPool.prototype.collect = function () {

    // just forget the list and let the garbage collector reap them
    this._pool = []; // fresh and new
    this.counter = 0;
};

CLOUD.ObjectPool.prototype.getObjects = function () {
    return this._pool;
};

// --------------------------------------------------------- //
/**
 * 可扩容对象池
 *
 * @class  CLOUD.ExpandableObjectPool
 */
CLOUD.ExpandableObjectPool = function () {

    this.size = 0;
    this.counter = 0;
    this.expansion = 1;
    this._pool = null;
};

/**
 * 初始化对象池
 *
 * @param {Object} classType - 对象类型
 * @param {Number} initialSize - 初始大小
 */
CLOUD.ExpandableObjectPool.prototype.init = function (classType, initialSize) {

    this.classType = classType;
    this._pool = [];

    this._expand(initialSize);
};

/**
 * 构造一组新对象来扩展对象池
 *
 * @param {Number} howMany - 添加的新对象的数量
 */
CLOUD.ExpandableObjectPool.prototype._expand = function (howMany) {

    this.size += howMany;

    for (var i = 0; i < howMany; i++) {
        this._pool.push(new this.classType());
    }
};

/**
 * 从对象池中取出可以使用的对象
 *
 * @return {Object} 对象池中的一个对象
 */
CLOUD.ExpandableObjectPool.prototype.acquire = function () {

    if (this.counter >= this.size) {

        // 扩展空间(扩展20%，最小1)
        this.expansion = Math.round(this.expansion * 1.2) + 1;
        this._expand(this.expansion);

        console.log("_expand");
    }

    return this._pool[this.counter++];
};

/**
 * 清除对象池状态
 *
 */
CLOUD.ExpandableObjectPool.prototype.clear = function () {

    this.counter = 0;
};

/**
 * 卸载对象池资源
 *
 */
CLOUD.ExpandableObjectPool.prototype.destroy = function () {

    for (var i = 0, len = this.size; i < len; ++i) {
        this._pool[i].destroy();
    }

    this.counter = 0;
    this.size = 0;
    this.expansion = 1;
    this._pool = null;
};

/**
 * 获得对象池中的所有对象
 *
 */
CLOUD.ExpandableObjectPool.prototype.getObjects = function () {
    return this._pool;
};

var lights_fillFace_template = ["GeometricContext geometry;", "geometry.position = - vViewPosition;",
//change fillFace's normal
"#if NUM_CLIPPING_PLANES == 1", "	if (gl_FrontFacing) geometry.normal = normal;", "	else if (fillFaceClipDistance < 0.0) geometry.normal = -clippingPlanes[0].xyz;", "	else geometry.normal = -normal;", "#else", "	geometry.normal = normal;", "#endif", "geometry.viewDir = normalize( vViewPosition );", "IncidentLight directLight;", "#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )", "	PointLight pointLight;", "	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {", "		pointLight = pointLights[ i ];", "		getPointDirectLightIrradiance( pointLight, geometry, directLight );", "		#ifdef USE_SHADOWMAP", "		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;", "		#endif", "		RE_Direct( directLight, geometry, material, reflectedLight );", "	}", "#endif", "#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )", "	SpotLight spotLight;", "	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {", "		spotLight = spotLights[ i ];", "		getSpotDirectLightIrradiance( spotLight, geometry, directLight );", "		#ifdef USE_SHADOWMAP", "		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;", "		#endif", "	RE_Direct( directLight, geometry, material, reflectedLight );", "	}", "#endif", "#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )", "	DirectionalLight directionalLight;", "	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {", "		directionalLight = directionalLights[ i ];", "		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );", "		#ifdef USE_SHADOWMAP", "		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;", "		#endif", "		RE_Direct( directLight, geometry, material, reflectedLight );", "	}", "#endif", "#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )", "	RectAreaLight rectAreaLight;", "	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {", "		rectAreaLight = rectAreaLights[ i ];", "		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );", "	}", "#endif", "#if defined( RE_IndirectDiffuse )", "	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );", "	#ifdef USE_LIGHTMAP", "		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;", "		#ifndef PHYSICALLY_CORRECT_LIGHTS", "			lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage", "		#endif", "		irradiance += lightMapIrradiance;", "	#endif", "	#if ( NUM_HEMI_LIGHTS > 0 )", "		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {", "			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );", "		}", "	#endif", "	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )",

// TODO, replace 8 with the real maxMIPLevel
"		irradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, 8 );", "	#endif", "	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );", "#endif", "#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )",

// TODO, replace 8 with the real maxMIPLevel
"	vec3 radiance = getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_BlinnShininessExponent( material ), 8 );", "	#ifndef STANDARD", "		vec3 clearCoatRadiance = getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );", "	#else", "		vec3 clearCoatRadiance = vec3( 0.0 );", "	#endif", "	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );", "#endif"].join('\n');
var fillFaceFragment = ["#define PHONG", "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform vec3 specular;", "uniform float shininess;", "uniform float opacity;", "#include <common>", "#include <packing>", "#include <dithering_pars_fragment>", "#include <color_pars_fragment>", "#include <uv_pars_fragment>", "#include <uv2_pars_fragment>", "#include <map_pars_fragment>", "#include <alphamap_pars_fragment>", "#include <aomap_pars_fragment>", "#include <lightmap_pars_fragment>", "#include <emissivemap_pars_fragment>", "#include <envmap_pars_fragment>", "#include <gradientmap_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars>", "#include <lights_phong_pars_fragment>", "#include <shadowmap_pars_fragment>", "#include <bumpmap_pars_fragment>", "#include <normalmap_pars_fragment>", "#include <specularmap_pars_fragment>", "#include <logdepthbuf_pars_fragment>", "#include <clipping_planes_pars_fragment>", "void main() {", "	#include <clipping_planes_fragment>", "	vec4 diffuseColor = vec4( diffuse, opacity );", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "	vec3 totalEmissiveRadiance = emissive;", "	#include <logdepthbuf_fragment>", "	#include <map_fragment>", "	#include <color_fragment>", "	#include <alphamap_fragment>", "	#include <alphatest_fragment>", "	#include <specularmap_fragment>", "	#include <normal_flip>", "	#include <normal_fragment>", "	#include <emissivemap_fragment>", "   float fillFaceClipDistance = 0.0;", "   #if NUM_CLIPPING_PLANES == 1", "       vec4 plane = clippingPlanes[ 0 ];", "	    fillFaceClipDistance = dot( vViewPosition, plane.xyz ) - plane.w;", "   #endif",

// accumulation
"	#include <lights_phong_fragment>", "	#include <lights_fillFace_template>",

// modulation
"	#include <aomap_fragment>", "	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;", "	#include <envmap_fragment>", "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "	#include <tonemapping_fragment>", "	#include <encodings_fragment>", "	#include <fog_fragment>", "	#include <premultiplied_alpha_fragment>", "	#include <dithering_fragment>", "}"].join('\n');
THREE.ShaderChunk["lights_fillFace_template"] = lights_fillFace_template;
THREE.ShaderChunk["fillFaceFragment"] = fillFaceFragment;

THREE.ShaderLib["fillFacePhong"] = {
    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.bumpmap, THREE.UniformsLib.normalmap, THREE.UniformsLib.displacementmap, THREE.UniformsLib.gradientmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, {
        emissive: { value: new THREE.Color(0x000000) },
        specular: { value: new THREE.Color(0x111111) },
        shininess: { value: 30 }
    }]),

    vertexShader: THREE.ShaderChunk.meshphong_vert,
    fragmentShader: THREE.ShaderChunk.fillFaceFragment
};

CLOUD.Marker3D = function (viewer, highPriority) {

    var _viewer = viewer;
    var _scene = viewer.getScene();
    var _group = new CLOUD.Group();
    _group.tag = "Marker3D";
    _group.matrixAutoUpdate = false;

    var _groupParent;

    if (highPriority) {
        _groupParent = _scene.highPriorityGroup;
    } else {
        _groupParent = _scene;
    }

    _groupParent.add(_group);
    // 添加到pick group
    _scene.addToPickGroups(_group);

    var _isHidden = false;

    var _markersGroup = {};
    var _textures = {};

    var _defaultSize = 32;
    var _defaultColor = 0x857980; // HSL(0.90, 0.05, 0.5)

    var _textureLoader = new THREE.TextureLoader();
    _textureLoader.setCrossOrigin("anonymous");

    // var _loadTextureCount = 0;
    // var _maxLoadTextureCount = 0;

    // function onTextureLoaded() {
    //
    //     if (_loadTextureCount > _maxLoadTextureCount) {
    //         _loadTextureCount = 0;
    //         _maxLoadTextureCount = 0;
    //         _viewer.render();
    //     }
    // }

    function loadTexture(path) {

        // if (_textures[path] === undefined) {
        //
        //     _textures[path] = _textureLoader.load(path, function () {
        //         _loadTextureCount++;
        //         onTextureLoaded();
        //     });
        // } else {
        //     _loadTextureCount++;
        // }

        if (_textures[path] === undefined) {
            _textures[path] = _textureLoader.load(path);
        }
    }

    function unloadTexture() {

        for (var path in _textures) {

            if (_textures.hasOwnProperty(path)) {
                delete _textures[path];
            }
        }
    }

    /**
     * 添加一组Marker
     *
     * @param {Array} items - marker数组  item = {position: {x: xxx, y : xxx, z : xxx}, size: xxx, iconUrl:xxx, tooltip:xxx}}
     */
    this.add = function (items) {

        var texturePaths = [];
        var i, len;

        if (items && items instanceof Array) {

            for (i = 0, len = items.length; i < len; ++i) {

                var item = items[i];

                var newItem = {
                    id: item.id ? item.id : THREE.Math.generateUUID(),
                    position: { x: item.position.x, y: item.position.y, z: item.position.z },
                    size: item.size ? item.size : _defaultSize,
                    iconUrl: item.iconUrl ? item.iconUrl : null,
                    tooltip: item.tooltip
                };

                var key = "";

                if (newItem.iconUrl) {
                    key = newItem.iconUrl;
                    texturePaths.push(newItem.iconUrl);
                } else {
                    key = _defaultColor;
                }

                key += "_";
                key += newItem.size;

                if (_markersGroup[key] === undefined) {
                    _markersGroup[key] = [];
                }

                _markersGroup[key].push(newItem);
            }
        }

        // _maxLoadTextureCount = texturePaths.length;

        for (i = 0, len = texturePaths.length; i < len; ++i) {

            loadTexture(texturePaths[i]);
        }
    };

    /**
     * 移除Marker
     *
     * @param {Object} item - marker对象  item = {position: {x: xxx, y : xxx, z : xxx}, size: xxx, iconUrl:xxx, tooltip:xxx}}
     */
    this.remove = function (item) {

        if (!item) {
            return;
        }

        var key = item.iconUrl ? item.iconUrl + "_" + item.size : item.color + "_" + item.size;

        if (_markersGroup[key] === undefined) {
            return;
        }

        var markers = _markersGroup[key];

        for (var i = 0, len = markers.length; i < len; ++i) {

            if (markers[i].id === item.id) {

                markers.splice(i, 1);

                return;
            }
        }
    };

    /**
     * 根据Id移除Marker
     *
     * @param {String} id - marker id
     */
    this.removeById = function (id) {

        for (var key in _markersGroup) {

            if (_markersGroup.hasOwnProperty(key)) {

                var markers = _markersGroup[key];

                for (var i = 0, len = markers.length; i < len; ++i) {

                    if (markers[i].id === id) {

                        markers.splice(i, 1);

                        return;
                    }
                }
            }
        }
    };

    /**
     * 根据Id获取Marker
     *
     * @param {String} id - marker id
     */
    this.getItemById = function (id) {

        for (var key in _markersGroup) {

            if (_markersGroup.hasOwnProperty(key)) {

                var markers = _markersGroup[key];

                for (var i = 0, len = markers.length; i < len; ++i) {

                    var marker = markers[i];

                    if (marker.id === id) {

                        return {
                            id: marker.id,
                            position: { x: marker.position.x, y: marker.position.y, z: marker.position.z },
                            size: marker.size,
                            iconUrl: marker.iconUrl,
                            tooltip: marker.tooltip
                        };
                    }
                }
            }
        }

        return null;
    };

    /**
     * 获得所有的Marker
     *
     * @returns {Array} marker数组  item = {position: {x: xxx, y : xxx, z : xxx}, size: xxx, iconUrl:xxx, tooltip:xxx}}
     */
    this.getItems = function () {

        var items = [];

        for (var key in _markersGroup) {

            if (_markersGroup.hasOwnProperty(key)) {

                var markers = _markersGroup[key];

                for (var i = 0, len = markers.length; i < len; ++i) {

                    var marker = markers[i];

                    items.push({
                        id: marker.id,
                        position: { x: marker.position.x, y: marker.position.y, z: marker.position.z },
                        size: marker.size,
                        iconUrl: marker.iconUrl,
                        tooltip: marker.tooltip
                    });
                }
            }
        }

        if (items.length > 0) {
            return items;
        }

        return null;
    };

    /**
     * 清除所有的Marker
     *
     */
    this.clear = function () {

        _group.children.length = 0;

        unloadTexture();

        for (var key in _markersGroup) {

            if (_markersGroup.hasOwnProperty(key)) {

                delete _markersGroup[key];
            }
        }
    };

    /**
     * 激活Marker
     *
     */
    this.activate = function () {

        this.clear();

        if (_group.parent !== _groupParent) {

            _scene.addToPickGroups(_group);
            _groupParent.add(_group);
        }
    };

    // 禁用Marker
    this.deactivate = function () {

        this.clear();

        if (_group.parent === _groupParent) {

            _scene.removeFromPickGroups(_group);
            _groupParent.remove(_group);
        }
    };

    /**
     * 显示Marker
     *
     */
    this.show = function () {

        _group.pickEnabled = true;
        _isHidden = false;
        this.update();
    };

    /**
     * 隐藏marker
     *
     */
    this.hide = function () {

        _group.pickEnabled = false;
        _isHidden = true;
        this.update();
    };

    /**
     * 加载一组Marker
     *
     * @param {Array} items - marker数组  item = {position: {x: xxx, y : xxx, z : xxx}, size: xxx, iconUrl:xxx, tooltip:xxx}}
     */
    this.load = function (items) {

        this.clear();
        this.add(items);
        this.update();
    };

    /**
     * 更新渲染对象
     *
     */
    this.update = function () {

        _group.matrixWorld.copy(_scene.getMatrixGlobal());
        _group.children.length = 0;

        if (_isHidden) {
            return;
        }

        for (var key in _markersGroup) {

            if (_markersGroup.hasOwnProperty(key)) {

                var markers = _markersGroup[key];
                var len = markers.length;

                if (len < 1) {
                    continue;
                }

                // 路径中可能存在 "_",使用split可能有问题
                // var segments = key.split("_");
                var idx = key.lastIndexOf("_");
                var sprite = _textures[key.substring(0, idx)];
                var size = parseInt(key.substring(idx + 1));

                var geometry = new THREE.Geometry();

                for (var i = 0; i < len; ++i) {

                    // if (_viewer.insideCamera(markers[i].position)) {
                    //     var vertex = new THREE.Vector3(markers[i].position.x, markers[i].position.y, markers[i].position.z);
                    //     geometry.vertices.push(vertex);
                    // }

                    var vertex = new THREE.Vector3(markers[i].position.x, markers[i].position.y, markers[i].position.z);
                    geometry.vertices.push(vertex);
                }

                var material = new THREE.PointsMaterial({
                    size: size,
                    sizeAttenuation: false,
                    map: sprite,
                    // blending: THREE.AdditiveBlending,
                    depthTest: true,
                    transparent: true
                });

                material.color.setHex(_defaultColor);

                var particles = new CLOUD.PointsEx(geometry, material);
                particles.name = key;
                particles.radius = size; //0.707 * size;//对角线长度一半;

                _group.add(particles);
                particles.matrixAutoUpdate = false;
                particles.updateMatrixWorld(true);
            }
        }
    };

    /**
     * 根据key和index获取Marker
     *
     * @param {String} key - marker组标识
     * @param {String} idx - marker组索引
     */
    this.getItemByKeyAndIdx = function (key, idx) {

        if (_markersGroup.hasOwnProperty(key)) {

            var marker = _markersGroup[key][idx];

            if (marker) {

                return {
                    id: marker.id,
                    position: { x: marker.position.x, y: marker.position.y, z: marker.position.z },
                    size: marker.size,
                    iconUrl: marker.iconUrl,
                    tooltip: marker.tooltip
                };
            }
        }

        return null;
    };

    /**
     * 根据选中对象获取Marker
     *
     * @param {Object} intersect - 选中对象
     */
    this.getItemByPick = function (intersect) {

        var key = intersect.selectedObjectId;
        var idx = intersect.index;

        return this.getItemByKeyAndIdx(key, idx);
    };
};
CLOUD.SceneStateHelper = function (modelManager, filter) {
    // Currently, we still use FilterManager to manage the selection object ids and hover state
    // TODO: We should manage the object ids here
    //this.selectionList = {};

    // TODO: manage hove state here
    //this.hoverId = undefined;
    this.modelManager = modelManager;
    this.filter = filter;
};

// the object Id may be not unique when there are multiple models
//
CLOUD.SceneStateHelper.prototype = {

    constructor: CLOUD.SceneStateHelper,

    _checkSelectionChange: function _checkSelectionChange(oldSelList) {
        var newSelList = this.filter._getSelectedIds();

        var selChanged = oldSelList.length !== newSelList.length;

        if (!selChanged) {
            oldSelList.sort();
            newSelList.sort();
            for (var i = 0; i < oldSelList.length; i++) {
                if (oldSelList[i] !== newSelList[i]) {
                    selChanged = true;
                    break;
                }
            }
        }

        if (selChanged) {
            this.modelManager.dispatchEvent({
                type: CLOUD.EVENTS.ON_SELECTION_CHANGED,
                selectionList: newSelList
            });
        }
    },

    clearSelection: function clearSelection() {
        var oldSelList = this.filter._getSelectedIds();

        this.filter.clearIdList(CLOUD.EnumIdBasedType.SELECTED);

        if (oldSelList.length > 0) {
            this.modelManager.dispatchEvent({
                type: CLOUD.EVENTS.ON_SELECTION_CHANGED,
                selectionList: []
            });
        }
    },

    // check if there is any selection object changed,
    // dispatch event only when there is selection changed
    addSelection: function addSelection(selList) {
        var oldSelList = this.filter._getSelectedIds();

        this.filter.addToIdList(CLOUD.EnumIdBasedType.SELECTED, selList);

        this._checkSelectionChange(oldSelList);
    },

    setSelection: function setSelection(selList) {
        var oldSelList = this.filter._getSelectedIds();

        this.filter.setIdList(CLOUD.EnumIdBasedType.SELECTED, selList);

        this._checkSelectionChange(oldSelList);
    },

    removeSelection: function removeSelection(selList) {
        var oldSelList = this.filter._getSelectedIds();

        this.filter.removeFromIdList(CLOUD.EnumIdBasedType.SELECTED, selList);

        this._checkSelectionChange(oldSelList);
    },

    getSelection: function getSelection() {
        return this.filter._getSelectedIds();
    }

};

CLOUD.MaterialSelector = function () {

    "use strict";

    var _materialAttrs = [{ name: 'scene', param: { name: 'scene', color: 0x888888, opacity: 0.4, transparent: true, side: THREE.DoubleSide } }, { name: 'darkRed', param: { name: 'darkRed', color: 0xA02828, opacity: 1, transparent: false, side: THREE.DoubleSide } }, { name: 'lightBlue', param: { name: 'lightBlue', color: 0x1377C0, opacity: 1, transparent: false, side: THREE.DoubleSide } }, { name: 'black', param: { name: 'black', color: 0x0, opacity: 0.3, transparent: true, side: THREE.DoubleSide } }, { name: 'add', param: { name: 'add', color: 0x00FF00, opacity: 1, transparent: true, side: THREE.DoubleSide } }, { name: 'delete', param: { name: 'delete', color: 0xFF0000, opacity: 0.5, transparent: true, side: THREE.DoubleSide } }, { name: 'beforeEdit', param: { name: 'beforeEdit', color: 0xFABD05, opacity: 0.5, transparent: true, side: THREE.DoubleSide } }, { name: 'afterEdit', param: { name: 'afterEdit', color: 0xFABD05, opacity: 1, transparent: true, side: THREE.DoubleSide } }];

    // 内置材质库
    var _materials = {};
    _materials.selection = CLOUD.MaterialUtil.createHighlightMaterial();
    _materials.selection.name = "selection";

    for (var i = 0, len = _materialAttrs.length; i < len; ++i) {
        var attr = _materialAttrs[i];
        var name = attr.name;
        var param = attr.param;
        _materials[name] = CLOUD.MaterialUtil.createPhongMaterial(param);
    }

    _materials.red = _materials.delete;
    _materials.green = _materials.add;
    _materials.yellow = _materials.beforeEdit;
    _materials.blue = _materials.selection;

    var _hoverMaterialDefaultParams = { color: 0xdddddd, opacity: 0.9, transparent: true, side: THREE.DoubleSide };
    var _hoverMaterial = CLOUD.MaterialUtil.createPhongMaterial(_hoverMaterialDefaultParams);
    _hoverMaterial.name = "hover";

    var _isolateMaterialDefaultParams = { color: 0x888888, opacity: 0.2, transparent: true, side: THREE.DoubleSide };
    var _isolateMaterial = CLOUD.MaterialUtil.createPhongMaterial(_isolateMaterialDefaultParams);
    _isolateMaterial.name = "isolate";

    /**
     *  获得缺省材质名
     *
     * @return {Object} 材质
     */
    this.getDefaultMaterialName = function () {
        return 'lightBlue';
    };

    /**
     *  获得缺省材质名
     *
     * @param {String} name - 材质名称
     * @return {Object} 材质
     */
    this.get = function (name) {
        return _materials[name];
    };

    /**
     *  获得所有材质
     *
     * @return {Object} 材质
     */
    this.getAll = function () {
        return _materials;
    };

    /**
     * 增加新材质
     *
     * @param {Object} color - 十六进制颜色 + 透明度 ({color: 0x123456, opacity: 0.1})
     * @return {String} 材质标识名
     */
    this.add = function (color) {

        var name, material;
        var params = {};

        if (color && color.color) {

            params.color = color.color;
            params.side = THREE.DoubleSide;

            if (color.opacity) {

                params.opacity = color.opacity;
                params.transparent = true;
                name = color.color + '_' + color.opacity;
            } else {
                name = color.color;
            }
        } else {
            name = color + '';
        }

        material = _materials[name];

        if (!material) {
            params.name = name;
            material = CLOUD.MaterialUtil.createPhongMaterial(params);
            _materials[name] = material;
        }

        return name;
    };

    /**
     * 移除新材质
     *
     * @param {Object} color - 十六进制颜色 + 透明度 ({color: 0x123456, opacity: 0.1})
     */
    this.remove = function (color) {

        var name, material;

        if (color.color) {

            if (color.opacity) {
                name = color.color + '_' + color.opacity;
            } else {
                name = color.color;
            }
        } else {
            name = color + '';
        }

        material = _materials[name];

        if (material) {
            delete _materials[name];
        }
    };

    /**
     * 是否存在材质
     *
     * @param {string} name - 材质名称
     * @return {Boolean} true - 存在， 否则 不存在
     */
    this.has = function (name) {

        return _materials[name] ? true : false;
    };

    /**
     * 根据颜色获得材质名
     *
     * @param {Object} color - 十六进制颜色 + 透明度 ({color: 0x123456, opacity: 0.1})
     * @return {string} 材质名称
     */
    this.getMaterialNameByColor = function (color) {

        var name, material;

        if (color.color) {

            if (color.opacity) {
                name = color.color + '_' + color.opacity;
            } else {
                name = color.color;
            }
        } else {
            name = color + '';
        }

        material = _materials[name];

        if (!material) {
            return this.add(color);
        }

        return name;
    };

    /**
     *  设置隔离构件材质
     *
     * @param {Object} params - 材质参数({color: 0x888888, opacity: 0.5, transparent: true, side: THREE.DoubleSide})
     */
    this.setIsolateMaterial = function (params) {

        if (params.color !== undefined) {
            _isolateMaterial.color.setHex(params.color);
        } else {
            _isolateMaterial.color.setHex(_isolateMaterialDefaultParams.color);
        }

        if (params.opacity !== undefined) {
            _isolateMaterial.opacity = params.opacity;
        } else {
            _isolateMaterial.opacity = _isolateMaterialDefaultParams.opacity;
        }

        if (params.transparent !== undefined) {
            _isolateMaterial.transparent = params.transparent;
        } else {
            _isolateMaterial.transparent = _isolateMaterialDefaultParams.transparent;
        }

        if (params.side !== undefined) {
            _isolateMaterial.side = params.side;
        } else {
            _isolateMaterial.side = _isolateMaterialDefaultParams.side;
        }

        _isolateMaterial.needsUpdate = true;
    };

    /**
     *  获得隔离构件材质
     *
     * @return {Object} 材质
     */
    this.getIsolateMaterial = function () {

        return _isolateMaterial;
    };

    /**
     *  重置隔离构件材质
     *
     */
    this.resetIsolateMaterial = function () {

        _isolateMaterial.color.setHex(_isolateMaterialDefaultParams.color);
        _isolateMaterial.opacity = _isolateMaterialDefaultParams.opacity;
        _isolateMaterial.transparent = _isolateMaterialDefaultParams.transparent;
        _isolateMaterial.side = _isolateMaterialDefaultParams.side;
        _isolateMaterial.needsUpdate = true;
    };

    /**
     *  设置hover构件材质
     *
     * @param {Object} params - 材质参数({color: 0x888888, opacity: 0.2, transparent: true, side: THREE.DoubleSide})
     */
    this.setHoverMaterial = function (params) {

        if (params.color !== undefined) {
            _hoverMaterial.color.setHex(params.color);
        } else {
            _hoverMaterial.color.setHex(_hoverMaterialDefaultParams.color);
        }

        if (params.opacity !== undefined) {
            _hoverMaterial.opacity = params.opacity;
        } else {
            _hoverMaterial.opacity = _hoverMaterialDefaultParams.opacity;
        }

        if (params.transparent !== undefined) {
            _hoverMaterial.transparent = params.transparent;
        } else {
            _hoverMaterial.transparent = _hoverMaterialDefaultParams.transparent;
        }

        if (params.side !== undefined) {
            _hoverMaterial.side = params.side;
        } else {
            _hoverMaterial.side = _hoverMaterialDefaultParams.side;
        }

        _hoverMaterial.needsUpdate = true;
    };

    /**
     *  获得Hover构件材质
     *
     * @return {Object} 材质
     */
    this.getHoverMaterial = function (material) {
        if (material) {
            if (material.color) {

                var newColor = material.color.clone();
                newColor.r += newColor.r * 0.3;
                newColor.g += newColor.g * 0.3;
                newColor.b += newColor.b * 0.3;

                if (newColor.r > 1.0) {
                    newColor.r = 1.0;
                }

                if (newColor.g > 1.0) {
                    newColor.g = 1.0;
                }

                if (newColor.b > 1.0) {
                    newColor.b = 1.0;
                }

                if (newColor.r === 1.0 && newColor.g === 1.0 && newColor.b === 1.0) {
                    newColor.r = 0.87;
                    newColor.g = 0.87;
                    newColor.b = 0.87;
                }

                var params = {
                    color: newColor.getHex(),
                    opacity: material.opacity,
                    transparent: material.transparent,
                    side: material.side
                };

                this.setHoverMaterial(params);
            }
        }
        return _hoverMaterial;
    };
};
/**
 * 过滤管理器：   用于构件可见性，材质变更，隔离等处理
 * 构件状态 ：    选中、高亮、半透明、隔离(隐藏其它，半透明其它)
 *
 * 六个过滤器：   id过滤器，材质过滤器，隔离过滤器，自定义过滤器，条件过滤器。
 *                这些过滤存在相互交叉和依赖，内部使用优先级控制过滤状态。
 *                id过滤器的优先级最高，隔离过滤器是在id过滤器的基础上进行的，
 *                例如，隐藏了某些构件，在隔离半透明了另一些构件，取消隔离后，隐藏的构件依然是隐藏的。
 * id过滤器：     文件隐藏(隐藏自己)、文件显示(隐藏其它)、
 *                构件选中、构件不可选、
 *                构件显示(隐藏其它)、构件隐藏(隐藏自己)、
 *                构件半透明(半透明自己)、构件不透明(半透明其它)
 * 材质过滤器：   批量(分组)修改构件材质；
 *                材质过滤的优先级为：
 *                  1, 半透明构件采用半透明材质；
 *                  2, 如果构件被冻结，则保持构件自身的材质；
 *                  3, 如果被选中，采用选中高亮材质
 *                  4, 构件被其他材质过滤器命中，采用该过滤器指定的材质
 *
 * 隔离过滤器：   隐藏隔离出的构件(隐藏自己)，隐藏未隔离出的构件(隐藏其它),
 *                半透明隔离出的构件(半透明自己)，半透明未隔离出的构件(半透明其它)
 * 自定义过滤器： 依赖userdata数据
 * 条件过滤器：   根据条件过滤，依赖userdata数据
 * 冻结过滤器：   暂时只支持冻结构件的不可选状态，即在冻结过滤器中的id对应的构件不能选中,
 *                被冻结构件如果不是半透明状态，则保持构件自身的材质
 *
 * 过滤器优先级： 材质过滤管理器中的过滤器存在优先级，对于同样优先级的过滤器，后设置的过滤器具有高优先级；
 *                对于其他过滤管理器，过滤器根据设置的先后设置优先级，后设置的过滤器具有高优先级
 *
 * @class  CLOUD.FilterManager
 *
 */
CLOUD.FilterManager = function () {

    this._filterImpl = new CLOUD.FilterManager2();

    // 基于ID的过滤器
    var EnumIdBasedType = CLOUD.EnumIdBasedType;

    // ---------------------------- render 使用 ---------------------------- //

    var _boundingBoxFromSelections = new THREE.Box3(); // 选中构件的包围盒

    /**
     * 【选择集对象】是否为null
     *
     */
    this._isEmptySelections = function () {
        return this._filterImpl._isEmptySelections();
    };

    /**
     * 重置包围盒（世界系）
     *
     */
    this._resetBoundingBoxFromSelections = function () {
        _boundingBoxFromSelections.makeEmpty();
    };

    /**
     * 计算渲染列表中所有选中对象的包围盒（世界系）
     *
     */
    this._getBoundingBoxFromSelections = function () {
        return _boundingBoxFromSelections;
    };

    /**
     * 计算渲染列表中所有选中对象的包围盒（世界系）
     *
     * @param {Array} renderList - 渲染列表
     */
    this._calcBoundingBoxFromSelections = function (renderList) {

        // var boundingBox = new THREE.Box3();
        var selections = this._filterImpl._getSelected();

        if (CLOUD.Utils.isEmptyObject(selections)) {
            return false;
        }

        for (var i = 0, len = renderList.length; i < len; ++i) {

            var object = renderList[i].object;
            var geometry = object.geometry;

            if (!geometry) {
                CLOUD.Logger.log("empty geometry!");
                continue;
            }

            if (selections[object.name] !== undefined) {

                if (!geometry.boundingBox) {
                    geometry.computeBoundingBox();
                }

                var box = geometry.boundingBox;

                if (box) {

                    var boxTmp = box.clone();

                    if (object.matrixWorld) {
                        boxTmp.applyMatrix4(object.matrixWorld);
                    }

                    _boundingBoxFromSelections.expandByPoint(boxTmp.min);
                    _boundingBoxFromSelections.expandByPoint(boxTmp.max);
                }
            }
        }

        return true;
    };

    /**
     * 计算渲染列表中所有对象的包围盒
     *
     * @param {Array} renderList - 渲染列表
     */
    this._getBoundingBoxFromRenderObjects = function (renderList) {

        var boundingBox = new THREE.Box3();

        for (var i = 0, len = renderList.length; i < len; ++i) {

            var object = renderList[i].object;

            if (!this._isVisible(object)) {
                continue;
            }

            if (object.customTag) {
                continue;
            }

            var geometry = object.geometry;

            if (!geometry) {
                CLOUD.Logger.log("empty geometry!");
                continue;
            }

            if (geometry.boundingBox == null) {
                geometry.computeBoundingBox();
            }

            var box = geometry.boundingBox;

            if (box) {

                var boxTmp = box.clone();

                if (object.matrixWorld) {
                    boxTmp.applyMatrix4(object.matrixWorld);
                }

                boundingBox.expandByPoint(boxTmp.min);
                boundingBox.expandByPoint(boxTmp.max);
            }
        }

        return boundingBox;
    };

    this._setHoverMaterial = function (params) {
        this._filterImpl._setHoverMaterial(params);
    };

    this._setHoverId = function (id) {
        this._filterImpl._setHoverId(id);
    };

    this._clearHoverId = function () {
        this._filterImpl._clearHoverId();
    };

    this._getSelectedIds = function () {
        return this._filterImpl._getSelectedIds();
    };

    // --------------------------------------------------------- //

    /**
     * 判断构件是否可见
     *
     * @param {Object} object - 构件对象 {name: xxx, userData: xxx}
     * @return {Boolean} true: 可见， 否则 不可见
     */
    this._isVisible = function (object) {

        return this._filterImpl._isVisible(object);
    };

    /**
     * 判断对象是否可以被pick。冻结的构件或者半透明的构件不能选中。
     *
     * @param {Object} object - 构件对象 {name: xxx, userData: xxx}
     * @return {Boolean} 是否可以pick - true: 对象可以被pick，false: 对象不可以pick
     */
    this._isSelectable = function (object) {

        return this._filterImpl._isSelectable(object);
    };

    /**
     * 根据构件对象获得构件材质
     *
     * @param {Object} object - 构件对象 {name: xxx, userData: xxx}
     */
    this._getOverrideMaterial = function (object) {

        return this._filterImpl._getOverrideMaterial(object);
    };

    /**
     * 判断构件是否高亮(pick, highlight)
     *
     * @param {Object} object - 自定义数据 {name: xxx, userData: xxx}
     * @return {Boolean} true: 高亮
     */
    this._hasOverrideMaterial = function (object) {

        return this._filterImpl._hasHighPriorityOverrideMaterial(object);
    };

    /**
        * 判断构件是否高亮
        *
        * @param {Object} object - 自定义数据 {name: xxx, userData: xxx}
        * @return {Boolean} true: 高亮
        */
    this._hasHighPriorityOverrideMaterial = function (object) {
        return this._filterImpl._hasHighPriorityOverrideMaterial(object);
    };

    /**
     * 是否隐藏对应id的文件
     *
     * @param {String} id - 文件id
     */
    this._isHiddenFileId = function (object) {

        return this._filterImpl._isHiddenFileId(object);
    };

    this._hasHiddenFileIdFilter = function () {
        return this._filterImpl._hasHiddenFileIdFilter();
    };

    this._hasVisibleFilter = function () {
        return this._filterImpl._hasVisibleFilter();
    };

    this._hasSelectableFilter = function () {
        return this._filterImpl._hasSelectableFilter();
    };

    this._hasOverrideMaterialFilter = function () {
        return this._filterImpl._hasOverrideMaterialFilter();
    };

    this._hasLowPriorityOverride = function () {
        return this._filterImpl._hasLowPriorityOverride();
    };

    // ------------------------------------- 外部 API ------------------------------------- //

    /**
     * 保存当前过滤器状态
     *
     */
    this.saveState = function () {

        return this._filterImpl.saveState();
    };

    /**
     * 恢复过滤器状态
     *
     */
    this.loadState = function (obj) {

        return this._filterImpl.loadState(obj);
    };

    /**
     * 清除所有的过滤器数据, 除了冻结过滤器
     * 注意：冻结的构件没有清除，因为冻结操作可能是在初始化的时候就做了，整个生命周期里，都要保持冻结
     *
     */
    this.clear = function () {

        return this._filterImpl.clear();
    };

    /**
     * 清除所有的过滤器数据, 包含冻结过滤器
     *
     */
    this.clearAll = function () {

        return this._filterImpl.clearAll();
    };

    /**
     * 清除隔离过滤器数据
     *
     */
    this.clearIsolate = function () {

        return this._filterImpl.clearIsolate();
    };

    this.getSelectionSet = function () {

        return this._filterImpl._getSelected();
    };

    /**
     * 设置【选中构件】的材质颜色
     *
     * @param {Number} color - 十六进制颜色
     */
    this.setSelectionColor = function (color) {

        return this._filterImpl.setSelectionColor(color);
    };

    // ---------------- 冻结过滤器  ---------------- //

    /**
     * 清除指定类型的数据 - 清除【Frozen id列表】
     *
     */
    this.clearFrozenList = function () {
        return this._filterImpl.clearFrozenList();
    };

    /**
     * 批量增加 - 增加到【Frozen id列表】
     *
     * @param {Array} ids - id数组
     */
    this.addToFrozenList = function (ids) {
        return this._filterImpl.addToFrozenList(ids);
    };

    /**
     * 批量删除 - 从【Frozen id列表】中移除ids
     *
     * @param {Array} ids - id数组
     */
    this.removeFromFrozenList = function (ids) {

        return this._filterImpl.removeFromFrozenList(ids);
    };

    /**
     * 批量增加 - 设置【id列表】
     *
     * @param {Array} ids - id数组
     */
    this.setFrozenList = function (ids) {

        return this._filterImpl.setFrozenList(ids);
    };

    /**
     * 按条件冻结构件
     *
     * @param {Array} conditions    - 多个条件对象数组，多个条件取交集
     *                                  [{"categoryId":-2001340},{"specialty":"AR"},{"categoryId":-2321500,"levelName":"F03"}]
     */
    this.setFrozenConditions = function (conditions) {
        this._filterImpl.setFrozenConditions(conditions);
    };

    /**
     * 获得冻结状态的条件
     *
     */
    this.getFrozenConditions = function () {
        return this._filterImpl.getFrozenConditions();
    };

    /**
     * 清除冻结状态的条件
     *
     */
    this.clearFrozenConditions = function () {
        this._filterImpl.clearFrozenConditions();
    };

    /**
     * 清除冻结状态的所有设置：条件和id列表
     *
     */
    this.clearFrozen = function () {
        this.clearFrozenList();
        this.clearFrozenConditions();
    };

    // ---------------- ID 过滤器  ---------------- //
    /**
     * 清除所有类型的ID过滤器数据 - 清除所有类型的【id列表】
     *
     */
    this.clearAllIdList = function () {
        return this._filterImpl.clearAllIdList();
    };

    /**
     * 清除指定类型的ID过滤器数据 - 清除【id列表】
     *
     */
    this.clearIdList = function (type) {
        return this._filterImpl.clearIdList(type);
    };

    /**
     * 批量增加 - 增加到【id列表】
     *
     * @param {Number} type - 类型
     *                          {
     *                              FILE_VISIBLE: 0,
     *                              FILE_HIDDEN: 1,
     *                              SELECTED: 2,
     *                              NOT_SELECTED: 3,
     *                              VISIBLE: 4,
     *                              HIDDEN: 5,
     *                              TRANSLUCENT: 6,
     *                              TRANSLUCENT_OTHERS: 7
     *                           }
     * @param {Array} ids - id数组
     */
    this.addToIdList = function (type, ids) {

        return this._filterImpl.addToIdList(type, ids);
    };

    /**
     * 批量删除 - 从【id列表】中移除ids
     *
     * @param {Number} type - 类型
     * @param {Array} ids - id数组
     */
    this.removeFromIdList = function (type, ids) {

        return this._filterImpl.removeFromIdList(type, ids);
    };

    /**
     * 批量增加 - 设置【id列表】
     *
     * @param {Number} type - 类型
     * @param {Array} ids - id数组
     */
    this.setIdList = function (type, ids) {

        return this._filterImpl.setIdList(type, ids);
    };

    // ----------------  材质替换 --------------------------- //

    /**
     * 清除所有的材质更改 - 清除所有类型的【替换材质的构件id列表】
     *
     */
    this.clearAllOverrideList = function () {
        this._filterImpl.clearAllOverrideList();
    };

    /**
     * 清除某个分组的材质更改 - 清除【替换材质的构件id列表】
     *
     * @param {String} name - 分组名
     */
    this.clearOverrideList = function (name) {
        return this._filterImpl.clearOverrideList(name);
    };

    /**
     * 批量更改材质 - 增加到【替换材质的构件id列表】
     *      data = {name1 : {id1 : materialName1, id2 : materialName1,  ... }, name2 : {id1 : materialName2, id2 : materialName2,  ... }, ...}
     *
     * @param {String} name - 分组名
     * @param {Array} ids - 构件id数组
     * @param {String} materialName - 材质名
     */
    this.addToOverrideList = function (name, ids, materialName) {

        return this._filterImpl.addToOverrideList(name, ids, materialName);
    };

    /**
     * 批量清除材质更改 - 从【替换材质的构件id列表】移除ids
     *
     * @param {String} name - 分组名
     * @param {Array} ids - 构件id数组
     */
    this.removeFromOverrideList = function (name, ids) {

        return this._filterImpl.removeFromOverrideList(name, ids);
    };

    /**
     * 批量更改材质 - 设置到名为name的【替换材质的构件id列表】
     *
     * @param {String} name - 分组名
     * @param {Array} ids - 构件id数组
     * @param {String} materialName - 材质名
     */
    this.setOverrideList = function (name, ids, materialName) {

        return this._filterImpl.setOverrideList(name, ids, materialName);
    };

    /**
     * 批量更改材质 - 增加到【替换材质的构件id列表】
     *     data = {name1 : {id1 : color1, id2 : color1,  ... }, name2 : {id1 : color2, id2 : color2,  ... }, ...}
     *
     * @param {String} name - 分组名
     * @param {Array} ids - 构件id数组
     * @param {Object} color - 十六进制颜色 + 透明度 ({color: 0x123456, opacity: 0.1})
     */
    this.addToOverrideListByColor = function (name, ids, color) {

        return this._filterImpl.addToOverrideListByColor(name, ids, color);
    };

    /**
     * 批量更改材质 - 设置【替换材质的构件id列表】
       *
     * @param {String} name - 分组名
     * @param {Array} ids - 构件id数组
     * @param {Object} color - 十六进制颜色 + 透明度 ({color: 0x123456, opacity: 0.1})
     */
    this.setOverrideListByColor = function (name, ids, color) {

        return this._filterImpl.setOverrideListByColor(name, ids, color);
    };

    // ------------------------------------------- //

    /**
     * 清除所有的自定义过滤器数据 - 清除所有的【自定义构件列表】
     *
     */
    this.clearAllUserList = function () {

        return this._filterImpl.clearAllUserList();
    };

    /**
     * 清除指定类型的自定义过滤器数据 - 清除【自定义构件列表】
     *
     * @param {Number} type - 类型标识 ({ HIDDEN_DATA: 0, OVERRIDE_DATA: 1 })
     */
    this.clearUserListByType = function (type) {

        return this._filterImpl.clearUserListByType(type);
    };

    /**
     * 批量清除 - 清除组名name的【自定义构件列表】
     *
     * @param {Number} type - 类型标识 ({ HIDDEN_DATA: 0, OVERRIDE_DATA: 1 })
     * @param {String} name - 分组名
     */
    this.clearUserList = function (type, name) {

        return this._filterImpl.clearUserList(type, name);
    };

    /**
     * 批量增加 - 增加到【自定义构件列表】
     *
     * @param {Number} type - 类型标识 ({ HIDDEN_DATA: 0, OVERRIDE_DATA: 1 })
     * @param {String} name - 分组名
     *   eg:
     *     若 userData = { categoryId: "-2000181", classCode: "-1", plan: "-1", sceneId: "c338aae5-d92d-42c2-b092-ccf9ab0a9d07"} ,
     *     则 name可以为 ["categoryId" , "classCode" , "plan" , "sceneId" , "classCode"] 之一。
     * @param {Array} keys - 自定义数据值集合, 每个key对应一个userData对象的属性对应的数据值。
     *   eg：
     *     若 userData = { categoryId: "-2000181", classCode: "-1", plan: "-1"}，
     *     则 keys = ["-2000181", "-2000182"]
     * @param {Object} [value] - 可选，keys对应的值。
     *                            当type为HIDDEN_DATA时，可以忽略该值；
     *                            当type为OVERRIDE_DATA时，
     *                            1) 指定材质颜色 value = {color: 0x123456, opacity: 0.1}
     *                            2) 指定材质名 value = {material: 'lightBlue'}
     *                            3) 指定材质名 value = 'lightBlue'
     */
    this.addToUserList = function (type, name, keys, value) {

        return this._filterImpl.addToUserList(type, name, keys, value);
    };

    /**
     * 批量删除 - 从【自定义构件列表】中移除数据
     *
     * @param {Number} type - 类型标识
     * @param {String} name - 分组名
     * @param {Array} keys - 自定义数据值集合, 每个key对应一个userData对象的属性值
     */
    this.removeFromUserList = function (type, name, keys) {

        this._filterImpl.removeFromUserList(type, name, keys);
    };

    /**
     * 批量增加 - 设置【自定义构件列表】,参数详情见 addToUserList
     *
     * @param {Number} type - 类型标识
     * @param {String} name - 分组名
     * @param {Array} keys - 自定义数据值集合, 每个key对应一个userData对象的属性对应的数据值。
     * @param {Object} [value] - 可选，keys对应的值。
     */
    this.setUserList = function (type, name, keys, value) {

        this._filterImpl.setUserList(type, name, keys, value);
    };

    // ---------- isolate ---------- //

    /**
     * 是否处于隔离状态
     * 构件被选中，构件被隔离都表示处于隔离状态
     *
     */
    this.isIsolate = function () {

        return this._filterImpl.isIsolate();
    };

    /**
     * 是否处于过滤状态
     *
     */
    this.isFiltering = function () {

        return this._filterImpl.isFiltering();
    };

    /**
     * 设置隔离材质
     *
     * @param {Object} params    - 材质参数
     *        params = {color: 0x888888, opacity: 0.1, transparent: true, side: THREE.DoubleSide}
     */
    this.setIsolateMaterial = function (params) {

        this._filterImpl.setIsolateMaterial(params);
    };

    /**
     * 获得隔离材质
     *
     */
    this.getIsolateMaterial = function () {

        return this._filterImpl.getIsolateMaterial();
    };

    /**
     * 重置隔离材质
     *
     */
    this.resetIsolateMaterial = function () {

        this._filterImpl.resetIsolateMaterial();
    };

    /**
     * 清除所有 - 清除所有状态的【隔离列表】
     *
     */
    this.clearAllIsolateList = function () {
        this._filterImpl.clearAllIsolateList();
    };

    /**
     * 清除指定状态 - 清除某个状态的【隔离列表】
     *
     * @param {Number} state - 隔离状态
     */
    this.clearIsolateList = function (state) {
        this._filterImpl.clearIsolateList(state);
    };

    /**
     * 批量增加 - 增加到【隔离列表】
     * @param {Number} state - 隔离状态
     *              {HIDDEN: 0,  HIDDEN_OTHERS: 1, TRANSLUCENT: 2, TRANSLUCENT_OTHERS: 3}
     * @param {Array} ids - 构件id数组
     */
    this.addToIsolateList = function (state, ids) {

        this._filterImpl.addToIsolateList(state, ids);
    };

    /**
     * 批量删除 - 【隔离构件id列表】中移除指定的ids
     *
     * @param {Number} state - 隔离状态
     * @param {Array} ids - 构件id数组
     */
    this.removeFromIsolateList = function (state, ids) {

        this._filterImpl.removeFromIsolateList(state, ids);
    };

    /**
     * 批量增加 - 设置【隔离列表】, 参数详情见 addToIsolateList
     *
     * @param {Number} state - 隔离状态
     * @param {Array} ids - 构件id数组
     */
    this.setIsolateList = function (state, ids) {

        this._filterImpl.setIsolateList(state, ids);
    };

    /**
     *  根据选择集进行隔离（隐藏或者半透明选择集外的构件）
     *
     * @param {Number} state - 隔离状态
     */
    this.isolateSelections = function (state) {

        this._filterImpl.isolateSelections(state);
    };

    /**
     * 从【隔离构件id列表】中移除选中的构件集
     *
     */
    this.removeSelectionsFromIsolateList = function (state) {

        this._filterImpl.removeSelectionsFromIsolateList(state);
    };

    /**
     * 根据数据设置隔离条件
     *
     * @param {Object} data - 条件数据
     */
    //this._setIsolateConditionsByData = function (data) {
    //    this._filterImpl._setIsolateConditionsByData(data);
    //};

    /**
     * 按条件隔离构件
     *
     * @param {Array} conditions    - 多个条件对象数组，单个数组取交集，多个数组取并集
     *                                  [{"categoryId":-2001340},{"specialty":"AR"},{"categoryId":-2321500,"levelName":"F03"}]
     * @param {Number} state        - 类型标识  ({HIDDEN: 0, HIDDEN_OTHERS: 1, TRANSLUCENT: 2, TRANSLUCENT_OTHERS: 3})
     */
    this.setIsolateConditions = function (conditions, state) {

        this._filterImpl.setIsolateConditions(conditions, state);
    };

    /**
     * 获得指定状态的隔离条件
     *
     * @param {Number} state - 类型标识  ({HIDDEN: 0, HIDDEN_OTHERS: 1, TRANSLUCENT: 2, TRANSLUCENT_OTHERS: 3})
     */
    this.getIsolateConditions = function (state) {
        return this._filterImpl.getIsolateConditions(state);
    };

    /**
     * 获得所有状态的隔离条件
     *
     */
    //this.getAllIsolateConditions = function () {
    //    return this._filterImpl.getAllIsolateConditions();
    //};

    /**
     * 清除某个状态的隔离条件
     *
     */
    this.clearIsolateConditions = function (state) {

        this._filterImpl.clearIsolateConditions(state);
    };

    /**
     * 清除所有状态的隔离条件
     *
     */
    this.clearAllIsolateConditions = function () {

        this._filterImpl.clearAllIsolateConditions();
    };

    // ------------------- Conditions --------------------------- //

    /**
     * 按条件过滤
     *
     * @param {Number} type         - 类型标识  ({ HIDDEN_OTHERS: 0, TRANSLUCENT: 1, OVERRIDE: 2 })
     * @param {Array} conditions    - 多个条件对象数组，单个数组取交集，多个数组取并集
     *                                 如果type为OVERRIDE，则数据格式：
     *                                 data = [{condition:{levelName:'xxx'}, material: 'xxx'}, {condition:{levelName:'xxx', categoryId: 'xxx'}, material:'xxx'}]
     *                                 data = [{condition:{levelName:'xxx'}, color: {color: 0x123456, opacity: 0.1}}, {condition:{levelName:'xxx', categoryId: 'xxx'}, color: {color: 0x123456, opacity: 0.1}}]
     *                                 否则，数据格式：
     *                                 data = [{"categoryId":-2001340},{"specialty":"AR"},{"categoryId":-2321500,"levelName":"F03"}]
     *
     *                                 注意：type为OVERRIDE，则数据格式为下面格式更为合理
     *                                 data = {conditions:[{levelName:'xxx'},{levelName:'xxx', categoryId: 'xxx'}, ...], material:'xxx'}
     *                                 data = {conditions:[{levelName:'xxx'},{levelName:'xxx', categoryId: 'xxx'}, ...], color:{color: 0x123456, opacity: 0.1}}
     */
    this.setConditions = function (type, conditions) {

        this._filterImpl.setConditions(type, conditions);
    };

    /**
     * 获得指定类型的条件
     *
     * @param {Number} type - 类型标识  ({ HIDDEN_OTHERS: 0, TRANSLUCENT: 1, OVERRIDE: 2 })
     */
    this.getConditions = function (type) {
        return this._filterImpl.getConditions(type);
    };

    /**
     * 清除指定类型的条件
     *
     * @param {Number} type - 类型标识  ({ HIDDEN_OTHERS: 0, TRANSLUCENT: 1, OVERRIDE: 2 })
     */
    this.clearConditions = function (type) {

        this._filterImpl.clearConditions(type);
    };

    /**
     * 获得所有类型的条件
     *
     */
    //this.getAllConditions = function () {
    //    return _conditions;
    //};

    /**
     * 清除所有类型的条件
     *
     */
    this.clearAllConditions = function () {
        this._filterImpl.clearAllConditions();
    };

    /**
     * 根据数据设置条件
     *
     * @param {Object} data - 条件数据
     */
    //this._setConditionsByData = function (data) {
    //    _conditions = data;
    //};

    // ---------- Override scene ---------- //

    /**
     * 场景半透明
     *
     */
    this.makeSceneTranslucent = function () {
        this._filterImpl.makeSceneTranslucent();
    };

    /**
     * 取消场景半透明
     *
     */
    this.cancelSceneTranslucent = function () {
        this._filterImpl.cancelSceneTranslucent();
    };

    /**
     * 场景隐藏
     *
     */
    this.hideScene = function () {
        this._filterImpl.hideScene();
    };

    /**
     * 场景显示
     *
     */
    this.showScene = function () {
        this._filterImpl.showScene();
    };

    /**
     * 设置场景状态
     *
     */
    this.setSceneState = function (state) {
        this._filterImpl.setSceneState(state);
    };

    /**
     * 是获得场景状态
     *
     * @return {Number} 场景状态
     */
    this.getSceneState = function () {
        return this._filterImpl.getSceneState();
    };

    // --------------------------- //

    /**
     *  隐藏【选中的构件】(或 显示【未选中的构件】)
     *
     */
    this.hideSelections = function () {

        this._filterImpl.hideSelections();
    };

    /**
     * 隐藏【未选中的构件】 (或 显示【选中的构件】)
     *
     */
    this.hideUnselections = function () {

        this._filterImpl.hideUnselections();
    };

    /**
     * 取消隐藏状态
     *
     */
    this.cancelHidden = function () {

        this._filterImpl.cancelHidden();
    };

    /**
     * 【已选中的构件】半透明 (或 【未选中的构件】不透明)
     *
     */
    this.makeSelectedTranslucent = function () {

        this._filterImpl.makeSelectedTranslucent();
    };

    /**
     * 【未选中的构件】半透明 (或 【已选中的构件】不透明)
     *
     */
    this.makeSelectedOthersTranslucent = function () {

        this._filterImpl.makeSelectedOthersTranslucent();
    };

    /**
     * 取消半透明状态
     *
     */
    this.cancelTranslucent = function () {

        this._filterImpl.cancelTranslucent();
    };

    // ------------------------------------------ //

    /**
     *  隐藏【指定的构件】
     *
     * @param {Array} ids - 构件 id 集合
     */
    this.hideByIds = function (ids) {
        this._filterImpl._addIdsToFilter(EnumIdBasedType.HIDDEN, ids);
    };

    /**
     * 仅仅显示【指定的构件】
     *
     * @param {Array} ids - 构件 id 集合
     */
    this.showByIds = function (ids) {
        this._filterImpl._addIdsToFilter(EnumIdBasedType.VISIBLE, ids);
    };

    /**
     * 【指定的构件】 半透明
     *
     * @param {Array} ids - 构件 id 集合
     */
    this.makeTranslucentByIds = function (ids) {
        this._filterImpl._addIdsToFilter(EnumIdBasedType.TRANSLUCENT, ids);
    };

    /**
     * 【指定的构件】不透明
     *
     * @param {Array} ids - 构件 id 集合
     */
    this.makeTranslucentOthersByIds = function (ids) {
        this._filterImpl._addIdsToFilter(EnumIdBasedType.TRANSLUCENT_OTHERS, ids);
    };

    this.getFilterType = function () {
        return this._filterImpl._getFilterType();
    };
};

CLOUD.FilterManager2 = function () {

    // 基于ID的过滤器
    var EnumIdBasedType = CLOUD.EnumIdBasedType;
    // 场景状态
    var EnumSceneState = CLOUD.EnumSceneState;

    var EnumFilterResultMode = CLOUD.FilterResultMode;

    // basic filter types, one type has a peer filter
    var EnumFilterType = {
        IDFILTER_OFFSET: 0,
        FILE_VISIBLE: 0,
        FILE_HIDDEN: 1,
        SELECTED: 2,
        VISIBLE: 3,
        HIDDEN: 4,
        TRANSLUCENT: 5,
        TRANSLUCENT_OTHERS: 6,
        IDFILTER_ENDOFFSET: 6,

        ISOLATEFILTER_OFFSET: 7,
        ISOLATE_HIDDEN: 7,
        ISOLATE_HIDDEN_OTHERS: 8,
        ISOLATE_TRANSLUCENT: 9,
        ISOLATE_TRANSLUCENT_OTHERS: 10,
        ISOLATEFILTER_ENDOFFSET: 10,

        USERFILTER_OFFSET: 11,
        USER_HIDDEN: 11,
        USER_OVERRIDE: 12,
        USERFILTER_ENDOFFSET: 12,

        CONDITIONFILTER_OFFSET: 13,
        CONDITION_HIDDEN_OTHERS: 13,
        CONDITION_TRANSLUCENT_OTHERS: 14,
        CONDITION_OVERRIDE: 15,
        CONDITIONFILTER_ENDOFFSET: 15,

        ISOLATECONDITIONFILTER_OFFSET: 16,
        ISOLATE_CONDITION_HIDDEN: 16, // not used currently
        ISOLATE_CONDITION_HIDDEN_OTHERS: 17,
        ISOLATE_CONDITION_TRANSLUCENT: 18, // not used currently
        ISOLATE_CONDITION_TRANSLUCENT_OTHERS: 19,
        ISOLATECONDITIONFILTER_ENDOFFSET: 19,

        FROZENFILTER: 20,
        FROZENCONDITIONFILTER: 21,
        OVERRIDEFILTER: 22,

        BASICFILTER_COUNT: 22
    };

    // compound filter list
    //
    var _visibleCompoundFilter = new CLOUD.CompoundFilter(true);
    var _overrideCompoundFilter = new CLOUD.CompoundFilter(true);
    var _highPriorityOverrideCompoundFilter = new CLOUD.CompoundFilter(false);
    var _selectableCompoundFilter = new CLOUD.CompoundFilter(true);
    var _hiddenFileIdCompoundFilter = new CLOUD.CompoundFilter(false);

    // basic filters
    // get one basic filter according to its type index, see EnumFilterType
    var _basicFilterList = [];

    var _basicSelectedFilter;
    var _overrideFilter;
    var _frozenFilter;

    var _sceneState = EnumSceneState.DISABLED;
    var _materialSelector = new CLOUD.MaterialSelector();
    var _hoverId = undefined;

    function _init() {

        // create basic filters
        //
        _basicFilterList[EnumFilterType.FILE_VISIBLE] = new CLOUD.FileIdFilter(EnumFilterType.FILE_VISIBLE);
        _basicFilterList[EnumFilterType.FILE_HIDDEN] = new CLOUD.FileIdFilter(EnumFilterType.FILE_HIDDEN);

        _basicSelectedFilter = new CLOUD.GeneralIdFilter(EnumFilterType.SELECTED);
        _basicFilterList[EnumFilterType.SELECTED] = _basicSelectedFilter;
        _basicFilterList[EnumFilterType.VISIBLE] = new CLOUD.GeneralIdFilter(EnumFilterType.VISIBLE);
        _basicFilterList[EnumFilterType.HIDDEN] = new CLOUD.GeneralIdFilter(EnumFilterType.HIDDEN);
        _basicFilterList[EnumFilterType.TRANSLUCENT] = new CLOUD.GeneralIdFilter(EnumFilterType.TRANSLUCENT);
        _basicFilterList[EnumFilterType.TRANSLUCENT_OTHERS] = new CLOUD.GeneralIdFilter(EnumFilterType.TRANSLUCENT_OTHERS);

        _basicFilterList[EnumFilterType.ISOLATE_HIDDEN] = new CLOUD.GeneralIdFilter(EnumFilterType.ISOLATE_HIDDEN);
        _basicFilterList[EnumFilterType.ISOLATE_HIDDEN_OTHERS] = new CLOUD.GeneralIdFilter(EnumFilterType.ISOLATE_HIDDEN_OTHERS);
        _basicFilterList[EnumFilterType.ISOLATE_TRANSLUCENT] = new CLOUD.GeneralIdFilter(EnumFilterType.ISOLATE_TRANSLUCENT);
        _basicFilterList[EnumFilterType.ISOLATE_TRANSLUCENT_OTHERS] = new CLOUD.GeneralIdFilter(EnumFilterType.ISOLATE_TRANSLUCENT_OTHERS);

        _basicFilterList[EnumFilterType.USER_HIDDEN] = new CLOUD.UserListFilter(EnumFilterType.USER_HIDDEN);
        _basicFilterList[EnumFilterType.USER_OVERRIDE] = new CLOUD.UserListFilter(EnumFilterType.USER_OVERRIDE);

        _basicFilterList[EnumFilterType.CONDITION_HIDDEN_OTHERS] = new CLOUD.ConditionFilter(EnumFilterType.CONDITION_HIDDEN_OTHERS);
        _basicFilterList[EnumFilterType.CONDITION_TRANSLUCENT_OTHERS] = new CLOUD.ConditionFilter(EnumFilterType.CONDITION_TRANSLUCENT_OTHERS);
        _basicFilterList[EnumFilterType.CONDITION_OVERRIDE] = new CLOUD.MultiConditionFilter(EnumFilterType.CONDITION_OVERRIDE);

        _basicFilterList[EnumFilterType.ISOLATE_CONDITION_HIDDEN] = new CLOUD.ConditionFilter(EnumFilterType.ISOLATE_CONDITION_HIDDEN);
        _basicFilterList[EnumFilterType.ISOLATE_CONDITION_HIDDEN_OTHERS] = new CLOUD.ConditionFilter(EnumFilterType.ISOLATE_CONDITION_HIDDEN_OTHERS);
        _basicFilterList[EnumFilterType.ISOLATE_CONDITION_TRANSLUCENT] = new CLOUD.ConditionFilter(EnumFilterType.ISOLATE_CONDITION_TRANSLUCENT);
        _basicFilterList[EnumFilterType.ISOLATE_CONDITION_TRANSLUCENT_OTHERS] = new CLOUD.ConditionFilter(EnumFilterType.ISOLATE_CONDITION_TRANSLUCENT_OTHERS);

        _frozenFilter = new CLOUD.GeneralIdFilter(EnumFilterType.FROZENFILTER);
        _basicFilterList[EnumFilterType.FROZENCONDITIONFILTER] = new CLOUD.ConditionFilter(EnumFilterType.FROZENCONDITIONFILTER);
        _basicFilterList[EnumFilterType.FROZENFILTER] = _frozenFilter;
        _overrideFilter = new CLOUD.OverrideListFilter(EnumFilterType.OVERRIDEFILTER);
        _basicFilterList[EnumFilterType.OVERRIDEFILTER] = _overrideFilter;

        var f;

        // register basic filter to compound filter
        //
        var filtersForVisible = {};
        filtersForVisible[EnumFilterType.HIDDEN] = EnumFilterResultMode.MATCH_RETURN_FALSE;
        filtersForVisible[EnumFilterType.VISIBLE] = EnumFilterResultMode.NOMATCH_RETURN_FALSE;
        filtersForVisible[EnumFilterType.USER_HIDDEN] = EnumFilterResultMode.MATCH_RETURN_FALSE;
        filtersForVisible[EnumFilterType.CONDITION_HIDDEN_OTHERS] = EnumFilterResultMode.NOMATCH_RETURN_FALSE;
        filtersForVisible[EnumFilterType.ISOLATE_HIDDEN] = EnumFilterResultMode.MATCH_RETURN_FALSE;
        filtersForVisible[EnumFilterType.ISOLATE_HIDDEN_OTHERS] = EnumFilterResultMode.NOMATCH_RETURN_FALSE;
        filtersForVisible[EnumFilterType.ISOLATE_CONDITION_HIDDEN_OTHERS] = EnumFilterResultMode.NOMATCH_RETURN_FALSE;

        _visibleCompoundFilter.setFilterMode(filtersForVisible);
        for (f in filtersForVisible) {
            _basicFilterList[f].registerToCompoundFilter(_visibleCompoundFilter);
        }

        var filtersForSelect = {};
        filtersForSelect[EnumFilterType.FROZENFILTER] = EnumFilterResultMode.MATCH_RETURN_FALSE;
        filtersForSelect[EnumFilterType.FROZENCONDITIONFILTER] = EnumFilterResultMode.MATCH_RETURN_FALSE;
        filtersForSelect[EnumFilterType.TRANSLUCENT] = EnumFilterResultMode.MATCH_RETURN_FALSE;
        filtersForSelect[EnumFilterType.TRANSLUCENT_OTHERS] = EnumFilterResultMode.NOMATCH_RETURN_FALSE;
        filtersForSelect[EnumFilterType.CONDITION_TRANSLUCENT_OTHERS] = EnumFilterResultMode.NOMATCH_RETURN_FALSE;
        filtersForSelect[EnumFilterType.ISOLATE_TRANSLUCENT] = EnumFilterResultMode.MATCH_RETURN_FALSE;
        filtersForSelect[EnumFilterType.ISOLATE_TRANSLUCENT_OTHERS] = EnumFilterResultMode.NOMATCH_RETURN_FALSE;
        filtersForSelect[EnumFilterType.ISOLATE_CONDITION_TRANSLUCENT_OTHERS] = EnumFilterResultMode.NOMATCH_RETURN_FALSE;

        _selectableCompoundFilter.setFilterMode(filtersForSelect);
        for (f in filtersForSelect) {
            _basicFilterList[f].registerToCompoundFilter(_selectableCompoundFilter);
        }

        var filtersForOverride = {};
        filtersForOverride[EnumFilterType.ISOLATE_TRANSLUCENT] = EnumFilterResultMode.MATCH_RETURN_TRUE;
        filtersForOverride[EnumFilterType.ISOLATE_TRANSLUCENT_OTHERS] = EnumFilterResultMode.NOMATCH_RETURN_TRUE;
        filtersForOverride[EnumFilterType.ISOLATE_CONDITION_TRANSLUCENT_OTHERS] = EnumFilterResultMode.NOMATCH_RETURN_TRUE;
        filtersForOverride[EnumFilterType.CONDITION_TRANSLUCENT_OTHERS] = EnumFilterResultMode.NOMATCH_RETURN_TRUE;
        filtersForOverride[EnumFilterType.TRANSLUCENT] = EnumFilterResultMode.MATCH_RETURN_TRUE;
        filtersForOverride[EnumFilterType.TRANSLUCENT_OTHERS] = EnumFilterResultMode.NOMATCH_RETURN_TRUE;
        filtersForOverride[EnumFilterType.SELECTED] = EnumFilterResultMode.MATCH_RETURN_TRUE;
        filtersForOverride[EnumFilterType.OVERRIDEFILTER] = EnumFilterResultMode.MATCH_RETURN_TRUE;
        filtersForOverride[EnumFilterType.USER_OVERRIDE] = EnumFilterResultMode.MATCH_RETURN_TRUE;
        filtersForOverride[EnumFilterType.CONDITION_OVERRIDE] = EnumFilterResultMode.MATCH_RETURN_TRUE;
        filtersForOverride[EnumFilterType.FROZENFILTER] = EnumFilterResultMode.MATCH_RETURN_TRUE;
        filtersForOverride[EnumFilterType.FROZENCONDITIONFILTER] = EnumFilterResultMode.MATCH_RETURN_TRUE;

        // different override conditions have different priority
        // translucent condition is highest, then frozen (no override material except translucent), then selection,
        // the last is normal override conditions
        var priorityForOverride = {};
        priorityForOverride[EnumFilterType.ISOLATE_TRANSLUCENT] = 5;
        priorityForOverride[EnumFilterType.ISOLATE_TRANSLUCENT_OTHERS] = 5;
        priorityForOverride[EnumFilterType.ISOLATE_CONDITION_TRANSLUCENT_OTHERS] = 5;
        priorityForOverride[EnumFilterType.CONDITION_TRANSLUCENT_OTHERS] = 5;
        priorityForOverride[EnumFilterType.TRANSLUCENT] = 5;
        priorityForOverride[EnumFilterType.TRANSLUCENT_OTHERS] = 5;
        priorityForOverride[EnumFilterType.SELECTED] = 2;
        priorityForOverride[EnumFilterType.OVERRIDEFILTER] = 0;
        priorityForOverride[EnumFilterType.USER_OVERRIDE] = 0;
        priorityForOverride[EnumFilterType.CONDITION_OVERRIDE] = 0;
        priorityForOverride[EnumFilterType.FROZENFILTER] = 3;
        priorityForOverride[EnumFilterType.FROZENCONDITIONFILTER] = 3;

        _overrideCompoundFilter.setFilterMode(filtersForOverride);
        _overrideCompoundFilter.setFilterPriority(priorityForOverride);
        for (f in filtersForOverride) {
            _basicFilterList[f].registerToCompoundFilter(_overrideCompoundFilter);
        }

        var filterForHighOverride = {};
        filterForHighOverride[EnumFilterType.SELECTED] = EnumFilterResultMode.MATCH_RETURN_TRUE;
        filterForHighOverride[EnumFilterType.OVERRIDEFILTER] = EnumFilterResultMode.MATCH_RETURN_TRUE;
        filterForHighOverride[EnumFilterType.USER_OVERRIDE] = EnumFilterResultMode.MATCH_RETURN_TRUE;
        filterForHighOverride[EnumFilterType.CONDITION_OVERRIDE] = EnumFilterResultMode.MATCH_RETURN_TRUE;
        filterForHighOverride[EnumFilterType.CONDITION_TRANSLUCENT_OTHERS] = EnumFilterResultMode.MATCH_RETURN_TRUE;
        filterForHighOverride[EnumFilterType.ISOLATE_CONDITION_TRANSLUCENT_OTHERS] = EnumFilterResultMode.NOMATCH_RETURN_TRUE;

        _highPriorityOverrideCompoundFilter.setFilterMode(filterForHighOverride);
        for (f in filterForHighOverride) {
            _basicFilterList[f].registerToCompoundFilter(_highPriorityOverrideCompoundFilter);
        }

        var filterForHiddenFileId = {};
        filterForHiddenFileId[EnumFilterType.FILE_VISIBLE] = EnumFilterResultMode.NOMATCH_RETURN_TRUE;
        filterForHiddenFileId[EnumFilterType.FILE_HIDDEN] = EnumFilterResultMode.MATCH_RETURN_TRUE;

        _hiddenFileIdCompoundFilter.setFilterMode(filterForHiddenFileId);
        for (f in filterForHiddenFileId) {
            _basicFilterList[f].registerToCompoundFilter(_hiddenFileIdCompoundFilter);
        }
    }

    _init();

    // ------------------------------------- external API ------------------------------------- //

    this.saveState = function () {

        var obj = {};

        var basicFilter;
        for (var i = 0, len = _basicFilterList.length; i < len; i++) {
            basicFilter = _basicFilterList[i];
            obj[i] = basicFilter.getAll();
        }

        obj.sceneState = this.getSceneState();

        return obj;
    };

    this.loadState = function (obj) {

        for (var index in obj) {
            if (index !== "sceneState") {
                _basicFilterList[index].setByData(obj[index]);
            }
        }

        this.setSceneState(obj.sceneState);
    };

    this.clear = function () {

        for (var i = 0, len = _basicFilterList.length; i < len; i++) {
            if (_basicFilterList[i].getType() === EnumFilterType.FROZENFILTER) {
                continue;
            }

            _basicFilterList[i].clearAll();
        }

        this.setSceneState(EnumSceneState.DISABLED);
        _hoverId = undefined;
    };

    this.clearAll = function () {

        for (var i = 0, len = _basicFilterList.length; i < len; i++) {
            _basicFilterList[i].clearAll();
        }

        this.setSceneState(EnumSceneState.DISABLED);
        _hoverId = undefined;
    };

    this.clearIsolate = function () {
        this.clearAllIsolateList();
        this.clearAllIsolateConditions();
    };

    this.setSelectionColor = function (color) {
        var material = _materialSelector.get('selection');
        material.color.setHex(color);
        material.needsUpdate = true;
    };

    // ---------------- frozen filter  ---------------- //

    this.clearFrozenList = function () {
        _frozenFilter.clearAll();
    };

    this.addToFrozenList = function (ids) {

        _frozenFilter.add(ids);
    };

    this.removeFromFrozenList = function (ids) {

        _frozenFilter.remove(ids);
    };

    this.setFrozenList = function (ids) {

        this.clearFrozenList();
        this.addToFrozenList(ids);
    };

    this.setFrozenConditions = function (conditions) {
        _basicFilterList[EnumFilterType.FROZENCONDITIONFILTER].setByData(conditions);
    };

    this.getFrozenConditions = function () {
        return _basicFilterList[EnumFilterType.FROZENCONDITIONFILTER].getAll();
    };

    this.clearFrozenConditions = function () {
        _basicFilterList[EnumFilterType.FROZENCONDITIONFILTER].clear();
    };

    this.clearFrozen = function () {
        this.clearFrozenList();
        this.clearFrozenConditions();
    };

    // ---------------- ID filter  ---------------- //
    this.clearAllIdList = function () {
        var i;
        for (i = EnumFilterType.IDFILTER_OFFSET; i <= IDFILTER_ENDOFFSET; i++) {
            _basicFilterList[i].clearAll();
        }
    };

    this.clearIdList = function (type) {
        var internalType = EnumFilterType.IDFILTER_OFFSET + type;

        if (internalType >= EnumFilterType.IDFILTER_OFFSET && internalType <= EnumFilterType.IDFILTER_ENDOFFSET) {
            _basicFilterList[internalType].clear();
        }
    };

    this.addToIdList = function (type, ids) {
        var internalType = EnumFilterType.IDFILTER_OFFSET + type;

        if (internalType >= EnumFilterType.IDFILTER_OFFSET && internalType <= EnumFilterType.IDFILTER_ENDOFFSET) {
            _basicFilterList[internalType].add(ids);
        }
    };

    this.removeFromIdList = function (type, ids) {
        var internalType = EnumFilterType.IDFILTER_OFFSET + type;

        if (internalType >= EnumFilterType.IDFILTER_OFFSET && internalType <= EnumFilterType.IDFILTER_ENDOFFSET) {
            _basicFilterList[internalType].remove(ids);
        }
    }, this.setIdList = function (type, ids) {

        this.clearIdList(type);
        this.addToIdList(type, ids);
    };

    // ----------------  override material --------------------------- //

    this.clearAllOverrideList = function () {
        _overrideFilter.clearAll();
    };

    this.clearOverrideList = function (name) {
        _overrideFilter.clear(name);
    };

    this.addToOverrideList = function (name, ids, materialName) {

        if (ids && ids.length > 0) {

            if (!_materialSelector.has(materialName)) {
                materialName = _materialSelector.getDefaultMaterialName();
            }

            _overrideFilter.add(name, ids, materialName);
        }
    };

    this.removeFromOverrideList = function (name, ids) {

        _overrideFilter.remove(name, ids);
    };

    this.setOverrideList = function (name, ids, materialName) {

        this.clearOverrideList(name);
        this.addToOverrideList(name, ids, materialName);
    };

    this.addToOverrideListByColor = function (name, ids, color) {

        var materialName = _materialSelector.add(color);
        _overrideFilter.add(name, ids, materialName);
    };

    this.setOverrideListByColor = function (name, ids, color) {

        this.clearOverrideList(name);
        this.addToOverrideListByColor(name, ids, color);
    };

    // ---------------------- user list--------------------- //

    this.clearAllUserList = function () {
        var i;
        for (i = EnumFilterType.USERFILTER_OFFSET; i <= EnumFilterType.USERFILTER_ENDOFFSET; i++) {
            _basicFilterList[i].clearAll();
        }
    };

    this.clearUserListByType = function (type) {
        var internalType = EnumFilterType.USERFILTER_OFFSET + type;
        if (internalType >= EnumFilterType.USERFILTER_OFFSET && internalType <= EnumFilterType.USERFILTER_ENDOFFSET) {
            _basicFilterList[internalType].clearAll();
        }
    };

    this.clearUserList = function (type, name) {
        var internalType = EnumFilterType.USERFILTER_OFFSET + type;
        if (internalType >= EnumFilterType.USERFILTER_OFFSET && internalType <= EnumFilterType.USERFILTER_ENDOFFSET) {
            _basicFilterList[internalType].clear(name);
        }
    };

    this.addToUserList = function (type, name, keys, value) {

        var internalType = EnumFilterType.USERFILTER_OFFSET + type;
        if (internalType >= EnumFilterType.USERFILTER_OFFSET && internalType <= EnumFilterType.USERFILTER_ENDOFFSET) {
            _basicFilterList[internalType].add(name, keys, value);
        }
    };

    this.removeFromUserList = function (type, name, keys) {

        var internalType = EnumFilterType.USERFILTER_OFFSET + type;
        if (internalType >= EnumFilterType.USERFILTER_OFFSET && internalType <= EnumFilterType.USERFILTER_ENDOFFSET) {
            _basicFilterList[internalType].remove(name, keys);
        }
    };

    this.setUserList = function (type, name, keys, value) {

        this.clearUserList(type, name);
        this.addToUserList(type, name, keys, value);
    };

    // ------------------- Isolate --------------------------- //

    this.isIsolate = function () {
        var i;
        for (i = EnumFilterType.ISOLATEFILTER_OFFSET; i <= EnumFilterType.ISOLATEFILTER_ENDOFFSET; i++) {
            if (!_basicFilterList[i].isEmpty()) {
                return true;
            }
        }

        return false;
    };

    this.isFiltering = function () {

        if (this.isIsolate()) {
            return true;
        }

        return !_basicFilterList[EnumFilterType.HIDDEN].isEmpty() || !_basicFilterList[EnumFilterType.VISIBLE].isEmpty() || !_basicFilterList[EnumFilterType.TRANSLUCENT].isEmpty() || !_basicFilterList[EnumFilterType.TRANSLUCENT_OTHERS].isEmpty() || this.getSceneState() !== EnumSceneState.DISABLED;
    };

    this.setIsolateMaterial = function (params) {

        _materialSelector.setIsolateMaterial(params);
    };

    this.getIsolateMaterial = function () {

        return _materialSelector.getIsolateMaterial();
    };

    this.resetIsolateMaterial = function () {

        _materialSelector.resetIsolateMaterial();
    };

    this.clearAllIsolateList = function () {
        var i;
        for (i = EnumFilterType.ISOLATEFILTER_OFFSET; i <= EnumFilterType.ISOLATEFILTER_ENDOFFSET; i++) {
            _basicFilterList[i].clear();
        }
    };

    this.clearIsolateList = function (type) {
        var internalType = EnumFilterType.ISOLATEFILTER_OFFSET + type;
        if (internalType >= EnumFilterType.ISOLATEFILTER_OFFSET && internalType <= EnumFilterType.ISOLATEFILTER_ENDOFFSET) {
            _basicFilterList[internalType].clear();
        }
    };

    this.addToIsolateList = function (type, ids) {
        var internalType = EnumFilterType.ISOLATEFILTER_OFFSET + type;
        if (internalType >= EnumFilterType.ISOLATEFILTER_OFFSET && internalType <= EnumFilterType.ISOLATEFILTER_ENDOFFSET) {
            _basicFilterList[internalType].add(ids);
        }
    };

    this.removeFromIsolateList = function (type, ids) {
        var internalType = EnumFilterType.ISOLATEFILTER_OFFSET + type;
        if (internalType >= EnumFilterType.ISOLATEFILTER_OFFSET && internalType <= EnumFilterType.ISOLATEFILTER_ENDOFFSET) {
            _basicFilterList[internalType].remove(ids);
        }
    };

    this.setIsolateList = function (type, ids) {
        this.clearIsolateList(type);
        this.addToIsolateList(type, ids);
    };

    this.isolateSelections = function (type) {
        this.clearAllIsolateList();
        var internalType = EnumFilterType.ISOLATEFILTER_OFFSET + type;
        if (internalType >= EnumFilterType.ISOLATEFILTER_OFFSET && internalType <= EnumFilterType.ISOLATEFILTER_ENDOFFSET) {
            _basicFilterList[internalType].add(this._getSelectedIds());
        }
    };

    this.removeSelectionsFromIsolateList = function (type) {

        this.removeFromIsolateList(type, this._getSelectedIds());
    };

    // ------------------- Isolate Conditions --------------------------- //
    //

    this.setIsolateConditions = function (conditions, type) {
        var internalType = EnumFilterType.ISOLATECONDITIONFILTER_OFFSET + type;
        if (internalType >= EnumFilterType.ISOLATECONDITIONFILTER_OFFSET && internalType <= EnumFilterType.ISOLATECONDITIONFILTER_ENDOFFSET) {
            _basicFilterList[internalType].setByData(conditions);
        }
    };

    this.getIsolateConditions = function (type) {
        var items = null;

        var internalType = EnumFilterType.ISOLATECONDITIONFILTER_OFFSET + type;
        if (internalType >= EnumFilterType.ISOLATECONDITIONFILTER_OFFSET && internalType <= EnumFilterType.ISOLATECONDITIONFILTER_ENDOFFSET) {
            items = _basicFilterList[internalType].getAll();
        }

        return items;
    };

    this.clearIsolateConditions = function (type) {
        var internalType = EnumFilterType.ISOLATECONDITIONFILTER_OFFSET + type;
        if (internalType >= EnumFilterType.ISOLATECONDITIONFILTER_OFFSET && internalType <= EnumFilterType.ISOLATECONDITIONFILTER_ENDOFFSET) {
            _basicFilterList[internalType].clear();
        }
    };

    this.clearAllIsolateConditions = function () {
        var i;
        for (i = EnumFilterType.ISOLATECONDITIONFILTER_OFFSET; i <= EnumFilterType.ISOLATECONDITIONFILTER_ENDOFFSET; i++) {
            _basicFilterList[i].clearAll();
        }
    };

    // ------------------- Conditions --------------------------- //
    this.setConditions = function (type, conditions) {
        var internalType = EnumFilterType.CONDITIONFILTER_OFFSET + type;
        if (internalType >= EnumFilterType.CONDITIONFILTER_OFFSET && internalType <= EnumFilterType.CONDITIONFILTER_ENDOFFSET) {
            _basicFilterList[internalType].setByData(conditions);
        }
    };

    this.getConditions = function (type) {
        var items = null;

        var internalType = EnumFilterType.CONDITIONFILTER_OFFSET + type;
        if (internalType >= EnumFilterType.CONDITIONFILTER_OFFSET && internalType <= EnumFilterType.CONDITIONFILTER_ENDOFFSET) {
            items = _basicFilterList[internalType].get();
        }

        return items;
    };

    this.clearConditions = function (type) {
        var internalType = EnumFilterType.CONDITIONFILTER_OFFSET + type;
        if (internalType >= EnumFilterType.CONDITIONFILTER_OFFSET && internalType <= EnumFilterType.CONDITIONFILTER_ENDOFFSET) {
            _basicFilterList[internalType].clearAll();
        }
    };

    this.clearAllConditions = function () {
        var i;
        for (i = EnumFilterType.CONDITIONFILTER_OFFSET; i <= EnumFilterType.CONDITIONFILTER_ENDOFFSET; i++) {
            _basicFilterList[i].clear();
        }
    };

    // ---------- Override scene ---------- //
    this.makeSceneTranslucent = function () {
        this.setSceneState(EnumSceneState.TRANSLUCENT);
    };

    this.cancelSceneTranslucent = function () {
        this.setSceneState(EnumSceneState.DISABLED);
    };

    this.hideScene = function () {
        this.setSceneState(EnumSceneState.HIDDEN);
    };

    this.showScene = function () {
        this.setSceneState(EnumSceneState.DISABLED);
    };

    this.setSceneState = function (state) {
        _sceneState = state;
    };

    this.getSceneState = function () {
        return _sceneState;
    };

    // -------------------------selection ------------------- //

    this.hideSelections = function () {
        _basicFilterList[EnumFilterType.HIDDEN].add(this._getSelectedIds());
    };

    this.hideUnselections = function () {
        _basicFilterList[EnumFilterType.VISIBLE].add(this._getSelectedIds());
        _basicFilterList[EnumFilterType.VISIBLE].forceEnable();
    };

    this.cancelHidden = function () {
        this.clearIdList(EnumIdBasedType.VISIBLE);
        this.clearIdList(EnumIdBasedType.HIDDEN);
    };

    this.makeSelectedTranslucent = function () {
        _basicFilterList[EnumFilterType.TRANSLUCENT].add(this._getSelectedIds());
    };

    this.makeSelectedOthersTranslucent = function () {
        _basicFilterList[EnumFilterType.TRANSLUCENT_OTHERS].add(this._getSelectedIds());
        _basicFilterList[EnumFilterType.TRANSLUCENT_OTHERS].forceEnable();
    };

    this.cancelTranslucent = function () {
        this.clearIdList(EnumIdBasedType.TRANSLUCENT);
        this.clearIdList(EnumIdBasedType.TRANSLUCENT_OTHERS);
    };

    this._addIdsToFilter = function (type, ids) {
        var internalType = EnumFilterType.IDFILTER_OFFSET + type;
        if (internalType >= EnumFilterType.IDFILTER_OFFSET && internalType <= EnumFilterType.IDFILTER_ENDOFFSET) {
            _basicFilterList[internalType].add(ids);
        }
    };

    this.hideByIds = function (ids) {
        this._addIdsToFilter(EnumIdBasedType.HIDDEN, ids);
    };

    this.showByIds = function (ids) {
        this._addIdsToFilter(EnumIdBasedType.VISIBLE, ids);
    };

    this.makeTranslucentByIds = function (ids) {
        this._addIdsToFilter(EnumIdBasedType.TRANSLUCENT, ids);
    };

    this.makeTranslucentOthersByIds = function (ids) {
        this._addIdsToFilter(EnumIdBasedType.TRANSLUCENT_OTHERS, ids);
    };

    //----------------- internal method --------------------//

    this._isVisible = function (object) {

        var sceneState = this.getSceneState();
        // scene is hidden
        if (sceneState === EnumSceneState.HIDDEN) {
            return false;
        }

        return _visibleCompoundFilter.apply(object);
    };

    this._isSelectable = function (object) {
        var sceneState = this.getSceneState();
        if (sceneState === EnumSceneState.TRANSLUCENT) {
            return false;
        }

        return _selectableCompoundFilter.apply(object, this.getSceneState());
    };

    this._getOverrideMaterial = function (object) {

        var sceneState = this.getSceneState();
        if (sceneState === EnumSceneState.TRANSLUCENT) {
            return _materialSelector.get('scene');
        }

        // hover does not work when the object is translucent or frozen
        var checkHover = true;

        var matchedFilter = _overrideCompoundFilter.getApplyFilterId(object);

        var material = null;
        var materialName = '';
        switch (matchedFilter) {
            case EnumFilterType.ISOLATE_TRANSLUCENT:
            case EnumFilterType.ISOLATE_TRANSLUCENT_OTHERS:
            case EnumFilterType.ISOLATE_CONDITION_TRANSLUCENT_OTHERS:
                material = this.getIsolateMaterial();
                checkHover = false;
                break;
            case EnumFilterType.CONDITION_TRANSLUCENT_OTHERS:
            case EnumFilterType.TRANSLUCENT:
            case EnumFilterType.TRANSLUCENT_OTHERS:
                material = _materialSelector.get('scene');
                checkHover = false;
                break;
            case EnumFilterType.SELECTED:
                material = _materialSelector.get('selection');
                break;
            case EnumFilterType.OVERRIDEFILTER:
                materialName = _basicFilterList[EnumFilterType.OVERRIDEFILTER].getMatchItem(object);
                break;
            case EnumFilterType.USER_OVERRIDE:
                var itemValue = _basicFilterList[EnumFilterType.USER_OVERRIDE].getMatchItem(object);
                if (itemValue.color) {

                    materialName = _materialSelector.getMaterialNameByColor(itemValue);
                } else if (itemValue.material) {

                    materialName = itemValue.material;
                } else {

                    // set material directly
                    materialName = itemValue;
                }
                break;
            case EnumFilterType.CONDITION_OVERRIDE:
                itemValue = _basicFilterList[EnumFilterType.CONDITION_OVERRIDE].getMatchItem(object);
                if (itemValue.color) {
                    materialName = _materialSelector.getMaterialNameByColor(itemValue.color);
                } else {

                    materialName = itemValue.material;
                }
                break;

            case EnumFilterType.FROZENFILTER:
            case EnumFilterType.FROZENCONDITIONFILTER:
                // if hit frozen filter, the object has no override material
                checkHover = false;
                break;
        }

        if (!material && materialName !== '') {
            if (!_materialSelector.has(materialName)) {

                //console.log("no set override material, use default material!");
                materialName = _materialSelector.getDefaultMaterialName();
            }

            material = _materialSelector.get(materialName);
        }

        if (_hoverId && _hoverId === object.name && checkHover) {
            material = _materialSelector.getHoverMaterial(material ? material : null);
        }

        return material;
    };

    this._hasHighPriorityOverrideMaterial = function (object) {
        if (_hoverId && _hoverId === object.name) {
            return true;
        }

        return _highPriorityOverrideCompoundFilter.apply(object);
    };

    this._isHiddenFileId = function (object) {
        return _hiddenFileIdCompoundFilter.apply(object);
    };

    this._hasHiddenFileIdFilter = function () {
        return !_hiddenFileIdCompoundFilter.isEmpty();
    };

    this._hasVisibleFilter = function () {
        return this.getSceneState() === EnumSceneState.HIDDEN || !_visibleCompoundFilter.isEmpty();
    };

    this._hasSelectableFilter = function () {
        return this.getSceneState() === EnumSceneState.TRANSLUCENT || !_selectableCompoundFilter.isEmpty();
    };

    this._hasOverrideMaterialFilter = function () {
        return this.getSceneState() === EnumSceneState.TRANSLUCENT || _hoverId !== undefined || !_overrideCompoundFilter.isEmpty();
    };

    this._hasLowPriorityOverride = function () {
        if (_overrideCompoundFilter.isEmpty()) return false;

        return _overrideCompoundFilter.hasFilterNotIn(_highPriorityOverrideCompoundFilter);
    };

    this._isEmptySelections = function () {
        return _basicSelectedFilter.isEmpty();
    };

    this._setHoverMaterial = function (params) {
        _materialSelector.setHoverMaterial(params);
    };

    this._setHoverId = function (id) {
        _hoverId = id;
    };

    this._clearHoverId = function () {
        _hoverId = undefined;
    };

    // helper method
    //
    this._getSelectedIds = function () {
        var selectedItems = _basicSelectedFilter.get();
        var ids = [];
        for (var id in selectedItems) {
            ids.push(id);
        }

        return ids;
    };

    this._getSelected = function () {

        return _basicSelectedFilter.get();
    };

    this._getFilterType = function () {

        return EnumFilterType;
    };
};
// base class for all filters
//
CLOUD.BasicFilter = function (type) {
    this._type = type;
    this._enabled = false;
    this._items = {};

    this._relatedCompoundFilterList = [];
};

CLOUD.BasicFilter.prototype.getType = function () {
    return this._type;
};

CLOUD.BasicFilter.prototype.get = function () {
    return this._items;
};

CLOUD.BasicFilter.prototype.getAll = function () {

    return this._items;
};

CLOUD.BasicFilter.prototype.clearAll = function () {
    var scope = this;
    scope._items = {};

    if (scope._enabled) {
        scope._enabled = false;
        scope.enableStateChanged();
    }
};

CLOUD.BasicFilter.prototype.clear = function () {
    this.clearAll();
};

CLOUD.BasicFilter.prototype.isEmpty = function () {
    return !this._enabled;
};

CLOUD.BasicFilter.prototype.forceEnable = function () {
    if (!this._enabled) {
        this._enabled = true;
        this.enableStateChanged();
    }
};

CLOUD.BasicFilter.prototype.setByData = function (data) {
    var scope = this;

    function isEmpty(obj) {

        // null and undefined are "empty"
        if (obj == null) return true;

        // If it isn't an object at this point
        if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) !== "object") return true;

        // Otherwise, does it have any properties of its own?
        // Note that this doesn't handle
        // toString and valueOf enumeration bugs in IE < 9
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) return false;
        }

        return true;
    }

    if (isEmpty(data)) {
        scope._items = {};

        if (scope._enabled) {
            scope._enabled = false;
            scope.enableStateChanged();
        }
    } else {
        scope._items = data;

        if (!scope._enabled) {
            scope._enabled = true;
            scope.enableStateChanged();
        }
    }
};

// require to override this method in child classes
CLOUD.BasicFilter.prototype.match = function (object) {
    return false;
};

CLOUD.BasicFilter.prototype.registerToCompoundFilter = function (compoundFilter) {
    this._relatedCompoundFilterList.push(compoundFilter);
};

CLOUD.BasicFilter.prototype.enableStateChanged = function () {
    var scope = this;

    for (var i = 0, len = scope._relatedCompoundFilterList.length; i < len; i++) {
        scope._enabled ? scope._relatedCompoundFilterList[i].addBaseFilter(scope) : scope._relatedCompoundFilterList[i].removeBaseFilter(scope);
    }
};

/***************************************************************
 *
 ***************************************************************/

CLOUD.BasicIdFilter = function (type) {
    CLOUD.BasicFilter.call(this, type);
};

CLOUD.BasicIdFilter.prototype = Object.create(CLOUD.BasicFilter.prototype);
CLOUD.BasicIdFilter.prototype.constructor = CLOUD.BasicIdFilter;

CLOUD.BasicIdFilter.prototype.add = function (ids) {
    var scope = this;
    var items = scope._items;

    if (ids && ids.length > 0) {
        for (var i = 0, len = ids.length; i < len; ++i) {
            items[ids[i]] = true;
        }

        if (!scope._enabled) {
            scope._enabled = true;
            scope.enableStateChanged();
        }
    }
};

CLOUD.BasicIdFilter.prototype.remove = function (ids) {
    var scope = this;
    var items = scope._items;

    if (ids && ids.length > 0) {
        for (var i = 0, len = ids.length; i < len; ++i) {

            var id = ids[i];

            if (items.hasOwnProperty(id)) {
                delete items[id];
            }
        }

        if (items.length === 0 && scope._enabled) {
            scope._enabled = false;
            scope.enableStateChanged();
        }
    }
};

CLOUD.ListFilter = function (type) {
    CLOUD.BasicFilter.call(this, type);
};

CLOUD.ListFilter.prototype = Object.create(CLOUD.BasicFilter.prototype);
CLOUD.ListFilter.prototype.constructor = CLOUD.ListFilter;

CLOUD.ListFilter.prototype.remove = function (name, keys) {
    var scope = this;
    var item = scope._items[name];

    if (item && keys && keys.length > 0) {
        for (var i = 0, len = keys.length; i < len; ++i) {

            var key = keys[i];

            if (item.hasOwnProperty(key)) {
                delete item[key];
            }
        }

        if (CLOUD.Utils.isEmptyObject(scope._items) && scope._enabled) {
            scope._enabled = false;
            scope.enableStateChanged();
        }
    }
};

CLOUD.ListFilter.prototype.add = function (name, keys, value) {
    var scope = this;

    var items = scope._items;
    var item = items[name];

    if (keys && keys.length > 0) {
        if (value === undefined) {
            value = true;
        }

        if (!item) {
            item = items[name] = {};
        }

        for (var i = 0, len = keys.length; i < len; ++i) {
            item[keys[i]] = value;
        }

        if (!scope._enabled) {
            scope._enabled = true;
            scope.enableStateChanged();
        }
    }
};

CLOUD.ListFilter.prototype.clear = function (name) {
    var scope = this;
    var items = scope._items;

    if (items.hasOwnProperty(name)) {

        delete items[name];
        //_items[name] = {};

        if (CLOUD.Utils.isEmptyObject(items) && scope._enabled) {
            scope._enabled = false;
            scope.enableStateChanged();
        }
    }
};

CLOUD.UserListFilter = function (type) {
    CLOUD.BasicFilter.call(this, type);
};

CLOUD.UserListFilter.prototype = Object.create(CLOUD.ListFilter.prototype);
CLOUD.UserListFilter.prototype.constructor = CLOUD.UserListFilter;

CLOUD.UserListFilter.prototype.match = function (object) {

    return this.getMatchItem(object) !== null;
};

CLOUD.UserListFilter.prototype.getMatchItem = function (object) {
    var items = this._items;
    var userData = object.userData;
    if (userData) {
        for (var name in items) {
            var item = items[name];
            var key = userData[name];

            if (key && item[key] !== undefined) {
                return item[key];
            }
        }
    }

    return null;
};

CLOUD.OverrideListFilter = function (type) {
    CLOUD.BasicFilter.call(this, type);
};

CLOUD.OverrideListFilter.prototype = Object.create(CLOUD.ListFilter.prototype);
CLOUD.OverrideListFilter.prototype.constructor = CLOUD.OverrideListFilter;

CLOUD.OverrideListFilter.prototype.match = function (object) {

    return this.getMatchItem(object) !== null;
};

CLOUD.OverrideListFilter.prototype.getMatchItem = function (object) {
    var items = this._items;
    var id = object.name;
    for (var name in items) {

        var item = items[name];
        if (item[id]) {

            return item[id];
        }
    }

    return null;
};

CLOUD.ConditionFilter = function (type) {
    CLOUD.BasicFilter.call(this, type);
};

CLOUD.ConditionFilter.prototype = Object.create(CLOUD.BasicFilter.prototype);
CLOUD.ConditionFilter.prototype.constructor = CLOUD.ConditionFilter;

CLOUD.ConditionFilter.prototype.match = function (object) {

    function matchConditions(conditions, userData) {

        // 多个数组取并集
        var isMatch;
        for (var i = 0, len = conditions.length; i < len; ++i) {
            isMatch = true;
            var condition = conditions[i];
            for (var attr in condition) {
                if (condition[attr] != userData[attr]) {
                    isMatch = false;
                    break;
                }
            }

            if (isMatch) {
                return true;
            }
        }

        return false;
    }

    var userData = object.userData;
    if (userData) {

        if (!matchConditions(this._items, userData)) return false;
    }

    return true;
};

CLOUD.MultiConditionFilter = function (type) {
    CLOUD.BasicFilter.call(this, type);
};

CLOUD.MultiConditionFilter.prototype = Object.create(CLOUD.BasicFilter.prototype);
CLOUD.MultiConditionFilter.prototype.constructor = CLOUD.MultiConditionFilter;

CLOUD.MultiConditionFilter.prototype.match = function (object) {

    return this.getMatchItem(object) !== null;
};

CLOUD.MultiConditionFilter.prototype.getMatchItem = function (object) {
    var conditions = this._items;
    var userData = object.userData;

    var isMatch;
    if (userData) {

        var len = conditions.length;
        for (var i = 0; i < len; ++i) {
            var item = conditions[i];
            var condition = item.condition;
            isMatch = true;
            for (var attr in condition) {

                if (condition[attr] != userData[attr]) {
                    isMatch = false;
                    break;
                }
            }

            if (isMatch) {
                return item;
            }
        }
    }

    return null;
};

/***************************************************************
 *
 ***************************************************************/
CLOUD.FileIdFilter = function (type) {
    CLOUD.BasicIdFilter.call(this, type);
};

CLOUD.FileIdFilter.prototype = Object.create(CLOUD.BasicIdFilter.prototype);
CLOUD.FileIdFilter.prototype.constructor = CLOUD.FileIdFilter;

CLOUD.FileIdFilter.prototype.match = function (object) {
    var userData = object.userData;

    if (userData) {

        var fileId = userData.sceneId;
        if (fileId) {
            return this._items[fileId] ? true : false;
        }
    }

    return false;
};

CLOUD.GeneralIdFilter = function (type) {
    CLOUD.BasicIdFilter.call(this, type);
};

CLOUD.GeneralIdFilter.prototype = Object.create(CLOUD.BasicIdFilter.prototype);
CLOUD.GeneralIdFilter.prototype.constructor = CLOUD.GeneralIdFilter;

CLOUD.GeneralIdFilter.prototype.match = function (object) {
    return this._items[object.name] ? true : false;
};

CLOUD.FilterResultMode = {
    MATCH_RETURN_TRUE: 0,
    MATCH_RETURN_FALSE: 1,
    NOMATCH_RETURN_TRUE: 2,
    NOMATCH_RETURN_FALSE: 3
};

CLOUD.CompoundFilter = function (ret) {
    // latest filter is added to the last of the list
    this._activeFilterList = [];

    // key is filter id, value is the parse mode to filter result
    this._filterResultModes = {};

    // default return value when check object with the filter
    this._defaultRetValue = ret;

    // priority for filter
    // if not set, the last added filter has the highest priority
    this._filterPriority = null;
};

CLOUD.CompoundFilter.prototype.setFilterMode = function (modes) {
    this._filterResultModes = modes;
};

CLOUD.CompoundFilter.prototype.setFilterPriority = function (priority) {
    this._filterPriority = priority;
};

CLOUD.CompoundFilter.prototype.addBaseFilter = function (filter) {
    var activeList = this._activeFilterList;
    var i = activeList.indexOf(filter);

    if (this._filterPriority === null) {
        if (i === -1) {
            // append the filter to the last of the list
            activeList.push(filter);
        } else if (i !== activeList.length - 1) {

            // if the filter is in the list and not in the last, remove it at first
            activeList.splice(i, 1);

            // append the filter to the last of the list
            activeList.push(filter);
        }
    } else {
        if (activeList.length === 0) {
            activeList.push(filter);
        } else {
            if (i !== -1 && i !== activeList.length - 1) {
                // if the filter is in the list and not in the last, remove it at first
                activeList.splice(i, 1);
            }

            var priority = this._filterPriority[filter.getType()];
            // find proper position according to priority
            for (var li = 0, len = activeList.length; li < len; li++) {
                if (this._filterPriority[activeList[li].getType()] > priority) {
                    activeList.splice(li, 0, filter);
                    break;
                }
            }

            if (li === len) {
                activeList.push(filter);
            }
        }
    }
};

CLOUD.CompoundFilter.prototype.removeBaseFilter = function (filter) {
    // remove the filter from list
    var i = this._activeFilterList.indexOf(filter);
    if (i !== -1) {
        this._activeFilterList.splice(i, 1);
    }
};

CLOUD.CompoundFilter.prototype.isEmpty = function () {
    return this._activeFilterList.length === 0;
};

CLOUD.CompoundFilter.prototype.hasFilterNotIn = function (other) {
    var filterList = this._activeFilterList;

    for (var i = filterList.length - 1; i >= 0; i--) {
        var filter = filterList[i];
        if (other._filterResultModes[filter.getType()] === undefined) {
            return true;
        }
    }

    return false;
};

CLOUD.CompoundFilter.prototype.apply = function (object) {
    var scope = this;
    var parseMode = CLOUD.FilterResultMode;
    var filter;
    for (var i = scope._activeFilterList.length - 1; i >= 0; i--) {
        filter = scope._activeFilterList[i];
        switch (scope._filterResultModes[filter.getType()]) {
            case parseMode.MATCH_RETURN_TRUE:
                if (filter.match(object)) return true;
                break;

            case parseMode.MATCH_RETURN_FALSE:
                if (filter.match(object)) return false;
                break;

            case parseMode.NOMATCH_RETURN_TRUE:
                if (!filter.match(object)) return true;
                break;

            case parseMode.NOMATCH_RETURN_FALSE:
                if (!filter.match(object)) return false;
                break;

        }
    }

    return scope._defaultRetValue;
};

CLOUD.CompoundFilter.prototype.getApplyFilterId = function (object) {
    var scope = this;
    var parseMode = CLOUD.FilterResultMode;
    var filter;
    for (var i = scope._activeFilterList.length - 1; i >= 0; i--) {
        filter = scope._activeFilterList[i];
        switch (scope._filterResultModes[filter.getType()]) {
            case parseMode.MATCH_RETURN_TRUE:
            case parseMode.MATCH_RETURN_FALSE:
                if (filter.match(object)) return filter.getType();
                break;

            case parseMode.NOMATCH_RETURN_TRUE:
            case parseMode.NOMATCH_RETURN_FALSE:
                if (!filter.match(object)) return filter.getType();
                break;

        }
    }

    return -1;
};

var CloudTouch = CloudTouch || {};

(function () {
    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;

    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };

    var INPUT_TYPE_TOUCH = 'touch';

    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;

    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

    var PROPS_XY = ['x', 'y'];
    var PROPS_CLIENT_XY = ['clientX', 'clientY'];

    // 处理touch事件
    var touchsHandler = function touchsHandler(manage, event) {
        var manage_scope = manage;
        var input = {
            pointers: event.touches,
            changedPointers: event.changedTouches,
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: event
        };

        var pointersLen = event.touches.length;
        var changedPointersLen = event.changedTouches.length;
        var eventType = TOUCH_INPUT_MAP[event.type];
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;

        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;

        if (isFirst) {
            manage_scope.session = {};
        }

        input.eventType = eventType;

        computeTouchData(manage_scope, input);

        manage_scope.session.prevInput = input;
    };

    // 复制touch数据
    var simpleCloneTouchData = function simpleCloneTouchData(input) {
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: Math.round(input.pointers[i].clientX),
                clientY: Math.round(input.pointers[i].clientY)
            };
            i++;
        }

        return {
            timeStamp: Date.now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX || 0,
            deltaY: input.deltaY || 0
        };
    };

    // 得到所有点的中心点
    var getCenter = function getCenter(pointers) {
        var pointersLength = pointers.length;

        // no need to loop when only one touch
        if (pointersLength === 1) {
            return {
                x: Math.round(pointers[0].clientX),
                y: Math.round(pointers[0].clientY)
            };
        }

        var x = 0,
            y = 0,
            i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }

        return {
            x: Math.round(x / pointersLength),
            y: Math.round(y / pointersLength)
        };
    };

    // 计算并缓存touch数据
    var computeTouchData = function computeTouchData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;

        // store the first input to calculate the distance and direction
        if (!session.firstInput) {
            session.firstInput = simpleCloneTouchData(input);
        }

        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneTouchData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }

        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

        var center = input.center = getCenter(pointers);
        input.timeStamp = Date.now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;

        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);

        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

        // 计算偏移量
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);

        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
    };

    // 计算输入数据的偏移量
    var computeDeltaXY = function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};

        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };

            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }

        // 相对第一个点的偏移量
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);

        if (input.eventType === INPUT_START) {
            // 相对前一个点的偏移量
            input.relativeDeltaX = 0;
            input.relativeDeltaY = 0;
            // 相对前一个点的旋转量
            input.relativeRotation = 0;
            // 相对前一个点的缩放量
            input.relativeScale = 1;
            // 相对前一个点的角度变化量
            input.deltaAngle = 0;
        } else {
            // 相对前一个点的偏移量
            input.relativeDeltaX = center.x - prevInput.center.x;
            input.relativeDeltaY = center.y - prevInput.center.y;
            // 相对前一个点的旋转量
            input.relativeRotation = input.rotation - prevInput.rotation;
            // 相对前一个点的缩放量
            input.relativeScale = input.scale / prevInput.scale;
            // 相对前一个点的角度变化量
            input.deltaAngle = input.angle - prevInput.angle;
        }
    };

    // 获得点的方向
    var getDirection = function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }

        if (Math.abs(x) >= Math.abs(y)) {
            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }

        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
    };

    // 计算两个点的距离
    var getDistance = function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];

        return Math.sqrt(x * x + y * y);
    };

    // 计算两个点的角度
    var getAngle = function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x);
    };

    // 计算两个点集的旋转角度
    var getRotation = function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
    };

    // 计算两个点集的缩放系数
    var getScale = function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    };

    // export it
    CloudTouch.proxy = {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,
        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,
        touchsHandler: touchsHandler
    };
})();
CLOUD.CameraControl = function (viewer, camera, domElement, onChange) {
    "use strict";

    this.viewer = viewer;
    this.camera = camera;
    this.domElement = domElement;

    this.intersector = new CLOUD.IntersectHelper(viewer.getFilters());

    // Set to false to disable this control
    this.enabled = true;

    // the orbit center
    this.pivot = null;

    var geometry = new THREE.SphereBufferGeometry(15, 64, 64);
    this.pivotBall = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
        color: 0xffffff,
        depthTest: false,
        opacity: 0.5,
        transparent: true
    }));

    geometry = new THREE.SphereBufferGeometry(1, 64, 64);
    this.pivotCenter = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
        color: 0xff0000,
        depthTest: false,
        opacity: 0.5,
        transparent: true
    }));

    //this.movementSpeed = 0.005 * CLOUD.GlobalData.SceneSize; // 移动速度
    this.movementSpeed = 0.0008 * CLOUD.GlobalData.SceneSize; // 移动速度
    this.defaultMovementSpeed = this.movementSpeed;
    this.minMovementSpeed = 0.01;

    this.minDollyDistance = 2.0;

    // This option actually enables dollying in and out; left as "zoom" for
    // backwards compatibility
    this.noZoom = false;
    this.zoomSpeed = 0.2;

    // Limits to how far you can dolly in and out
    //this.minDistance = camera.near;//
    this.minDistance = 0.1; // 0.000001; // 可能影响pick，pick对象与camera.near有关，是否这里也设置成camera.near？待进一步测试
    //this.maxDistance = Infinity;
    this.maxDistance = camera.far - CLOUD.GlobalData.SceneSize * 2; //camera.far * 0.9

    this.defaultThroughOutDistance = 0.1;

    // Set to true to disable this control
    this.noRotate = false;
    this.rotateSpeed = 1.0;

    // Set to true to disable this control
    this.noPan = false;
    this.keyPanSpeed = 2.0; // pixels moved per arrow key push
    this.defaultKeyPanSpeed = this.keyPanSpeed;
    this.minKeyPanSpeed = 0.01;
    //this.movementSpeedMultiplier = 1.0;

    // Set to true to automatically rotate around the target
    this.autoRotate = true;
    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

    // How far you can orbit vertically, upper and lower limits.
    // Range is 0 to Math.PI radians.
    this.minPolarAngle = 0; // radians
    this.maxPolarAngle = Math.PI; // radians

    // How far you can orbit horizontally, upper and lower limits.
    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
    this.minAzimuthAngle = -Infinity; // radians
    this.maxAzimuthAngle = Infinity; // radians

    this.enablePassThrough = true; // 允许缩放穿透

    this.isDisableRotate = false; // 禁止旋转

    // Set to true to disable use of the keys
    this.noKeys = false;

    // The four arrow keys
    this.keys = {
        ALT: 18,
        BACKSPACE: 8,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        A: 65,
        D: 68,
        E: 69,
        Q: 81,
        S: 83,
        W: 87,
        PLUS: 187,
        SUB: 189,
        ZERO: 48,
        ESC: 27
    };

    // 限制Z轴, 因为做过场景旋转，故场景Z轴其实对应坐标Y轴
    this.isConstrainedAxisZ = false;
    var _zAxisUp = new THREE.Vector3(0, 1, 0);

    var scope = this;
    var EPS = 0.000001;

    var rotateStart = new THREE.Vector2();
    var rotateEnd = new THREE.Vector2();
    var rotateDelta = new THREE.Vector2();

    var panStart = new THREE.Vector2();
    var panEnd = new THREE.Vector2();
    var panDelta = new THREE.Vector2();
    var panOffset = new THREE.Vector3();
    var pan = new THREE.Vector3();
    var panDeltaBasedWorld = new THREE.Vector3();
    var worldDimension = new THREE.Vector2();

    var dollyStart = new THREE.Vector2();
    var dollyEnd = new THREE.Vector2();
    var dollyDelta = new THREE.Vector2();
    var dollyCenter = new THREE.Vector2();

    var theta;
    var phi;
    var phiDelta = 0;
    var thetaDelta = 0;
    var scale = 1;

    var lastPosition = new THREE.Vector3();
    var lastQuaternion = new THREE.Quaternion();

    var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2 };
    var state = STATE.NONE;

    var lastTrackingPoint;

    var _pointRotateMode = CLOUD.PointRotateMode.MOUSEPOINT;

    /**
     * 设置绕点旋转模式
     *
     * @param {Number} mode - 模式 参见CLOUD.PointRotateMode
     */
    this.setPointRotateMode = function (mode) {
        _pointRotateMode = mode;
    };

    /**
     * 获得绕点旋转模式
     *
     * @return {Number} mode - 模式 参见CLOUD.PointRotateMode
     */
    this.getPointRotateMode = function () {
        return _pointRotateMode;
    };

    this.destroy = function () {
        this.viewer = null;
    };

    this.IsIdle = function () {
        return state === STATE.NONE;
    };

    this.getFrustum = function () {

        return this.camera.getFrustum();
    };

    this.getCamera = function () {

        return this.camera;
    };

    this._handleRotation = function () {

        var camera = this.camera;
        var position = camera.position;
        var target = camera.target;
        var camDir = camera.getWorldDirection();

        var eye = target.clone().sub(position);
        var eyeDistance = eye.length();

        var viewTrf = null;
        var pivot = this.pivot;

        // 调整相机位置
        var adjustCameraPosition = function adjustCameraPosition(trf) {

            var viewVec, viewLength, newViewDir;
            var newTarget = new THREE.Vector3(); // 新目标点

            if (pivot) {

                viewVec = position.clone().sub(pivot);
                viewLength = viewVec.length();
                viewVec.normalize();

                newViewDir = viewVec.clone().applyQuaternion(trf).normalize();

                // 相机新位置
                position.copy(pivot).add(newViewDir.multiplyScalar(viewLength));

                // 保持相机到目标点的距离不变
                camDir.applyQuaternion(trf).normalize();

                // 设置target新位置
                newTarget.copy(position).add(camDir.multiplyScalar(eyeDistance));
                target.copy(newTarget);
            } else {

                viewVec = eye.clone();
                viewLength = eyeDistance;
                viewVec.normalize();

                newViewDir = viewVec.clone().applyQuaternion(trf).normalize();

                // 设置target新位置
                newTarget.copy(position).add(newViewDir.multiplyScalar(viewLength));
                target.copy(newTarget);
            }
        };

        var up = camera.realUp || camera.up;
        var rightDir = camDir.clone().cross(up).normalize();
        var realUp = rightDir.clone().cross(camDir).normalize();
        camera.realUp.copy(realUp);

        var rotAxis;

        // 锁定Z轴
        if (this.isConstrainedAxisZ) {

            // 水平旋转
            if (Math.abs(thetaDelta) > Math.abs(phiDelta)) {

                rotAxis = _zAxisUp;
                viewTrf = new THREE.Quaternion().setFromAxisAngle(rotAxis, thetaDelta);
                adjustCameraPosition(viewTrf);
                camera.realUp.applyQuaternion(viewTrf).normalize();
            }
        } else {

            // 水平旋转
            if (Math.abs(thetaDelta) > Math.abs(phiDelta)) {

                // remark: this.camera.up 的使用有些奇怪，大多数都被置成了 THREE.Object3D.DefaultUp，后续需要在重新考虑下
                // 当this.camera.up为THREE.Object3D.DefaultUp时，其实水平旋转就是锁定了Z轴的旋转(模型的Z轴对应场景的Y轴)
                rotAxis = camera.up.clone().normalize();
                viewTrf = new THREE.Quaternion().setFromAxisAngle(rotAxis, thetaDelta);
                adjustCameraPosition(viewTrf);
                camera.realUp.applyQuaternion(viewTrf).normalize();
            } else if (Math.abs(phiDelta) > 0.01) {
                // 垂直旋转

                rotAxis = camDir.clone().cross(up).normalize();
                viewTrf = new THREE.Quaternion().setFromAxisAngle(rotAxis, phiDelta);
                adjustCameraPosition(viewTrf);
                camera.realUp.applyQuaternion(viewTrf).normalize();

                // 旋转180度时，up的y值应该反向，否则移动会反
                this.adjustCameraUp();
            }
        }
    };

    this.update = function () {

        return function (forceRender, updateRenderList) {

            var camera = this.camera;

            if (state !== STATE.NONE) {
                this.dirtyCamera(true);
            }

            // 处理旋转
            if (!this.isDisableRotate && state === STATE.ROTATE) {

                this._handleRotation();
            }

            // 处理平移
            if (state === STATE.PAN) {

                camera.target.add(pan);
                camera.position.add(pan);
            }

            // lookAt使用realUp
            var tmpUp = new THREE.Vector3();
            tmpUp.copy(camera.up);
            camera.up.copy(camera.realUp);
            camera.lookAt(camera.target);
            camera.up.copy(tmpUp);
            camera.updateMVP();

            thetaDelta = 0;
            phiDelta = 0;
            scale = 1;
            pan.set(0, 0, 0);

            if (forceRender) {
                //CLOUD.Logger.log("CameraControl.forceRender");
                if (updateRenderList !== undefined) {
                    this.needUpdateRenderList(updateRenderList);
                }

                onChange();

                this.dirtyCamera(false);

                lastPosition.copy(camera.position);
                lastQuaternion.copy(camera.quaternion);
            } else {

                // update condition is:
                // min(camera displacement, camera rotation in radians)^2 > EPS
                // using small-angle approximation cos(x/2) = 1 - x^2 / 8

                if (lastPosition.distanceToSquared(camera.position) > EPS || 8 * (1 - lastQuaternion.dot(camera.quaternion)) > EPS) {

                    //CLOUD.Logger.log("CameraControl.render");
                    onChange();

                    this.dirtyCamera(false);

                    lastPosition.copy(camera.position);
                    lastQuaternion.copy(camera.quaternion);
                }
            }
        };
    }();

    this.updateAuto = function () {

        var offset = new THREE.Vector3();

        // so camera.up is the orbit axis
        var quat = new THREE.Quaternion().setFromUnitVectors(camera.up, new THREE.Vector3(0, 1, 0));
        var quatInverse = quat.clone().inverse();

        var lastPosition = new THREE.Vector3();
        var lastQuaternion = new THREE.Quaternion();

        return function () {

            var position = this.camera.position;

            offset.copy(position).sub(this.camera.target);

            // rotate offset to "y-axis-is-up" space
            offset.applyQuaternion(quat);

            // angle from z-axis around y-axis

            theta = Math.atan2(offset.x, offset.z);

            // angle from y-axis

            phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);

            theta += thetaDelta;
            phi += phiDelta;

            // restrict theta to be between desired limits
            theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));

            // restrict phi to be between desired limits
            phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));

            // restrict phi to be betwee EPS and PI-EPS
            phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));

            var radius = offset.length() * scale;

            // restrict radius to be between desired limits
            radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));

            // move target to panned location
            this.camera.target.add(panOffset);

            offset.x = radius * Math.sin(phi) * Math.sin(theta);
            offset.y = radius * Math.cos(phi);
            offset.z = radius * Math.sin(phi) * Math.cos(theta);

            // rotate offset back to "camera-up-vector-is-up" space
            offset.applyQuaternion(quatInverse);

            position.copy(this.camera.target).add(offset);

            this.camera.lookAt(this.camera.target);

            thetaDelta = 0;
            phiDelta = 0;
            scale = 1;
            panOffset.set(0, 0, 0);

            lastPosition.copy(this.camera.position);
            lastQuaternion.copy(this.camera.quaternion);

            onChange();

            return true;
        };
    }();

    // 锁定Z轴
    this.lockAxisZ = function (isLock) {

        this.isConstrainedAxisZ = isLock;
    };

    this.updateView = function (updateRenderList) {

        if (updateRenderList !== undefined) {
            this.needUpdateRenderList(updateRenderList);
        }

        onChange();
    };

    // 是否需要更新RenderList
    this.needUpdateRenderList = function (need) {
        this.viewer.editorManager.isUpdateRenderList = need;
    };

    // 是否禁止旋转
    this.disableRotate = function (disable) {

        this.isDisableRotate = disable;
    };

    this.rotateLeft = function (angle) {
        if (angle === undefined) {
            angle = getAutoRotationAngle();
        }

        thetaDelta -= angle;
    };

    this.rotateUp = function (angle) {
        if (angle === undefined) {
            angle = getAutoRotationAngle();
        }

        phiDelta -= angle;
    };

    // pass in x,y of change desired in pixel space,
    // right and down are positive
    this.pan = function (deltaX, deltaY) {
        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
        var offset = new THREE.Vector3();

        // pass in distance in world space to move left
        function panLeft(distance) {
            var te = scope.camera.matrix.elements;

            // get X column of matrix
            offset.set(te[0], te[1], te[2]);
            offset.multiplyScalar(-distance);

            scope.camera.target.add(offset);
            scope.camera.position.add(offset);
        }

        // pass in distance in world space to move up
        function panUp(distance) {
            var te = scope.camera.matrix.elements;

            // get Y column of matrix
            offset.set(te[4], te[5], te[6]);
            offset.multiplyScalar(distance);

            scope.camera.target.add(offset);
            scope.camera.position.add(offset);
            //CLOUD.Logger.log("Warning!");
        }

        if (scope.camera.fov !== undefined) {
            // perspective
            var position = scope.camera.position;
            var targetDistance = position.clone().sub(scope.camera.target).length();

            // half of the fov is center to top of screen
            targetDistance *= Math.tan(scope.camera.fov / 2 * Math.PI / 180.0);

            //CLOUD.Logger.log(targetDistance);
            // we actually don't use screenWidth, since perspective camera is fixed to screen height
            panLeft(2 * deltaX * targetDistance / element.clientHeight);
            panUp(2 * deltaY * targetDistance / element.clientHeight);
        } else if (scope.camera.top !== undefined) {
            // orthographic
            panLeft(deltaX * (scope.camera.right - scope.camera.left) / element.clientWidth);
            panUp(deltaY * (scope.camera.top - scope.camera.bottom) / element.clientHeight);
        } else {
            // camera neither orthographic or perspective
            CLOUD.Logger.warn('WARNING: CloudPickEditor.js encountered an unknown camera type - pan disabled.');
        }
    };

    this.panOnWorld = function () {

        var startPoint = new THREE.Vector3();
        var endPoint = new THREE.Vector3();
        var delta = new THREE.Vector3();

        return function () {

            var canvasContainer = this.getContainerDimensions();

            // 规范化开始点
            var canvasX = panStart.x - canvasContainer.left;
            var canvasY = panStart.y - canvasContainer.top;
            startPoint.x = canvasX / canvasContainer.width;
            startPoint.y = canvasY / canvasContainer.height;

            // 规范化结束点
            canvasX = panEnd.x - canvasContainer.left;
            canvasY = panEnd.y - canvasContainer.top;
            endPoint.x = canvasX / canvasContainer.width;
            endPoint.y = canvasY / canvasContainer.height;

            delta.subVectors(endPoint, startPoint);

            var offsetX = -delta.x * worldDimension.x;
            var offsetY = delta.y * worldDimension.y;
            var deltaX = this.getWorldRight().multiplyScalar(offsetX);
            var deltaY = this.getWorldUp().multiplyScalar(offsetY);

            panDeltaBasedWorld.addVectors(deltaX, deltaY);

            pan.add(panDeltaBasedWorld);
        };
    }();

    this.dolly = function () {
        var pos = new THREE.Vector2(dollyCenter.x, dollyCenter.y);
        var intersectContext = this.getIntersectContext(pos);

        var centerPosition = this.intersector.hitTest(intersectContext);
        if (centerPosition != null) {
            if (Math.abs(scale - 1.0) < EPS) {
                return;
            }

            var cameraPos = this.camera.position;
            var eye = this.getWorldEye();

            var dir = new THREE.Vector3();
            dir.subVectors(centerPosition, cameraPos);

            var distance = dir.multiplyScalar(scale - 1).length();

            var newCameraPos = new THREE.Vector3();

            if (Math.abs(distance) < this.minDollyDistance) {
                newCameraPos.addVectors(cameraPos, dir.normalize().multiplyScalar(this.minDollyDistance));
            } else {
                newCameraPos.addVectors(cameraPos, dir);
            }

            this.camera.position.copy(newCameraPos);
            this.camera.target.copy(eye.add(newCameraPos));
        } else {
            scope.dollyByCenter();
        }
    };

    this.dollyIn = function (dollyScale) {
        if (dollyScale === undefined) {
            dollyScale = getZoomScale();
        }

        scale /= dollyScale;
    };

    this.dollyOut = function (dollyScale) {
        if (dollyScale === undefined) {
            dollyScale = getZoomScale();
        }

        scale *= dollyScale;
    };

    this.dollyByPoint = function (cx, cy) {

        if (Math.abs(scale - 1.0) < EPS) {
            return;
        }

        var minDistance = this.minDollyDistance;

        var cameraPos = this.camera.position;
        var eye = this.getWorldEye();
        var dollyPoint = this.getTrackingPoint(cx, cy);

        var dir = new THREE.Vector3();
        dir.subVectors(dollyPoint, cameraPos);

        var distance = dir.multiplyScalar(scale - 1).length();

        var newCameraPos = new THREE.Vector3();

        if (Math.abs(distance) < this.minDollyDistance) {
            newCameraPos.addVectors(cameraPos, dir.normalize().multiplyScalar(this.minDollyDistance));
        } else {
            newCameraPos.addVectors(cameraPos, dir);
        }

        this.camera.position.copy(newCameraPos);
        this.camera.target.copy(eye.add(newCameraPos));
    };

    this.dollyByCenter = function () {

        if (Math.abs(scale - 1.0) < EPS) {
            return;
        }

        var eye = this.getWorldEye();
        var lastLength = eye.length();
        var currLength = lastLength * scale;
        var deltaStep = currLength - lastLength;
        var dir = eye.clone().normalize();

        dir.multiplyScalar(deltaStep);
        this.camera.position.add(dir);
        this.camera.target.addVectors(this.camera.position, eye);
    };

    this.updateCamera = function (target, noRest) {

        this.dirtyCamera(true);

        lastPosition.copy(this.camera.position);
        lastQuaternion.copy(this.camera.quaternion);
        this.camera.target.copy(target);

        if (!noRest) {
            scope.reset();
        }
    };

    this.dirtyCamera = function (dirty) {
        this.camera.dirty = dirty;
    };

    this.modelView = function (forceRender, updateRenderList) {
        if (state !== STATE.NONE) {
            this.dirtyCamera(true);
        }

        var pivot = this.pivot !== null ? this.pivot : this.viewer.getScene().getBoundingBox().getCenter();
        var scope = this;

        if (state == STATE.ROTATE) {
            var position = this.camera.position;

            var eye = this.camera.target.clone().sub(position);
            var eyeDistance = eye.length();
            var viewVec = position.clone().sub(pivot);
            var viewLength = viewVec.length();
            var viewTrf = null;
            var camDir = this.camera.getWorldDirection();

            viewVec.normalize();

            var adjustCameraPosition = function adjustCameraPosition(trf) {
                var newTarget = new THREE.Vector3(); // 新目标点
                var newViewDir = viewVec.clone().applyQuaternion(trf).normalize();

                // 相机新位置
                position.copy(pivot).add(newViewDir.multiplyScalar(viewLength));

                // 保持相机到目标点的距离不变
                camDir.applyQuaternion(trf).normalize();
                newTarget.copy(position).add(camDir.multiplyScalar(eyeDistance));
                // 相机目标点位置
                scope.camera.target.copy(newTarget);
            };

            var up = this.camera.realUp || this.camera.up;
            var rightDir = camDir.clone().cross(up).normalize();
            var realUp = rightDir.clone().cross(camDir).normalize();
            this.camera.realUp.copy(realUp);

            var rotAxis;

            // 锁定Z轴
            if (this.isConstrainedAxisZ) {
                // 水平旋转
                if (Math.abs(thetaDelta) > Math.abs(phiDelta)) {

                    rotAxis = _zAxisUp;
                    viewTrf = new THREE.Quaternion().setFromAxisAngle(rotAxis, thetaDelta);
                    adjustCameraPosition(viewTrf);
                    this.camera.realUp.applyQuaternion(viewTrf).normalize();
                }
            } else {
                // 水平旋转
                if (Math.abs(thetaDelta) > Math.abs(phiDelta)) {

                    // remark: this.camera.up 的使用有些奇怪，大多数都被置成了 THREE.Object3D.DefaultUp，后续需要在重新考虑下
                    // 当this.camera.up为THREE.Object3D.DefaultUp时，其实水平旋转就是锁定了Z轴的旋转(模型的Z轴对应场景的Y轴)
                    rotAxis = this.camera.up.clone().normalize();
                    viewTrf = new THREE.Quaternion().setFromAxisAngle(rotAxis, thetaDelta);
                    adjustCameraPosition(viewTrf);
                    this.camera.realUp.applyQuaternion(viewTrf).normalize();
                } else if (Math.abs(phiDelta) > 0.01) {
                    // 垂直旋转

                    var EPS = 0.000001;

                    rotAxis = camDir.clone().cross(up).normalize();

                    var cross = new THREE.Vector3(0, 1, 0).clone().cross(up);
                    var dot = cross.dot(rightDir);
                    var angle = Math.asin(cross.length());
                    if (dot < 0) {
                        angle = -angle;
                    }
                    if (angle + phiDelta > Math.PI / 2 - EPS) {
                        phiDelta = Math.PI / 2 - EPS - angle;
                    } else if (angle + phiDelta < -Math.PI / 2 + EPS) {
                        phiDelta = -Math.PI / 2 + EPS - angle;
                    }

                    viewTrf = new THREE.Quaternion().setFromAxisAngle(rotAxis, phiDelta);
                    adjustCameraPosition(viewTrf);
                    this.camera.realUp.applyQuaternion(viewTrf).normalize();

                    // 旋转180度时，up的y值应该反向，否则移动会反
                    this.adjustCameraUp();
                }
            }

            if (scope.pivot != null) {
                scope.pivotBall.position.copy(scope.pivot);
                scope.pivotCenter.position.copy(scope.pivot);

                var scale = pivotBallSize();
                scope.pivotBall.scale.set(scale, scale, scale);
                scope.pivotCenter.scale.set(scale, scale, scale);
            } else {
                var scene = scope.viewer.getScene();
                var center = scene.getBoundingBox().getCenter();
                scope.pivotBall.position.copy(center);
                scope.pivotCenter.position.copy(center);

                var scale = pivotBallSize();
                scope.pivotBall.scale.set(scale, scale, scale);
                scope.pivotCenter.scale.set(scale, scale, scale);
            }

            scope.pivotBall.updateMatrixWorld();
            scope.viewer.getScene().add(scope.pivotBall);

            scope.pivotCenter.updateMatrixWorld();
            scope.viewer.getScene().add(scope.pivotCenter);
        }
    };

    this.getScene = function () {
        return this.viewer.getScene();
    };

    this.personView = function (forceRender, updateRenderList) {
        if (state !== STATE.NONE) {
            this.dirtyCamera(true);
        }

        var scope = this;

        if (state == STATE.ROTATE) {
            var position = this.camera.position;

            var eye = this.camera.target.clone().sub(position);
            var eyeDistance = eye.length();
            var camDir = this.camera.getWorldDirection();

            var up = this.camera.realUp || this.camera.up;
            var rightDir = camDir.clone().cross(up).normalize();
            var realUp = rightDir.clone().cross(camDir).normalize();
            this.camera.realUp.copy(realUp);

            var adjustCameraPosition = function adjustCameraPosition(trf) {
                var newTarget = new THREE.Vector3(); // 新目标点

                // 保持相机到目标点的距离不变
                camDir.applyQuaternion(trf).normalize();
                newTarget.copy(position).add(camDir.multiplyScalar(eyeDistance));
                // 相机目标点位置
                scope.camera.target.copy(newTarget);
            };

            var rotAxis, rotAngle;
            if (Math.abs(thetaDelta) > Math.abs(phiDelta)) {
                rotAxis = _zAxisUp;
                rotAngle = thetaDelta;
            } else if (!this.isConstrainedAxisZ) {
                rotAxis = rightDir;

                var cross = new THREE.Vector3(0, 1, 0).clone().cross(up);
                var dot = cross.dot(rightDir);
                var angle = Math.asin(cross.length());
                if (dot < 0) {
                    angle = -angle;
                }
                if (angle + phiDelta > Math.PI / 4 - EPS) {
                    phiDelta = Math.PI / 4 - EPS - angle;
                } else if (angle + phiDelta < -Math.PI / 4 + EPS) {
                    phiDelta = -Math.PI / 4 + EPS - angle;
                }

                rotAngle = phiDelta;
            }
            var viewTrf = new THREE.Quaternion().setFromAxisAngle(rotAxis, rotAngle);
            adjustCameraPosition(viewTrf);
            this.camera.realUp.applyQuaternion(viewTrf).normalize();
        }
    };

    this.touchUpdate = function () {
        var lastPosition = new THREE.Vector3();
        var lastQuaternion = new THREE.Quaternion();

        return function (forceRender, updateRenderList) {

            var position = this.camera.position;
            var sceneBoundingBox = this.viewer.getScene().getBoundingBox();

            if (sceneBoundingBox.containsPoint(position)) {
                this.personView(forceRender, updateRenderList);
            } else {
                this.modelView(forceRender, updateRenderList);
            }

            this.camera.target.add(pan);
            this.camera.position.add(pan);

            // lookAt使用realUp
            var tmpUp = new THREE.Vector3();
            tmpUp.copy(this.camera.up);
            this.camera.up.copy(this.camera.realUp);
            this.camera.lookAt(this.camera.target);
            this.camera.up.copy(tmpUp);
            this.camera.updateMVP();

            thetaDelta = 0;
            phiDelta = 0;
            scale = 1;
            pan.set(0, 0, 0);

            if (forceRender) {
                //CLOUD.Logger.log("CameraControl.forceRender");
                if (updateRenderList !== undefined) {
                    this.needUpdateRenderList(updateRenderList);
                }

                onChange();

                this.dirtyCamera(false);

                lastPosition.copy(this.camera.position);
                lastQuaternion.copy(this.camera.quaternion);
            } else {
                if (lastPosition.distanceToSquared(this.camera.position) > EPS || 8 * (1 - lastQuaternion.dot(this.camera.quaternion)) > EPS) {

                    //CLOUD.Logger.log("CameraControl.render");
                    onChange();

                    this.dirtyCamera(false);

                    lastPosition.copy(this.camera.position);
                    lastQuaternion.copy(this.camera.quaternion);
                }
            }
        };
    }();

    this.setState = function (val) {
        state = val;
    };

    this.reset = function () {
        state = STATE.NONE;

        //this.target.copy( this.target0 );
        //this.camera.position.copy( this.position0 );

        // Modified by xmh 2016-6-24 begin
        // 强制重刷一帧，设置视点后，将相机设成脏状态，不强制刷新，状态设成正常状态的时机可能会出错。
        // 问题对应：批注模式下,先设置视点，后加载批注，因为没有即时刷新，批注加载完成后，才开始render,这时批注才收到视点变化的消息，造成批注不能显示。
        //this.update();
        this.update(true);
        // Modified by xmh 2016-6-24 end
    };

    function getAutoRotationAngle() {
        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }

    function getZoomScale() {
        return Math.pow(0.95, scope.zoomSpeed);
    }

    this.beginRotate = function (cx, cy) {
        if (scope.noRotate === true) return;

        state = STATE.ROTATE;
        rotateStart.set(cx, cy);

        // 获得追踪点
        lastTrackingPoint = null;
        //var trackingPoint = this.getTrackingPoint(cx, cy);
    };

    this.beginZoom = function (cx, cy) {
        if (scope.noZoom === true) return;

        state = STATE.DOLLY;
        dollyStart.set(cx, cy);
    };

    this.beginPan = function (cx, cy) {
        if (scope.noPan === true) return;
        state = STATE.PAN;
        panStart.set(cx, cy);

        // 根据当前鼠标点获得世界坐标系中的宽高
        worldDimension = this.getWorldDimension(cx, cy);
        // 清零
        panDeltaBasedWorld.set(0, 0, 0);
    };

    this.endOperation = function () {
        state = STATE.NONE;
        this.intersector.lastIntersect = null;
        this.pivot = null;
    };

    // factor: 正数 - 放大， 负数 - 缩小
    this.zoom = function (factor, cx, cy) {

        state = STATE.DOLLY;

        if (cx === undefined || cy === undefined) {
            if (factor > 0) {
                this.dollyIn(1 - factor);
            } else {
                this.dollyOut(1 + factor);
            }

            this.dollyByCenter();
            this.update();
        } else {

            if (factor > 0) {
                this.dollyIn(1 - factor);
            } else {
                this.dollyOut(1 + factor);
            }

            this.dollyByPoint(cx, cy);
            this.update();
        }

        state = STATE.NONE;
    };

    // 基于相机空间的漫游
    this.fly = function (moveVector, quaternion) {
        this.camera.translateX(moveVector.x);
        this.camera.translateY(moveVector.y);
        this.camera.translateZ(moveVector.z);
        this.camera.quaternion.multiply(quaternion);

        // expose the rotation vector for convenience
        this.camera.rotation.setFromQuaternion(this.camera.quaternion, this.camera.rotation.order);

        // update target
        this.camera.target.copy(this.camera.position).add(this.camera.getWorldDirection());

        onChange();
    };

    // 基于世界空间的漫游
    this.flyOnWorld = function () {

        var up = this.camera.up.clone();

        if (this.camera.realUp) {
            this.camera.up.copy(this.camera.realUp);
        }

        // 使用realUp
        this.camera.lookAt(this.camera.target);

        if (this.camera.realUp) {
            this.camera.up.copy(up);
        }

        // 调用Render刷新
        onChange();
    };

    this.walkWithParallelEye = function (center) {

        var camera = this.camera;

        // 将相机移动到指定的点
        var eye = this.getWorldEye();
        var distance = eye.length();

        var newEye = new THREE.Vector3();
        newEye.subVectors(center, camera.position);

        var newDistance = newEye.length();

        newEye.y = 0;
        newEye.normalize();
        newEye.multiplyScalar(newDistance);

        camera.position.subVectors(center, newEye);
        camera.target.addVectors(camera.position, newEye.normalize().multiplyScalar(distance));

        var up = new THREE.Vector3(0, 1, 0);
        camera.up.copy(up);
        camera.realUp.copy(up);

        state = STATE.NONE; // fixed BIMFACEDM-2507: 按下鼠标键状态为被设置了STATE.ROTATE,进行平行视角时应该清除所有状态

        this.update(true);
    };
    this.processRotate = function (delta) {

        var currentState = state; // 保持状态

        state = STATE.ROTATE; // 将状态设置成旋转

        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

        // rotating across whole screen goes 360 degrees around
        scope.rotateLeft(2 * Math.PI * delta.x / element.clientWidth * scope.rotateSpeed);

        // rotating up and down along whole screen attempts to go 360, but limited to 180
        scope.rotateUp(2 * Math.PI * delta.y / element.clientHeight * scope.rotateSpeed);

        scope.update();

        state = currentState; // 恢复状态
    };

    this.process = function (cx, cy, forceRender) {

        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

        if (state === STATE.ROTATE) {
            if (scope.noRotate === true) return;

            rotateEnd.set(cx, cy);
            rotateDelta.subVectors(rotateEnd, rotateStart);

            if (rotateDelta.x == 0 && rotateDelta.y == 0) return;

            // rotating across whole screen goes 360 degrees around
            scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

            // rotating up and down along whole screen attempts to go 360, but limited to 180
            scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

            rotateStart.copy(rotateEnd);
        } else if (state === STATE.DOLLY) {
            if (scope.noZoom === true) return;

            dollyEnd.set(cx, cy);
            dollyDelta.subVectors(dollyEnd, dollyStart);
            if (dollyDelta.x == 0 && dollyDelta.y == 0) return;
            if (dollyDelta.y > 0) {
                //CLOUD.Logger.log("dollyOut");
                scope.dollyOut();
            } else {
                //CLOUD.Logger.log("dollyIn");
                scope.dollyIn();
            }

            scope.dollyByCenter();

            dollyStart.copy(dollyEnd);
        } else if (state === STATE.PAN) {
            if (scope.noPan === true) return;

            panEnd.set(cx, cy);
            panDelta.subVectors(panEnd, panStart);
            if (panDelta.x == 0 && panDelta.y == 0) return;

            scope.panOnWorld();
            //scope.pan( panDelta.x, panDelta.y );

            panStart.copy(panEnd);
        }

        if (state !== STATE.NONE) scope.update(forceRender);
    };

    this.processTouch = function (input, forceRender) {
        var pointersLength = input.pointers.length;

        if (pointersLength > 1) {
            // 多指操作
            // ROTATE
            if (scope.noRotate !== true) {
                state = STATE.ROTATE;

                var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
                var thresholdAngle = 0.5 * Math.PI / 180; // 0.5度

                if (input.deltaAngle < thresholdAngle && input.deltaAngle > -thresholdAngle) {
                    phiDelta += 2 * Math.PI * input.relativeDeltaY / element.clientWidth * scope.rotateSpeed;
                } else {
                    thetaDelta += input.relativeRotation;
                }
            }

            // DOLLY
            if (scope.noZoom !== true) {
                state = STATE.DOLLY;
                scale /= input.relativeScale;
            }
        } else {
            // 单指操作
            if (scope.noPan !== true) {
                state = STATE.PAN;

                var deltaX = input.relativeDeltaX;
                var deltaY = input.relativeDeltaY;

                scope.pan(deltaX, deltaY);
            }
        }

        if (state !== STATE.NONE) scope.update(forceRender);
    };

    /**
     * 获得canvas父容器尺寸 ({width : xxx, height : xxx, left : xxx, top : xxx})
     *
     * @return {Object} 如果父容器存在，则返回父容器尺寸， 否则，返回 null
     */
    this.getContainerDimensions = function () {
        return CLOUD.DomUtil.getContainerOffsetToClient(this.domElement);
    };

    this.computeFrustum = function () {

        var projectionMatrix = new THREE.Matrix4();
        var viewProjectionMatrix = new THREE.Matrix4();

        return function (x1, x2, y1, y2, frustum, dim) {

            var camera = this.camera;

            var ymax = camera.near * Math.tan(THREE.Math.degToRad(camera.fov * 0.5));
            var xmax = ymax * camera.aspect;

            var rx1 = (x1 - dim.left) / dim.width * 2 - 1;
            var rx2 = (x2 - dim.left) / dim.width * 2 - 1;
            var ry1 = -((y1 - dim.top) / dim.height) * 2 + 1;
            var ry2 = -((y2 - dim.top) / dim.height) * 2 + 1;

            projectionMatrix.makePerspective(rx1 * xmax, rx2 * xmax, ry1 * ymax, ry2 * ymax, camera.near, camera.far);

            camera.updateMatrixWorld();
            camera.matrixWorldInverse.getInverse(camera.matrixWorld);
            viewProjectionMatrix.multiplyMatrices(projectionMatrix, camera.matrixWorldInverse);
            frustum.setFromMatrix(viewProjectionMatrix);
        };
    }();

    this.screenToCanvas = function (cx, cy) {

        var dim = this.getContainerDimensions();
        return { x: cx - dim.left, y: cy - dim.top };
    };

    this.mapScreenToLocal = function (cx, cy, target) {
        var dim = this.getContainerDimensions();
        target.set(cx - dim.left, dim.height - (cy - dim.top));
    };

    this.mapWindowToViewport = function (cx, cy, target) {
        var dim = this.getContainerDimensions();
        var mouse = target || new THREE.Vector2();

        mouse.x = (cx - dim.left) / dim.width * 2 - 1;
        mouse.y = -((cy - dim.top) / dim.height) * 2 + 1;

        return mouse;
    };

    this.getCameraInfo = function () {
        var camInfo = new CLOUD.CameraInfo(this.camera.position, this.camera.target, this.camera.up);
        return JSON.stringify(camInfo);
    };

    // 放大缩小限制：根据相机与目标点距离来判断是否需要继续放大或缩小
    // 在限制范围内，可以继续缩放，否则，不再缩放
    this.isKeepZoom = function (zoom, minDistance, maxDistance) {
        if (minDistance === undefined) {
            minDistance = this.minDistance;
        }

        if (maxDistance === undefined) {
            maxDistance = this.maxDistance;
        }

        var position = this.camera.position;
        var target = this.camera.target;
        var offset = new THREE.Vector3();

        offset.copy(position).sub(target);
        var distance = offset.length() * (2 - zoom); // D = X + X * (1 - factor)

        if (distance < minDistance || distance > maxDistance) {
            return false;
        }

        return true;
    };

    this.computeRotation = function () {
        // 旋转矩阵
        var m1 = new THREE.Matrix4();
        m1.lookAt(this.camera.position, this.camera.target, this.camera.up);

        var quat2 = new THREE.Quaternion();
        quat2.setFromRotationMatrix(m1);

        // 获得旋转角
        var rotation = new THREE.Euler();
        rotation.setFromQuaternion(quat2, undefined, false);

        return rotation;
    };

    this.adjustCameraUp = function () {

        if (this.camera.realUp.y > 0) {

            this.camera.up = new THREE.Vector3(0, 1, 0);
        } else if (this.camera.realUp.y < 0) {

            this.camera.up = new THREE.Vector3(0, -1, 0);
        } else {

            if (this.camera.realUp.x > 0) {

                this.camera.up = new THREE.Vector3(1, 0, 0);
            } else if (this.camera.realUp.x < 0) {

                this.camera.up = new THREE.Vector3(-1, 0, 0);
            } else {

                if (this.camera.realUp.z > 0) {

                    this.camera.up = new THREE.Vector3(0, 0, 1);
                } else if (this.camera.realUp.z < 0) {

                    this.camera.up = new THREE.Vector3(0, 0, -1);
                }
            }
        }
    };

    this.getWorldEye = function () {
        return this.camera.target.clone().sub(this.camera.position);
    };

    this.getWorldRight = function () {
        var right = new THREE.Vector3();
        var up = this.camera.up;
        var eye = this.getWorldEye();
        right.crossVectors(eye, up);

        if (right.lengthSq() === 0) {
            if (up.z > up.y) eye.y -= 0.0001;else eye.z += 0.0001;

            right.crossVectors(eye, up);
        }

        return right.normalize();
    };

    this.getWorldUp = function () {
        var right = this.getWorldRight();
        var eye = this.getWorldEye();
        return right.cross(eye).normalize();
    };

    this.getWorldDimension = function (cx, cy) {

        var position = this.camera.position;
        var eye = this.getWorldEye().normalize();

        // 计算跟踪距离
        var trackingPoint = this.getTrackingPoint(cx, cy);
        var trackingDir = trackingPoint.clone().sub(position);
        var distance = Math.abs(eye.dot(trackingDir));

        var canvasContainer = this.getContainerDimensions();
        var aspect = canvasContainer.width / canvasContainer.height;
        var height = 2.0 * distance * Math.tan(THREE.Math.degToRad(this.camera.fov * 0.5));
        var width = height * aspect;

        return new THREE.Vector2(width, height);
    };

    this.pointToWorld = function (normalizedX, normalizedY) {

        var worldPoint = new THREE.Vector3(normalizedX, normalizedY, 0.0);
        worldPoint.unproject(camera);

        return worldPoint;
    };

    this.getTrackingPoint = function (cx, cy) {
        var pos = new THREE.Vector2(cx, cy);
        var intersectContext = this.getIntersectContext(pos);

        var trackingPoint = this.intersector.hitTest(intersectContext);
        if (!trackingPoint) {
            var mouse = intersectContext.mouse;

            var position = this.camera.position;
            var normEye = this.getWorldEye().normalize();
            var worldPoint = this.pointToWorld(mouse.x, mouse.y);

            var ray = new THREE.Ray();
            ray.origin.copy(position);
            ray.direction.copy(worldPoint.clone().sub(position).normalize());

            if (!lastTrackingPoint) {

                trackingPoint = this.getTrackingPointFromBoundingBox(normEye, ray);
            } else {

                // 保持上一次的基点和本次基点在同一平面内

                var plane = new THREE.Plane();
                plane.setFromNormalAndCoplanarPoint(normEye, lastTrackingPoint);

                trackingPoint = ray.intersectPlane(plane);

                // 如果没有取到点，说明上一次的点在相机背后，重新取点
                if (!trackingPoint) {

                    //CLOUD.Logger.log("trackingPoint === null");
                    trackingPoint = this.getTrackingPointFromBoundingBox(normEye, ray);
                } else {

                    // 基准点在相机位置，重新取点

                    var dist = trackingPoint.distanceTo(position);

                    if (dist < EPS) {

                        //CLOUD.Logger.log("equal");
                        trackingPoint = this.getTrackingPointFromBoundingBox(normEye, ray);
                    }
                }
            }

            // 没有取到点，则取worldPoint
            if (!trackingPoint) {

                CLOUD.Logger.log("tracking point is default!");
                trackingPoint = worldPoint;
            }
        }

        // 保存状态
        lastTrackingPoint = trackingPoint.clone();

        return trackingPoint;
    };

    // 获取相机到场景包围盒8个顶点的最大距离对应点所在平面与所给射线的交点
    this.getTrackingPointFromBoundingBox = function (direction, ray) {

        var scene = this.viewer.getScene();
        return scene.getTrackingPointFromBoundingBox(direction, ray);
    };

    this.updateCameraPosition = function (position) {

        // 将相机移动到指定的点
        var eye = this.getWorldEye();
        var distance = eye.length();

        // 平行视角
        //var dir = new THREE.Vector3(0, 0, -1);
        var dir = eye.clone();
        dir.y = 0;
        dir.normalize();
        dir.setLength(distance);

        var up = new THREE.Vector3(0, 1, 0);

        this.camera.up = up;
        this.camera.realUp = up.clone();

        this.camera.position.copy(position);
        this.camera.target.addVectors(this.camera.position, dir);
    };

    // 飞到指定点（平行视角）
    this.flyToPointWithParallelEye = function (point) {

        // 将相机移动到指定的点
        var eye = this.getWorldEye();
        var distance = eye.length();

        // 保持视角方向
        //var dir = new THREE.Vector3(0, 0, -1);
        var dir = eye.clone();
        dir.y = 0;
        dir.normalize();
        dir.setLength(distance);

        var up = new THREE.Vector3(0, 1, 0);

        this.camera.up = up;
        this.camera.realUp = up.clone();

        this.camera.position.copy(point);
        this.camera.target.addVectors(this.camera.position, dir);

        this.update(true);
    };

    // 飞到指定点（保持视角）
    this.flyToPoint = function (point) {

        var position = this.camera.position;
        var eye = this.getWorldEye();
        var normalizedEye = eye.clone().normalize();
        var trackingEye = point.clone().sub(position);
        var distance = Math.abs(normalizedEye.dot(trackingEye));
        var flyOffset = normalizedEye.clone().multiplyScalar(distance);

        this.camera.position.subVectors(point, flyOffset);
        this.camera.target.addVectors(this.camera.position, eye);

        this.update(true);
    };

    // 后退
    this.moveBackward = function (step, keepHeight) {

        var position = this.camera.position;
        var target = this.camera.target;
        if (keepHeight) {
            var diff = new THREE.Vector3(target.x - position.x, 0, target.z - position.z);
            var len = diff.length();
            var coe = step / len;
            var stepDiff = new THREE.Vector3(-diff.x * coe, 0, -diff.z * coe);

            position.add(stepDiff);
            target.add(stepDiff);
        } else {
            var eye = target.clone().sub(position);
            this.camera.translateZ(step);
            target.addVectors(position, eye);
        }
    };

    // 前进
    this.moveForward = function (step, keepHeight) {

        var position = this.camera.position;
        var target = this.camera.target;

        if (keepHeight) {
            var diff = new THREE.Vector3(target.x - position.x, 0, target.z - position.z);
            var len = diff.length();
            var coe = step / len;
            var stepDiff = new THREE.Vector3(diff.x * coe, 0, diff.z * coe);

            position.add(stepDiff);
            target.add(stepDiff);
        } else {
            var eye = target.clone().sub(position);

            this.camera.translateZ(-step);
            target.addVectors(position, eye);
        }
    };

    this.getIntersectContext = function (pos) {
        var context = new CLOUD.IntersectContext();
        var scope = this;

        context.scene = scope.viewer.getScene();
        context.camera = this.camera;
        scope.mapWindowToViewport(pos.x, pos.y, context.mouse);

        context.octreeRoots = scope.viewer.modelManager.getOctreeRoots();
        context.octantMap = scope.viewer.modelManager.octantToObjectMap;

        return context;
    };

    this.getLastIntersect = function () {

        return this.intersector.lastIntersect;
    };

    // 根据鼠标位置计算pivot点, 没有交点，取场景中点
    this._calcPivotByMouse = function (clientXY) {
        var scope = this;

        var context = scope.getIntersectContext(clientXY);

        var pt = scope.intersector.hitTest(context);

        if (pt) {
            scope.pivot = pt;
        } else {
            var scene = scope.viewer.getScene();
            scope.pivot = scene.getBoundingBox().getCenter();
        }
    };

    this.updatePivot = function (clientXY) {

        var scope = this;
        var viewer = this.viewer;
        var scene = viewer.getScene();
        var rotateMode = this.getPointRotateMode();

        switch (rotateMode) {

            case CLOUD.PointRotateMode.SELECTION:

                var box = viewer.renderer.computeSelectionBBox();

                if (box == null || box.isEmpty()) {

                    scope._calcPivotByMouse(clientXY);
                } else {
                    this.pivot = box.getCenter(this.pivot);
                }

                break;

            case CLOUD.PointRotateMode.CENTER:

                this.pivot = scene.getBoundingBox().getCenter();
                break;

            case CLOUD.PointRotateMode.CAMERA:

                this.pivot = null;
                break;

            default:
                // 默认 CLOUD.PointRotateMode.MOUSEPOINT

                this._calcPivotByMouse(clientXY);

                break;
        }
    };

    this.touchStartHandler = function (event) {
        switch (event.touches.length) {

            case 1:
                // one-fingered touch: rotate
                if (this.noRotate === true) return;
                handleTouchStartRotate(event);
                state = STATE.ROTATE;
                break;

            case 2:
                // two-fingered touch: dolly and pan
                if (this.noZoom !== true) {
                    handleTouchStartDolly(event);
                }
                if (this.noPan !== true) {
                    handleTouchStartPan(event);
                }
                break;

            default:
                state = STATE.NONE;
        }
    };

    this.touchMoveHandler = function (event) {

        this.viewer.editorManager.cameraChange = true;

        switch (event.touches.length) {
            case 1:
                // one-fingered touch: rotate
                if (this.noRotate !== true) {
                    handleTouchMoveRotate(event);
                }
                break;

            case 2:
                // two-fingered touch: dolly or pan
                this.viewer.getScene().remove(this.pivotBall);
                this.viewer.getScene().remove(this.pivotCenter);

                if (this.noZoom !== true) {
                    handleTouchMoveDolly(event);
                    state = STATE.DOLLY;
                }
                if (this.noPan !== true) {
                    handleTouchMovePan(event);
                    state = STATE.PAN;
                }

                break;

            default:
                state = STATE.NONE;
        }

        this.touchUpdate();
    };

    this.touchEndHandler = function (event) {

        this.viewer.editorManager.cameraChange = false;

        switch (event.touches.length) {
            // case 1:
            //     if ( this.noRotate !== true ){
            //         handleTouchMoveRotate( event );
            //     }
            //     break;

            default:
                state = STATE.NONE;
        }

        this.viewer.getScene().remove(this.pivotBall);
        this.viewer.getScene().remove(this.pivotCenter);

        this.touchUpdate();
    };

    function pivotBallSize() {
        var camera = scope.camera;
        var position = camera.position;

        var cameraDir = scope.camera.target.clone().sub(position);
        cameraDir.normalize();

        var plane = new THREE.Plane();
        plane.setFromNormalAndCoplanarPoint(cameraDir.clone().negate(), scope.pivotBall.position);
        plane.normalize();
        var distance = plane.distanceToPoint(position);
        var planeWidth = distance * Math.tan(camera.fov * 0.5);

        var dim = scope.getContainerDimensions();
        return planeWidth * 2 / (dim.height - dim.top);
    }

    function handleTouchStartRotate(event) {
        //CLOUD.Logger.log( 'handleTouchStartRotate' );

        rotateStart.set(event.touches[0].clientX, event.touches[0].clientY);
    }

    function handleTouchStartDolly(event) {
        //CLOUD.Logger.log( 'handleTouchStartDolly' );

        var dx = event.touches[0].clientX - event.touches[1].clientX;
        var dy = event.touches[0].clientY - event.touches[1].clientY;

        dollyStart.set(0, Math.sqrt(dx * dx + dy * dy));
    }

    function handleTouchStartPan(event) {
        //CLOUD.Logger.log( 'handleTouchStartPan' );

        var cx = (event.touches[0].clientX + event.touches[1].clientX) * 0.5;
        var cy = (event.touches[0].clientY + event.touches[1].clientY) * 0.5;
        panStart.set(cx, cy);
    }

    function handleTouchMoveRotate(event) {
        //CLOUD.Logger.log( 'handleTouchMoveRotate' );

        rotateEnd.set(event.touches[0].clientX, event.touches[0].clientY);
        rotateDelta.subVectors(rotateEnd, rotateStart);

        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

        thetaDelta -= 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed;
        phiDelta -= 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed;

        rotateStart.copy(rotateEnd);

        var scale = pivotBallSize();
        scope.pivotBall.scale.set(scale, scale, scale);
        scope.pivotCenter.scale.set(scale, scale, scale);
        scope.pivotBall.updateMatrixWorld();
        scope.pivotCenter.updateMatrixWorld();
    }

    function handleTouchMoveDolly(event) {
        //CLOUD.Logger.log( 'handleTouchMoveDolly' );

        var dx = event.touches[0].clientX - event.touches[1].clientX;
        var dy = event.touches[0].clientY - event.touches[1].clientY;

        var distance = Math.sqrt(dx * dx + dy * dy);
        dollyEnd.set(0, distance);
        dollyDelta.subVectors(dollyEnd, dollyStart);

        if (Math.abs(dollyDelta.y) < 3) return;

        if (dollyDelta.y > 0) {
            scale /= getZoomScale();
        } else if (dollyDelta.y < 0) {
            scale *= getZoomScale();
        }
        dollyStart.copy(dollyEnd);

        dollyCenter.x = (event.touches[0].clientX + event.touches[1].clientX) * 0.5;
        dollyCenter.y = (event.touches[0].clientY + event.touches[1].clientY) * 0.5;

        scope.dolly();
    }

    function handleTouchMovePan(event) {
        //CLOUD.Logger.log( 'handleTouchMovePan' );

        var cx = (event.touches[0].clientX + event.touches[1].clientX) * 0.5;
        var cy = (event.touches[0].clientY + event.touches[1].clientY) * 0.5;
        panEnd.set(cx, cy);
        panDelta.subVectors(panEnd, panStart);

        if (Math.abs(panDelta.x) < 3 && Math.abs(panDelta.y) < 3) return;

        worldDimension = scope.getWorldDimension(cx, cy);
        panDeltaBasedWorld.set(0, 0, 0);

        scope.panOnWorld();

        panStart.copy(panEnd);
    }

    this.fitAndRotateBySelection = function () {

        var viewer = this.viewer;
        viewer.setPointRotateMode(CLOUD.PointRotateMode.SELECTION);
        viewer.zoomToSelection();
    };

    /**
     * 设置漫游行走时相机的高度
     *
     * @param {Number} height - 相机绝对高度(世界系中的高度)
     */
    this.setRoamingWalkAbsoluteHeight = function (height) {};

    /**
     * 设置漫游行走时相机的高度
     *
     * @param {Array} elevations - 参考标高数组（从小到大的排序）
     * @param {Number} height - 相机相对高度(世界系中的高度)
     */
    this.setRoamingWalkHeight = function (elevations, height) {

        if (!(elevations instanceof Array)) {

            console.log("elevations is not arry");
            return;
        }

        if (this.roamingWalkHeight === undefined) {
            this.roamingWalkHeight = [];
        } else {
            this.roamingWalkHeight.length = 0;
        }

        for (var i = 0, len = elevations.length; i < len; ++i) {
            this.roamingWalkHeight[i] = elevations[i] + height;
        }
    };

    /**
     * 更新漫游行走时相机状态
     *
     */
    this.updateRoamingWalkState = function () {

        if (this.roamingWalkHeight) {

            var camera = this.getCamera();
            var scene = this.viewer.getScene();
            var currentCameraHeight = camera.position.y; // 场景绘图空间进行过90度旋转变换

            if (this.lastCameraHeight !== currentCameraHeight) {

                // 转世界坐标
                var worldPosition = scene.drawingToWorld(camera.position);
                // 计算相机的放置位置
                var idx = CLOUD.Utils.findRange(this.roamingWalkHeight, worldPosition.z);
                var newHeight = this.roamingWalkHeight[idx];
                // 转绘制坐标
                var point = scene.worldToDrawing({ x: worldPosition.x, y: worldPosition.y, z: newHeight });

                // 更新相机
                this.updateCameraPosition(point);

                this.lastCameraHeight = point.y;

                // console.log("point ---- ",point);
                // console.log("cameraHeight ---- ",newHeight);
                // console.log("roamingWalkHeight ---- ",this.roamingWalkHeight);
            }
        }
    };
};
CLOUD.IntersectHelper = function (filter) {
    this.raycaster = new CLOUD.Raycaster();
    this.filter = filter;

    this.lastIntersect = null;
};

CLOUD.IntersectHelper.prototype.destroy = function () {
    this.raycaster = null;
    this.lastIntersect = null;
};

CLOUD.IntersectContext = function () {
    this.scene = null;
    this.camera = null;
    // octree root nodes of all active models in current scene
    this.octreeRoots = null;
    // map from octree node id to object indices in object pool
    this.octantMap = null;
    // mouse click position, normalized
    this.mouse = new THREE.Vector2();
};

/**
 * Get info of nearest intersected mesh object.
 *
 * @param {ObjectPool} pool - Mesh object pool
 * @param {OctreeNode} octreeRoots - octree root nodes of all active models in current scene
 * @param {Map} octantMap - map from octant to index of object pool
 * @param {Bool} pickable - flag if the intersected object is pickable
 * @param {Object} distanceScope - near and far distance scope to the ray origin
 */
CLOUD.IntersectHelper.prototype.intersectMeshesWithDistance = function (pool, octreeRoots, octantMap, pickable, distanceScope) {
    var i, j;
    var len;
    var object;
    var distance;
    var minusEpislon = -0.000001;
    var raycaster = this.raycaster;
    var intersectObjects = [];
    var octants = [];

    // Visit all octree, get octree nodes that intersect with the ray
    for (i = 0; i < octreeRoots.length; i++) {
        this.raycaster.intersectOctantForNode(octreeRoots[i], octants);
    }

    var filter = this.filter;
    var hasVisibleFilter = filter._hasVisibleFilter();
    var hasSelectableFilter = filter._hasSelectableFilter();
    var isPickableFiltered = function isPickableFiltered(object) {

        return hasVisibleFilter && !filter._isVisible(object) || hasSelectableFilter && !filter._isSelectable(object);
    };

    distanceScope.near += minusEpislon;
    // travesal mesh objects in all intersected octree nodes, get meshes which
    // bounding box is intersected with ray
    for (i = 0, len = octants.length; i < len; i++) {
        var nodeIndices = octantMap[octants[i].octantId];
        if (nodeIndices) {
            for (j = 0; j < nodeIndices.length; j += 2) {
                for (var k = nodeIndices[j]; k <= nodeIndices[j + 1]; k++) {
                    object = pool._pool[k];

                    // get the distance from ray origin to bounding box of object
                    distance = object.intersectBoxWithDistance(raycaster);
                    if (distance >= distanceScope.near && distance <= distanceScope.far) {
                        intersectObjects.push({ object: object, distance: distance });
                    }
                }
            }
        }
    }

    // sort object according to distance
    intersectObjects.sort(function (a, b) {
        return a.distance - b.distance;
    });

    var intersects = [];
    var finalIntersects = [];
    var minIntersectDistance = distanceScope.far;
    for (i = 0; i < intersectObjects.length; i++) {
        if (intersectObjects[i].distance > minIntersectDistance || intersectObjects[i].distance < distanceScope.near) continue;

        object = intersectObjects[i].object;

        if (pickable && isPickableFiltered(object)) continue;

        intersects = [];
        object.raycast(raycaster, intersects);
        if (intersects.length > 0) {
            // one mesh may have multiple faces intersected with the ray, sort them
            // and the nearest intersect will be at the first
            intersects.sort(function (a, b) {
                return a.distance - b.distance;
            });

            // only get one intersect that passes the distance scope filter
            for (j = 0; j < intersects.length; j++) {
                if (intersects[j].distance < minIntersectDistance && intersects[j].distance > distanceScope.near) {
                    minIntersectDistance = intersects[j].distance - minusEpislon;
                    finalIntersects.push(intersects[j]);
                    break;
                }
            }
        }
    }

    finalIntersects.sort(function (a, b) {
        return a.distance - b.distance;
    });

    return finalIntersects;
};

CLOUD.IntersectHelper.prototype.intersect = function (context, ray, pickable) {
    var scope = this;
    var raycaster = scope.raycaster;

    // set up the ray
    if (ray === null) {
        raycaster.setFromCamera(context.mouse, context.camera);
    } else {
        var origin = ray.origin;
        var direction = ray.direction;

        raycaster.set(origin, direction);
    }

    console.log("request intersect");

    // require intersected mesh in camera visible scope
    var distanceScope = { near: context.camera.near, far: context.camera.far };
    // also take the clip plances into consideration
    context.scene.shrinkScopeByClipPlane(raycaster, distanceScope);

    var intersects = this.intersectMeshesWithDistance(context.scene.pool, context.octreeRoots, context.octantMap, pickable, distanceScope);
    var length = intersects.length;

    if (length > 0) {
        for (var ii = 0; ii < length; ++ii) {
            var intersect = intersects[ii];

            var meshNode = intersect.object;
            if (meshNode.geometry) {
                intersect.userId = meshNode.name; // name -> userId
                intersect.databagId = meshNode.databagId;

                this.lastIntersect = intersect;

                return intersect;
            }
        }
    }

    this.lastIntersect = null;

    return null;
};

/**
 * Obtain intersect point
 *
 * @param {IntersectContext} intersectContext - context to do the intersect operation
 * @return {Object} position of intersect point; return null if hit nothing
 */
CLOUD.IntersectHelper.prototype.hitTest = function (intersectContext) {

    var intersect = this.intersect(intersectContext, null, false);

    return intersect !== null ? intersect.point : null;
};

CLOUD.IntersectHelper.prototype.pick = function (context, callback) {

    var intersect = this.intersect(context, null, true);

    if (callback) {
        callback(intersect);
    }

    return intersect;
};

CLOUD.IntersectHelper.prototype.getIntersectByRay = function (context, ray) {

    return this.intersect(context, ray, true);
};

CLOUD.PickUtil = {
    pickByRect: function pickByRect(scene, frustum, selectState, modelManager) {
        var selObjects = [];
        var octants = [];
        var pool = scene.pool;
        var octreeRoots = modelManager.getOctreeRoots();
        var octantMap = modelManager.octantToObjectMap;
        var sceneState = modelManager.sceneState;
        var i, j, len;

        var bbox = new THREE.Box3();

        var p1 = new THREE.Vector3(),
            p2 = new THREE.Vector3();
        function intersectBox(frustum, box) {

            var nCount = 0;
            var planes = frustum.planes;

            for (var i = 0; i < 6; i++) {

                var plane = planes[i];

                p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

                var d1 = plane.distanceToPoint(p1);
                var d2 = plane.distanceToPoint(p2);

                // if both outside plane, no intersection

                if (d1 < 0 && d2 < 0) {

                    return false; // no intersection
                } else if (d1 * d2 >= 0) {
                    ++nCount;
                }
            }

            return nCount === 6; // contains the box
        }

        function frustumIntersectOctant(root) {
            bbox.set(root.min, root.max);

            if (frustum.intersectsBox(bbox)) {
                octants.push(root);

                // search subtree
                for (var i = 0, length = root.childOctants.length; i < length; ++i) {

                    var node = root.childOctants[i];
                    frustumIntersectOctant(node);
                }
            }
        }

        var filter = modelManager.filter;
        var hasVisibleFilter = filter._hasVisibleFilter();
        var hasSelectableFilter = filter._hasSelectableFilter();
        function isPickableFiltered(object) {

            return hasVisibleFilter && !filter._isVisible(object) || hasSelectableFilter && !filter._isSelectable(object);
        }

        if (selectState === CLOUD.OPSELECTIONTYPE.Clear) {
            sceneState.clearSelection();
            return;
        }

        // Visit all octree, get octree nodes that intersect with the frustum
        for (i = 0; i < octreeRoots.length; i++) {
            frustumIntersectOctant(octreeRoots[i], octants);
        }

        // travesal mesh objects in all intersected octree nodes, get meshes which
        // bounding box is contained in frustum
        for (i = 0, len = octants.length; i < len; i++) {
            var nodeIndices = octantMap[octants[i].octantId];
            if (nodeIndices) {
                for (j = 0; j < nodeIndices.length; j += 2) {
                    for (var k = nodeIndices[j]; k <= nodeIndices[j + 1]; k++) {
                        var object = pool._pool[k];

                        if (isPickableFiltered(object)) continue;

                        var geometry = object.geometry;
                        var material = object.material;
                        var matrixWorld = object.matrixWorld;

                        if (material === undefined) continue;

                        if (geometry.boundingBox === null) geometry.computeBoundingBox();

                        bbox.copy(geometry.boundingBox);
                        bbox.applyMatrix4(matrixWorld);

                        // Checking boundingbox although this is not accurate
                        if (intersectBox(frustum, bbox)) {
                            // frustum contains the box
                            selObjects.push(object.name);
                        }
                    }
                }
            }
        }

        if (selObjects.length > 0) {

            if (CLOUD.OPSELECTIONTYPE.Remove === selectState) {
                sceneState.removeSelection(selObjects);
            } else if (CLOUD.OPSELECTIONTYPE.Add === selectState) {
                sceneState.addSelection(selObjects);
            }
        }
    }
};

CLOUD.Object3DIdCount = 0;

CLOUD.Object3D = function () {

    Object.defineProperty(this, 'id', { value: CLOUD.Object3DIdCount++ });
    // Object.defineProperty(this, 'id', {value: THREE.Object3DIdCount++});

    this.name = '';
    this.type = 'Object3D';

    this.parent = null;

    // this.channels = new THREE.Channels();
    this.children = [];

    this.layers = new THREE.Layers();

    var position = new THREE.Vector3();
    var rotation = new THREE.Euler();
    var quaternion = new THREE.Quaternion();
    var scale = new THREE.Vector3(1, 1, 1);

    function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
    }

    function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, undefined, false);
    }

    rotation.onChange(onRotationChange);
    quaternion.onChange(onQuaternionChange);

    Object.defineProperties(this, {
        position: {
            enumerable: true,
            value: position
        },
        rotation: {
            enumerable: true,
            value: rotation
        },
        quaternion: {
            enumerable: true,
            value: quaternion
        },
        scale: {
            enumerable: true,
            value: scale
        },
        modelViewMatrix: {
            value: new THREE.Matrix4()
        },
        normalMatrix: {
            value: new THREE.Matrix3()
        }
    });

    this.matrix = new THREE.Matrix4();
    this.matrixWorld = new THREE.Matrix4();
    this.matrixWorldNeedsUpdate = true;

    this.visible = true;

    this.renderOrder = 0;
};

CLOUD.Object3D.prototype = {

    constructor: CLOUD.Object3D,

    applyMatrix: function applyMatrix(matrix) {
        this.matrix.multiplyMatrices(matrix, this.matrix);
    },

    localToWorld: function localToWorld(vector) {
        return vector.applyMatrix4(this.matrixWorld);
    },

    worldToLocal: function () {
        var m1 = new THREE.Matrix4();

        return function (vector) {
            return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
        };
    }(),

    getWorldPosition: function getWorldPosition(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.setFromMatrixPosition(this.matrixWorld);
    },

    raycast: function raycast() {},

    traverse: function traverse(callback) {
        callback(this);
    },

    traverseVisible: function traverseVisible(callback) {

        if (this.visible === false) return;

        callback(this);
    },

    traverseAncestors: function traverseAncestors(callback) {
        var parent = this.parent;

        if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
        }
    },

    updateMatrix: function updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
    },

    updateMatrixWorld: function updateMatrixWorld(force) {

        if (this.matrixWorldNeedsUpdate === true || force) {

            if (this.parent === null) {
                this.matrixWorld.copy(this.matrix);
            } else {
                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            }

            this.matrixWorldNeedsUpdate = false;
            force = true;
        }

        // update children
        if (this.children) {

            for (var i = 0, len = this.children.length; i < len; i++) {
                this.children[i].updateMatrixWorld(force);
            }
        }
    }
};

// THREE.EventDispatcher.prototype.apply(CLOUD.Object3D.prototype);
Object.assign(CLOUD.Object3D.prototype, THREE.EventDispatcher.prototype);

CLOUD.Group = function () {
    "use strict";

    CLOUD.Object3D.call(this);

    this.type = 'Group';

    this.children = [];

    this.boundingBox = null;

    this.pickEnabled = true;

    this.tag = ""; // 分类标识
};

CLOUD.Group.prototype = Object.create(CLOUD.Object3D.prototype);
CLOUD.Group.prototype.constructor = CLOUD.Group;

CLOUD.Group.prototype.raycast = function () {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();

    return function (raycaster, intersects) {

        var boundingBox = this.boundingBox;

        // Check boundingBox before continuing
        inverseMatrix.getInverse(this.matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

        if (boundingBox !== null) {
            if (ray.intersectsBox(boundingBox) === false) {
                return false;
            }
        }

        return true;
    };
}();

CLOUD.Group.prototype.add = function (object) {

    if (arguments.length > 1) {

        for (var i = 0; i < arguments.length; i++) {
            this.add(arguments[i]);
        }

        return this;
    }

    if (object === this) {
        console.error("CLOUD.Object3D.add: object can't be added as a child of itself.", object);
        return this;
    }

    if (object instanceof CLOUD.Object3D || object instanceof THREE.Object3D) {

        if (object.parent !== null) {
            object.parent.remove(object);
        }

        object.parent = this;
        object.dispatchEvent({ type: 'added' });

        this.children.push(object);
    } else {
        console.error("CLOUD.Object3D.add: object not an instance of Object3D.", object);
    }

    return this;
};

CLOUD.Group.prototype.remove = function (object) {

    if (arguments.length > 1) {

        for (var i = 0; i < arguments.length; i++) {
            this.remove(arguments[i]);
        }
    }

    var index = this.children.indexOf(object);

    if (index !== -1) {
        object.parent = null;
        object.dispatchEvent({ type: 'removed' });
        this.children.splice(index, 1);
    }
};

CLOUD.Group.prototype.traverseVisible = function (callback) {

    if (this.visible === false) return;

    callback(this);

    var children = this.children;

    for (var i = 0, len = children.length; i < len; ++i) {
        children[i].traverseVisible(callback);
    }
};

CLOUD.Group.prototype.traverse = function (callback) {

    callback(this);

    var children = this.children;

    for (var i = 0, len = children.length; i < len; ++i) {
        children[i].traverse(callback);
    }
};
CLOUD.Camera = function (width, height, fov, near, far) {

    THREE.CombinedCamera.call(this, width, height, fov, near, far);

    this.realUp = this.up.clone(); //
    this.target = new THREE.Vector3();
    this.dirty = false;

    this.positionPlane = new THREE.Plane();
    this.projScreenMatrix = new THREE.Matrix4();
    this.viewProjInverse = new THREE.Matrix4();

    this.frustum = new THREE.Frustum();
};

CLOUD.Camera.prototype = Object.create(THREE.CombinedCamera.prototype);
CLOUD.Camera.prototype.constructor = CLOUD.Camera;

CLOUD.Camera.prototype._updatePositionPlane = function () {
    this.positionPlane.setFromNormalAndCoplanarPoint(this.getWorldDirection(), this.position);
};

CLOUD.Camera.prototype._updateFrustum = function () {
    this.frustum.setFromMatrix(this.projScreenMatrix);
};

// 更新相机矩阵
CLOUD.Camera.prototype.updateMVP = function () {

    if (this.parent === null) this.updateMatrixWorld();

    this.matrixWorldInverse.getInverse(this.matrixWorld);
    this.projScreenMatrix.multiplyMatrices(this.projectionMatrix, this.matrixWorldInverse);
    this.viewProjInverse.getInverse(this.projScreenMatrix);

    this._updateFrustum();
    this._updatePositionPlane();
};

// 获得相机视锥
CLOUD.Camera.prototype.getFrustum = function (needsUpdate) {

    // 默认更新
    if (needsUpdate === undefined) {
        needsUpdate = true;
    }

    if (needsUpdate) {
        this.updateMVP();
    }

    return this.frustum;
};

CLOUD.Camera.prototype.LookAt = function (target, dir, up, focal) {

    var offset = new THREE.Vector3();
    offset.copy(dir);

    if (focal !== undefined) offset.setLength(focal);

    this.position.subVectors(target, offset);
    this.up = up;
    this.lookAt(target);
    this.realUp = up.clone();
    this.target = target.clone();
};

CLOUD.Camera.prototype.clone = function () {

    var camera = new CLOUD.Camera(this.right * 2.0, this.top * 2.0, this.fov, this.near, this.far);

    camera.position.copy(this.position);
    camera.up.copy(this.up);
    camera.realUp.copy(this.realUp);
    camera.target.copy(this.target);

    camera.aspect = this.aspect;
    camera.fov = this.fov;
    camera.near = this.near;
    camera.far = this.far;

    camera.left = this.left;
    camera.right = this.right;
    camera.top = this.top;
    camera.bottom = this.bottom;

    camera.zoom = this.zoom;
    camera.isPerspective = this.isPerspective;

    camera.updateProjectionMatrix();
    camera.updateMVP();

    return camera;
};

CLOUD.Camera.prototype.copy = function (camera) {

    // THREE.CombinedCamera.prototype.copy.call( this, camera );

    this.position.copy(camera.position);
    this.target.copy(camera.target);
    this.up.copy(camera.up);
    this.realUp.copy(camera.realUp);

    this.aspect = camera.aspect;
    this.fov = camera.fov;
    this.near = camera.near;
    this.far = camera.far;

    this.left = camera.left;
    this.right = camera.right;
    this.top = camera.top;
    this.bottom = camera.bottom;

    this.zoom = camera.zoom;
    this.isPerspective = camera.isPerspective;

    this.updateProjectionMatrix();
    this.updateMVP();

    return this;
};

// 用THREE.Camera.getWorldDirection替换
//CLOUD.Camera.prototype.LookDir = function () {
//    var vector = new THREE.Vector3(0, 0, -1);
//    vector.applyQuaternion(this.quaternion);
//    return vector;
//};

CLOUD.Camera.prototype.setStandardView = function (stdView, box) {

    var target;

    if (box) {
        target = box.getCenter();
    } else {
        target = new THREE.Vector3(0, 0, 0);
    }

    var sceneSize = CLOUD.GlobalData.SceneSize;
    var focal = sceneSize / 2;

    switch (stdView) {
        case CLOUD.EnumStandardView.ISO:
            var position = new THREE.Vector3(-sceneSize, sceneSize, sceneSize);
            var dir = new THREE.Vector3();
            // BIMFACEDM-1456 : 如果场景中心点不在原点(0, 0, 0)，相机的方向应该使用原点计算，与target无关
            // dir.subVectors(target, position);
            var center = new THREE.Vector3(0, 0, 0);
            dir.subVectors(center, position);
            this.LookAt(target, dir, THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.Top:
            this.LookAt(target, new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, -1), focal);
            // 这里恢复up方向有问题，应该在本次渲染结束后才能恢复。
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.Bottom:
            this.LookAt(target, new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.Front:
            //this.LookAt(target, new THREE.Vector3(0, -0.5, -1), new THREE.Vector3(0, 1, 0), focal);
            this.LookAt(target, new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.Back:
            this.LookAt(target, new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.Right:
            this.LookAt(target, new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.Left:
            this.LookAt(target, new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.SouthEast:
            // 将视点抬高，避开坐标轴重叠 (-1, 0, -1)  --> (-1, -1, -1)
            //this.LookAt(target, new THREE.Vector3(-1, -1, -1), new THREE.Vector3(0, 1, 0), focal);
            // 注意：之前修改过bug（GGP-11834：标准视图与Jetfire不一致）。修改方法是抬高视点。
            // 但是在viewhouse的多维度观察视角下，抬高视点对应的实际上是RoofSouthEast,所以这里恢复视点。
            this.LookAt(target, new THREE.Vector3(-1, 0, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.SouthWest:
            // 将视点抬高，避开坐标轴重叠 (1, 0, -1)  --> (1, -1, -1)
            //this.LookAt(target, new THREE.Vector3(1, -1, -1), new THREE.Vector3(0, 1, 0), focal);
            // 注意：之前修改过bug（GGP-11834：标准视图与Jetfire不一致）。修改方法是抬高视点。
            // 但是在viewhouse的多维度观察视角下，抬高视点对应的实际上是RoofSouthEast,所以这里恢复视点
            this.LookAt(target, new THREE.Vector3(1, 0, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.NorthWest:
            // 将视点抬高，避开坐标轴重叠 (1, 0, 1)  --> (1, -1, 1)
            //this.LookAt(target, new THREE.Vector3(1, -1, 1), new THREE.Vector3(0, 1, 0), focal);
            // 注意：之前修改过bug（GGP-11834：标准视图与Jetfire不一致）。修改方法是抬高视点。
            // 但是在viewhouse的多维度观察视角下，抬高视点对应的实际上是NorthWest,所以这里恢复视点
            this.LookAt(target, new THREE.Vector3(1, 0, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.NorthEast:
            // 将视点抬高，避开坐标轴重叠 (-1, 0, 1)  --> (-1, -1, 1)
            //this.LookAt(target, new THREE.Vector3(-1, -1, 1), new THREE.Vector3(0, 1, 0), focal);
            // 注意：之前修改过bug（GGP-11834：标准视图与Jetfire不一致）。修改方法是抬高视点。
            // 但是在viewhouse的多维度观察视角下，抬高视点对应的实际上是RoofNorthEast,所以这里恢复视点
            this.LookAt(target, new THREE.Vector3(-1, 0, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.BottomFront:
            this.LookAt(target, new THREE.Vector3(0, 1, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.BottomBack:
            this.LookAt(target, new THREE.Vector3(0, 1, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.BottomRight:
            this.LookAt(target, new THREE.Vector3(-1, 1, 0), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.BottomLeft:
            this.LookAt(target, new THREE.Vector3(1, 1, 0), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.BottomSouthEast:
            this.LookAt(target, new THREE.Vector3(-1, 1, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.BottomSouthWest:
            this.LookAt(target, new THREE.Vector3(1, 1, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.BottomNorthWest:
            this.LookAt(target, new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.BottomNorthEast:
            this.LookAt(target, new THREE.Vector3(-1, 1, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.RoofFront:
            this.LookAt(target, new THREE.Vector3(0, -1, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.RoofBack:
            this.LookAt(target, new THREE.Vector3(0, -1, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.RoofRight:
            this.LookAt(target, new THREE.Vector3(-1, -1, 0), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.RoofLeft:
            this.LookAt(target, new THREE.Vector3(1, -1, 0), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.RoofSouthEast:
            this.LookAt(target, new THREE.Vector3(-1, -1, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.RoofSouthWest:
            this.LookAt(target, new THREE.Vector3(1, -1, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.RoofNorthWest:
            this.LookAt(target, new THREE.Vector3(1, -1, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.RoofNorthEast:
            this.LookAt(target, new THREE.Vector3(-1, -1, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.TopTurnRight:
            this.LookAt(target, new THREE.Vector3(0, -1, 0), new THREE.Vector3(-1, 0, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.TopTurnBack:
            this.LookAt(target, new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.TopTurnLeft:
            this.LookAt(target, new THREE.Vector3(0, -1, 0), new THREE.Vector3(1, 0, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.BottomTurnRight:
            this.LookAt(target, new THREE.Vector3(0, 1, 0), new THREE.Vector3(-1, 0, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.BottomTurnBack:
            this.LookAt(target, new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, -1), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.BottomTurnLeft:
            this.LookAt(target, new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.FrontTurnTop:
            this.LookAt(target, new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, -1, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.FrontTurnLeft:
            this.LookAt(target, new THREE.Vector3(0, 0, -1), new THREE.Vector3(1, 0, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.FrontTurnRight:
            this.LookAt(target, new THREE.Vector3(0, 0, -1), new THREE.Vector3(-1, 0, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.RightTurnTop:
            this.LookAt(target, new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, -1, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.RightTurnFront:
            this.LookAt(target, new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, -1), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.RightTurnBack:
            this.LookAt(target, new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, 1), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.BackTurnTop:
            this.LookAt(target, new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, -1, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.BackTurnLeft:
            this.LookAt(target, new THREE.Vector3(0, 0, 1), new THREE.Vector3(-1, 0, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.BackTurnRight:
            this.LookAt(target, new THREE.Vector3(0, 0, 1), new THREE.Vector3(1, 0, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.LeftTurnTop:
            this.LookAt(target, new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -1, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.LeftTurnBack:
            this.LookAt(target, new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 1), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.LeftTurnFront:
            this.LookAt(target, new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, -1), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;

    }
    this.updateProjectionMatrix();

    return target;
};

/**
 * 缩放到指定的包围盒范围
 *
 * @param {THREE.Box3} box - 包围盒
 * @param {Float} margin - 包围盒缩放比例 (< 1.0), 缺省值: 0.0。margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
 * @param {Float} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
 * @param {THREE.Vector3} direction - 相机观察方向
 */
CLOUD.Camera.prototype.zoomToBBox = function (box, margin, ratio, direction) {

    ratio = ratio || 1.0;
    margin = margin || 0.0;
    margin = margin < -1.0 ? -1.0 : margin; // 钳制

    var newBox = new THREE.Box3();
    newBox.copy(box);

    if (margin !== 0.0) {
        var boxLen = box.getSize().length() * 0.5;
        var diagonalLine = new THREE.Vector3();
        diagonalLine.subVectors(newBox.min, newBox.max).normalize();
        diagonalLine.multiplyScalar(boxLen * margin);
        newBox.expandByVector(diagonalLine);
    }

    var dir = direction ? direction : this.getWorldDirection();
    var up = this.up;
    var aspect = this.aspect;
    var halfFov = THREE.Math.degToRad(this.fov * 0.5); // 转成弧度

    var boxSize = newBox.getSize();
    var center = newBox.getCenter();
    var radius = boxSize.length() * 0.5;
    var distToCenter = radius / Math.sin(halfFov) * ratio;

    var offset = new THREE.Vector3();
    offset.copy(dir);
    offset.setLength(distToCenter);

    var position = new THREE.Vector3();
    position.subVectors(center, offset);

    // ---------- 计算新位置 S ----------------- //
    var right = new THREE.Vector3();
    right.crossVectors(dir, up);
    right.normalize();

    var newUp = new THREE.Vector3();
    newUp.crossVectors(dir, right);
    newUp.normalize();

    var vertPlane = new THREE.Plane();
    vertPlane.setFromNormalAndCoplanarPoint(right, position);

    var horzPlane = new THREE.Plane();
    horzPlane.setFromNormalAndCoplanarPoint(newUp, position);

    var maxHeight = 0;
    var maxDistForHeight = 0;
    var maxWidth = 0;
    var maxDistForWidth = 0;

    var corners = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];

    corners[0].set(newBox.min.x, newBox.min.y, newBox.min.z); // 000
    corners[1].set(newBox.min.x, newBox.min.y, newBox.max.z); // 001
    corners[2].set(newBox.min.x, newBox.max.y, newBox.min.z); // 010
    corners[3].set(newBox.min.x, newBox.max.y, newBox.max.z); // 011
    corners[4].set(newBox.max.x, newBox.min.y, newBox.min.z); // 100
    corners[5].set(newBox.max.x, newBox.min.y, newBox.max.z); // 101
    corners[6].set(newBox.max.x, newBox.max.y, newBox.min.z); // 110
    corners[7].set(newBox.max.x, newBox.max.y, newBox.max.z); // 111

    for (var i = 0; i < 8; i++) {
        var v = new THREE.Vector3();
        v.subVectors(corners[i], position);
        var dist = Math.abs(v.dot(dir));

        var h1 = Math.abs(horzPlane.distanceToPoint(corners[i]));
        var w1 = h1 * aspect;
        var w2 = Math.abs(vertPlane.distanceToPoint(corners[i]));
        var h2 = w2 / aspect;

        var h = Math.max(h1, h2);
        var w = Math.max(w1, w2);

        if (!maxHeight || !maxDistForHeight || h > maxHeight * dist / maxDistForHeight) {
            maxHeight = h;
            maxDistForHeight = dist;
        }

        if (!maxWidth || !maxDistForWidth || w > maxWidth * dist / maxDistForWidth) {
            maxWidth = w;
            maxDistForWidth = dist;
        }
    }

    var cameraDist = maxHeight / Math.tan(halfFov) + (distToCenter - maxDistForHeight);
    if (aspect < 1.0) {
        cameraDist = maxWidth / Math.tan(halfFov) + (distToCenter - maxDistForWidth);
    }

    // BIMFACEDM-2206：防止小构件被相机裁剪 (cameraDist < this.near)， 重新计算近裁剪面。
    if (cameraDist < this.near) {
        var delta = 0.001;
        this.near = (cameraDist * cameraDist + cameraDist * delta) / ((1 << 24) * delta);
    }

    offset.copy(dir).normalize().setLength(cameraDist);
    position.subVectors(center, offset);

    // ---------- 计算新位置 E ----------------- //

    this.position.copy(position);
    this.lookAt(center);
    this.updateProjectionMatrix();
    this.target.copy(center);
    return center;
};

CLOUD.Camera.prototype.computeRay = function (cx, cy, domElement) {
    var viewportDim = new THREE.Vector2();

    if (domElement === undefined) {
        viewportDim.x = window.innerWidth;
        viewportDim.y = window.innerHeight;
    } else {
        var element = domElement === document ? domElement.body : domElement;

        // clientWidth: 是对象可见的宽度，不包含滚动条等边线，会随窗口的显示大小改变。
        // offsetWidth:	是对象的可见宽度，包含滚动条等边线，会随窗口的显示大小改变。
        // CloudCameraEditor.getContainerDimensions 使用的是offsetWidth, offsetHeight,保持统一。
        //viewportDim.x = element.clientWidth;
        //viewportDim.y = element.clientHeight;
        viewportDim.x = element.offsetWidth;
        viewportDim.y = element.offsetHeight;
    }

    // To Viewport
    var viewPos = new THREE.Vector2();

    // 注意这里传入的cx, cy是相对视口的值（即已做过偏移）
    viewPos.x = cx / viewportDim.x * 2 - 1;
    viewPos.y = -(cy / viewportDim.y) * 2 + 1;

    var ray = new THREE.Ray();
    if (this.isPerspective) {
        ray.origin.copy(this.position);
        ray.direction.set(viewPos.x, viewPos.y, 0.5).unproject(this).sub(this.position).normalize();
    } else {
        ray.origin.set(viewPos.x, viewPos.y, -1).unproject(this);
        ray.direction.set(0, 0, -1).transformDirection(this.matrixWorld);
    }

    return ray;
};

CLOUD.Camera.prototype.screenToWorld = function (cx, cy, domElement, target) {

    var ray = this.computeRay(cx, cy, domElement);
    // plane on target
    var dir = this.getWorldDirection().normalize();

    var plane = new THREE.Plane(dir);
    plane.setFromNormalAndCoplanarPoint(dir, target);

    return ray.intersectPlane(plane, target);
};

/**
 * 世界空间中的距离转换成绘图空间(相机空间)的距离
 *
 * @param {THREE.Matrix4} matrixScene - 场景变换矩阵
 * @param {Number} distance - 世界空间中的距离
 * @return {Number} distance - 绘图空间中的距离
 */
CLOUD.Camera.prototype.distanceFromWorldToDrawing = function (matrixScene, distance) {

    var origin = this.position.clone();
    var direction = this.target.clone();

    direction.subVectors(this.target, this.position);
    direction.normalize();

    // 先变回世界空间
    var inverseMatrix = new THREE.Matrix4();
    inverseMatrix.getInverse(matrixScene);

    direction.add(origin).applyMatrix4(inverseMatrix);
    origin.applyMatrix4(inverseMatrix);
    direction.sub(origin);
    direction.normalize().multiplyScalar(distance);

    // 再变回绘图空间
    direction.add(origin).applyMatrix4(matrixScene);
    // 起始点就是相机的位置
    // origin.applyMatrix4( matrixScene );
    // direction.sub(origin);
    direction.sub(this.position);

    return direction.length();
};

/**
 * 将相机从绘图坐标系转换到世界坐标系
 *
 * @param {Object} cameraInfo - 绘图坐标系中相机位置 {position:xxx, target:xxx, up:xxx}
 * @param {THREE.Matrix4} matrixScene - 场景变换矩阵
 * @returns {Object} - 世界系中相机位置 {position:xxx, target:xxx, up:xxx}
 */
CLOUD.Camera.drawingToWorld = function (cameraInfo, matrixScene) {

    var position = cameraInfo.position.clone();
    var target = cameraInfo.target.clone();
    var up = cameraInfo.up.clone();

    var inverseMatrix = new THREE.Matrix4();
    inverseMatrix.getInverse(matrixScene);

    up.add(position);
    up.applyMatrix4(inverseMatrix);

    position.applyMatrix4(inverseMatrix);
    target.applyMatrix4(inverseMatrix);

    up.sub(position);
    up.normalize();

    return { position: position, target: target, up: up };
};

/**
 * 将相机从世界坐标系转换到绘图坐标系
 *
 * @param {Object} cameraInfo - 世界坐标系中相机位置 {position:xxx, target:xxx, up:xxx}
 * @param {THREE.Matrix4} matrixScene - 场景变换矩阵
 * @returns {Object} - 绘图坐标系中相机位置 {position:xxx, target:xxx, up:xxx}
 */
CLOUD.Camera.worldToDrawing = function (cameraInfo, matrixScene) {

    var position = cameraInfo.position.clone();
    var target = cameraInfo.target.clone();
    var up = cameraInfo.up.clone();

    up.add(position);
    up.applyMatrix4(matrixScene);

    position.applyMatrix4(matrixScene);
    target.applyMatrix4(matrixScene);

    up.sub(position);
    up.normalize();

    return { position: position, target: target, up: up };
};
CLOUD.Scene = function () {

    CLOUD.Group.call(this);

    this.type = 'Scene';
    this.autoUpdate = false; // 不自动更新

    // Add global visible renderable into this group, such as "light", "assist debug renderable", "cliping planes" etc.
    // In incremental rendering this group will be projected in high priority.
    // "rootNode" group hold general renderables, the number might be huge, some of them might not be projected
    // because of time limitation of single frame in "projectObject(object, camera)".
    this.highPriorityGroup = new CLOUD.Group();
    this.add(this.highPriorityGroup);

    this.rootNode = new CLOUD.Group();
    this.rootNode.sceneRoot = true;
    this.add(this.rootNode);

    this.clipPlanes = null;
    this.fillClipPlane = null;

    // CLOUD.Logger.time("ObjectPool");
    this.pool = new CLOUD.ObjectPool(CLOUD.MeshEx, CLOUD.GlobalData.maxObjectNumInPool);
    this.pool.init({ parent: this.rootNode });
    // CLOUD.Logger.timeEnd("ObjectPool");

    this.transformMatrix = new THREE.Matrix4(); // 用于保存变换后的矩阵

    this.IBLcfg = null;
    this.IBLIndex = 0;
    this.iblProbe = null;

    if (CLOUD.GlobalData.DirectionalLight) {

        var initIntensity = 0.3;
        this.hemisphereLight = new THREE.HemisphereLight(0xffffff, 0xffffff, initIntensity * CLOUD.GlobalData.LightIntensityFactor);
        this.hemisphereLight.initIntensity = initIntensity;
        this.hemisphereLight.position.set(0, 500, 0);
        this.hemisphereLight.updateMatrixWorld(true);
        this.add(this.hemisphereLight);

        initIntensity = 0.7;
        this.dirLight = new THREE.DirectionalLight(0xffffff, initIntensity * CLOUD.GlobalData.LightIntensityFactor);
        this.dirLight.initIntensity = initIntensity;
        this.dirLight.color.setHSL(0.1, 1, 0.95);
        this.dirLight.position.set(-1, 0.75, 1);
        this.dirLight.position.multiplyScalar(50);
        this.add(this.dirLight);
    } else {

        this.lightOffset = new THREE.Vector3(-1, -1, -1);
        this.lightOffset.normalize();
        var initIntensity = 0.35;
        this.lampHead = new THREE.DirectionalLight(0xffffff, initIntensity * CLOUD.GlobalData.LightIntensityFactor);
        this.lampHead.initIntensity = initIntensity;
        this.lampAssist = new THREE.DirectionalLight(0xffffff, initIntensity * CLOUD.GlobalData.LightIntensityFactor);
        this.lampAssist.initIntensity = initIntensity;
        initIntensity = 0.3;
        this.hemisphereLight = new THREE.HemisphereLight(0xffffff, 0xffffff, initIntensity * CLOUD.GlobalData.LightIntensityFactor);
        this.hemisphereLight.initIntensity = initIntensity;
        this.hemisphereLight.updateMatrixWorld(true);
        this.add(this.hemisphereLight);
        this.add(this.lampHead);
        this.add(this.lampAssist);
    }

    this.groupOctreeBox = new THREE.Group();
    this.add(this.groupOctreeBox);

    this.pickGroups = [];
    this.pickGroups.push(this.rootNode);
};

CLOUD.Scene.prototype = Object.create(CLOUD.Group.prototype);
CLOUD.Scene.prototype.constructor = CLOUD.Scene;

CLOUD.Scene.prototype.destroy = function () {

    if (this.hemisphereLight) {
        this.remove(this.hemisphereLight);
        this.hemisphereLight = null;
    }

    if (this.dirLight) {
        this.remove(this.dirLight);
        this.dirLight = null;
    }

    if (this.lampHead) {
        this.remove(this.lampHead);
        this.lampHead = null;
    }

    if (this.lampAssist) {
        this.remove(this.lampAssist);
        this.lampAssist = null;
    }

    this.clearAll();

    this.pool.destroy();
    this.pool = null;

    this.clipPlanes = null;
    this.fillClipPlane = null;
};

CLOUD.Scene.prototype.resizePool = function (size) {
    this.rootNode.children = [];
    this.pool.resize(size, { parent: this.rootNode });
};

/**
 * 清除场景数据
 *
 */
CLOUD.Scene.prototype.clearAll = function () {

    this.pool.clear();
    this.autoUpdate = false;
    // this.rootNode.children = [];
    // this.rootNode.boundingBox = null;
};

/**
 * 获得场景模型数据根节点
 *
 */
CLOUD.Scene.prototype.getRootNode = function () {
    return this.rootNode;
};

/**
 * 判断场景是否已加载
 *
 */
CLOUD.Scene.prototype.isLoaded = function () {
    return this.rootNode.boundingBox !== null;
};

/**
 * 获得缺省的场景包围盒(场景变换后)
 *
 */
CLOUD.Scene.prototype.getBoundingBoxDefault = function () {

    var sceneHalfSize = CLOUD.GlobalData.SceneSize * 0.5;
    var min = new THREE.Vector3(-sceneHalfSize, -sceneHalfSize, -sceneHalfSize);
    var max = new THREE.Vector3(sceneHalfSize, sceneHalfSize, sceneHalfSize);
    var box = new THREE.Box3(min, max);

    return box;
};

/**
 * 获得的场景包围盒(场景变换前)
 *
 */
CLOUD.Scene.prototype.getBoundingBox = function () {

    var box = new THREE.Box3();

    return function () {
        box.copy(this.rootNode.boundingBox);
        box.applyMatrix4(this.rootNode.matrix);
        return box;
    };
}();

/**
 * 获得的场景包围盒(场景变换前)
 *
 */
CLOUD.Scene.prototype.getBoundingBoxWorld = function () {
    return this.rootNode.boundingBox;
};

/**
 * 获得默认场景变换矩阵
 *
 */
CLOUD.Scene.prototype.getTransformMatrixGlobal = function () {
    return this.transformMatrix;
};

/**
 * 获得场景变换矩阵
 *
 */
CLOUD.Scene.prototype.getMatrixGlobal = function () {
    return this.rootNode.matrix;
};

/**
 * 获得场景世界变换矩阵
 *
 */
CLOUD.Scene.prototype.getMatrixWorldGlobal = function () {
    return this.rootNode.matrixWorld;
};

/**
 * 获得场景旋转角度(Euler)
 *
 */
CLOUD.Scene.prototype.getRotationGlobal = function () {

    if (this.rootNode.matrix) {

        var rotMat = new THREE.Matrix4();
        rotMat.extractRotation(this.rootNode.matrix);

        var rotation = new THREE.Euler();
        rotation.setFromRotationMatrix(rotMat);

        return rotation;
    }

    return null;
};

/**
 * 获取相机到场景包围盒8个顶点的最大距离对应点所在平面与所给射线的交点
 *
 * @param {Object} direction - 相机方向
 * @param {Object} ray - 射线
 * @return {Object} 交点
 */
CLOUD.Scene.prototype.getTrackingPointFromBoundingBox = function (direction, ray) {

    if (!this.rootNode.boundingBox) return null;

    var position = ray.origin;
    var box = this.getBoundingBox();
    var maxLen = 0;

    var corners = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];

    corners[0].set(box.min.x, box.min.y, box.min.z); // 000
    corners[1].set(box.min.x, box.min.y, box.max.z); // 001
    corners[2].set(box.min.x, box.max.y, box.min.z); // 010
    corners[3].set(box.min.x, box.max.y, box.max.z); // 011
    corners[4].set(box.max.x, box.min.y, box.min.z); // 100
    corners[5].set(box.max.x, box.min.y, box.max.z); // 101
    corners[6].set(box.max.x, box.max.y, box.min.z); // 110
    corners[7].set(box.max.x, box.max.y, box.max.z); // 111

    for (var i = 0; i < 8; i++) {

        var v = new THREE.Vector3();
        v.subVectors(corners[i], position);

        var len = v.dot(direction);

        if (maxLen < len) {
            maxLen = len;
        }
    }

    var offsetVec = direction.clone().multiplyScalar(maxLen);
    var coplanarPoint = position.clone().add(offsetVec);

    var plane = new THREE.Plane();
    plane.setFromNormalAndCoplanarPoint(direction, coplanarPoint);

    return ray.intersectPlane(plane);
};

CLOUD.Scene.prototype.getNearDepthByRect = function () {

    var box = new THREE.Box3();
    var nearDepth = Infinity;
    var projectScreenMatrix = new THREE.Matrix4();
    var projectPosition = new THREE.Vector3();

    // 计算最近的深度
    function calcNearDepth(object) {
        projectPosition.setFromMatrixPosition(object.matrixWorld);
        projectPosition.applyProjection(projectScreenMatrix);

        var depth = projectPosition.z;

        if (depth < nearDepth && depth >= 0 && depth <= 1) {
            nearDepth = depth;
        }
    }

    function intersectObjectByBox(frustum, object) {

        if (object.boundingBox && !(object instanceof THREE.Mesh)) {
            box.copy(object.boundingBox);
            box.applyMatrix4(object.matrixWorld);
        } else {
            var geometry = object.geometry;

            if (geometry.boundingBox === null) geometry.computeBoundingBox();

            box.copy(geometry.boundingBox);
            box.applyMatrix4(object.matrixWorld);
        }

        return frustum.intersectsBox(box);
    }

    return function (frustum, camera) {
        nearDepth = Infinity;
        projectScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

        function frustumTest(node) {

            if (node instanceof CLOUD.MeshEx) {

                if (!intersectObjectByBox(frustum, node)) {
                    return;
                }

                // 计算最近的深度
                calcNearDepth(node);
            } else if (node.worldBoundingBox) {

                if (!frustum.intersectsBox(node.worldBoundingBox)) {
                    return;
                }

                // 计算最近的深度
                calcNearDepth(node);
            }

            var children = node.children;
            if (!children) return;

            for (var i = 0, l = children.length; i < l; i++) {
                var child = children[i];
                if (child.visible) {
                    frustumTest(child);
                }
            }
        }

        var children = this.rootNode.children;
        for (var i = 0, l = children.length; i < l; i++) {
            var child = children[i];
            if (child.visible) {
                frustumTest(child);
            }
        }

        return nearDepth;
    };
}();

CLOUD.Scene.prototype.getClipPlanes = function () {

    if (this.clipPlanes == null) {
        var bbox = new THREE.Box3();
        bbox.copy(this.rootNode.boundingBox);
        bbox.applyMatrix4(this.rootNode.matrix);

        this.clipPlanes = new CLOUD.ClipPlanes(bbox.getSize(), bbox.getCenter());
        this.highPriorityGroup.add(this.clipPlanes);
    }

    return this.clipPlanes;
};

CLOUD.Scene.prototype.getFillClipPlane = function () {

    if (this.fillClipPlane == null) {
        var bbox = new THREE.Box3();
        bbox.copy(this.rootNode.boundingBox);
        bbox.applyMatrix4(this.rootNode.matrix);

        this.fillClipPlane = new CLOUD.FillClipPlane(bbox.getSize(), bbox.getCenter());
        this.add(this.fillClipPlane);
    }

    return this.fillClipPlane;
};

/**
 * Shrink distance (near/far) scope with enabled clip planes.
 *
 * @param {THREE.Ray} ray - Ray object to intersect with clip planes
 * @param {Object} scope - near and far distance scope to the ray origin
 */
CLOUD.Scene.prototype.shrinkScopeByClipPlane = function (ray, scope) {
    if (this.clipPlanes && this.clipPlanes.isEnabled()) {

        var hit = this.clipPlanes.hitTest(ray);

        if (hit.distance == null) return;

        if (hit.sign) {
            if (hit.distance > scope.near) {
                scope.near = hit.distance;
            }
        } else if (hit.distance < scope.far) {
            scope.far = hit.distance;
        }
    }
};

CLOUD.Scene.prototype.traverseIf = function (callback) {

    function traverseChild(node, callback) {

        var children = node.children;

        for (var i = 0, len = children.length; i < len; i++) {

            var child = children[i];

            if (!callback(child, node)) {
                break;
            }

            if (child.visible) {
                traverseChild(child, callback);
            }
        }
    }

    var children = this.rootNode.children;

    for (var i = 0, len = children.length; i < len; i++) {
        var child = children[i];
        traverseChild(child, callback);
    }
};

CLOUD.Scene.prototype.findNode = function (sceneId) {

    var children = this.rootNode.children;

    for (var i = 0, l = children.length; i < l; i++) {

        var child = children[i];

        if (child.userData && sceneId == child.userData.sceneId) {
            return child;
        }
    }

    return null;
};

CLOUD.Scene.prototype.getNodeById = function (id) {

    var children = this.rootNode.children;

    for (var i = 0, l = children.length; i < l; i++) {

        var node = children[i];

        if (id === node.name) {
            return node;
        }
    }

    return null;
};

CLOUD.Scene.prototype.showNodes = function (model, bVisible) {

    var children = this.rootNode.children;

    for (var i = 0, len = children.length; i < len; i++) {

        var child = children[i];

        if (child.databagId === model.databagId) {
            child.visible = bVisible;
        }
    }
};

CLOUD.Scene.prototype.containsBoxInFrustum = function () {

    var p1 = new THREE.Vector3(),
        p2 = new THREE.Vector3();

    return function (frustum, box) {

        var planes = frustum.planes;

        for (var i = 0; i < 6; i++) {
            var plane = planes[i];

            p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
            p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
            p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
            p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

            var d1 = plane.distanceToPoint(p1);
            var d2 = plane.distanceToPoint(p2);

            // if one outside plane, is not contained.

            if (d1 < 0 || d2 < 0) {
                return false;
            }
        }

        return true;
    };
}();

CLOUD.Scene.prototype.prepareScene = function () {};

// 对应多模型,应该保持旋转缩放矩阵一致，应该从数据层面修改矩阵变换
CLOUD.Scene.prototype.parseRootNode = function (data) {

    var rootNode = this.rootNode;
    var dataView = data.view;
    var boundingBox = CLOUD.Utils.box3FromArray(dataView.bbox);
    var hasTransform = dataView.transform;

    var position = new THREE.Vector3();
    var rotation = new THREE.Quaternion();
    var scale = new THREE.Vector3(1, 1, 1);

    // 对于不同旋转方向的模型怎么处理？
    if (dataView.rotation) {

        var euler = new THREE.Euler();
        euler.fromArray(dataView.rotation);
        rotation.setFromEuler(euler, false);
    }

    // -------------- 临时用于数据兼容，以后会移除 --------------- //
    var positionTrans = new THREE.Vector3();
    var scaleTrans = new THREE.Vector3(1, 1, 1);

    if (dataView.position) {
        positionTrans.fromArray(dataView.position);
    }

    if (dataView.scale) {
        scaleTrans.fromArray(dataView.scale);
    }

    this.transformMatrix.compose(positionTrans, rotation, scaleTrans);

    // ----------------------------------------------------------- //

    // 0 - 数据没有经过矩阵变换； 未定义或者1 - 数据经过矩阵变换

    // 经过变换, 这种方式对多模型显示来说存在严重问题
    if (hasTransform === undefined || hasTransform === 1) {

        if (rootNode.boundingBox === null || rootNode.boundingBox.isEmpty()) {

            rootNode.boundingBox = boundingBox;

            if (dataView.position) {
                position.fromArray(dataView.position);
            }

            if (dataView.scale) {
                scale.fromArray(dataView.scale);
            }

            rootNode.matrix.compose(position, rotation, scale);
            rootNode.matrixAutoUpdate = false;
            rootNode.updateMatrixWorld(true);
        } else {

            rootNode.boundingBox.expandByPoint(boundingBox.min);
            rootNode.boundingBox.expandByPoint(boundingBox.max);
        }
    } else {

        if (rootNode.boundingBox === null || rootNode.boundingBox.isEmpty()) {

            rootNode.boundingBox = boundingBox;
        } else {

            rootNode.boundingBox.expandByPoint(boundingBox.min);
            rootNode.boundingBox.expandByPoint(boundingBox.max);
        }

        // fixed bug BIMFACEDM-1872 : 采用统一的scale
        var sceneSize = CLOUD.GlobalData.SceneSize;
        var boxSize = rootNode.boundingBox.size();
        var maxLen = Math.max(boxSize.x, boxSize.y, boxSize.z);
        var sceneScale = sceneSize / maxLen;

        scale.multiplyScalar(sceneScale);

        rootNode.matrix.compose(position, rotation, scale);
        rootNode.matrixAutoUpdate = false;
        rootNode.updateMatrixWorld(true);
    }
};

CLOUD.Scene.prototype.updateLights = function (camera) {

    if (CLOUD.GlobalData.DirectionalLight) {

        var dirLight = this.dirLight;
        dirLight.intensity = dirLight.initIntensity * CLOUD.GlobalData.LightIntensityFactor;
        dirLight.updateMatrixWorld(true);

        var hemisphereLight = this.hemisphereLight;
        hemisphereLight.intensity = hemisphereLight.initIntensity * CLOUD.GlobalData.LightIntensityFactor;
    } else {

        var headLamp = this.lampHead;
        headLamp.intensity = headLamp.initIntensity * CLOUD.GlobalData.LightIntensityFactor;
        headLamp.position.copy(camera.getWorldDirection()).multiplyScalar(-1);
        headLamp.updateMatrixWorld(true);

        var assistLamp = this.lampAssist;
        assistLamp.intensity = assistLamp.initIntensity * CLOUD.GlobalData.LightIntensityFactor;
        assistLamp.position.copy(headLamp.position).add(this.lightOffset).normalize();
        assistLamp.updateMatrixWorld();

        var hemisphereLight = this.hemisphereLight;
        hemisphereLight.intensity = hemisphereLight.initIntensity * CLOUD.GlobalData.LightIntensityFactor;
    }
};

CLOUD.Scene.prototype.updateOctreeBox = function (rootNode) {
    var groupBox = this.groupOctreeBox;

    function traverse(parent) {

        for (var i = 0, len = parent.childOctants.length; i < len; i++) {
            var child = parent.childOctants[i];
            var box = new THREE.Box3(child.min, child.max);
            var clr = 0xff;
            clr = clr << child.depth * 5;

            var boxNode = new CLOUD.BBoxNode(box, clr);
            groupBox.add(boxNode);
            boxNode.updateMatrixWorld(true);

            traverse(child);
        }
    }

    if (CLOUD.GlobalData.ShowOctant) {

        groupBox.visible = true;

        if (groupBox.children.length === 0) {

            // var rootNodeMatrix = this.getMatrixWorldGlobal();
            // groupBox.matrixWorld.copy(rootNodeMatrix);

            var box = new THREE.Box3(rootNode.min, rootNode.max);
            var clr = 0xff0000;
            var boxNode = new CLOUD.BBoxNode(box, clr);
            groupBox.add(boxNode);
            boxNode.updateMatrixWorld(true);

            traverse(rootNode);
        }
    } else {
        groupBox.visible = false;
    }
};

CLOUD.Scene.prototype.intersectToWorld = function (intersect) {

    // 注意：不确定相对坐标位置是否被其他模块使用，暂时先采用新的变量来保存世界坐标下的位置及包围盒
    // 最好是在求交点的时候，包围盒就和位置一起进行坐标变换, 就可以免除这里的计算了
    var sceneMatrix = this.getMatrixGlobal();

    // 获得世界坐标下的位置
    intersect.worldPosition = CLOUD.GeomUtil.getWorldPositionOfMesh(intersect.point, sceneMatrix);
    // 获得世界坐标下的包围盒
    intersect.worldBoundingBox = CLOUD.GeomUtil.getBoundingBoxWorldOfMesh(intersect.object, sceneMatrix);
};

/**
 * 世界坐标转绘图空间(场景变换后)坐标
 *
 * @param {object} point - 世界坐标下的点集 {x:0, y:0, z:0}
 * @return {object} 绘图区域坐标 {x:0, y:0, z:0}
 */
CLOUD.Scene.prototype.worldToDrawing = function (point) {

    var sceneMatrix = this.getMatrixGlobal();

    // 进行场景变换，获得场景变换后的世界坐标
    var result = new THREE.Vector3(point.x, point.y, point.z);
    result.applyMatrix4(sceneMatrix);

    return result;
};

/**
 * 绘图空间(场景变换后)坐标转世界坐标
 *
 * @param {object} point - 绘图区域坐标下的点集 {x:0, y:0, z:0}。
 * @return {object} 世界坐标 {x:0, y:0, z:0}
 */
CLOUD.Scene.prototype.drawingToWorld = function (point) {

    var sceneMatrix = this.getMatrixGlobal();

    var inverseScaleMatrix = new THREE.Matrix4();
    inverseScaleMatrix.getInverse(sceneMatrix);

    // 计算世界坐标下的位置
    var result = new THREE.Vector3(point.x, point.y, point.z);
    result.applyMatrix4(inverseScaleMatrix);

    return result;
};

/**
 * 获得mesh的包围盒
 *
 */
CLOUD.Scene.prototype.getBoundingBoxWorldByMesh = function (mesh) {

    var sceneMatrix = this.getMatrixGlobal();

    // 计算世界坐标下的包围盒
    var bBox = mesh.boundingBox;

    if (!bBox) {

        if (!mesh.geometry.boundingBox) {
            mesh.geometry.computeBoundingBox();
        }

        bBox = mesh.geometry.boundingBox;
    }

    var boundingBox = bBox.clone();
    boundingBox.applyMatrix4(mesh.matrixWorld);

    var inverseScaleMatrix = new THREE.Matrix4();
    inverseScaleMatrix.getInverse(sceneMatrix);
    boundingBox.applyMatrix4(inverseScaleMatrix);

    return boundingBox;
};

/**
 * 获得对象池
 *
 */
CLOUD.Scene.prototype.getObjectPool = function () {

    return this.pool;
};

/**
 * 设置 boundingbox
 *
 */
CLOUD.Scene.prototype.setBoundingBoxWorld = function (boundingBox) {

    this.rootNode.boundingBox = boundingBox;
};

CLOUD.Scene.prototype.clearPickGroups = function () {

    this.pickGroups.length = 0;
};

CLOUD.Scene.prototype.addToPickGroups = function (group) {

    var exist = false;

    for (var i = 0, len = this.pickGroups.length; i < len; ++i) {

        if (this.pickGroups[i] === group) {
            exist = true;
            break;
        }
    }

    if (exist) {
        return;
    }

    this.pickGroups.push(group);
};

CLOUD.Scene.prototype.removeFromPickGroups = function (group) {

    for (var i = 0, len = this.pickGroups.length; i < len; ++i) {

        if (this.pickGroups[i] === group) {

            this.pickGroups.splice(i, 1);
            break;
        }
    }
};

CLOUD.Raycaster = function (origin, direction, near, far) {
    "use strict";

    this.ray = new THREE.Ray(origin, direction);
    // direction is assumed to be normalized (for accurate distance calculations)

    this.near = near || 0;
    this.far = far || Infinity;

    this.params = {
        Sprite: {},
        Mesh: {},
        Points: { threshold: 1 },
        LOD: {},
        Line: {}
    };
};

CLOUD.Raycaster.prototype = {

    constructor: CLOUD.Raycaster,

    precision: 0.0001,
    linePrecision: 1,

    descSort: function descSort(a, b) {
        return a.distance - b.distance;
    },

    set: function set(origin, direction) {
        // direction is assumed to be normalized (for accurate distance calculations)

        this.ray.set(origin, direction);
    },

    setFromCamera: function setFromCamera(coords, camera) {

        // camera is assumed _not_ to be a child of a transformed object
        if (camera instanceof THREE.CombinedCamera) {
            if (camera.isPerspective) {
                this.ray.origin.copy(camera.position);
                this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(camera.position).normalize();
            } else {
                this.ray.origin.set(coords.x, coords.y, -1).unproject(camera);
                this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            }
        } else if (camera instanceof THREE.PerspectiveCamera) {
            this.ray.origin.copy(camera.position);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(camera.position).normalize();
        } else if (camera instanceof THREE.OrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, -1).unproject(camera);
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
        } else {
            console.error('CLOUD.Raycaster: Unsupported camera type.');
        }
    },

    intersectObject: function intersectObject(object, recursive) {

        var intersects = [];

        CLOUD.CameraUtil.intersectObject(object, this, intersects, recursive);

        //intersects.sort( descSort );

        return intersects;
    },

    intersectObjects: function intersectObjects(objects, recursive) {

        var intersects = [];

        for (var i = 0, len = objects.length; i < len; i++) {
            CLOUD.CameraUtil.intersectObject(objects[i], this, intersects, recursive);
        }

        //intersects.sort( descSort );

        return intersects;
    },

    // travesal octree, get octree nodes that intersect with the ray
    intersectOctantForNode: function intersectOctantForNode(octreeRoot, octants) {
        var scope = this;
        var bbox = new THREE.Box3();

        function doIntersect(root) {
            var i;
            var length;
            bbox.set(root.min, root.max);
            if (scope.ray.intersectBox(bbox)) {
                octants.push(root);

                if (root.childOctants) {
                    for (i = 0, length = root.childOctants.length; i < length; i++) {
                        doIntersect(root.childOctants[i]);
                    }
                }
            }
        }

        doIntersect(octreeRoot);
    }
};

// Get distance from the ray origin to the near intersect point to the box
// If the box is not intersected with the ray, return -1
THREE.Ray.prototype.intersectBoxWithDistance = function (box) {

    var tmin, tmax, tymin, tymax, tzmin, tzmax;

    var invdirx = 1 / this.direction.x,
        invdiry = 1 / this.direction.y,
        invdirz = 1 / this.direction.z;

    var origin = this.origin;

    if (invdirx >= 0) {

        tmin = (box.min.x - origin.x) * invdirx;
        tmax = (box.max.x - origin.x) * invdirx;
    } else {

        tmin = (box.max.x - origin.x) * invdirx;
        tmax = (box.min.x - origin.x) * invdirx;
    }

    if (invdiry >= 0) {

        tymin = (box.min.y - origin.y) * invdiry;
        tymax = (box.max.y - origin.y) * invdiry;
    } else {

        tymin = (box.max.y - origin.y) * invdiry;
        tymax = (box.min.y - origin.y) * invdiry;
    }

    if (tmin > tymax || tymin > tmax) return -1;

    // These lines also handle the case where tmin or tmax is NaN
    // (result of 0 * Infinity). x !== x returns true if x is NaN

    if (tymin > tmin || tmin !== tmin) tmin = tymin;

    if (tymax < tmax || tmax !== tmax) tmax = tymax;

    if (invdirz >= 0) {

        tzmin = (box.min.z - origin.z) * invdirz;
        tzmax = (box.max.z - origin.z) * invdirz;
    } else {

        tzmin = (box.max.z - origin.z) * invdirz;
        tzmax = (box.min.z - origin.z) * invdirz;
    }

    if (tmin > tzmax || tzmin > tmax) return -1;

    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;

    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

    if (tmax < 0) return -1;

    if (tmin < 0) return 0;

    // get the near intersect point
    var optionalTarget = this.at(tmin >= 0 ? tmin : tmax);

    // get distance from the near point to ray origin
    var dx = optionalTarget.x - origin.x;
    var dy = optionalTarget.y - origin.y;
    var dz = optionalTarget.z - origin.z;
    return Math.sqrt(dx * dx + dy * dy + dz * dz);
};
CLOUD.BaseEditor = function (cameraControl, scene, domElement) {

    this.name = '';
    this.scene = scene;
    this.domElement = domElement !== undefined ? domElement : document;
    this.cameraControl = cameraControl;
    this.mouseButtons = { ORBIT: THREE.MOUSE.RIGHT, PAN2: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.LEFT };
    this.mouseMoveAlwaysAllowed = false;
    this.pickHelper = new CLOUD.PickHelper(scene, cameraControl);
};

CLOUD.BaseEditor.prototype.getName = function () {
    return this.name;
};

CLOUD.BaseEditor.prototype.destroy = function () {

    this.pickHelper.destroy();
    this.pickHelper = null;

    this.scene = null;
    this.domElement = null;
    this.cameraControl = null;
    this.mouseButtons = null;
};

CLOUD.BaseEditor.prototype.onExist = function () {};

CLOUD.BaseEditor.prototype.resize = function () {};

CLOUD.BaseEditor.prototype.onEnter = function () {};

CLOUD.BaseEditor.prototype.onMouseDown = function (event) {};

CLOUD.BaseEditor.prototype.onMouseMove = function (event) {};

CLOUD.BaseEditor.prototype.onMouseUp = function (event) {};

CLOUD.BaseEditor.prototype.onMouseWheel = function (event) {};

CLOUD.BaseEditor.prototype.onMouseDoubleClick = function (event) {};

CLOUD.BaseEditor.prototype.onKeyDown = function (event) {};

CLOUD.BaseEditor.prototype.onKeyUp = function (event) {};

CLOUD.BaseEditor.prototype.touchstart = function (event) {};

CLOUD.BaseEditor.prototype.touchmove = function (event) {};

CLOUD.BaseEditor.prototype.touchend = function (event) {};

CLOUD.BaseEditor.prototype.onHover = function (event) {};

CLOUD.BaseEditor.prototype.moveTo = function (direction) {};

CLOUD.BaseEditor.prototype.dispatchEvent = function (event) {
    var modelManager = this.cameraControl.viewer.modelManager;
    modelManager.dispatchEvent(event);
};

CLOUD.BaseEditor.prototype.getDomElement = function () {
    return this.domElement;
};

CLOUD.BaseEditor.prototype.updateButtons = function (mouseButtons) {

    if (mouseButtons.ORBIT !== undefined) {
        this.mouseButtons.ORBIT = mouseButtons.ORBIT;
    }

    if (mouseButtons.PAN !== undefined) {
        this.mouseButtons.PAN = mouseButtons.PAN;
    }

    if (mouseButtons.PAN2 !== undefined) {
        this.mouseButtons.PAN2 = mouseButtons.PAN2;
    }

    if (mouseButtons.ZOOM !== undefined) {
        this.mouseButtons.ZOOM = mouseButtons.ZOOM;
    }
};

CLOUD.BaseEditor.prototype.getReverseWheelDirection = function () {
    return this.cameraControl.viewer.getReverseWheelDirection();
};

CLOUD.BaseEditor.prototype.getSpeedRate = function () {
    return this.cameraControl.viewer.getMovementSpeedRate();
};

CLOUD.PickHelper = function (scene, cameraControl) {
    "use strict";

    this.cameraControl = cameraControl;
    this.scene = scene;

    this.timerId = null;
};

CLOUD.PickHelper.prototype = {

    constructor: CLOUD.PickHelper,

    destroy: function destroy() {
        this.cameraControl = null;
        this.scene = null;
        this.filter = null;
    },

    click: function click(event, preIntersect) {

        var scope = this;

        function handleClick() {
            scope.handleMousePick(event, false, preIntersect);
        }

        if (this.timerId) {
            clearTimeout(this.timerId);
        }

        // 延迟300ms以判断是否单击
        this.timerId = setTimeout(handleClick, 300);
    },

    doubleClick: function doubleClick(event) {

        event.preventDefault();

        if (this.timerId) {
            clearTimeout(this.timerId);
        }

        this.handleMousePick(event, true, null);
    },

    handleMousePick: function handleMousePick(event, isDoubleClick, preIntersect) {

        var cameraControl = this.cameraControl;

        if (cameraControl.enabled === false) return false;

        // 禁用单击pick
        if (!isDoubleClick && CLOUD.GlobalData.DisablePick) {
            return false;
        }

        var sceneState = cameraControl.viewer.modelManager.sceneState;

        var scope = this;
        var screenPos = new THREE.Vector2(event.clientX, event.clientY);

        var canvasXY = cameraControl.screenToCanvas(event.clientX, event.clientY);

        function dispatchPickEvent(intersect) {
            var modelManager = cameraControl.viewer.modelManager;

            // 外部需要获得event的一些状态，需要得到canvas坐标(屏幕坐标没用处)
            modelManager.dispatchEvent({
                type: CLOUD.EVENTS.ON_CLICK_PICK,
                event: event, // add
                doubleClick: isDoubleClick, // add
                canvasPos: { x: canvasXY.x, y: canvasXY.y }, // adjust
                intersectInfo: intersect ? {
                    tag: intersect.tag, // 选中元素的标识
                    selectedObjectId: intersect.userId,
                    modelId: intersect.databagId,
                    worldPosition: intersect.worldPosition,
                    worldBoundingBox: intersect.worldBoundingBox,
                    point: intersect.point,
                    index: intersect.index, // CLOUD.Points存在索引值
                    innnerDebugging: intersect.innnerDebugging
                } : null
            });
        }

        var intersect;
        if (preIntersect) {
            intersect = preIntersect;
        } else {

            var pickGroups = this.scene.pickGroups;
            var intersects = [];

            for (var i = 0, len = pickGroups.length; i < len; ++i) {

                var intersectTemp = null;
                var pickGroup = pickGroups[i];

                if (pickGroup.sceneRoot) {

                    var intersectContext = cameraControl.getIntersectContext(screenPos);
                    intersectTemp = cameraControl.intersector.pick(intersectContext, null);
                } else {

                    if (pickGroup.pickEnabled) {

                        intersectTemp = this.pick(screenPos, cameraControl.camera, pickGroup);

                        if (intersectTemp) {
                            intersectTemp.tag = pickGroup.tag;
                        }
                    }
                }

                if (intersectTemp) {
                    intersects.push(intersectTemp);
                }
            }

            if (intersects.length > 0) {

                intersects.sort(function (a, b) {
                    return a.distance - b.distance;
                });

                intersect = intersects[0];
            }

            if (!intersect) {

                if (scope.lastPickedUserId !== undefined) {

                    sceneState.clearSelection();
                    scope.lastPickedUserId = undefined;
                    dispatchPickEvent(null);
                    cameraControl.updateView(true);
                } else {
                    dispatchPickEvent(null);
                }

                return;
            }
        }

        var userId = intersect.userId;

        // if (scope.lastPickedUserId === userId) {
        //     return;
        // }

        scope.lastPickedUserId = userId;

        if (CLOUD.Utils.isMobileDevice()) {
            cameraControl.pivot = intersect.point;
        }

        // 将位置和包围转换到世界系
        scope.scene.intersectToWorld(intersect);

        // 双击构件变半透明，再双击取消半透明状态
        if (isDoubleClick) {

            if (CLOUD.GlobalData.EnableDemolishByDClick) {
                sceneState.addSelection([userId]);
                cameraControl.updateView(true);
            } else {
                sceneState.setSelection([userId]);
                cameraControl.fitAndRotateBySelection();
            }
        } else {

            intersect.innnerDebugging = event.altKey;
            intersect.cx = screenPos.x;
            intersect.cy = screenPos.y;

            if (!event.ctrlKey) {
                sceneState.setSelection([userId]);
            } else {
                sceneState.addSelection([userId]);
            }
            dispatchPickEvent(intersect);
            cameraControl.updateView(true);
        }
    },

    handleMouseHover: function handleMouseHover(event) {

        if (CLOUD.GlobalData.Hover) {

            var scope = this;
            var cameraControl = this.cameraControl;
            var filter = cameraControl.viewer.getFilters();

            var screenPos = new THREE.Vector2(event.clientX, event.clientY);
            var intersectContext = cameraControl.getIntersectContext(screenPos);

            cameraControl.intersector.pick(intersectContext, function (intersect) {

                if (intersect) {

                    var userId = intersect.userId;

                    if (scope.lastHoverUserId !== userId) {

                        scope.lastHoverUserId = userId;

                        var material = intersect.object.material;

                        // color可能不存在
                        if (material.color) {

                            var newColor = material.color.clone();
                            newColor.r += newColor.r * 0.3;
                            newColor.g += newColor.g * 0.3;
                            newColor.b += newColor.b * 0.3;

                            if (newColor.r > 1.0) {
                                newColor.r = 1.0;
                            }

                            if (newColor.g > 1.0) {
                                newColor.g = 1.0;
                            }

                            if (newColor.b > 1.0) {
                                newColor.b = 1.0;
                            }

                            if (newColor.r === 1.0 && newColor.g === 1.0 && newColor.b === 1.0) {
                                newColor.r = 0.87;
                                newColor.g = 0.87;
                                newColor.b = 0.87;
                            }

                            var params = {
                                color: newColor.getHex(),
                                opacity: material.opacity,
                                transparent: material.transparent,
                                side: material.side
                            };

                            filter._setHoverMaterial(params);
                            filter._setHoverId(intersect.userId);

                            cameraControl.updateView(true);
                        }
                    }
                } else {

                    if (scope.lastHoverUserId !== undefined) {

                        scope.lastHoverUserId = undefined;
                        filter._clearHoverId();
                        cameraControl.updateView(true);
                    }
                }
            });
        }
    },

    pick: function pick(mouse, camera, group) {

        var normalizedPoint = this.cameraControl.mapWindowToViewport(mouse.x, mouse.y);
        var raycaster = this.cameraControl.intersector.raycaster;
        raycaster.setFromCamera(normalizedPoint, camera);

        var intersects = raycaster.intersectObjects(group.children, true);

        var length = intersects.length;

        if (length > 0) {

            intersects.sort(function (a, b) {
                return a.distance - b.distance;
            });

            for (var ii = 0; ii < length; ++ii) {

                var intersect = intersects[ii];

                if (intersect.distance <= camera.near) continue;

                var meshNode = intersect.object;

                if (meshNode.geometry) {

                    intersect.userId = meshNode.name;

                    return intersect;
                }
            }
        }

        return null;
    }
};

CLOUD.OrbitEditor = function (cameraControl, scene, domElement) {
    "use strict";

    CLOUD.BaseEditor.call(this, cameraControl, scene, domElement);

    // Mouse buttons
    this.mouseButtons = { ORBIT: THREE.MOUSE.RIGHT, PAN2: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.LEFT };

    this.isMouseClick = false;
    this.oldMouseX = -1;
    this.oldMouseY = -1;

    this.timeoutId = null;
    this.intersectOfMouseDown = null;
};

CLOUD.OrbitEditor.prototype = Object.create(CLOUD.BaseEditor.prototype);
CLOUD.OrbitEditor.prototype.constructor = CLOUD.OrbitEditor;

CLOUD.OrbitEditor.prototype.destroy = function () {

    CLOUD.BaseEditor.prototype.destroy.call(this);

    this.intersectOfMouseDown = null;
    this.timeoutId = null;
};

CLOUD.OrbitEditor.prototype._delayHandle = function () {

    var cameraControl = this.cameraControl;

    function handle() {
        cameraControl.update(true, true);
    }

    if (this.timeoutId) {
        clearTimeout(this.timeoutId);
    }

    // 延迟300ms以判断是否单击
    this.timeoutId = setTimeout(handle, 200);
    cameraControl.needUpdateRenderList(false);
};

CLOUD.OrbitEditor.prototype.onMouseDown = function (event) {
    return this.processMouseDown(event);
};

CLOUD.OrbitEditor.prototype.onMouseMove = function (event) {
    this.processMouseMove(event);
};

CLOUD.OrbitEditor.prototype.onMouseUp = function (event) {
    return this.processMouseUp(event);
};

CLOUD.OrbitEditor.prototype.onMouseWheel = function (event) {
    this.processMouseWheel(event);
};

CLOUD.OrbitEditor.prototype.onMouseDoubleClick = function (event) {};

CLOUD.OrbitEditor.prototype.onKeyDown = function (event) {
    this.processKeyDown(event);
};

CLOUD.OrbitEditor.prototype.onKeyUp = function (event) {
    this.processKeyUp(event);
};

CLOUD.OrbitEditor.prototype.touchstart = function (event) {
    this.processTouchStart(event);
};

CLOUD.OrbitEditor.prototype.touchmove = function (event) {
    this.processTouchMove(event);
};

CLOUD.OrbitEditor.prototype.touchend = function (event) {
    this.processTouchEnd(event);
};

CLOUD.OrbitEditor.prototype.onHover = function (event) {
    this.processMouseHover(event);
};

CLOUD.OrbitEditor.prototype.processMouseDown = function (event) {

    this.isMouseClick = false;
    this.oldMouseX = event.clientX;
    this.oldMouseY = event.clientY;

    var scope = this;
    var cameraControl = this.cameraControl;

    if (cameraControl.enabled === false) {
        return false;
    }

    this.intersectOfMouseDown = null;
    event.preventDefault();

    if (event.button === scope.mouseButtons.ORBIT) {

        if (cameraControl.noRotate === true) return false;

        cameraControl.updatePivot({ x: event.clientX, y: event.clientY });
        cameraControl.beginRotate(event.clientX, event.clientY);
    } else if (event.button === scope.mouseButtons.ZOOM) {

        if (cameraControl.noZoom === true) {
            return false;
        }

        cameraControl.beginZoom(event.clientX, event.clientY);
    } else if (event.button === scope.mouseButtons.PAN || event.button === scope.mouseButtons.PAN2) {

        if (cameraControl.noPan === true) {
            return false;
        }

        cameraControl.beginPan(event.clientX, event.clientY);
        this.intersectOfMouseDown = cameraControl.getLastIntersect();
    }

    if (cameraControl.IsIdle() === false) {
        return true;
    }

    return false;
};

CLOUD.OrbitEditor.prototype.processMouseMove = function (event) {

    var cameraControl = this.cameraControl;
    if (cameraControl.enabled === false) {
        return false;
    }

    event.preventDefault();

    //CLOUD.Logger.log("[CloudOrbitEditor.onMouseMove][mouse.clientXY(" + event.clientX + "," + event.clientY + "),mouse.offsetXY(" + event.offsetX + "," + event.offsetY + ")]");

    // 当鼠标移动到其他元素上时，event.offsetX, event.offsetY获得的是鼠标在其他元素区域里的相对坐标，
    // 会造成模型跳变，所以传入event.clientX, event.clientY，根据当前父元素节点位置计算鼠标的真实偏移量
    //cameraControl.process(event.offsetX, event.offsetY);
    cameraControl.process(event.clientX, event.clientY, true);

    return true;
};

CLOUD.OrbitEditor.prototype.processMouseUp = function (event) {

    this.intersectOfMouseDown = null;

    // 直接使用up来模拟click
    if (this.oldMouseX == event.clientX && this.oldMouseY == event.clientY) {
        this.isMouseClick = true;
    } else {
        this.oldMouseX = event.clientX;
        this.oldMouseY = event.clientY;
    }

    var cameraControl = this.cameraControl;
    if (cameraControl.enabled === false) return false;

    if (cameraControl.IsIdle() === true) {
        return false;
    }

    if (!this.isMouseClick) {
        cameraControl.update(true);
    }

    cameraControl.endOperation();

    return true;
};

CLOUD.OrbitEditor.prototype.processMouseWheel = function (event) {

    var cameraControl = this.cameraControl;

    if (cameraControl.enabled === false || cameraControl.noZoom === true) return;

    event.preventDefault();
    event.stopPropagation();

    //滚轮操作在浏览器中要考虑兼容性
    // 五大浏览器（IE、Opera、Safari、Firefox、Chrome）中Firefox 使用detail，其余四类使用wheelDelta；
    var delta = 0;

    if (event.wheelDelta) {
        delta = event.wheelDelta;
    } else if (event.detail) {
        delta = -event.detail * 40;
    }

    delta *= 0.0005; // 0.0005

    if (this.getReverseWheelDirection()) {
        delta *= -1;
    }

    cameraControl.zoom(delta, event.clientX, event.clientY);
    this._delayHandle();
};

CLOUD.OrbitEditor.prototype.processKeyDown = function (event) {

    var cameraControl = this.cameraControl;

    if (cameraControl.enabled === false || cameraControl.noKeys === true || cameraControl.noPan === true) return;

    this._delayHandle();

    var movementSpeed = cameraControl.movementSpeed * this.getSpeedRate();
    var keyPanSpeed = cameraControl.keyPanSpeed * this.getSpeedRate();

    switch (event.keyCode) {
        case cameraControl.keys.ZERO:
            cameraControl.keyPanSpeed = cameraControl.defaultKeyPanSpeed;
            cameraControl.movementSpeed = cameraControl.defaultMovementSpeed;
            break;

        case cameraControl.keys.PLUS:
            cameraControl.keyPanSpeed *= 1.1;
            cameraControl.movementSpeed *= 1.1;
            break;

        case cameraControl.keys.SUB:
            cameraControl.keyPanSpeed *= 0.9;

            if (cameraControl.keyPanSpeed < cameraControl.minKeyPanSpeed) {
                cameraControl.keyPanSpeed = this.minKeyPanSpeed;
            }

            cameraControl.movementSpeed *= 0.9;

            if (cameraControl.movementSpeed < cameraControl.minMovementSpeed) {
                cameraControl.movementSpeed = this.minMovementSpeed;
            }
            break;

        case cameraControl.keys.Q:
            cameraControl.pan(0, keyPanSpeed);
            cameraControl.update(true);
            break;

        case cameraControl.keys.E:
            cameraControl.pan(0, -keyPanSpeed);
            cameraControl.update(true);
            break;

        case cameraControl.keys.LEFT:
        case cameraControl.keys.A:
            cameraControl.pan(keyPanSpeed, 0);
            cameraControl.update(true);
            break;

        case cameraControl.keys.RIGHT:
        case cameraControl.keys.D:
            cameraControl.pan(-keyPanSpeed, 0);
            cameraControl.update(true);
            break;

        case cameraControl.keys.UP:
        case cameraControl.keys.W:
            cameraControl.moveForward(movementSpeed, !event.shiftKey);
            cameraControl.update(true);
            break;

        case cameraControl.keys.DOWN:
        case cameraControl.keys.S:
            cameraControl.moveBackward(movementSpeed, !event.shiftKey);
            cameraControl.update(true);
            break;
    }
};

CLOUD.OrbitEditor.prototype.processKeyUp = function (event) {

    var cameraControl = this.cameraControl;
    if (cameraControl.enabled === false || cameraControl.noKeys === true || cameraControl.noPan === true) return;

    switch (event.keyCode) {
        case cameraControl.keys.ESC:
            this.clearSelection();
            break;
        default:
            break;
    }
};

CLOUD.OrbitEditor.prototype.processTouchStart = function (event) {

    var cameraControl = this.cameraControl;

    if (cameraControl.enabled === false) return;

    cameraControl.touchStartHandler(event);
};

CLOUD.OrbitEditor.prototype.processTouchMove = function (event) {

    var cameraControl = this.cameraControl;

    if (cameraControl.enabled === false) return;

    event.preventDefault();
    //event.stopPropagation();

    cameraControl.touchMoveHandler(event);
};

CLOUD.OrbitEditor.prototype.processTouchEnd = function (event) {

    var cameraControl = this.cameraControl;

    if (cameraControl.enabled === false) return;

    cameraControl.touchEndHandler(event);

    //scope.dispatchEvent( endEvent );
};

CLOUD.OrbitEditor.prototype.processMouseHover = function (event) {

    this.pickHelper.handleMouseHover(event);
};

CLOUD.OrbitEditor.prototype.moveTo = function (direction) {

    if (direction === undefined) {
        return;
    }

    var cameraControl = this.cameraControl;

    if (cameraControl.enabled === false || cameraControl.noKeys === true || cameraControl.noPan === true) return;

    var movementSpeed = cameraControl.movementSpeed * this.getSpeedRate();
    var keyPanSpeed = cameraControl.keyPanSpeed * this.getSpeedRate();
    var enumMoveDirection = CLOUD.MoveDirection;

    switch (direction) {

        case enumMoveDirection.FORWARD:
            cameraControl.moveForward(movementSpeed, true);
            break;
        case enumMoveDirection.BACK:
            cameraControl.moveBackward(movementSpeed, true);
            break;

        case enumMoveDirection.LEFT:
            cameraControl.pan(keyPanSpeed, 0);
            break;

        case enumMoveDirection.RIGHT:
            cameraControl.pan(-keyPanSpeed, 0);
            break;

        case enumMoveDirection.UP:
            cameraControl.pan(0, keyPanSpeed);
            break;

        case enumMoveDirection.DOWN:
            cameraControl.pan(0, -keyPanSpeed);
            break;
        default:
            direction = enumMoveDirection.NONE;
            break;

    }

    if (direction !== enumMoveDirection.NONE) {
        cameraControl.update(true, true);
    }
};

/**
 * 清除构件选中状态
 *
 */
CLOUD.OrbitEditor.prototype.clearSelection = function () {

    // 对构件的特殊处理，严重依赖业务，需要考虑更灵活的实现
    var filter = this.cameraControl.viewer.filter;
    filter.clearIdList(CLOUD.EnumIdBasedType.SELECTED);
    this.dispatchEvent({ type: CLOUD.EVENTS.ON_SELECTION_CHANGED, intersect: null, click: 1 });
};
CLOUD.PickEditor = function (cameraControl, scene, domElement) {
    "use strict";

    CLOUD.OrbitEditor.call(this, cameraControl, scene, domElement);
};

CLOUD.PickEditor.prototype = Object.create(CLOUD.OrbitEditor.prototype);
CLOUD.PickEditor.prototype.constructor = CLOUD.PickEditor;

CLOUD.PickEditor.prototype.processMouseUp = function (event) {

    if (this.oldMouseX == event.clientX && this.oldMouseY == event.clientY) {
        this.pickHelper.click(event, this.intersectOfMouseDown);
    } else {
        this.cameraControl.update(true);
    }

    this.intersectOfMouseDown = null;
};

CLOUD.PickEditor.prototype.onMouseUp = function (event) {

    event.preventDefault();

    if (event.button === THREE.MOUSE.LEFT) {
        this.processMouseUp(event);
    }

    this.cameraControl.setState(-1);
};

CLOUD.PickEditor.prototype.onMouseDoubleClick = function (event) {

    if (event.button === THREE.MOUSE.LEFT) {
        this.pickHelper.doubleClick(event);
    }
};

CLOUD.RectPickEditor = function (cameraControl, scene, domElement) {

    CLOUD.OrbitEditor.call(this, cameraControl, scene, domElement);

    this.startPt = new THREE.Vector2();
    this.endPt = new THREE.Vector2();
    this.frustum = new THREE.Frustum();

    this.timeId = null;
    this.longTapFlag = false;

    if (CLOUD.Utils.isMobileDevice()) {
        this.selectPad = new CLOUD.SelectPad(this);
    } else {
        this.selectPad = null;
    }

    var scope = this;

    this.longTap = function () {
        scope.longTapFlag = true;
        CLOUD.Logger.log("long tap");

        if (scope.selectPad) {
            scope.selectPad.showOverlay(scope.startPt);
        }
    };
};

CLOUD.RectPickEditor.prototype = Object.create(CLOUD.OrbitEditor.prototype);
CLOUD.RectPickEditor.prototype.constructor = CLOUD.RectPickEditor;

CLOUD.RectPickEditor.prototype.destroy = function () {

    CLOUD.OrbitEditor.prototype.destroy.call(this);

    if (this.selectPad) {
        this.selectPad = null;
    }

    this.startPt = null;
    this.endPt = null;
    this.frustum = null;

    this.timeId = null;
};

CLOUD.RectPickEditor.prototype.onUpdateUI = function (obj) {
    this.dispatchEvent({ type: CLOUD.EVENTS.ON_EDITOR_UPDATEUI, data: obj, editor: this.name });
};

CLOUD.RectPickEditor.prototype.getDomElement = function () {
    return this.domElement;
};

CLOUD.RectPickEditor.prototype.updateFrustum = function (frustumUpdate, uiUpdate) {

    var x1 = this.startPt.x;
    var x2 = this.endPt.x;
    var y1 = this.startPt.y;
    var y2 = this.endPt.y;

    if (x1 > x2) {

        var tmp1 = x1;
        x1 = x2;
        x2 = tmp1;
    }

    if (y1 > y2) {

        var tmp2 = y1;
        y1 = y2;
        y2 = tmp2;
    }

    if (x2 - x1 == 0 || y2 - y1 == 0) return false;

    var cameraControl = this.cameraControl;
    var dim = cameraControl.getContainerDimensions();

    if (frustumUpdate) {
        cameraControl.computeFrustum(x1, x2, y1, y2, this.frustum, dim);
    }

    if (uiUpdate) {

        this.onUpdateUI({
            visible: true,
            dir: this.startPt.x < this.endPt.x,
            left: x1 - dim.left,
            top: y1 - dim.top,
            width: x2 - x1,
            height: y2 - y1
        });
    }

    return true;
};

CLOUD.RectPickEditor.prototype.onMouseDoubleClick = function (event) {
    this.pickHelper.doubleClick(event);
};

CLOUD.RectPickEditor.prototype.onMouseDown = function (event) {

    event.preventDefault();
    //event.stopPropagation();

    if (event.button === THREE.MOUSE.LEFT) {

        this.startPt.set(event.clientX, event.clientY);
    }

    return this.processMouseDown(event);
};

CLOUD.RectPickEditor.prototype.onMouseMove = function (event) {

    event.preventDefault();

    var allowRectPick = event.shiftKey || event.ctrlKey || event.altKey;

    if (allowRectPick && event.button === THREE.MOUSE.LEFT) {

        this.endPt.set(event.clientX, event.clientY);

        this.updateFrustum(false, true);
        return true;
    }

    this.processMouseMove(event);
};

CLOUD.RectPickEditor.prototype.onMouseUp = function (event) {

    event.preventDefault();
    //event.stopPropagation();

    this.onUpdateUI({ visible: false });

    if (event.button === THREE.MOUSE.LEFT) {

        if (Math.abs(this.startPt.x - event.clientX) < 2 && Math.abs(this.startPt.y - event.clientY) < 2) {
            this.pickHelper.click(event, this.intersectOfMouseDown);
            this.intersectOfMouseDown = null;
            return true;
        } else {
            var allowRectPick = event.shiftKey || event.ctrlKey || event.altKey;
            if (allowRectPick) {

                this.endPt.set(event.clientX, event.clientY);

                if (!this.updateFrustum(true, false)) {
                    this.pickHelper.click(event);
                    return false;
                }

                var state = CLOUD.OPSELECTIONTYPE.Clear;

                if (event.ctrlKey) {
                    state = CLOUD.OPSELECTIONTYPE.Add;
                } else if (event.altKey) {
                    state = CLOUD.OPSELECTIONTYPE.Remove;
                }

                CLOUD.PickUtil.pickByRect(this.scene, this.frustum, state, this.cameraControl.viewer.modelManager);

                this.pickHelper.lastPickedUserId = '';

                this.cameraControl.updateView(true);

                return true;
            }
        }
    }

    return this.processMouseUp(event);
};

CLOUD.RectPickEditor.prototype.touchstart = function (event) {

    this.startPt.set(event.touches[0].clientX, event.touches[0].clientY);

    this.processTouchStart(event);

    if (this.timeId) {
        clearTimeout(this.timeId);
    }

    var scope = this;
    scope.timeId = setTimeout(scope.longTap, 400);

    if (this.selectPad) {
        this.selectPad.hideOverlay();
    }
};

CLOUD.RectPickEditor.prototype.touchmove = function (event) {

    if (this.timeId) {
        clearTimeout(this.timeId);
    }

    event.preventDefault();
    event.stopPropagation();

    this.processTouchMove(event);
};

CLOUD.RectPickEditor.prototype.touchend = function (event) {

    this.processTouchEnd(event);

    if (this.timeId) {
        clearTimeout(this.timeId);
    }

    if (this.longTapFlag) {
        this.longTapFlag = false;
        event.preventDefault();
    }
};

CLOUD.ZoomEditor = function (cameraControl, scene, domElement) {
    "use strict";

    CLOUD.OrbitEditor.call(this, cameraControl, scene, domElement);
    this.mouseButtons = { ZOOM: THREE.MOUSE.LEFT, PAN2: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };
};
CLOUD.ZoomEditor.prototype = Object.create(CLOUD.OrbitEditor.prototype);
CLOUD.ZoomEditor.prototype.constructor = CLOUD.ZoomEditor;

CLOUD.ZoomEditor.prototype.updateButtons = function () {};

CLOUD.RectZoomEditor = function (cameraControl, scene, domElement) {
    "use strict";

    CLOUD.OrbitEditor.call(this, cameraControl, scene, domElement);
    this.startPt = new THREE.Vector2();
    this.endPt = new THREE.Vector2();
    this.frustum = new THREE.Frustum();
    this.activateZoom = false;
};

CLOUD.RectZoomEditor.prototype = Object.create(CLOUD.OrbitEditor.prototype);
CLOUD.RectZoomEditor.prototype.constructor = CLOUD.RectZoomEditor;

CLOUD.RectZoomEditor.prototype.onUpdateUI = function (obj) {
    this.dispatchEvent({ type: CLOUD.EVENTS.ON_EDITOR_UPDATEUI, data: obj, editor: this.name });
};

CLOUD.RectZoomEditor.prototype.updateFrustum = function (frustumUpdate, uiUpdate) {

    var x1 = this.startPt.x;
    var x2 = this.endPt.x;
    var y1 = this.startPt.y;
    var y2 = this.endPt.y;

    if (x1 > x2) {

        var tmp1 = x1;
        x1 = x2;
        x2 = tmp1;
    }

    if (y1 > y2) {

        var tmp2 = y1;
        y1 = y2;
        y2 = tmp2;
    }

    if (x2 - x1 == 0 || y2 - y1 == 0) return false;

    var cameraControl = this.cameraControl;
    var dim = cameraControl.getContainerDimensions();

    if (frustumUpdate) {
        cameraControl.computeFrustum(x1, x2, y1, y2, this.frustum, dim);
    }

    if (uiUpdate) {

        this.onUpdateUI({
            visible: true,
            dir: this.startPt.x < this.endPt.x,
            left: x1 - dim.left,
            top: y1 - dim.top,
            width: x2 - x1,
            height: y2 - y1
        });
    }

    return true;
};

CLOUD.RectZoomEditor.prototype.onMouseDown = function (event) {

    event.preventDefault();
    event.stopPropagation();

    if (event.button === THREE.MOUSE.LEFT) {

        this.startPt.set(event.clientX, event.clientY);
        this.activateZoom = true;
    }

    return this.processMouseDown(event);
};

CLOUD.RectZoomEditor.prototype.onMouseMove = function (event) {

    event.preventDefault();

    if (this.activateZoom) {

        this.endPt.set(event.clientX, event.clientY);
        this.updateFrustum(false, true);
        return true;
    }

    this.processMouseMove(event);
};

CLOUD.RectZoomEditor.prototype.onMouseUp = function (event) {

    event.preventDefault();
    event.stopPropagation();

    this.activateZoom = false;

    this.onUpdateUI({ visible: false });

    if (event.button === THREE.MOUSE.LEFT) {

        if (this.startPt.x == event.clientX && this.startPt.y == event.clientY) {

            return true;
        } else {

            this.endPt.set(event.clientX, event.clientY);

            if (!this.updateFrustum(true, false)) {
                return false;
            }

            this.zoomToRectangle();

            return true;
        }
    }

    return this.processMouseUp(event);
};

CLOUD.RectZoomEditor.prototype.zoomToRectangle = function () {
    var camera = this.cameraControl.camera;
    var target = this.cameraControl.camera.target;
    var zNear = camera.near;

    var canvasBounds = this.cameraControl.getContainerDimensions();
    // var startX = this.startPt.x - canvasBounds.left;
    // var startY = this.startPt.y - canvasBounds.top;
    // var endX = this.endPt.x - canvasBounds.left;
    // var endY = this.endPt.y - canvasBounds.top;

    var startX = this.startPt.x;
    var startY = this.startPt.y;
    var endX = this.endPt.x;
    var endY = this.endPt.y;
    var rectWidth = Math.abs(endX - startX);
    var rectHeight = Math.abs(startY - endY);

    if (rectWidth === 0 || rectHeight === 0) return;

    var rectCenter = new THREE.Vector2((startX + endX) / 2, (startY + endY) / 2);

    var eye = camera.position.clone();
    var dirEyeToTarget = target.clone().sub(eye);
    var distEyeToTarget = dirEyeToTarget.length();

    var dirZoom;

    var intersectContext = this.cameraControl.getIntersectContext(rectCenter);

    var pivot = this.cameraControl.intersector.hitTest(intersectContext);

    if (pivot) {

        var scaleFactor = rectWidth / rectHeight > canvasBounds.width / canvasBounds.height ? rectWidth / canvasBounds.width : rectHeight / canvasBounds.height;
        var distEyeToPivot = pivot.distanceTo(eye);
        var distZoom = distEyeToPivot * scaleFactor;

        dirEyeToTarget.normalize();
        //dirZoom = eye.clone().sub(pivot).normalize().multiplyScalar(zoomDist);
        dirZoom = dirEyeToTarget.clone().negate().multiplyScalar(distZoom);
    } else {

        var rcZoom = {};
        rcZoom.left = Math.min(startX, endX);
        rcZoom.top = Math.min(startY, endY);
        rcZoom.right = Math.max(startX, endX);
        rcZoom.bottom = Math.max(startY, endY);

        var closeDepth = this.scene.getNearDepthByRect(this.frustum, camera);

        if (closeDepth !== Infinity) {

            var rCenter = new THREE.Vector3((startX + endX) / 2, (startY + endY) / 2, closeDepth);
            var rCorner = new THREE.Vector3(rcZoom.left, rcZoom.top, closeDepth);
            var wCenter = this.clientToWorld(rCenter);
            var wCorner = this.clientToWorld(rCorner);
            var distZoom = wCenter.clone().sub(wCorner).length();

            //if (distZoom < zNear) {
            //    //CLOUD.Logger.log("new dist", [newDist, near]);
            //    distZoom = zNear;
            //}

            pivot = wCenter.clone();
            dirEyeToTarget.normalize();
            dirZoom = dirEyeToTarget.clone().negate().multiplyScalar(distZoom);
        } else {

            return;
            /*
            // below code cannot work well. When near is small, the camera will be moved largely and cannot zoom back
            // see BIMFACEDM-1957
            var halfFrustumHeight = zNear * Math.tan(THREE.Math.degToRad(camera.fov * 0.5));
            var halfFrustumWidth = halfFrustumHeight * camera.aspect;
            var rightWidth = rectCenter.x * 2 * halfFrustumWidth / canvasBounds.width;
            var distCenterToRight = rightWidth - halfFrustumWidth;
            var upHeight = rectCenter.y * 2 * halfFrustumHeight / canvasBounds.height;
            var distCenterToUp = upHeight - halfFrustumHeight;
            var dirRight = this.cameraControl.getWorldRight();
            var dirUp = this.cameraControl.getWorldUp();
              dirRight.normalize().multiplyScalar(distCenterToRight);
            dirUp.multiplyScalar(distCenterToUp);
              var dirRay = dirEyeToTarget.clone().add(dirUp).add(dirRight);
              pivot = eye.clone().add(dirRay);
              var scaleFactor = rectWidth / rectHeight > canvasBounds.width / canvasBounds.height ? rectWidth / canvasBounds.width : rectHeight / canvasBounds.height;
            var distEyeToPivot = pivot.distanceTo(eye);
            var distZoom = distEyeToPivot * scaleFactor;
              dirEyeToTarget.normalize();
            //dirZoom = eye.clone().sub(pivot).normalize().multiplyScalar(zoomDist);
            dirZoom = dirEyeToTarget.clone().negate().multiplyScalar(distZoom);
            */
        }
    }

    eye = pivot.clone().add(dirZoom);
    camera.position.copy(eye);
    target.copy(eye).sub(dirZoom.clone().normalize().multiplyScalar(distEyeToTarget));
    this.cameraControl.updateView(true);
};

CLOUD.RectZoomEditor.prototype.worldToClient = function (wPoint) {

    var camera = this.cameraControl.camera;
    var result = new THREE.Vector3(wPoint.x, wPoint.y, wPoint.z);

    result.project(camera);

    return result;
};

CLOUD.RectZoomEditor.prototype.clientToWorld = function (cPoint) {

    var rect = this.cameraControl.getContainerDimensions();
    var camera = this.cameraControl.camera;
    var result = new THREE.Vector3();

    result.x = cPoint.x / rect.width * 2 - 1;
    result.y = -cPoint.y / rect.height * 2 + 1;
    result.z = cPoint.z;

    result.unproject(camera);

    return result;
};
CLOUD.PanEditor = function (cameraControl, scene, domElement) {
    "use strict";

    CLOUD.OrbitEditor.call(this, cameraControl, scene, domElement);
};

CLOUD.PanEditor.prototype = Object.create(CLOUD.OrbitEditor.prototype);
CLOUD.PanEditor.prototype.constructor = CLOUD.PanEditor;

CLOUD.PanEditor.prototype.updateButtons = function () {};
CLOUD.FlyEditor = function (cameraControl, scene, domElement) {

    "use strict";

    CLOUD.BaseEditor.call(this, cameraControl, scene, domElement);

    // API
    this.movementSpeed = 0.005 * CLOUD.GlobalData.SceneSize; // 移动速度
    this.defaultMovementSpeed = this.movementSpeed;
    this.minMovementSpeed = 0.001;

    this.lookSpeed = 0.001; // 相机观察速度

    this.constrainPitch = true; // 是否限制仰角
    // 仰角范围[-85, 175]
    this.pitchMin = THREE.Math.degToRad(5) - 0.5 * Math.PI; // 仰角最小值
    this.pitchMax = 0.5 * Math.PI - this.pitchMin; // 仰角最大值
    this.pitchDeltaTotal = 0;

    // 处理状态
    this.processState = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2 };
    this.currentProcessState = this.processState.NONE;

    this.moveState = CLOUD.MoveDirection.NONE;

    this.deltaYaw = 0.0;
    this.deltaPitch = 0.0;

    // 保存旋转点
    this.rotateStart = new THREE.Vector2();
    this.rotateEnd = new THREE.Vector2();
    this.rotateDelta = new THREE.Vector2();

    // 鼠标位置
    this.lastMousePoint = new THREE.Vector2();

    this.timeoutId = null;

    this.isLockHeight = false;
    this.lockedHeight = 0;

    this.pickHelper = new CLOUD.PickHelper(scene, cameraControl);
    this.intersectOfMouseDown = null;
};

CLOUD.FlyEditor.prototype = Object.create(CLOUD.BaseEditor.prototype);
CLOUD.FlyEditor.prototype.constructor = CLOUD.FlyEditor;

CLOUD.FlyEditor.prototype._update = function () {

    //var moveStep = delta * this.movementSpeed * this.movementSpeedMultiplier;
    var moveStep = this.movementSpeed * this.getSpeedRate();
    var cameraControl = this.cameraControl;
    var camera = cameraControl.camera;
    var position = camera.position;
    var target = camera.target;
    var eye = target.clone().sub(position);

    cameraControl.dirtyCamera(true);

    var enumMoveDirection = CLOUD.MoveDirection;

    // 前进
    if (this.moveState & enumMoveDirection.FORWARD) {
        this._goForward(moveStep);
    }

    // 后退
    if (this.moveState & enumMoveDirection.BACK) {
        this._goBack(moveStep);
    }

    // 左移
    if (this.moveState & enumMoveDirection.LEFT) {
        this._goLeft(moveStep);
    }

    // 右移
    if (this.moveState & enumMoveDirection.RIGHT) {
        this._goRight(moveStep);
    }

    // 上移
    if (this.moveState & enumMoveDirection.UP) {
        this._goUp(moveStep);
    }

    // 下移
    if (this.moveState & enumMoveDirection.DOWN) {
        this._goDown(moveStep);
    }

    // Pitch around axis Z only when axis Z locked.
    if (this.cameraControl.isConstrainedAxisZ) {
        this.deltaPitch = 0;
    }

    var worldUp = new THREE.Vector3(0, 1, 0);
    var upDir = camera.realUp || camera.up;
    var rightDir = eye.clone().cross(upDir).normalize();

    if (this.deltaPitch != 0) {
        var pitchTransform = new THREE.Quaternion().setFromAxisAngle(rightDir, -this.deltaPitch);
        var tmp = eye.clone();

        tmp.applyQuaternion(pitchTransform);

        var angle = tmp.angleTo(worldUp);
        // 钳制到[-PI/2, PI/2]
        angle = angle - 0.5 * Math.PI;

        // 限制角度
        if (angle >= this.pitchMin && angle <= this.pitchMax) {
            eye.applyQuaternion(pitchTransform);
        }

        this.deltaPitch = 0.0;
    }

    if (this.deltaYaw != 0) {
        //注意：鼠标左右移动的旋转轴要沿世界坐标系的y轴旋转，而不是摄像机自己的坐标轴，防止视角倾斜
        var yawTransform = new THREE.Quaternion().setFromAxisAngle(worldUp, -this.deltaYaw);

        eye.applyQuaternion(yawTransform);
        this.deltaYaw = 0.0;
    }

    target.addVectors(position, eye);

    // 刷新
    cameraControl.flyOnWorld();

    cameraControl.dirtyCamera(false);
};

// 前进
CLOUD.FlyEditor.prototype._goForward = function (step) {

    this.cameraControl.camera.translateZ(-step);
};

// 后退
CLOUD.FlyEditor.prototype._goBack = function (step) {

    this.cameraControl.camera.translateZ(step);
};

// 左移
CLOUD.FlyEditor.prototype._goLeft = function (step) {

    this.cameraControl.camera.translateX(-step);
};

// 右移
CLOUD.FlyEditor.prototype._goRight = function (step) {

    this.cameraControl.camera.translateX(step);
};

// 上移
CLOUD.FlyEditor.prototype._goUp = function (step) {

    this.cameraControl.camera.translateY(step);
};

// 下移
CLOUD.FlyEditor.prototype._goDown = function (step) {

    this.cameraControl.camera.translateY(-step);
};

//  右转：angle为正； 左转：angle为负
CLOUD.FlyEditor.prototype._goTurn = function (angle) {
    var position = this.cameraControl.camera.position;
    var target = this.cameraControl.camera.target;

    var diff = new THREE.Vector3(target.x - position.x, 0, target.z - position.z);
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    var centerDiff = new THREE.Vector3(diff.x * cosAngle - diff.z * sinAngle, 0, diff.x * sinAngle + diff.z * cosAngle);

    target.x = position.x + centerDiff.x;
    target.z = position.z + centerDiff.z;
};

// 俯仰
CLOUD.FlyEditor.prototype._goPitch = function (angle) {
    var position = this.cameraControl.camera.position;
    var target = this.cameraControl.camera.target;

    var offsetX = target.x - position.x;
    var offsetZ = target.z - position.z;
    var distance = Math.sqrt(offsetX * offsetX + offsetZ * offsetZ);
    var diff = new THREE.Vector3(distance, target.y - position.y, 0);
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    var centerDiff = new THREE.Vector3(diff.x * cosAngle - diff.y * sinAngle, diff.x * sinAngle + diff.y * cosAngle, 0);
    var percent = centerDiff.x / distance;

    target.x = position.x + percent * offsetX;
    target.y = position.y + centerDiff.y;
    target.z = position.z + percent * offsetZ;
};

CLOUD.FlyEditor.prototype._delayHandle = function () {

    var cameraControl = this.cameraControl;

    function handle() {
        cameraControl.needUpdateRenderList(true);
        //scope.update();
        // 最后一帧只需刷新数据
        cameraControl.flyOnWorld();
    }

    if (this.timeoutId) {
        clearTimeout(this.timeoutId);
    }

    // 延迟300ms以判断是否单击
    this.timeoutId = setTimeout(handle, 200);
    cameraControl.needUpdateRenderList(false);
};

CLOUD.FlyEditor.prototype.destroy = function () {
    this.cameraControl = null;
    this.scene = null;
    this.domElement = null;
};

CLOUD.FlyEditor.prototype.handleEvent = function (event) {
    if (typeof this[event.type] == 'function') {
        this[event.type](event);
    }
};

CLOUD.FlyEditor.prototype.onKeyDown = function (event) {
    this.processKeyDown(event);
};

CLOUD.FlyEditor.prototype.onKeyUp = function (event) {
    this.processKeyUp(event);
};

CLOUD.FlyEditor.prototype.onMouseDown = function (event) {

    this.lastMousePoint.set(event.clientX, event.clientY);

    return this.processMouseDown(event);
};

CLOUD.FlyEditor.prototype.onMouseMove = function (event) {
    this.processMouseMove(event);
};

CLOUD.FlyEditor.prototype.onMouseUp = function (event) {

    if (event.button === THREE.MOUSE.LEFT) {

        // check the location is not enough, also check time
        if (this.lastMousePoint.x === event.clientX && this.lastMousePoint.y === event.clientY) {
            this.pickHelper.click(event, this.intersectOfMouseDown);
            return true;
        }
    }

    this.intersectOfMouseDown = null;
    // this.lastMousePoint.set(event.clientX, event.clientY);

    return this.processMouseUp(event);
};

CLOUD.FlyEditor.prototype.onMouseWheel = function (event) {

    this.processMouseWheel(event);
};

CLOUD.FlyEditor.prototype.processMouseDown = function (event) {

    event.preventDefault();
    event.stopPropagation();

    var cameraControl = this.cameraControl;

    if (cameraControl.enabled === false) {
        return false;
    }

    this.intersectOfMouseDown = null;

    var enumProcessState = this.processState;

    if (event.button === this.mouseButtons.ORBIT) {

        // if (cameraControl.noRotate === true) {
        //     return false;
        // }

        // 设置旋转起点
        this.rotateStart.set(event.clientX, event.clientY);
        this.currentProcessState = enumProcessState.ROTATE;

        // cameraControl.beginRotate(event.clientX, event.clientY);

        this.dispatchEvent({ type: CLOUD.EVENTS.ON_EDITOR_BEGIN, name: "look", editor: this.name });
    } else if (event.button === this.mouseButtons.PAN || event.button === this.mouseButtons.PAN2) {

        if (cameraControl.noPan === true) {
            return false;
        }

        cameraControl.beginPan(event.clientX, event.clientY);
        this.intersectOfMouseDown = cameraControl.getLastIntersect();

        this.currentProcessState = enumProcessState.PAN;

        if (this.isLockHeight) {
            this.lockedHeight = event.clientY;
        }
    }
    // else if (event.button === this.mouseButtons.ZOOM) {
    //
    //     if (cameraControl.noZoom === true) {
    //         return false;
    //     }
    //
    //     cameraControl.beginZoom(event.clientX, event.clientY);
    //
    //     this.currentProcessState = enumProcessState.DOLLY;
    // }

    return true;
};

CLOUD.FlyEditor.prototype.processMouseMove = function (event) {

    var cameraControl = this.cameraControl;
    if (cameraControl.enabled === false) {
        return;
    }

    event.preventDefault();

    var currentState = this.currentProcessState,
        enumProcessState = this.processState;

    if (currentState === enumProcessState.ROTATE) {

        this.rotateEnd.set(event.clientX, event.clientY);
        this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
        this.rotateStart.copy(this.rotateEnd);

        if (this.rotateDelta.x != 0 || this.rotateDelta.y != 0) {

            this.deltaYaw += this.rotateDelta.x * this.lookSpeed;
            this.deltaPitch += this.rotateDelta.y * this.lookSpeed;

            this.isFirstPerson = !event.shiftKey;
            this._update();
        }
    } else if (currentState === enumProcessState.PAN /* || currentState === enumProcessState.DOLLY*/) {

            if (this.isLockHeight) {
                this.cameraControl.process(event.clientX, this.lockedHeight, true);
            } else {
                this.cameraControl.process(event.clientX, event.clientY, true);
            }
        }
};

CLOUD.FlyEditor.prototype.processMouseUp = function (event) {

    event.preventDefault();
    event.stopPropagation();

    var cameraControl = this.cameraControl;

    if (event.button === this.mouseButtons.ORBIT) {

        this.rotateDelta.set(0, 0);
        this.deltaYaw = 0;
        this.deltaPitch = 0;
        this.isFirstPerson = !event.shiftKey;
        this._update();
        this.dispatchEvent({ type: CLOUD.EVENTS.ON_EDITOR_END, name: "look", editor: this.name });
    } else if (event.button === this.mouseButtons.PAN) {

        if (this.isLockHeight) {
            cameraControl.process(event.clientX, this.lockedHeight, true);
        } else {
            cameraControl.process(event.clientX, event.clientY, true);
        }

        cameraControl.endOperation();
    }

    this.currentProcessState = this.processState.NONE;

    return true;
};

CLOUD.FlyEditor.prototype.processMouseWheel = function (event) {

    event.preventDefault();
    event.stopPropagation();

    var cameraControl = this.cameraControl;

    if (cameraControl.enabled === false || cameraControl.noZoom === true) {
        return;
    }

    // 鼠标滚轮缩放

    //滚轮操作在浏览器中要考虑兼容性
    // 五大浏览器（IE、Opera、Safari、Firefox、Chrome）中Firefox 使用detail，其余四类使用wheelDelta；
    //两者只在取值上不一致，代表含义一致，detail与wheelDelta只各取两个值，detail只取±3，wheelDelta只取±120，其中正数表示为向上，负数表示向下。
    var delta = 0 || event.wheelDelta || event.detail;
    delta = Math.abs(delta) > 10 ? delta : -delta * 40;
    delta *= 0.0005;

    if (this.getReverseWheelDirection()) {
        delta *= -1;
    }

    this._delayHandle();

    // 以中心为基准缩放
    var rect = cameraControl.getContainerDimensions();
    var clientX = rect.left + 0.5 * rect.width;
    var clientY = rect.top + 0.5 * rect.height;

    cameraControl.zoom(delta, clientX, clientY);
};

CLOUD.FlyEditor.prototype.processKeyDown = function (event) {

    if (event.altKey) {
        return;
    }

    var enumMoveDirection = CLOUD.MoveDirection;

    var moveDirection = enumMoveDirection.NONE;
    switch (event.keyCode) {
        case 48:
            /* 0 - 恢复速度 */
            this.movementSpeed = this.defaultMovementSpeed;
            break;
        case 187:
            /* 等号&加号 - 加速*/
            this.movementSpeed *= 1.1;
            break;
        case 189:
            /* 破折号&减号 - 减速*/
            this.movementSpeed *= 0.9;
            if (this.movementSpeed < this.minMovementSpeed) {
                this.movementSpeed = this.minMovementSpeed;
            }
            break;
        case 38: /*up - 前进*/
        case 87:
            /*W - 前进*/
            moveDirection = enumMoveDirection.FORWARD;
            break;
        case 40: /*down - 后退 */
        case 83:
            /*S - 后退*/
            moveDirection = enumMoveDirection.BACK;
            break;
        case 37: /*left - 左移 */
        case 65:
            /*A - 左移*/
            moveDirection = enumMoveDirection.LEFT;
            break;
        case 39: /*right - 右移*/
        case 68:
            /*D - 右移*/
            moveDirection = enumMoveDirection.RIGHT;
            break;
        case 81:
            /*Q - 上移*/
            moveDirection = enumMoveDirection.UP;
            break;
        case 69:
            /*E - 下移*/
            moveDirection = enumMoveDirection.DOWN;
            break;
        default:
        // needUpdateUI = true;
    }

    if (moveDirection !== enumMoveDirection.NONE) {
        this.moveState |= moveDirection;
        this.dispatchEvent({
            type: CLOUD.EVENTS.ON_EDITOR_KEYUP,
            event: event,
            state: moveDirection,
            direction: enumMoveDirection,
            editor: this.name
        });
    }

    this._delayHandle();

    this.isFirstPerson = !event.shiftKey;
    this._update();
};

CLOUD.FlyEditor.prototype.processKeyUp = function (event) {

    var enumMoveDirection = CLOUD.MoveDirection;
    var moveDirection = enumMoveDirection.NONE;

    switch (event.keyCode) {
        case 38: /*up - 前进*/
        case 87:
            /*W - 前进 */
            moveDirection = enumMoveDirection.FORWARD;
            break;
        case 40: /*down - 后退 */
        case 83:
            /*S - 后退 */
            moveDirection = enumMoveDirection.BACK;
            break;
        case 37: /*left - 左移 */
        case 65:
            /*A - 左移 */
            moveDirection = enumMoveDirection.LEFT;
            break;
        case 39: /*right - 右移*/
        case 68:
            /*D - 右移 */
            moveDirection = enumMoveDirection.RIGHT;
            break;
        case 81:
            /*Q - 上移 */
            moveDirection = enumMoveDirection.UP;
            break;
        case 69:
            /*E - 下移 */
            moveDirection = enumMoveDirection.DOWN;
            break;
    }

    if (moveDirection !== enumMoveDirection.NONE) {

        this.dispatchEvent({
            type: CLOUD.EVENTS.ON_EDITOR_KEYUP,
            event: event,
            state: moveDirection,
            direction: enumMoveDirection,
            editor: this.name
        });
        this.moveState &= ~moveDirection;
    }
};

CLOUD.FlyEditor.prototype.moveTo = function (direction) {

    this.moveState = direction;
    this._update();
    this.moveState = CLOUD.MoveDirection.NONE;
};

CLOUD.WalkEditor = function (cameraControl, scene, domElement) {

    "use strict";

    CLOUD.BaseEditor.call(this, cameraControl, scene, domElement);

    this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, PAN2: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };
    this.mouseMoveAlwaysAllowed = true;

    // API
    this.movementSpeed = 1000; // 移动速度
    this.defaultMovementSpeed = this.movementSpeed;
    this.minMovementSpeed = 0.001;

    this.lookSpeed = 0.001; // 相机观察速度

    this.constrainPitch = true; // 是否限制仰角
    // 仰角范围[-85, 175]
    this.pitchMin = THREE.Math.degToRad(5) - 0.5 * Math.PI; // 仰角最小值
    this.pitchMax = 0.5 * Math.PI - this.pitchMin; // 仰角最大值
    this.pitchDeltaTotal = 0;

    // 处理状态
    this.processState = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2 };
    this.currentProcessState = this.processState.NONE;

    this.moveState = CLOUD.MoveDirection.NONE;

    this.deltaYaw = 0.0;
    this.deltaPitch = 0.0;

    // 保存旋转点
    this.rotateStart = new THREE.Vector2();
    this.rotateEnd = new THREE.Vector2();
    this.rotateDelta = new THREE.Vector2();

    // 鼠标位置
    this.lastMousePoint = new THREE.Vector2();

    this.timeoutId = null;

    this.isLockHeight = false;
    this.lockedHeight = 0;

    this.isLookMousePressed = true;
    this.firstMouseMove = true;
    this.mousePressed = false;

    this.delayTime = 200; // ms
};

CLOUD.WalkEditor.prototype = Object.create(CLOUD.BaseEditor.prototype);
CLOUD.WalkEditor.prototype.constructor = CLOUD.WalkEditor;

CLOUD.WalkEditor.prototype.updateButtons = function () {};

// 根据世界系中的步进长度和绘图空间方向向量来获得绘图空间步进向量
CLOUD.WalkEditor.prototype.getStepDiff = function (camera, matrixScene, direction, stepWorld) {

    var inverseMatrix = new THREE.Matrix4();
    inverseMatrix.getInverse(matrixScene);

    var position = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
    var positionWorld = position.clone();
    positionWorld.applyMatrix4(inverseMatrix);

    // 变换到世界系
    var stepDiff = new THREE.Vector3(direction.x, direction.y, direction.z);
    stepDiff.add(position);
    stepDiff.applyMatrix4(inverseMatrix);
    stepDiff.sub(positionWorld).normalize().multiplyScalar(stepWorld);
    stepDiff.add(positionWorld);

    // 转换到绘图空间
    stepDiff.applyMatrix4(matrixScene);
    stepDiff.sub(position);

    return stepDiff;
};

CLOUD.WalkEditor.prototype.stepCameraForWalk = function (direction, step) {
    var camera = this.cameraControl.getCamera();
    var position = camera.position;
    var target = camera.target;
    var forward = new THREE.Vector3(target.x - position.x, 0, target.z - position.z).normalize();
    var up = new THREE.Vector3(0, 1, 0);
    var right = forward.clone().cross(up);
    var matrixScene = this.cameraControl.getScene().getMatrixGlobal();
    var stepDiff;

    switch (direction) {
        case CLOUD.MoveDirection.FORWARD:
            stepDiff = this.getStepDiff(camera, matrixScene, forward, step);
            stepDiff.y = 0;
            break;
        case CLOUD.MoveDirection.BACK:
            forward.multiplyScalar(-1);
            stepDiff = this.getStepDiff(camera, matrixScene, forward, step);
            stepDiff.y = 0;
            break;
        case CLOUD.MoveDirection.LEFT:
            right.multiplyScalar(-1);
            stepDiff = this.getStepDiff(camera, matrixScene, right, step);
            stepDiff.y = 0;
            break;
        case CLOUD.MoveDirection.RIGHT:
            stepDiff = this.getStepDiff(camera, matrixScene, right, step);
            stepDiff.y = 0;
            break;
    }

    position.add(stepDiff);
    target.add(stepDiff);
};

// 垂直移动照相机
CLOUD.WalkEditor.prototype._goUp = function (step) {

    var camera = this.cameraControl.getCamera();
    var position = camera.position;
    var target = camera.target;
    var up = new THREE.Vector3(0, 1, 0);
    var matrixScene = this.cameraControl.getScene().getMatrixGlobal();

    // 需要每次重新计算步进么？？？
    var stepDiff = this.getStepDiff(camera, matrixScene, up, step);

    // target和eye的Y轴上的坐标增加step
    position.y += stepDiff.y;
    target.y += stepDiff.y;
};

CLOUD.WalkEditor.prototype._goDown = function (step) {

    var camera = this.cameraControl.getCamera();
    var position = camera.position;
    var target = camera.target;
    var up = new THREE.Vector3(0, 1, 0);
    var matrixScene = this.cameraControl.getScene().getMatrixGlobal();

    // 需要每次重新计算步进么？？？
    var stepDiff = this.getStepDiff(camera, matrixScene, up, step);

    // target和eye的Y轴上的坐标增加step
    position.y -= stepDiff.y;
    target.y -= stepDiff.y;
};

//  右转：angle为正； 左转：angle为负
CLOUD.WalkEditor.prototype._goTurn = function (angle) {

    var camera = this.cameraControl.getCamera();
    var position = camera.position;
    var target = camera.target;

    var diff = new THREE.Vector3(target.x - position.x, 0, target.z - position.z);
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    var centerDiff = new THREE.Vector3(diff.x * cosAngle - diff.z * sinAngle, 0, diff.x * sinAngle + diff.z * cosAngle);

    target.x = position.x + centerDiff.x;
    target.z = position.z + centerDiff.z;
};

// 俯仰
CLOUD.WalkEditor.prototype._goPitch = function (angle) {

    var camera = this.cameraControl.getCamera();
    var position = camera.position;
    var target = camera.target;

    var offsetX = target.x - position.x;
    var offsetZ = target.z - position.z;
    var distance = Math.sqrt(offsetX * offsetX + offsetZ * offsetZ);
    var diff = new THREE.Vector3(distance, target.y - position.y, 0);
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    var centerDiff = new THREE.Vector3(diff.x * cosAngle - diff.y * sinAngle, diff.x * sinAngle + diff.y * cosAngle, 0);
    //var percent = centerDiff.x / distance;

    // 俯仰，不用改变x,z
    //target.x = position.x + percent * offsetX;
    target.y = position.y + centerDiff.y;
    //target.z = position.z + percent * offsetZ;
};

CLOUD.WalkEditor.prototype._delayHandle = function () {

    var cameraControl = this.cameraControl;

    function handle() {
        cameraControl.needUpdateRenderList(true);
        //scope.update();
        // 最后一帧只需刷新数据
        cameraControl.flyOnWorld();
    }

    if (this.timeoutId) {
        clearTimeout(this.timeoutId);
    }

    // 延迟以判断是否单击
    this.timeoutId = setTimeout(handle, this.delayTime);
    cameraControl.needUpdateRenderList(false);
};

CLOUD.WalkEditor.prototype.destroy = function () {

    CLOUD.BaseEditor.prototype.destroy.call(this);

    this.rotateStart = null;
    this.rotateEnd = null;
    this.rotateDelta = null;
    this.lastMousePoint = null;
    this.timeoutId = null;
};

CLOUD.WalkEditor.prototype.handleEvent = function (event) {
    if (typeof this[event.type] == 'function') {
        this[event.type](event);
    }
};

CLOUD.WalkEditor.prototype.onKeyDown = function (event) {
    this.processKeyDown(event);
};

CLOUD.WalkEditor.prototype.onKeyUp = function (event) {
    this.processKeyUp(event);
};

CLOUD.WalkEditor.prototype.onMouseDown = function (event) {

    this.lastMousePoint.set(event.clientX, event.clientY);
    this.mousePressed = true;
    this.firstMouseMove = true; // 只要按下即将该标志状态设成true

    return this.processMouseDown(event);
};

CLOUD.WalkEditor.prototype.onMouseMove = function (event) {
    this.processMouseMove(event);
};

CLOUD.WalkEditor.prototype.onMouseUp = function (event) {

    this.mousePressed = false;

    if (event.button === THREE.MOUSE.LEFT) {

        if (Math.abs(this.lastMousePoint.x - event.clientX) < 2 && Math.abs(this.lastMousePoint.y - event.clientY) < 2) {
            this.pickHelper.click(event);
            return true;
        }
    }

    // this.lastMousePoint.set(event.clientX, event.clientY);

    return this.processMouseUp(event);
};

CLOUD.WalkEditor.prototype.onMouseWheel = function (event) {

    this.processMouseWheel(event);
};

CLOUD.WalkEditor.prototype.processMouseDown = function (event) {

    event.preventDefault();
    event.stopPropagation();

    var cameraControl = this.cameraControl;

    if (cameraControl.enabled === false) {
        return false;
    }

    var enumProcessState = this.processState;

    if (event.button === this.mouseButtons.ORBIT) {

        // if (cameraControl.noRotate === true) {
        //     return false;
        // }

        // 设置旋转起点
        this.rotateStart.set(event.clientX, event.clientY);
        this.currentProcessState = enumProcessState.ROTATE;

        // cameraControl.beginRotate(event.clientX, event.clientY);

        this.dispatchEvent({ type: CLOUD.EVENTS.ON_EDITOR_BEGIN, name: "look", editor: this.name });
    }

    return true;
};

CLOUD.WalkEditor.prototype.processMouseMove = function (event) {

    var cameraControl = this.cameraControl;
    if (cameraControl.enabled === false) {
        return;
    }

    event.preventDefault();

    var needUpdate = false;

    if (this.isLookMousePressed) {

        // 鼠标按下移动来调整观察方向
        if (this.mousePressed) {

            needUpdate = true;
        }
    } else {

        // 鼠标直接移动来调整观察方向
        if (!this.mousePressed) {

            if (this.firstMouseMove) {

                this.firstMouseMove = false;
                this.rotateStart.set(event.clientX, event.clientY);
            }

            this.currentProcessState = this.processState.ROTATE;
            needUpdate = true;
        }
    }

    if (needUpdate) {

        if (this.currentProcessState === this.processState.ROTATE) {

            this.rotateEnd.set(event.clientX, event.clientY);
            this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
            this.rotateStart.copy(this.rotateEnd);

            if (this.rotateDelta.x != 0 || this.rotateDelta.y != 0) {

                this.deltaYaw += this.rotateDelta.x * this.lookSpeed;
                this.deltaPitch += this.rotateDelta.y * this.lookSpeed;

                this.update();
            }
        }
    }
};

CLOUD.WalkEditor.prototype.processMouseUp = function (event) {

    event.preventDefault();
    event.stopPropagation();

    var cameraControl = this.cameraControl;

    if (cameraControl.enabled === false) {
        return;
    }

    if (this.currentProcessState === this.processState.ROTATE) {

        this.rotateDelta.set(0, 0);
        this.deltaYaw = 0;
        this.deltaPitch = 0;
        this.update();
        this.dispatchEvent({ type: CLOUD.EVENTS.ON_EDITOR_END, name: "look", editor: this.name });
    }

    this.currentProcessState = this.processState.NONE;

    return true;
};

CLOUD.WalkEditor.prototype.processMouseWheel = function (event) {

    event.preventDefault();
    event.stopPropagation();

    var cameraControl = this.cameraControl;

    if (cameraControl.enabled === false || cameraControl.noZoom === true) {
        return;
    }

    // 鼠标滚轮缩放

    //滚轮操作在浏览器中要考虑兼容性
    // 五大浏览器（IE、Opera、Safari、Firefox、Chrome）中Firefox 使用detail，其余四类使用wheelDelta；
    //两者只在取值上不一致，代表含义一致，detail与wheelDelta只各取两个值，detail只取±3，wheelDelta只取±120，其中正数表示为向上，负数表示向下。
    var delta = 0 || event.wheelDelta || event.detail;
    delta = Math.abs(delta) > 10 ? delta : -delta * 40;
    delta *= 0.0005;

    if (this.getReverseWheelDirection()) {
        delta *= -1;
    }

    this._delayHandle();

    // 以中心为基准缩放
    var rect = cameraControl.getContainerDimensions();
    var clientX = rect.left + 0.5 * rect.width;
    var clientY = rect.top + 0.5 * rect.height;

    cameraControl.zoom(delta, clientX, clientY);
};

CLOUD.WalkEditor.prototype.processKeyDown = function (event) {

    if (event.altKey) {
        return;
    }

    var enumMoveDirection = CLOUD.MoveDirection;
    var moveDirection = enumMoveDirection.NONE;
    var keys = this.cameraControl.keys;

    switch (event.keyCode) {
        case keys.ZERO:
            /* 0 - 恢复速度 */
            this.movementSpeed = this.defaultMovementSpeed;
            break;
        case keys.PLUS:
            /* 等号&加号 - 加速*/
            this.movementSpeed *= 1.1;
            break;
        case keys.SUB:
            /* 破折号&减号 - 减速*/
            this.movementSpeed *= 0.9;
            if (this.movementSpeed < this.minMovementSpeed) {
                this.movementSpeed = this.minMovementSpeed;
            }
            break;
        case keys.UP: /*up - 前进*/
        case keys.W:
            /*W - 前进*/
            moveDirection = enumMoveDirection.FORWARD;
            break;
        case keys.DOWN: /*down - 后退 */
        case keys.S:
            /*S - 后退*/
            moveDirection = enumMoveDirection.BACK;
            break;
        case keys.LEFT: /*left - 左移 */
        case keys.A:
            /*A - 左移*/
            moveDirection = enumMoveDirection.LEFT;
            break;
        case keys.RIGHT: /*right - 右移*/
        case keys.D:
            /*D - 右移*/
            moveDirection = enumMoveDirection.RIGHT;
            break;
        case keys.Q:
            /*Q - 上移*/
            moveDirection = enumMoveDirection.UP;
            break;
        case keys.E:
            /*E - 下移*/
            moveDirection = enumMoveDirection.DOWN;
            break;
        default:
        // needUpdateUI = true;
    }

    if (moveDirection !== enumMoveDirection.NONE) {
        this.moveState |= moveDirection;
        this.dispatchEvent({
            type: CLOUD.EVENTS.ON_EDITOR_KEYUP,
            event: event,
            state: moveDirection,
            direction: enumMoveDirection,
            editor: this.name
        });
    }

    this._delayHandle();

    this.update();
};

CLOUD.WalkEditor.prototype.processKeyUp = function (event) {

    var enumMoveDirection = CLOUD.MoveDirection;
    var moveDirection = enumMoveDirection.NONE;
    var keys = this.cameraControl.keys;

    switch (event.keyCode) {
        case keys.UP: /*up - 前进*/
        case keys.W:
            /*W - 前进 */
            moveDirection = enumMoveDirection.FORWARD;
            break;
        case keys.DOWN: /*down - 后退 */
        case keys.S:
            /*S - 后退 */
            moveDirection = enumMoveDirection.BACK;
            break;
        case keys.LEFT: /*left - 左移 */
        case keys.A:
            /*A - 左移 */
            moveDirection = enumMoveDirection.LEFT;
            break;
        case keys.RIGHT: /*right - 右移*/
        case keys.D:
            /*D - 右移 */
            moveDirection = enumMoveDirection.RIGHT;
            break;
        case keys.Q:
            /*Q - 上移 */
            moveDirection = enumMoveDirection.UP;
            break;
        case keys.E:
            /*E - 下移 */
            moveDirection = enumMoveDirection.DOWN;
            break;
    }

    if (moveDirection !== enumMoveDirection.NONE) {

        this.dispatchEvent({
            type: CLOUD.EVENTS.ON_EDITOR_KEYUP,
            event: event,
            state: moveDirection,
            direction: enumMoveDirection,
            editor: this.name
        });
        this.moveState &= ~moveDirection;
    }
};

CLOUD.WalkEditor.prototype.update = function () {

    var moveStep = this.movementSpeed * this.getSpeedRate();

    var cameraControl = this.cameraControl;
    // cameraControl.updateCameraHeight();
    cameraControl.dirtyCamera(true);

    var enumMoveDirection = CLOUD.MoveDirection;

    // 前进
    if (this.moveState & enumMoveDirection.FORWARD) {
        this.stepCameraForWalk(CLOUD.MoveDirection.FORWARD, moveStep);
    }

    // 后退
    if (this.moveState & enumMoveDirection.BACK) {
        this.stepCameraForWalk(CLOUD.MoveDirection.BACK, moveStep);
    }

    // 左移
    if (this.moveState & enumMoveDirection.LEFT) {
        this.stepCameraForWalk(CLOUD.MoveDirection.LEFT, moveStep);
    }

    // 右移
    if (this.moveState & enumMoveDirection.RIGHT) {
        this.stepCameraForWalk(CLOUD.MoveDirection.RIGHT, moveStep);
    }

    // 上移
    if (this.moveState & enumMoveDirection.UP) {

        if (!this.isLockHeight) {
            this._goUp(moveStep * 0.5);
        }
    }

    // 下移
    if (this.moveState & enumMoveDirection.DOWN) {

        if (!this.isLockHeight) {
            this._goDown(moveStep * 0.5);
        }
    }

    // Pitch around axis Z only when axis Z locked.
    if (this.cameraControl.isConstrainedAxisZ) {
        this.deltaPitch = 0;
    }

    // 记录总仰角
    this.pitchDeltaTotal += this.deltaPitch;

    //CLOUD.Logger.log(this.pitchDeltaTotal);

    // 左右旋转
    this._goTurn(this.deltaYaw);
    this.deltaYaw = 0.0;

    if (this.deltaPitch !== 0) {
        // 俯仰
        if (this.constrainPitch) {
            if (this.pitchDeltaTotal < this.pitchMax && this.pitchDeltaTotal > this.pitchMin) {
                this._goPitch(-this.deltaPitch);
                this.deltaPitch = 0.0;
            }
        } else {
            this._goPitch(-this.deltaPitch);
            this.deltaPitch = 0.0;
        }
    }

    // 钳制总仰角
    this.pitchDeltaTotal = THREE.Math.clamp(this.pitchDeltaTotal, this.pitchMin, this.pitchMax);

    // 刷新
    cameraControl.flyOnWorld();
};

/**
 * 进入行走模式相关处理
 *
 */
CLOUD.WalkEditor.prototype.onEnter = function () {

    var camera = this.cameraControl.getCamera();

    if (!camera.isPerspective) {

        camera.toPerspective();
    }

    // 切换成平行视角
    this.cameraControl.walkWithParallelEye(this.scene.getBoundingBox().getCenter());
};

/**
 * 朝指定方向移动
 *
 * @param {Number} direction 移动方向 {@link CLOUD.MoveDirection}
 */
CLOUD.WalkEditor.prototype.moveTo = function (direction) {

    this.moveState = direction;
    this.update();
    this.moveState = CLOUD.MoveDirection.NONE;
};

/**
 * 锁定行走高度
 *
 * @param {Boolean} lock - 是否锁定
 */
CLOUD.WalkEditor.prototype.setHeightLocked = function (lock) {

    this.isLockHeight = lock;
    // this.update();
};

/**
 * 鼠标按下行走观察
 *
 * @param {Boolean} press - 是否按下
 */
CLOUD.WalkEditor.prototype.setLookMousePressed = function (press) {

    this.isLookMousePressed = press;
    // this.update();
};

/**
 * 设置行走倍率
 *
 * @param {Number} rate - 倍率
 */
CLOUD.WalkEditor.prototype.setSpeedRate = function (rate) {

    CLOUD.GlobalData.MovementSpeedRate = rate;
    // this.update();
};
CLOUD.ClipPlanesEditor = function (viewer) {

    CLOUD.OrbitEditor.call(this, viewer.cameraControl, viewer.getScene(), viewer.domElement);

    this.viewer = viewer;
    this.enablePick = false;

    // clip planes
    var planes = [];
    for (var ii = 0; ii < 6; ++ii) {
        planes.push(new THREE.Plane());
    }

    var clipPlanes = this.scene.getClipPlanes();

    function projectPlanes(planes, camera) {

        var nPlanes = planes !== null ? planes.length : 0;
        var dstArray = null;

        var plane = new THREE.Plane();

        if (nPlanes !== 0) {

            var flatSize = nPlanes * 4,
                viewMatrix = camera.matrixWorldInverse;

            var viewNormalMatrix = new THREE.Matrix3();

            viewNormalMatrix.getNormalMatrix(viewMatrix);

            if (dstArray === null || dstArray.length < flatSize) {

                dstArray = new Float32Array(flatSize);
            }

            for (var i = 0, i4 = 0; i !== nPlanes; ++i, i4 += 4) {

                plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);

                plane.normal.toArray(dstArray, i4);
                dstArray[i4 + 3] = plane.constant;
            }
        }

        return dstArray;
    }

    clipPlanes.updateClippingParams = function (uniforms) {

        if (uniforms.iClipPlane.value == 0) {
            viewer.renderer.clippingPlanes = Object.freeze([]);
        } else {
            // to plane
            for (var ii = 0, len = uniforms.iClipPlane.value; ii < len; ++ii) {
                var v = uniforms.vClipPlane.value[ii];
                var plane = planes[ii];
                plane.setComponents(-v.x, -v.y, -v.z, -v.w);
                plane.normalize();
            }
            viewer.renderer.clippingPlanes = planes;
        }

        if (CLOUD.GlobalData.IBL) {
            var clipState = projectPlanes(planes, viewer.camera);
            viewer.modelManager.updateMaterialsValue('clippingPlanes', clipState);
        }
    };

    clipPlanes.init();

    this.startPt = new THREE.Vector2();
    this.endPt = new THREE.Vector2();

    this.frustum = new THREE.Frustum();

    this.selectIndex = null;

    this.planeDistance = 0;

    this.offsetSpeed = 0.02;

    // var scope = this;
    // this.pickHelper = new CLOUD.PickHelper(this.scene, this.cameraControl);

    this.toggle = function (enable, visible) {
        clipPlanes.enable(enable, visible);
    };

    this.visible = function (enable) {
        clipPlanes.visible = enable;
    };

    this.rotatable = function (enable) {
        clipPlanes.rotatable = enable;
    };

    this.store = function () {
        return clipPlanes.store();
    };

    this.restore = function (clipPlanesInfo) {
        clipPlanes.restore(clipPlanesInfo);
    };

    this.reset = function () {
        clipPlanes.reset();
    };

    this.pointToScreen = function (point) {

        var camera = this.cameraControl.camera;
        var viewProjMatrix = new THREE.Matrix4();
        viewProjMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

        var point4 = new THREE.Vector4(point.x, point.y, point.z, 1.0);
        point4.applyMatrix4(viewProjMatrix);

        var screen = new THREE.Vector2();
        screen.x = (point4.x / point4.w + 1.0) / 2;
        screen.y = 1 - (point4.y / point4.w + 1.0) / 2;

        var dim = this.cameraControl.getContainerDimensions();

        screen.x = screen.x * dim.width + dim.left;
        screen.y = screen.y * dim.height + dim.top;

        return screen;
    };

    this.getPlaneDistanceInScreen = function () {

        if (this.selectIndex == null) return null;

        if (this.selectIndex < 2) {
            var right = clipPlanes.center.clone();
            var left = clipPlanes.center.clone();

            right.x -= clipPlanes.cubeSize.x;
            left.x += clipPlanes.cubeSize.x;

            var rightScreen = this.pointToScreen(right);
            var leftScreen = this.pointToScreen(left);

            return rightScreen.x - leftScreen.x;
        } else {
            var top = clipPlanes.center.clone();
            var bottom = clipPlanes.center.clone();

            bottom.y -= clipPlanes.cubeSize.y;
            top.y += clipPlanes.cubeSize.y;

            var bottomScreen = this.pointToScreen(bottom);
            var topScreen = this.pointToScreen(top);

            return bottomScreen.y - topScreen.y;
        }
    };

    this.getPickPoint = function (cx, cy) {

        var camera = this.cameraControl.camera;
        var canvasContainer = this.cameraControl.getContainerDimensions();
        // 规范化开始点
        var canvasX = cx - canvasContainer.left;
        var canvasY = cy - canvasContainer.top;
        // 规范化到[-1, 1]
        var normalizedX = canvasX / canvasContainer.width * 2.0 - 1.0;
        var normalizedY = (canvasContainer.height - canvasY) / canvasContainer.height * 2.0 - 1.0;

        var raycaster = new CLOUD.Raycaster();
        raycaster.setFromCamera(new THREE.Vector2(normalizedX, normalizedY), camera);

        var point = raycaster.ray.intersectPlane(this.plane);
        return point;
    };

    this.getSelectIndex = function () {
        return clipPlanes.selectIndex;
    };

    this._isVisible = function () {
        return clipPlanes.visible;
    };

    this.isRotate = function () {
        return clipPlanes.rotatable;
    };

    this.offset = function (offset) {
        var index = Math.floor(this.selectIndex / 2);
        if (this.selectIndex <= 3) {
            clipPlanes.offset(this.selectIndex, -offset * clipPlanes.cubeSize.getComponent(index) * 2);
        } else if (this.selectIndex % 2 == 1) {
            clipPlanes.offset(this.selectIndex, -offset * clipPlanes.cubeSize.getComponent(index) * 2);
        } else {
            clipPlanes.offset(this.selectIndex, offset * clipPlanes.cubeSize.getComponent(index) * 2);
        }
    };

    this.rotate = function (cx, cy) {
        if (this.selectIndex == 2 || this.selectIndex == 3) {
            clipPlanes.rotX(cy / 180 * Math.PI * 0.1);
        } else {
            clipPlanes.rotY(cx / 180 * Math.PI * 0.1);
        }
    };

    this.update = function (camera) {
        clipPlanes.update(camera);
    };

    this.cancelHighLight = function () {
        clipPlanes.cancelHighLight();
    };

    this.highLight = function () {
        clipPlanes.highLight();
    };
};

CLOUD.ClipPlanesEditor.prototype = Object.create(CLOUD.OrbitEditor.prototype);
CLOUD.ClipPlanesEditor.prototype.constructor = CLOUD.ClipPlanesEditor;

CLOUD.ClipPlanesEditor.prototype.destroy = function () {
    this.domElement = null;
    this.cameraControl = null;
    this.intersectPoint = null;
    this.selectIndex = null;
    this.normal = null;
    this.plane = null;
    this.pickHelper = null;
    this.scene = null;
    this.viewer = null;
};

CLOUD.ClipPlanesEditor.prototype.onExist = function () {
    this.toggle(false, false);
};

CLOUD.ClipPlanesEditor.prototype.onUpdateUI = function (obj) {
    this.dispatchEvent({ type: CLOUD.EVENTS.ON_EDITOR_UPDATEUI, data: obj, editor: this.name });
};

CLOUD.ClipPlanesEditor.prototype.updateFrustum = function (updateUI) {

    var x1 = this.startPt.x;
    var x2 = this.endPt.x;
    var y1 = this.startPt.y;
    var y2 = this.endPt.y;

    if (x1 > x2) {

        var tmp1 = x1;
        x1 = x2;
        x2 = tmp1;
    }

    if (y1 > y2) {

        var tmp2 = y1;
        y1 = y2;
        y2 = tmp2;
    }

    if (x2 - x1 == 0 || y2 - y1 == 0) return false;

    var helper = this.cameraControl;
    var dim = helper.getContainerDimensions();

    helper.computeFrustum(x1, x2, y1, y2, this.frustum, dim);

    if (updateUI) {
        this.onUpdateUI({
            visible: true,
            dir: this.startPt.x < this.endPt.x,
            left: x1 - dim.left,
            top: y1 - dim.top,
            width: x2 - x1,
            height: y2 - y1
        });
    }

    return true;
};

CLOUD.ClipPlanesEditor.prototype.processMouseDown = function (event) {

    this.startPt.set(event.clientX, event.clientY);

    if (!this.enablePick && event.button === THREE.MOUSE.LEFT) {
        this.intersectPoint = this.cameraControl.getTrackingPoint(event.clientX, event.clientY);
        this.selectIndex = this.getSelectIndex();
        this.planeDistance = this.getPlaneDistanceInScreen();
    }

    if (this.selectIndex != null) {
        this.highLight();
        this.cameraControl.needUpdateRenderList(true);
        this.cameraControl.update(true);
    } else {
        CLOUD.OrbitEditor.prototype.processMouseDown.call(this, event);
    }

    this.update();
};

CLOUD.ClipPlanesEditor.prototype.processMouseUp = function (event) {

    this.selectIndex = null;
    this.planeDistance = 0;

    this.onUpdateUI({ visible: false });

    if (this.enablePick && event.button === THREE.MOUSE.LEFT) {

        if (this.startPt.x == event.clientX && this.startPt.y == event.clientY) {
            this.pickHelper.click(event);
        } else {
            var allowRectPick = event.shiftKey || event.ctrlKey || event.altKey;
            if (allowRectPick) {

                this.endPt.set(event.clientX, event.clientY);
                if (!this.updateFrustum()) {
                    this.pickHelper.click(event);
                    return false;
                }

                var state = CLOUD.OPSELECTIONTYPE.Clear;

                if (event.ctrlKey) {
                    state = CLOUD.OPSELECTIONTYPE.Add;
                } else if (event.altKey) {
                    state = CLOUD.OPSELECTIONTYPE.Remove;
                }

                var scope = this;
                this.scene.pickByRect(this.frustum, state, function () {
                    scope.pickHelper.notifySelectionChanged(null, 0, event);
                });
                this.cameraControl.updateView(true);

                return true;
            }
        }
    }

    CLOUD.OrbitEditor.prototype.processMouseUp.call(this, event);

    this.cameraControl.needUpdateRenderList(true);
    this.cancelHighLight();
    this.cameraControl.update(true);

    this.update();

    return true;
};

CLOUD.ClipPlanesEditor.prototype.processMouseMove = function (event) {

    var allowRectPick = event.shiftKey || event.ctrlKey || event.altKey;
    if (allowRectPick && event.button === THREE.MOUSE.LEFT) {
        this.endPt.set(event.clientX, event.clientY);
        this.updateFrustum(true);
        return true;
    }

    if (this.selectIndex != null) {
        if (!this.isRotate()) {
            var delta = 0;
            if (this.selectIndex < 2) {
                delta = event.clientX - this.startPt.x;
            } else {
                delta = event.clientY - this.startPt.y;
            }

            this.offset(delta / this.planeDistance);
            this.startPt.set(event.clientX, event.clientY);
        } else {
            this.rotate(event.clientX - this.startPt.x, event.clientY - this.startPt.y);
            this.startPt.set(event.clientX, event.clientY);
        }
        this.cameraControl.update(true);
    } else {
        CLOUD.OrbitEditor.prototype.processMouseMove.call(this, event);
    }

    this.update();
};

CLOUD.ClipPlanesEditor.prototype.onMouseWheel = function (event) {

    CLOUD.OrbitEditor.prototype.onMouseWheel.call(this, event);
    this.update();
};

CLOUD.ClipPlanesEditor.prototype.touchstart = function (event) {
    event.preventDefault();

    this.startPt.set(event.touches[0].clientX, event.touches[0].clientY);
    if (!this.enablePick) {
        this.cameraControl.getTrackingPoint(event.touches[0].clientX, event.touches[0].clientY);
        this.selectIndex = this.getSelectIndex();
        this.planeDistance = this.getPlaneDistanceInScreen();
    }

    if (this.selectIndex != null) {
        this.highLight();
        this.cameraControl.needUpdateRenderList(true);
        this.cameraControl.update(true);
    } else {
        this.cameraControl.touchStartHandler(event);
    }

    this.update();
};

CLOUD.ClipPlanesEditor.prototype.touchmove = function (event) {
    event.preventDefault();

    if (this.selectIndex != null) {
        if (!this.isRotate()) {
            var delta = 0;
            if (this.selectIndex < 2) {
                delta = event.touches[0].clientX - this.startPt.x;
            } else {
                delta = event.touches[0].clientY - this.startPt.y;
            }

            this.offset(delta / this.planeDistance);
            this.startPt.set(event.touches[0].clientX, event.touches[0].clientY);
        } else {
            this.rotate(event.touches[0].clientX - this.startPt.x, event.touches[0].clientY - this.startPt.y);
            this.startPt.set(event.touches[0].clientX, event.touches[0].clientY);
        }
        this.cameraControl.update(true);
    } else {
        this.cameraControl.touchMoveHandler(event);
    }

    this.update();
};

CLOUD.ClipPlanesEditor.prototype.touchend = function (event) {
    event.preventDefault();

    this.selectIndex = null;
    this.planeDistance = 0;

    if (this.enablePick) {
        this.onUpdateUI({ visible: false });

        if (this.startPt.x == event.touches[0].clientX && this.startPt.y == event.touches[0].clientY) {
            this.pickHelper.click(event);
        }
    }

    this.cameraControl.touchEndHandler(event);

    this.cameraControl.needUpdateRenderList(true);
    this.cancelHighLight();
    this.cameraControl.update(true);

    this.update();

    return true;
};
CLOUD.FillClipPlaneEditor = function (viewer) {

    CLOUD.OrbitEditor.call(this, viewer.cameraControl, viewer.getScene(), viewer.domElement);

    this.viewer = viewer;
    this.enablePick = false;
    this.rotX = true;

    var fillClipPlane = this.scene.getFillClipPlane();
    fillClipPlane.updateClippingParams = function (uniforms) {
        if (uniforms.iClipPlane.value == 0) {
            viewer.renderer.clippingPlanes = Object.freeze([]);
        } else {
            var planes = [new THREE.Plane()];
            var v = uniforms.vClipPlane.value[0];
            var plane = planes[0];
            plane.setComponents(-v.x, -v.y, -v.z, -v.w);
            plane.normalize();

            viewer.renderer.clippingPlanes = planes;
        }
    };

    fillClipPlane.init();

    this.startPt = new THREE.Vector2();
    this.endPt = new THREE.Vector2();

    this.frustum = new THREE.Frustum();

    this.planeDistance = 0;

    this.offsetSpeed = 0.02;

    // var scope = this;
    // this.pickHelper = new CLOUD.PickHelper(this.scene, this.cameraControl);

    this.toggle = function (enable, visible) {
        fillClipPlane.enable(enable, visible);
        fillClipPlane.update();
    };

    this.visible = function (enable) {
        fillClipPlane.visible = enable;
        fillClipPlane.update();
    };

    this.rotatable = function (enable) {
        fillClipPlane.rotatable = enable;
        fillClipPlane.update();
    };

    this.hit = function () {
        return fillClipPlane.hit;
    };

    // this.store = function () {
    //     return clipPlanes.store();
    // };

    // this.restore = function (clipPlanesInfo) {
    //     clipPlanes.restore(clipPlanesInfo);
    // };

    // this.reset = function () {
    //     clipPlanes.reset();
    // };

    this.pointToScreen = function (point) {

        var camera = this.cameraControl.camera;
        var viewProjMatrix = new THREE.Matrix4();
        viewProjMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

        var point4 = new THREE.Vector4(point.x, point.y, point.z, 1.0);
        point4.applyMatrix4(viewProjMatrix);

        var screen = new THREE.Vector2();
        screen.x = (point4.x / point4.w + 1.0) / 2;
        screen.y = 1 - (point4.y / point4.w + 1.0) / 2;

        var dim = this.cameraControl.getContainerDimensions();

        screen.x = screen.x * dim.width + dim.left;
        screen.y = screen.y * dim.height + dim.top;

        return screen;
    };

    this.getPlaneDistanceInScreen = function () {

        if (this.selectIndex == null) return null;

        if (this.selectIndex < 2) {
            var right = clipPlanes.center.clone();
            var left = clipPlanes.center.clone();

            right.x -= clipPlanes.cubeSize.x;
            left.x += clipPlanes.cubeSize.x;

            var rightScreen = this.pointToScreen(right);
            var leftScreen = this.pointToScreen(left);

            return rightScreen.x - leftScreen.x;
        } else {
            var top = clipPlanes.center.clone();
            var bottom = clipPlanes.center.clone();

            bottom.y -= clipPlanes.cubeSize.y;
            top.y += clipPlanes.cubeSize.y;

            var bottomScreen = this.pointToScreen(bottom);
            var topScreen = this.pointToScreen(top);

            return bottomScreen.y - topScreen.y;
        }
    };

    this.getPickPoint = function (cx, cy) {

        var camera = this.cameraControl.camera;
        var canvasContainer = this.cameraControl.getContainerDimensions();
        // 规范化开始点
        var canvasX = cx - canvasContainer.left;
        var canvasY = cy - canvasContainer.top;
        // 规范化到[-1, 1]
        var normalizedX = canvasX / canvasContainer.width * 2.0 - 1.0;
        var normalizedY = (canvasContainer.height - canvasY) / canvasContainer.height * 2.0 - 1.0;

        var raycaster = new CLOUD.Raycaster();
        raycaster.setFromCamera(new THREE.Vector2(normalizedX, normalizedY), camera);

        var point = raycaster.ray.intersectPlane(this.plane);
        return point;
    };

    this._isVisible = function () {
        return fillClipPlane.visible;
    };

    this.isRotate = function () {
        return fillClipPlane.rotatable;
    };

    this.offset = function (offset) {
        fillClipPlane.offset(offset);
    };

    //设置切面的偏移量，-250至250，默认为0
    this.setOffset = function (offset) {
        fillClipPlane.setOffset(offset);
    };

    this.rotate = function (cx, cy) {
        if (this.rotX) {
            fillClipPlane.rotX(cy / 180 * Math.PI * 0.1);
        } else {
            fillClipPlane.rotY(cx / 180 * Math.PI * 0.1);
        }
    };

    //设置切面的法线方向，(0, 1, 2, 3, 4, 5)分别对应模型空间(X, -X, Y, -Y, Z, -Z)，默认值为3
    this.changeNormal = function (index) {
        fillClipPlane.changeNormal(index);
    };

    this.update = function (camera) {
        fillClipPlane.update(camera);
    };

    this.cancelHighLight = function () {
        fillClipPlane.cancelHighLight();
    };

    this.highLight = function () {
        fillClipPlane.highLight();
    };
};

CLOUD.FillClipPlaneEditor.prototype = Object.create(CLOUD.OrbitEditor.prototype);
CLOUD.FillClipPlaneEditor.prototype.constructor = CLOUD.FillClipPlaneEditor;

CLOUD.FillClipPlaneEditor.prototype.destroy = function () {
    this.domElement = null;
    this.cameraControl = null;
    this.intersectPoint = null;
    this.normal = null;
    this.plane = null;
    this.pickHelper = null;
    this.scene = null;
    this.viewer = null;
};

CLOUD.FillClipPlaneEditor.prototype.onExist = function () {
    this.toggle(false, false);
};

CLOUD.FillClipPlaneEditor.prototype.onUpdateUI = function (obj) {
    this.dispatchEvent({ type: CLOUD.EVENTS.ON_EDITOR_UPDATEUI, data: obj, editor: this.name });
};

CLOUD.FillClipPlaneEditor.prototype.updateFrustum = function (updateUI) {

    var x1 = this.startPt.x;
    var x2 = this.endPt.x;
    var y1 = this.startPt.y;
    var y2 = this.endPt.y;

    if (x1 > x2) {

        var tmp1 = x1;
        x1 = x2;
        x2 = tmp1;
    }

    if (y1 > y2) {

        var tmp2 = y1;
        y1 = y2;
        y2 = tmp2;
    }

    if (x2 - x1 == 0 || y2 - y1 == 0) return false;

    var helper = this.cameraControl;
    var dim = helper.getContainerDimensions();

    helper.computeFrustum(x1, x2, y1, y2, this.frustum, dim);

    if (updateUI) {
        this.onUpdateUI({
            visible: true,
            dir: this.startPt.x < this.endPt.x,
            left: x1 - dim.left,
            top: y1 - dim.top,
            width: x2 - x1,
            height: y2 - y1
        });
    }

    return true;
};

CLOUD.FillClipPlaneEditor.prototype.processMouseDown = function (event) {

    this.startPt.set(event.clientX, event.clientY);

    if (!this.enablePick && event.button === THREE.MOUSE.LEFT) {
        this.intersectPoint = this.cameraControl.getTrackingPoint(event.clientX, event.clientY);
        //this.planeDistance = this.getPlaneDistanceInScreen();
    }

    if (this.hit()) {
        this.highLight();
        this.cameraControl.needUpdateRenderList(true);
        this.cameraControl.update(true);
    } else {
        CLOUD.OrbitEditor.prototype.processMouseDown.call(this, event);
    }
};

CLOUD.FillClipPlaneEditor.prototype.processMouseUp = function (event) {

    this.planeDistance = 0;

    this.onUpdateUI({ visible: false });

    if (this.enablePick && event.button === THREE.MOUSE.LEFT) {

        if (this.startPt.x == event.clientX && this.startPt.y == event.clientY) {
            this.pickHelper.click(event);
        } else {
            var allowRectPick = event.shiftKey || event.ctrlKey || event.altKey;
            if (allowRectPick) {

                this.endPt.set(event.clientX, event.clientY);
                if (!this.updateFrustum()) {
                    this.pickHelper.click(event);
                    return false;
                }

                var state = CLOUD.OPSELECTIONTYPE.Clear;

                if (event.ctrlKey) {
                    state = CLOUD.OPSELECTIONTYPE.Add;
                } else if (event.altKey) {
                    state = CLOUD.OPSELECTIONTYPE.Remove;
                }

                var scope = this;
                this.scene.pickByRect(this.frustum, state, function () {
                    scope.pickHelper.notifySelectionChanged(null, 0, event);
                });
                this.cameraControl.updateView(true);

                return true;
            }
        }
    }

    CLOUD.OrbitEditor.prototype.processMouseUp.call(this, event);

    this.cameraControl.needUpdateRenderList(true);
    this.cancelHighLight();
    this.cameraControl.update(true);

    return true;
};

CLOUD.FillClipPlaneEditor.prototype.processMouseMove = function (event) {

    var allowRectPick = event.shiftKey || event.ctrlKey || event.altKey;
    if (allowRectPick && event.button === THREE.MOUSE.LEFT) {
        this.endPt.set(event.clientX, event.clientY);
        this.updateFrustum(true);
        return true;
    }

    if (event.button === THREE.MOUSE.LEFT && this.hit()) {
        if (!this.isRotate()) {
            var delta = 0;
            delta = event.clientX - this.startPt.x;
            this.offset(delta * 1);
            this.startPt.set(event.clientX, event.clientY);
        } else {
            this.rotate(event.clientX - this.startPt.x, event.clientY - this.startPt.y);
            this.startPt.set(event.clientX, event.clientY);
        }
        this.cameraControl.update(true);
    } else {
        CLOUD.OrbitEditor.prototype.processMouseMove.call(this, event);
    }
};

CLOUD.FillClipPlaneEditor.prototype.touchstart = function (event) {
    event.preventDefault();

    this.startPt.set(event.touches[0].clientX, event.touches[0].clientY);
    if (!this.enablePick) {
        this.cameraControl.getTrackingPoint(event.touches[0].clientX, event.touches[0].clientY);
    }

    if (this.hit()) {
        this.highLight();
        this.cameraControl.needUpdateRenderList(true);
        this.cameraControl.update(true);
    } else {
        this.cameraControl.touchStartHandler(event);
    }
};

CLOUD.FillClipPlaneEditor.prototype.touchmove = function (event) {
    event.preventDefault();

    if (this.hit()) {
        if (!this.isRotate()) {
            var delta = 0;
            delta = event.touches[0].clientX - this.startPt.x;
            this.offset(delta * 1);
            this.startPt.set(event.touches[0].clientX, event.touches[0].clientY);
        } else {
            this.rotate(event.touches[0].clientX - this.startPt.x, event.touches[0].clientY - this.startPt.y);
            this.startPt.set(event.touches[0].clientX, event.touches[0].clientY);
        }
        this.cameraControl.update(true);
    } else {
        this.cameraControl.touchMoveHandler(event);
    }
};

CLOUD.FillClipPlaneEditor.prototype.touchend = function (event) {
    event.preventDefault();

    if (this.enablePick) {
        this.onUpdateUI({ visible: false });

        if (this.startPt.x == event.touches[0].clientX && this.startPt.y == event.touches[0].clientY) {
            this.pickHelper.click(event);
        }
    }

    this.cameraControl.touchEndHandler(event);

    this.cameraControl.needUpdateRenderList(true);
    this.cancelHighLight();
    this.cameraControl.update(true);

    return true;
};
// handleViewHouseEvent
CLOUD.EditorManager = function () {

    this.editor = null;
    this.editors = {};

    this.animationDuration = 500; // 500毫秒
    this.animationFrameTime = 13; // 周期性执行或调用函数之间的时间间隔，以毫秒计
    this.enableAnimation = true; // 是否允许动画
    this.isUpdateRenderList = true; // 是否更新渲染列表

    this.mouseButtons = { ORBIT: THREE.MOUSE.RIGHT, PAN2: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.LEFT };

    this.movePad = null;

    var scope = this;
    var _canMouseMoveOperation = false; // 是否可以进行mouseMove相关操作

    function touchmove(event) {
        scope.editor.touchmove(event);
    }

    function touchstart(event) {
        scope.editor.touchstart(event);
    }

    function touchend(event) {
        scope.editor.touchend(event);
    }

    function onKeyDown(event) {
        scope.editor.onKeyDown(event);
    }

    function onKeyUp(event) {
        scope.editor.onKeyUp(event);
    }

    function onMouseWheel(event) {
        scope.cameraChange = true;
        //window.setTimeout(function() {
        //
        //    scope.editor.onMouseWheel(event);
        //
        //}, 50);
        scope.editor.onMouseWheel(event);
        // scope.cameraChange = false;
    }

    function onMouseDown(event) {

        // 每次按下鼠标激活canvas
        setFocuse();

        _canMouseMoveOperation = true;
        scope.isUpdateRenderList = false;

        var isAnimating = scope.isAnimating();

        // 判断是否在动画中, 若是动画中，不响应事件
        if (isAnimating) {
            scope.cameraChange = false;
            return;
        }

        scope.editor.onMouseDown(event);
    }

    function onMouseMove(event) {

        var isAnimating = scope.isAnimating();

        // 判断是否在动画中, 若是动画中，不响应事件
        if (isAnimating) {
            scope.cameraChange = false;
            return;
        }

        // 其它交互
        if (_canMouseMoveOperation) {
            // 不更新渲染列表
            scope.isUpdateRenderList = false;
            scope.cameraChange = true;
            scope.editor.onMouseMove(event);
        } else {

            if (scope.editor.mouseMoveAlwaysAllowed) {

                scope.isUpdateRenderList = false;
                scope.cameraChange = true;
                scope.editor.onMouseMove(event);
            }

            scope.editor.onHover(event);
        }
    }

    function onMouseUp(event) {

        var isAnimating = scope.isAnimating();

        // 只要存在up事件，允许更新渲染列表
        scope.isUpdateRenderList = true;
        // scope.cameraChange = false;

        var isCanMouseMove = _canMouseMoveOperation;
        // 只要存在up事件，就将其置为false
        _canMouseMoveOperation = false;

        // 判断是否在动画中, 若是动画中，不响应事件
        if (isAnimating) {
            return;
        }

        if (isCanMouseMove || scope.editor.mouseMoveAlwaysAllowed) {
            // 其它交互
            scope.editor.onMouseUp(event);
        }
    }

    function onMouseDoubleClick(event) {
        scope.editor.onMouseDoubleClick(event);
    }

    function setFocuse() {
        // 设置焦点
        var dom = scope.editor.getDomElement();
        if (dom) {
            var canvas = dom.querySelector("#cloud-main-canvas");
            if (canvas && canvas.focus) canvas.focus();
        }
    }

    // 返回鼠标运动状态
    this.isMouseMoving = function () {
        return _canMouseMoveOperation;
    };

    this.registerDomEventListeners = function (domElement) {

        domElement.addEventListener('contextmenu', function (event) {
            event.preventDefault();
        }, false);
        domElement.addEventListener('mousedown', onMouseDown, false);
        domElement.addEventListener('mousewheel', onMouseWheel, false);
        domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox
        domElement.addEventListener('dblclick', onMouseDoubleClick, false);

        // 注册在document上会影响dbgUI的resize事件
        window.addEventListener('mousemove', onMouseMove, false);
        window.addEventListener('mouseup', onMouseUp, false);

        domElement.addEventListener('touchstart', touchstart, false);
        domElement.addEventListener('touchend', touchend, false);
        domElement.addEventListener('touchmove', touchmove, false);

        //window.addEventListener( 'keydown', onKeyDown, false );
        //window.addEventListener( 'keyup', onKeyUp, false );
        domElement.addEventListener('keydown', onKeyDown, false);
        domElement.addEventListener('keyup', onKeyUp, false);

        setFocuse();
    };

    this.unregisterDomEventListeners = function (domElement) {

        domElement.removeEventListener('contextmenu', function (event) {
            event.preventDefault();
        }, false);
        domElement.removeEventListener('mousedown', onMouseDown, false);
        domElement.removeEventListener('mousewheel', onMouseWheel, false);
        domElement.removeEventListener('DOMMouseScroll', onMouseWheel, false); // firefox
        domElement.removeEventListener('dblclick', onMouseDoubleClick, false);

        // 注册在document上会影响dbgUI的resize事件
        window.removeEventListener('mousemove', onMouseMove, false);
        window.removeEventListener('mouseup', onMouseUp, false);

        domElement.removeEventListener('touchstart', touchstart, false);
        domElement.removeEventListener('touchend', touchend, false);
        domElement.removeEventListener('touchmove', touchmove, false);

        //window.removeEventListener( 'keydown', onKeyDown, false );
        //window.removeEventListener( 'keyup', onKeyUp, false );
        domElement.removeEventListener('keydown', onKeyDown, false);
        domElement.removeEventListener('keyup', onKeyUp, false);
    };
};

CLOUD.EditorManager.prototype = {

    constructor: CLOUD.EditorManager,

    destroy: function destroy() {

        this.editor = null;

        for (var name in this.editors) {
            var editor = this.editors[name];
            editor.destroy();
        }

        this.editors = {};
        this.movePad = null;
    },

    updateButtons: function updateButtons(mouseButtons, keys) {

        this.mouseButtons = mouseButtons;

        if (this.editor) {
            this.editor.updateButtons(this.mouseButtons, keys);
        }
    },

    getCurrentEditorName: function getCurrentEditorName() {
        return this.editor ? this.editor.name : "";
    },

    _getEditorByName: function _getEditorByName(viewer, name) {

        var editor = this.editors[name];

        if (editor) {
            return editor;
        }

        var editorMode = CLOUD.EditorMode;
        var cameraControl = viewer.cameraControl;
        var scene = viewer.getScene();
        var domElement = viewer.domElement;

        switch (name) {

            case editorMode.ORBIT:
                editor = new CLOUD.OrbitEditor(cameraControl, scene, domElement);
                break;

            case editorMode.PICK:
                editor = new CLOUD.PickEditor(cameraControl, scene, domElement);
                break;

            case editorMode.PICK_BY_RECT:
                editor = new CLOUD.RectPickEditor(cameraControl, scene, domElement);
                break;

            case editorMode.PAN:
                editor = new CLOUD.PanEditor(cameraControl, scene, domElement);
                break;

            case editorMode.ZOOM:
                editor = new CLOUD.ZoomEditor(cameraControl, scene, domElement);
                break;

            case editorMode.ZOOM_BY_RECT:
                editor = new CLOUD.RectZoomEditor(cameraControl, scene, domElement);
                break;

            case editorMode.FLY:
                editor = new CLOUD.FlyEditor(cameraControl, scene, domElement);
                break;

            case editorMode.WALK:
                editor = new CLOUD.WalkEditor(cameraControl, scene, domElement);
                break;

            case editorMode.CLIP_BY_BOX:
                editor = new CLOUD.ClipPlanesEditor(viewer);
                break;

            case editorMode.CLIP_FILL:
                editor = new CLOUD.FillClipPlaneEditor(viewer);
                break;

            default:
                editor = null;
                console.error("invalid editor name");
                break;
        }

        if (editor) {
            editor.name = name;
            this.editors[name] = editor;
        }

        return editor;
    },

    getCurrentEditorMode: function getCurrentEditorMode() {

        return this.editor;
    },

    setEditorMode: function setEditorMode(viewer, name) {

        var editor = this._getEditorByName(viewer, name);

        if (editor) {

            if (this.editor !== editor) {

                if (this.editor !== null) {

                    // if (this.editor == this.editors['orbitEditor']) {
                    //     //this.movePad.hideOverlay();
                    // }

                    this.editor.dispatchEvent({ type: CLOUD.EVENTS.ON_EDITOR_EXIST, name: this.editor.getName() });
                    this.editor.onExist();
                }

                // if (newEditor == this.editors['orbitEditor']) {
                //     //this.movePad.showOverlay();
                // }

                this.editor = editor;
                this.editor.onEnter();
                this.editor.dispatchEvent({ type: CLOUD.EVENTS.ON_EDITOR_ENTER, name: this.editor.getName() });
                this.editor.updateButtons(this.mouseButtons);
            }
        }
    },

    zoomIn: function zoomIn(factor, viewer) {
        //if(factor === undefined){
        //    factor = viewer.camera.zoom * 1.1;
        //}

        // 缩放时，改变相机缩放因子zoom，就会改变相机FOV，从而造成模型显示变形
        // 思路：保持相机FOV和目标点位置不变，调整相机位置达到缩放的目的
        //this.camera.setZoom(factor);

        // 放大，factor > 0
        if (factor === undefined) {
            factor = 0.1;
        }

        if (factor < 0) {
            factor = 0;
        }

        viewer.cameraControl.zoom(factor);
    },

    zoomOut: function zoomOut(factor, viewer) {

        //if(factor === undefined){
        //    factor = viewer.camera.zoom * 0.9;
        //}
        //if(factor < 0.28){
        //    factor = 0.28;
        //}

        // 缩放时，改变相机缩放因子zoom，就会改变相机FOV，从而造成模型显示变形
        // 思路：保持相机FOV和目标点位置不变，调整相机位置达到缩放的目的
        //this.camera.setZoom(factor);

        if (factor === undefined) {
            factor = 0.1;
        }

        if (factor > 0) {
            factor *= -1;
        } else {
            factor = 0;
        }

        // 缩小，factor < 0
        viewer.cameraControl.zoom(factor);
    },

    zoomToBBox: function zoomToBBox(viewer, box, margin, ratio, direction) {
        var target = viewer.camera.zoomToBBox(box, margin, ratio, direction);
        viewer.cameraControl.updateCamera(target, true);
        viewer.render();
    },

    isAnimating: function isAnimating() {
        return this.enableAnimation && this.animator && this.animator.isPlaying();
    },

    setStandardView: function setStandardView(stdView, viewer, margin, callback) {

        var box;
        var camera = viewer.camera;
        // var scene = viewer.getScene();

        // if (scene.isLoaded()) {
        //     box = scene.getBoundingBox();
        // } else {
        //     box = scene.getBoundingBoxDefault();
        // }

        box = viewer.getScene().getBoundingBox();

        if (this.enableAnimation) {

            if (!this.animator) {
                this.animator = new CLOUD.CameraAnimator();
            }

            this.animator.setDuration(this.animationDuration);
            this.animator.setFrameTime(this.animationFrameTime);
            this.animator.setStandardView(stdView, viewer, box, margin, callback);
        } else {

            camera.setStandardView(stdView, box); // 设置观察视图

            var target = viewer.camera.zoomToBBox(box, margin); // fit all
            viewer.cameraControl.updateCamera(target, true);
            viewer.render();

            callback && callback(); // 是否回调
            camera.up.copy(THREE.Object3D.DefaultUp); // 渲染完成后才可以恢复相机up方向
        }
    },

    setStandardViewWithBox: function setStandardViewWithBox(viewer, stdView, box, margin, ratio) {
        var camera = viewer.camera;
        camera.setStandardView(stdView, box); // 设置观察视图
        var target = camera.zoomToBBox(box, margin, ratio);
        viewer.cameraControl.updateCamera(target);
        viewer.render();
        camera.up.copy(THREE.Object3D.DefaultUp); // 渲染完成后才可以恢复相机up方向
    },

    resize: function resize() {
        if (this.editor) {
            this.editor.resize();
        }
    }
};
CLOUD.SelectPad = function (editor) {
    this.editor = editor;
    this.cameraControl = editor.cameraControl;
    this.dim = this.cameraControl.getContainerDimensions();

    this.pad = null;
    this.padSize = 96;

    this.startPt = new THREE.Vector2();
    this.position = new THREE.Vector2();

    this.callback = null;

    this.intersect = null;

    this.init = function () {
        window.addEventListener('resize', this.padInitBind, false);
        this.pad = document.createElement("div");

        this.padInit();

        var viewport = this.cameraControl.domElement;
        viewport.appendChild(this.pad);

        this.addEventListener();
    };

    this.addEventListener = function () {
        this.pad.addEventListener('touchstart', this.padOnTouchStartBind, false);
        this.pad.addEventListener('touchmove', this.padOnTouchMoveBind, false);
        this.pad.addEventListener('touchend', this.padOnTouchEndBind, false);
        //window.addEventListener('touchend', this.padOnTouchEndBind, false);
    };

    this.padInit = function () {
        if (this.pad != null) {
            this.pad.style.backgroundImage = "url(images/selectPad.png)";
            this.pad.style.backgroundSize = '100%';
            this.pad.style.position = 'absolute';
            this.pad.style.width = this.padSize.toString() + 'px';
            this.pad.style.height = this.padSize.toString() + 'px';
            this.pad.style.zIndex = '10';
            this.pad.style.display = 'none';
        }
    };

    this.showOverlay = function (position) {
        this.position = position;

        this.pad.style.left = this.position.x.toString() + 'px';
        this.pad.style.top = (this.position.y - this.dim.top).toString() + 'px';

        this.pad.style.display = '';

        this.pick();
    };

    this.hideOverlay = function () {
        this.pad.style.display = 'none';
    };

    this.pick = function () {
        var screenX = this.position.x;
        var screenY = this.position.y;

        var cameraControl = this.cameraControl;
        var pickHelper = this.editor.pickHelper;
        var filter = cameraControl.viewer.getFilters();

        var scope = this;

        var screenPos = new THREE.Vector2(screenX, screenY);
        var intersectContext = cameraControl.getIntersectContext(screenPos);

        cameraControl.intersector.pick(intersectContext, function (intersect) {

            filter.clearIdList(CLOUD.EnumIdBasedType.SELECTED);

            if (!intersect) {
                // if (pickHelper.filter.setSelectedIds()) {
                //     cameraControl.updateView(true);
                // }


                cameraControl.updateView(true);
                //pickHelper.onObjectSelected(null, false);
                scope.intersect = null;
                return;
            }

            var userId = intersect.userId;
            cameraControl.viewer.getScene().intersectToWorld(intersect);

            filter.addToIdList(CLOUD.EnumIdBasedType.SELECTED, [userId]);
            scope.intersect = intersect;

            // if (pickHelper.filter.addSelectedId(userId, intersect.object.userData, true)) {
            //     //pickHelper.notifySelectionChanged(intersect, false, event);
            //     scope.intersect = intersect;
            // }
            // else {
            //     //pickHelper.notifySelectionChanged(null, false, event);
            //     scope.intersect = null;
            // }
            cameraControl.updateView(true);
        });

        if (scope.intersect != null) {
            scope.intersect.cx = screenX;
            scope.intersect.cy = screenY;
        }
    };

    this.onTouchStart = function (event) {
        if (event.touches.length === 1) {
            event.stopPropagation();
            event.preventDefault();
            this.startPt.set(event.touches[0].clientX, event.touches[0].clientY);
        }
    };

    this.onTouchMove = function (event) {
        if (event.touches.length === 1) {
            event.stopPropagation();
            event.preventDefault();

            var deltaX = event.touches[0].clientX - this.startPt.x;
            var deltaY = event.touches[0].clientY - this.startPt.y;

            this.position.x += deltaX;
            this.position.y += deltaY;

            this.pad.style.left = this.position.x.toString() + 'px';
            this.pad.style.top = (this.position.y - this.dim.top).toString() + 'px';

            this.startPt.set(event.touches[0].clientX, event.touches[0].clientY);

            this.pick(event);
        }
    };

    this.onTouchEnd = function (event) {
        event.stopPropagation();

        if (this.callback != null) {
            this.callback(this.intersect);
        } else {
            console.log("selectPad click", this.intersect);
        }
    };

    this.padInitBind = this.padInit.bind(this);

    this.padOnTouchStartBind = this.onTouchStart.bind(this);
    this.padOnTouchEndBind = this.onTouchEnd.bind(this);
    this.padOnTouchMoveBind = this.onTouchMove.bind(this);

    this.init();
};

CLOUD.Loader = CLOUD.Loader || {};

CLOUD.Loader.Url = function (serverUrl, databagId) {
    this.serverUrl = serverUrl;
    this.databagId = databagId;
};

CLOUD.Loader.Url.prototype.projectUrl = function () {
    return this.serverUrl + this.databagId + "/config.json";
};

CLOUD.Loader.Url.prototype.sceneUrl = function (idx) {
    idx = idx || 0;
    return this.serverUrl + this.databagId + "/scene/scene_" + idx + CLOUD.GlobalData.ZipResourcePostfix;
};

CLOUD.Loader.Url.prototype.sceneIdUrl = function () {
    return this.serverUrl + this.databagId + "/scene/scene_id" + CLOUD.GlobalData.ZipResourcePostfix;
};

CLOUD.Loader.Url.prototype.userIdUrl = function () {
    return this.serverUrl + this.databagId + "/scene/user_id" + CLOUD.GlobalData.ZipResourcePostfix;
};

CLOUD.Loader.Url.prototype.octreeUrl = function (idx) {
    idx = idx || 'o';
    // octree index has not upgrade to binary yet
    // return this.serverUrl + this.databagId + "/scene/index_" + idx;
    return this.serverUrl + this.databagId + "/scene/octree_" + idx + CLOUD.GlobalData.ZipResourcePostfix;
};

CLOUD.Loader.Url.prototype.symbolUrl = function () {
    return this.serverUrl + this.databagId + "/symbol/symbol" + CLOUD.GlobalData.ZipResourcePostfix;
};

CLOUD.Loader.Url.prototype.mpkUrl = function (idx) {
    idx = idx || 0;
    return this.serverUrl + this.databagId + "/mpk/mpk_" + idx + CLOUD.GlobalData.ZipResourcePostfix;
};

CLOUD.Loader.Url.prototype.meshIdUrl = function () {
    return this.serverUrl + this.databagId + "/mpk/mesh_id" + CLOUD.GlobalData.ZipResourcePostfix;
};

CLOUD.Loader.Url.prototype.materialUrl = function () {
    return this.serverUrl + this.databagId + "/material/material" + CLOUD.GlobalData.ZipResourcePostfix;
};

CLOUD.Loader.Url.prototype.materialIdUrl = function () {
    return this.serverUrl + this.databagId + "/material/material_id" + CLOUD.GlobalData.ZipResourcePostfix;
};

CLOUD.Loader.Url.prototype.userDataUrl = function () {
    return this.serverUrl + this.databagId + "/userdata/userdata" + CLOUD.GlobalData.ZipResourcePostfix;
};

CLOUD.Loader.Url.prototype.textureUrl = function (textureId) {
    return this.serverUrl + this.databagId + "/texture/" + textureId;
};
/**
 * @author xiaoj-a@glodon.com
 **/

// Spatial hierarchy representation
CLOUD.Loader.OctreeNode = function (oId, depth) {

    if (oId === undefined) {
        alert("Invalid Octant Id");
    }

    this.octantId = oId;
    this.childOctants = new Array();
    this.min = null;
    this.max = null;
    this.depth = depth || 0;
    this.center = null;
    this.size = -1; // square length of octant size
    // used in generate priority factor F = size / (sqDistanceToCamera * cosTheta)
    this.priority = -1;
    // the child division below its parent
    // refer to OctantNeighborUtil.js OctType about the value definition
    this.octType = -1;
};

CLOUD.Loader.OctreeNode.prototype.isRoot = function () {
    return this.depth == 0;
};

// CLOUD.Loader.OctreeNode.prototype.constructor = CLOUD.Loader.OctreeNode;

CLOUD.Loader.OctreeNode.prototype.add = function (octant) {
    octant.depth = this.depth + 1;
    this.childOctants.push(octant);
};

/*
CLOUD.Loader.OctreeNode.prototype.findRadiusNeighborOctants = function (queryPoint, radius, squareRadius, depth, neighborOctants) {

    var node;
    var intersects = false;

    if (queryPoint && this.depth < depth) {
        // does inner box intersect with octant
        intersects = !(queryPoint.x + radius < this.min.x || queryPoint.x - radius > this.max.x ||
        queryPoint.y + radius < this.min.y || queryPoint.y - radius > this.max.y ||
        queryPoint.z + radius < this.min.z || queryPoint.z - radius > this.max.z);
    }

    if (intersects === true) {

        var queryPointToOctant = new THREE.Vector3(0.5 * (this.max.x + this.min.x) - queryPoint.x,
            0.5 * (this.max.y + this.min.y) - queryPoint.y, 0.5 * (this.max.z + this.min.z) - queryPoint.z);
        var distance = queryPointToOctant.lengthSq();
        if (distance < squareRadius) {
            // gather octants
            neighborOctants.push(this);
        }

        // search subtree
        for (var i = 0, length = this.childOctants.length; i < length; ++i) {

            node = this.childOctants[i];
            node.findRadiusNeighborOctants(queryPoint, radius, squareRadius, depth, neighborOctants);
        }
    }
    //else {
    //	CLOUD.Logger.log("Octant" + this.octantId + "culled!")
    //}
};

CLOUD.Loader.OctreeNode.prototype.intersectRayDistance = function (origin, direction) {
    var Tmin, Tmax, TYmin, TYmax;
    // X Axis
    var invDirectionX = 1 / direction.x;
    if (direction.x >= 0) {
        Tmin = (this.min.x - origin.x) * invDirectionX;
        Tmax = (this.max.x - origin.x) * invDirectionX;
    } else {
        Tmin = (this.max.x - origin.x) * invDirectionX;
        Tmax = (this.min.x - origin.x) * invDirectionX;
    }

    // Y Axis
    var invDirectionY = 1 / direction.y;
    if (direction.y >= 0) {
        TYmin = (this.min.y - origin.y) * invDirectionY;
        TYmax = (this.max.y - origin.y) * invDirectionY;
    } else {
        TYmin = (this.max.y - origin.y) * invDirectionY;
        TYmax = (this.min.y - origin.y) * invDirectionY;
    }

    if ((Tmin > TYmax) || (TYmin > Tmax)) {
        //no intersection
        return Infinity;
    }
    if (TYmin > Tmin) {
        Tmin = TYmin;
    }
    if (TYmax < Tmax) {
        Tmax = TYmax;
    }

    // Z Axis
    var TZmin, TZmax;
    var invDirectionZ = 1 / direction.z;
    if (direction.z >= 0) {
        TZmin = (this.min.z - origin.z) * invDirectionZ;
        TZmax = (this.max.z - origin.z) * invDirectionZ;
    } else {
        TZmin = (this.max.z - origin.z) * invDirectionZ;
        TZmaz = (this.min.z - origin.z) * invDirectionZ;
    }
    if ((Tmin > TZmax) || (TZmin > Tmax)) {
        // no intersection
        return Infinity;
    }
    if (TZmin > Tmin) {
        Tmin = TZmin;
    }
    if (TZmax < Tmax) {
        Tmax = TZmax;
    }
    // return nearest intersection distance
    return Tmin;
};
*/
CLOUD.Loader.OctreeNode.prototype.updateMaxDepth = function () {

    if (this.depth > CLOUD.GlobalData.MaximumDepth) {
        CLOUD.GlobalData.MaximumDepth = this.depth;
    }
};
/**
 * @author muwj 2016/12/15
 */

CLOUD.Loader.IdReader = function (buffer) {

    var header = new Uint32Array(buffer, 0, 2);
    this.size = header[0];
    this.count = header[1];

    this.cache = {};
    this.idBuffer = buffer.slice(4 * 2);
    header = null;
};

CLOUD.Loader.IdReader.prototype = {

    constructor: CLOUD.Loader.IdReader,

    getSize: function getSize() {

        return this.size;
    },

    getCount: function getCount() {

        return this.count;
    },

    getString: function getString(index_id) {

        if (this.cache[index_id] !== undefined) {
            return this.cache[index_id];
        }

        if (index_id >= 0 && index_id < this.count) {

            var buf = new Uint8Array(this.idBuffer, this.size * index_id, this.size);
            var id_string = String.fromCharCode.apply(null, buf);
            var idx = id_string.indexOf('\0');

            if (idx !== -1) {
                this.cache[index_id] = id_string.substring(0, idx);
            } else {
                this.cache[index_id] = id_string;
            }

            // this.cache[index_id] = id_string.substring( 0, id_string.indexOf('\0') );
            // return String.fromCharCode.apply( null, buf );

            return this.cache[index_id];
        }
        return undefined;
    },

    getIndex: function getIndex(string_id) {

        if (string_id == undefined) return -1;

        var left = 0;
        var right = this.count - 1;
        var length = string_id.length;

        while (left <= right) {
            var mid = Math.floor((left + right) / 2);
            var buf = new Uint8Array(this.idBuffer, this.size * mid, length);
            var str = String.fromCharCode.apply(null, buf);
            var idx = str.indexOf('\0');
            //var rt = string_id.localeCompare( str.substring( 0, str.indexOf('\0') ) );

            var rt = 0;

            if (idx !== -1) {
                rt = string_id.localeCompare(str.substring(0, idx));
            } else {
                rt = string_id.localeCompare(str);
            }

            if (rt == 0) return mid;else if (rt < 0) right = mid - 1;else if (rt > 0) left = mid + 1;
        }
        return -1;
    }
};
/**
 * @author muwj 2016/12/15
 */

CLOUD.Loader.UserDataReader = function (text) {

    this.userData = JSON.parse(text);
    this.count = 0;
    for (var key in this.userData) {
        if (this.userData.hasOwnProperty(key)) {
            this.count++;
        }
    }

    this.getCount = function () {

        return this.count;
    };

    this.getData = function () {

        return this.userData;
    };

    this.getUserData = function (index_id) {

        if (index_id >= 0 && index_id < this.count) {

            return this.userData[index_id + ''];
        }
        return undefined;
    };
};
/**
 * @author muwj 2017/01/25
 */

CLOUD.Loader.OctNode = function (buffer, offset) {

    var data_i = new Uint32Array(buffer, offset, 5);
    this.cell_id = data_i[0];
    this.child_s = data_i[3];
    this.child_e = data_i[4];

    var data_f = new Float32Array(buffer, offset + 5 * 4, 6);
    this.boundingBox = new THREE.Box3(new THREE.Vector3(data_f[0], data_f[1], data_f[2]), new THREE.Vector3(data_f[3], data_f[4], data_f[5]));
};

CLOUD.Loader.OctreeReader = function (buffer) {

    var data_i = new Uint32Array(buffer, 0, 1);
    this.count = data_i[0];
    this.data = new Array(this.count);

    for (var i = 0; i < this.count; ++i) {
        this.data[i] = new CLOUD.Loader.OctNode(buffer, (1 + i * 11) * 4);
    }
};

CLOUD.Loader.OctreeReader.prototype = {

    constructor: CLOUD.Loader.OctreeReader,

    getCount: function getCount() {

        return this.count;
    },

    getNode: function getNode(idx) {

        if (idx >= 0 && idx < this.count) {

            return this.data[idx];
        }
    }
};
/**
 * @author muwj 2016/12/15
 */

CLOUD.Loader.Material = function (buffer, offset) {

    var data_i = new Uint32Array(buffer, offset, 8);

    this.id = data_i[0];
    this.type = data_i[1];
    this.metal = data_i[2];
    this.color = data_i[3];
    this.emissive = data_i[4];
    this.specular = data_i[5];
    this.side = data_i[6];
    this.texture_n = data_i[7];

    this.texture_id = new Uint32Array(buffer, offset + 4 * 8, 8);

    var data_f = new Float32Array(buffer, offset + 4 * 16, 3);
    this.shininess = data_f[0];
    this.opacity = data_f[1];
    this.reflectivity = data_f[2];

    data_i = null;
    data_f = null;
};

CLOUD.Loader.Texture = function (buffer, offset) {

    var data_i = new Uint32Array(buffer, offset, 4);

    this.id = data_i[0];
    this.type = data_i[1];
    this.repeat_u = data_i[2];
    this.repeat_v = data_i[3];

    var data_f = new Float32Array(buffer, offset + 4 * 4, 5);
    this.angle = data_f[0];
    this.offset_u = data_f[1];
    this.offset_v = data_f[2];
    this.scale_u = data_f[3];
    this.scale_v = data_f[4];

    var data_c = new Uint8Array(buffer, offset + 4 * 9, 8);
    var ext_name = String.fromCharCode.apply(null, data_c);
    this.file_name_ext = ext_name.substring(0, ext_name.indexOf('\0'));

    data_i = null;
    data_f = null;
    data_c = null;
};

CLOUD.Loader.MaterialReader = function (buffer) {

    var header = new Uint32Array(buffer, 0, 4);

    this.materialCount = header[0];
    this.materialOffset = header[1];
    this.textureCount = header[2];
    this.textureOffset = header[3];

    this.materialSize = 4 * 19;
    this.textureSize = 4 * 9 + 8;
    this.materialBuffer = buffer.slice(this.materialOffset, this.materialOffset + this.materialCount * this.materialSize);
    this.textureBuffer = buffer.slice(this.textureOffset, this.textureOffset + this.textureCount * this.textureSize);

    // for data reading
    this.material_id = -1;
    this.texture_id = -1;
    var tmp_buffer = new ArrayBuffer(this.materialSize);
    this.material_cur = new CLOUD.Loader.Material(tmp_buffer, 0);
    this.texture_cur = new CLOUD.Loader.Texture(tmp_buffer, 0);

    header = null;
    tmp_buffer = null;
};

CLOUD.Loader.MaterialReader.prototype = {

    constructor: CLOUD.Loader.MaterialReader,

    getMaterial: function getMaterial(id) {

        if (id >= 0 && id < this.materialCount) {
            return new CLOUD.Loader.Material(this.materialBuffer, id * this.materialSize);
        }
    },

    getTexture: function getTexture(id) {

        if (id >= 0 && id < this.textureCount) {
            return new CLOUD.Loader.Texture(this.textureBuffer, id * this.textureSize);
        }
    },

    getMaterialInfo: function getMaterialInfo(id) {

        if (id == this.material_id) {
            return this.material_cur;
        }

        if (id >= 0 && id < this.materialCount) {

            var data_i = new Uint32Array(this.materialBuffer, id * this.materialSize, 8);
            this.material_cur.id = data_i[0];
            this.material_cur.type = data_i[1];
            this.material_cur.metal = data_i[2];
            this.material_cur.color = data_i[3];
            this.material_cur.emissive = data_i[4];
            this.material_cur.specular = data_i[5];
            this.material_cur.side = data_i[6];
            this.material_cur.texture_n = data_i[7];

            this.material_cur.texture_id = new Uint32Array(this.materialBuffer, id * this.materialSize + 4 * 8, 8);

            var data_f = new Float32Array(this.materialBuffer, id * this.materialSize + 4 * 16, 3);
            this.material_cur.shininess = data_f[0];
            this.material_cur.opacity = data_f[1];
            this.material_cur.reflectivity = data_f[2];

            data_i = null;
            data_f = null;
            this.material_id = id;
            return this.material_cur;
        }
    },

    getTextureInfo: function getTextureInfo(id) {

        if (id == this.texture_id) {
            return this.texture_cur;
        }

        if (id >= 0 && id < this.textureCount) {

            var data_i = new Uint32Array(this.textureBuffer, id * this.textureSize, 4);
            this.texture_cur.id = data_i[0];
            this.texture_cur.type = data_i[1];
            this.texture_cur.repeat_u = data_i[2];
            this.texture_cur.repeat_v = data_i[3];

            var data_f = new Float32Array(this.textureBuffer, id * this.textureSize + 4 * 4, 5);
            this.texture_cur.angle = data_f[0];
            this.texture_cur.offset_u = data_f[1];
            this.texture_cur.offset_v = data_f[2];
            this.texture_cur.scale_u = data_f[3];
            this.texture_cur.scale_v = data_f[4];

            var data_c = new Uint8Array(this.textureBuffer, id * this.textureSize + 4 * 9, 8);
            var ext_name = String.fromCharCode.apply(null, data_c);
            this.texture_cur.file_name_ext = ext_name.substring(0, ext_name.indexOf('\0'));

            data_i = null;
            data_f = null;
            data_c = null;
            this.texture_id = id;
            return this.texture_cur;
        }
    }
};
/**
 * @author muwj 2016/12/29
 */

CLOUD.Loader.SymbolHeader = function (buffer) {

    var header = new Uint32Array(buffer, 0, 9);

    this.blockId = header[0];
    this.symbolCount = header[1];
    this.itemCount = header[2];
    this.matrixCount = header[3];
    this.geomBuffSize = header[4];
    this.symbolOffset = header[5];
    this.itemOffset = header[6];
    this.matrixOffset = header[7];
    this.geomOffset = header[8];

    var bbox = new Float32Array(buffer, 4 * 9, 6);
    this.boundingBox = new THREE.Box3(new THREE.Vector3(bbox[0], bbox[1], bbox[2]), new THREE.Vector3(bbox[3], bbox[4], bbox[5]));

    header = null;
    bbox = null;
};

CLOUD.Loader.Symbol = function (buffer, offset) {

    var item_i = new Int32Array(buffer, offset, 3);

    this.symbolId = item_i[0];
    this.itemIndex = item_i[1];
    this.itemCount = item_i[2];

    var bbox = new Float32Array(buffer, offset + 4 * 3, 6);
    this.boundingBox = new THREE.Box3(new THREE.Vector3(bbox[0], bbox[1], bbox[2]), new THREE.Vector3(bbox[3], bbox[4], bbox[5]));

    item_i = null;
    bbox = null;
};

CLOUD.Loader.SymbolReader = function (buffer) {

    this.header = new CLOUD.Loader.SymbolHeader(buffer);

    this.symbolSize = 4 * 9;
    this.itemSize = 4 * 13;
    this.matrixSize = 4 * 16;
    this.geomSize = 4 * 8;
    this.maxSize = 4 * 64;

    this.symbolBuffer = buffer.slice(this.header.symbolOffset, this.header.symbolOffset + this.header.symbolCount * this.symbolSize);
    this.itemBuffer = buffer.slice(this.header.itemOffset, this.header.itemOffset + this.header.itemCount * this.itemSize);
    this.matrixBuffer = buffer.slice(this.header.matrixOffset, this.header.matrixOffset + this.header.matrixCount * this.matrixSize);
    this.geomBuffer = buffer.slice(this.header.geomOffset, this.header.geomOffset + this.header.geomBuffSize);

    // for data reading
    this.matr_cur_id = -1;

    this.pt_symb_min = new THREE.Vector3(0.0, 0.0, 0.0);
    this.pt_symb_max = new THREE.Vector3(0.0, 0.0, 0.0);
    this.pt_item_min = new THREE.Vector3(0.0, 0.0, 0.0);
    this.pt_item_max = new THREE.Vector3(0.0, 0.0, 0.0);

    var tmp_buffer = new ArrayBuffer(this.maxSize);
    this.symb_cur = new CLOUD.Loader.Symbol(tmp_buffer, 0);
    this.item_cur = new CLOUD.Loader.Item(tmp_buffer, 0);
    this.matr_cur = new CLOUD.Loader.Matrix(tmp_buffer, 0);
    this.pipe_cur = new CLOUD.Loader.GeomPipe(tmp_buffer, 0);

    this.symb_cur.boundingBox.set(this.pt_symb_min, this.pt_symb_max);
    this.item_cur.boundingBox.set(this.pt_item_min, this.pt_item_max);
};

CLOUD.Loader.SymbolReader.prototype = {

    constructor: CLOUD.Loader.SymbolReader,

    getSymbol: function getSymbol(index) {

        if (index >= 0 && index < this.header.symbolCount) {
            return new CLOUD.Loader.Symbol(this.symbolBuffer, index * this.symbolSize);
        }
    },

    getItem: function getItem(index) {

        if (index >= 0 && index < this.header.itemCount) {
            return new CLOUD.Loader.Item(this.itemBuffer, index * this.itemSize);
        }
    },

    getMatrix: function getMatrix(index) {

        if (index >= 0 && index < this.header.matrixCount) {
            return new CLOUD.Loader.Matrix(this.matrixBuffer, index * this.matrixSize);
        }
    },

    getGeomPipe: function getGeomPipe(offset) {

        if (offset >= 0 && index < this.header.geomBuffSize) {
            return new CLOUD.Loader.GeomPipe(this.geomBuffer, offset);
        }
    },

    getSymbolInfo: function getSymbolInfo(index) {

        if (index >= 0 && index < this.header.symbolCount) {

            var item_i = new Int32Array(this.symbolBuffer, index * this.symbolSize, 3);
            this.symb_cur.symbolId = item_i[0];
            this.symb_cur.itemIndex = item_i[1];
            this.symb_cur.itemCount = item_i[2];

            var data_f = new Float32Array(this.symbolBuffer, index * this.symbolSize + 4 * 3, 6);
            this.pt_symb_min.set(data_f[0], data_f[1], data_f[2]);
            this.pt_symb_max.set(data_f[3], data_f[4], data_f[5]);
            this.symb_cur.boundingBox.set(this.pt_symb_min, this.pt_symb_max);

            return this.symb_cur;
        }
    },

    getItemInfo: function getItemInfo(index) {

        if (index >= 0 && index < this.header.itemCount) {

            var data_i = new Int32Array(this.itemBuffer, index * this.itemSize, 7);
            this.item_cur.ItemId = data_i[0];
            this.item_cur.originalId = data_i[1];
            this.item_cur.materialId = data_i[2];
            this.item_cur.userDataId = data_i[3];
            this.item_cur.matrixId = data_i[4];
            this.item_cur.type = data_i[5];
            this.item_cur.toData = data_i[6];

            var data_f = new Float32Array(this.itemBuffer, index * this.itemSize + 4 * 7, 6);
            this.pt_item_min.set(data_f[0], data_f[1], data_f[2]);
            this.pt_item_max.set(data_f[3], data_f[4], data_f[5]);
            this.item_cur.boundingBox.set(this.pt_item_min, this.pt_item_max);

            return this.item_cur;
        }
    },

    getMatrixInfo: function getMatrixInfo(index) {

        if (index == this.matr_cur_id) {
            return this.matr_cur;
        }

        if (index >= 0 && index < this.header.matrixCount) {

            var data = new Float32Array(this.matrixBuffer, index * this.matrixSize, 4 * 4);
            this.matr_cur.matrix.fromArray(data);

            this.matr_cur_id = index;
            return this.matr_cur;
        }
    },

    getGeomPipeInfo: function getGeomPipeInfo(offset) {

        if (offset >= 0 && offset < this.header.geomBuffSize) {

            var data = new Float32Array(this.geomBuffer, offset, 8);

            this.pipe_cur.startPt.set(data[0], data[1], data[2]);
            this.pipe_cur.endPt.set(data[3], data[4], data[5]);
            this.pipe_cur.radius = data[6];
            this.pipe_cur.thickness = data[7];

            return this.pipe_cur;
        }
    },

    getMpkID: function getMpkID(mesh_id) {

        return parseInt(mesh_id / 65536);
    },

    getMeshIndex: function getMeshIndex(mesh_id) {

        return parseInt(mesh_id % 65536);
    }
};
/**
 * @author muwj 2016/12/15
 */

CLOUD.Loader.MPKHeader = function (buffer) {

    var header = new Uint32Array(buffer, 0, 7);

    this.blockId = header[0];
    this.startId = header[1];
    this.vtFormat = header[2];
    this.meshCount = header[3];
    this.meshOffset = header[4];
    this.bufferSize = header[5];
    this.bufferOffset = header[6];

    header = null;
};

CLOUD.Loader.MeshData = function (buffer, offset) {

    var mesh_info = new Uint32Array(buffer, offset, 4);

    this.mesh_id = mesh_info[0];
    this.ptCount = mesh_info[1];
    this.idxCount = mesh_info[2];
    this.dataOffset = mesh_info[3];

    var base_info = new Float32Array(buffer, offset + 4 * 4, 4);

    this.baseScale = base_info[0];
    this.baseVector = new THREE.Vector3(base_info[1], base_info[2], base_info[3]);

    mesh_info = null;
    base_info = null;
};

CLOUD.Loader.MPKReader = function (buffer) {

    this.header = new CLOUD.Loader.MPKHeader(buffer);

    this.meshSize = 4 * 8;
    this.maxSize = 4 * 64;
    this.meshBuffer = buffer.slice(this.header.meshOffset, this.header.meshOffset + this.header.meshCount * this.meshSize);
    this.geomBuffer = buffer.slice(this.header.bufferOffset, this.header.bufferOffset + this.header.bufferSize);

    // for data reading
    this.mesh_cur_id = -1;
    this.pt_pos = new THREE.Vector3(0.0, 0.0, 0.0);

    var tmp_buffer = new ArrayBuffer(this.maxSize);
    this.mesh_cur = new CLOUD.Loader.MeshData(tmp_buffer, 0);
    this.mesh_cur.baseVector = this.pt_pos;
};

CLOUD.Loader.MPKReader.prototype = {

    constructor: CLOUD.Loader.MPKReader,

    getMeshData: function getMeshData(id) {

        var index = id - this.header.startId;
        if (index >= 0 && index < this.header.meshCount) {

            return new CLOUD.Loader.MeshData(this.meshBuffer, index * this.meshSize);
        }
    },

    getMeshInfo: function getMeshInfo(id) {

        if (id == this.mesh_cur_id) {
            return this.mesh_cur;
        }

        var index = id - this.header.startId;
        if (index >= 0 && index < this.header.meshCount) {

            var data_i = new Uint32Array(this.meshBuffer, index * this.meshSize, 4);
            this.mesh_cur.mesh_id = data_i[0];
            this.mesh_cur.ptCount = data_i[1];
            this.mesh_cur.idxCount = data_i[2];
            this.mesh_cur.dataOffset = data_i[3];

            var data_f = new Float32Array(this.meshBuffer, index * this.meshSize + 4 * 4, 4);
            this.mesh_cur.baseScale = data_f[0];
            this.mesh_cur.baseVector.set(data_f[1], data_f[2], data_f[3]);

            this.mesh_cur_id = id;
            return this.mesh_cur;
        }
    },

    getPtBuffer: function getPtBuffer(id) {

        var index = id - this.header.startId;
        if (index >= 0 && index < this.header.meshCount) {

            var mesh = this.getMeshInfo(id);
            if (mesh === undefined) {
                return undefined;
            }

            if (mesh.baseScale == 0.0) {
                return new Float32Array(this.geomBuffer, mesh.dataOffset, mesh.ptCount * 3);
            } else {
                return new Uint16Array(this.geomBuffer, mesh.dataOffset, mesh.ptCount * 3);
            }
        }
    },

    getIdxBuffer: function getIdxBuffer(id) {

        var index = id - this.header.startId;
        if (index >= 0 && index < this.header.meshCount) {

            var mesh = this.getMeshInfo(id);
            if (mesh === undefined) {
                return undefined;
            }

            var offset = mesh.dataOffset;
            if (mesh.baseScale == 0.0) {
                offset += mesh.ptCount * 3 * 4;
            } else {
                offset += mesh.ptCount * 3 * 2;
                if (mesh.ptCount % 2 == 1) {
                    offset += 2;
                }
            }

            if (mesh.ptCount > 65535) {
                return new Uint32Array(this.geomBuffer, offset, mesh.idxCount);
            } else {
                return new Uint16Array(this.geomBuffer, offset, mesh.idxCount);
            }
        }
    },

    getNormalBuffer: function getNormalBuffer(id) {

        var index = id - this.header.startId;
        if ((this.header.vtFormat & 2) == 2 && index >= 0 && index < this.header.meshCount) {

            var mesh = this.getMeshInfo(id);
            if (mesh === undefined) {
                return undefined;
            }

            var offset = mesh.dataOffset;
            if (mesh.baseScale == 0.0) {
                offset += mesh.ptCount * 3 * 4;
            } else {
                offset += mesh.ptCount * 3 * 2;
                if (mesh.ptCount % 2 == 1) {
                    offset += 2;
                }
            }

            if (mesh.ptCount > 65535) {
                offset += mesh.idxCount * 4;
            } else {
                offset += mesh.idxCount * 2;
                if (mesh.idxCount % 2 == 1) {
                    offset += 2;
                }
            }

            return new Float32Array(this.geomBuffer, offset, mesh.ptCount * 3);
        }
    }
};
/**
 * @author muwj 2016/12/15
 */

CLOUD.Loader.SceneHeader = function (buffer) {

    var header = new Uint32Array(buffer, 0, 11);

    this.blockId = header[0];
    this.cellCount = header[1];
    this.itemCount = header[2];
    this.matrixCount = header[3];
    this.geomBuffSize = header[4];
    this.layerBuffSize = header[5];
    this.cellOffset = header[6];
    this.itemOffset = header[7];
    this.matrixOffset = header[8];
    this.geomOffset = header[9];
    this.layerOffset = header[10];

    var bbox = new Float32Array(buffer, 4 * 11, 6);
    this.boundingBox = new THREE.Box3(new THREE.Vector3(bbox[0], bbox[1], bbox[2]), new THREE.Vector3(bbox[3], bbox[4], bbox[5]));

    header = null;
    bbox = null;
};

CLOUD.Loader.Cell = function (buffer, offset) {

    var cell_i = new Int32Array(buffer, offset, 5);

    this.cellId = cell_i[0];
    this.depth = cell_i[1];
    this.itemIndex = cell_i[2];
    this.itemCount = cell_i[3];

    this.layerType = cell_i[4];
    this.layerSize = new Int32Array(buffer, offset + 5 * 4, 8);
    this.layerOffset = new Int32Array(buffer, offset + (5 + 8) * 4, 8);

    var bbox = new Float32Array(buffer, offset + (5 + 8 + 8) * 4, 6);
    this.boundingBox = new THREE.Box3(new THREE.Vector3(bbox[0], bbox[1], bbox[2]), new THREE.Vector3(bbox[3], bbox[4], bbox[5]));

    cell_i = null;
    bbox = null;
};

CLOUD.Loader.Item = function (buffer, offset) {

    var item_i = new Int32Array(buffer, offset, 7);

    this.ItemId = item_i[0];
    this.originalId = item_i[1];
    this.materialId = item_i[2];
    this.userDataId = item_i[3];
    this.matrixId = item_i[4];
    this.type = item_i[5];
    this.toData = item_i[6];

    var bbox = new Float32Array(buffer, offset + 4 * 7, 6);
    this.boundingBox = new THREE.Box3(new THREE.Vector3(bbox[0], bbox[1], bbox[2]), new THREE.Vector3(bbox[3], bbox[4], bbox[5]));

    item_i = null;
    bbox = null;
};

CLOUD.Loader.Matrix = function (buffer, offset) {

    var matrixData = new Float32Array(buffer, offset, 4 * 4);
    this.matrix = new THREE.Matrix4().fromArray(matrixData);
    matrixData = null;
};

CLOUD.Loader.GeomPipe = function (buffer, offset) {

    var geomData = new Float32Array(buffer, offset, 8);

    this.startPt = new THREE.Vector3(geomData[0], geomData[1], geomData[2]);
    this.endPt = new THREE.Vector3(geomData[3], geomData[4], geomData[5]);
    this.radius = geomData[6];
    this.thickness = geomData[7];

    geomData = null;
};

CLOUD.Loader.SceneReader = function (buffer) {

    this.header = new CLOUD.Loader.SceneHeader(buffer);

    this.cellSize = 4 * (5 + 8 + 8 + 6);
    this.itemSize = 4 * 13;
    this.matrixSize = 4 * 16;
    this.maxSize = 4 * 256;

    this.cellBuffer = buffer.slice(this.header.cellOffset, this.header.cellOffset + this.header.cellCount * this.cellSize);
    this.itemBuffer = buffer.slice(this.header.itemOffset, this.header.itemOffset + this.header.itemCount * this.itemSize);
    this.matrixBuffer = buffer.slice(this.header.matrixOffset, this.header.matrixOffset + this.header.matrixCount * this.matrixSize);
    this.geomBuffer = buffer.slice(this.header.geomOffset, this.header.geomOffset + this.header.geomBuffSize);
    this.layerBuffer = buffer.slice(this.header.layerOffset, this.header.layerOffset + this.header.layerBuffSize);

    // for data reading
    this.matr_cur_id = -1;
    this.pt_cell_min = new THREE.Vector3(0.0, 0.0, 0.0);
    this.pt_cell_max = new THREE.Vector3(0.0, 0.0, 0.0);
    this.pt_item_min = new THREE.Vector3(0.0, 0.0, 0.0);
    this.pt_item_max = new THREE.Vector3(0.0, 0.0, 0.0);

    var tmp_buffer = new ArrayBuffer(this.maxSize);
    this.cell_cur = new CLOUD.Loader.Cell(tmp_buffer, 0);
    this.item_cur = new CLOUD.Loader.Item(tmp_buffer, 0);
    this.matr_cur = new CLOUD.Loader.Matrix(tmp_buffer, 0);
    this.pipe_cur = new CLOUD.Loader.GeomPipe(tmp_buffer, 0);

    this.cell_cur.boundingBox.set(this.pt_cell_min, this.pt_cell_max);
    this.item_cur.boundingBox.set(this.pt_item_min, this.pt_item_max);
};

CLOUD.Loader.SceneReader.prototype = {

    constructor: CLOUD.Loader.SceneReader,

    getCellMpks: function getCellMpks(index) {

        if (index >= 0 && index < this.header.cellCount) {
            var src = [];
            var cell = this.getCellInfo(index);
            for (var i = cell.itemIndex; i < cell.itemCount; ++i) {
                var item = this.getItemInfo(i);
                if (item.type === 1) {
                    // mesh

                    var blockId = this.getMpkID(item.toData);
                    src.push(blockId);
                }
            }

            var key = {};
            var dist = [];
            for (var j = 0; j < src.length; ++j) {
                if (!key[src[j]]) {
                    key[src[j]] = true;
                    dist.push(src[j]);
                }
            }
            return dist;
        }
    },

    getCell: function getCell(index) {

        if (index >= 0 && index < this.header.cellCount) {
            return new CLOUD.Loader.Cell(this.cellBuffer, index * this.cellSize);
        }
    },

    getItem: function getItem(index) {

        if (index >= 0 && index < this.header.itemCount) {
            return new CLOUD.Loader.Item(this.itemBuffer, index * this.itemSize);
        }
    },

    getMatrix: function getMatrix(index) {

        if (index >= 0 && index < this.header.matrixCount) {
            return new CLOUD.Loader.Matrix(this.matrixBuffer, index * this.matrixSize);
        }
    },

    getGeomPipe: function getGeomPipe(offset) {

        if (offset >= 0 && offset < this.header.geomBuffSize) {
            return new CLOUD.Loader.GeomPipe(this.geomBuffer, offset);
        }
    },

    getCellInfo: function getCellInfo(index) {

        if (index >= 0 && index < this.header.cellCount) {

            var data_i = new Int32Array(this.cellBuffer, index * this.cellSize, 5);
            this.cell_cur.cellId = data_i[0];
            this.cell_cur.depth = data_i[1];
            this.cell_cur.itemIndex = data_i[2];
            this.cell_cur.itemCount = data_i[3];

            this.cell_cur.layerType = data_i[4];
            this.cell_cur.layerSize = new Int32Array(this.cellBuffer, index * this.cellSize + 5 * 4, 8);
            this.cell_cur.layerOffset = new Int32Array(this.cellBuffer, index * this.cellSize + (5 + 8) * 4, 8);

            var data_f = new Float32Array(this.cellBuffer, index * this.cellSize + (5 + 8 + 8) * 4, 6);
            this.pt_cell_min.set(data_f[0], data_f[1], data_f[2]);
            this.pt_cell_max.set(data_f[3], data_f[4], data_f[5]);
            this.cell_cur.boundingBox.set(this.pt_cell_min, this.pt_cell_max);

            return this.cell_cur;
        }
    },

    getItemInfo: function getItemInfo(index) {

        if (index >= 0 && index < this.header.itemCount) {

            var data_i = new Int32Array(this.itemBuffer, index * this.itemSize, 7);
            this.item_cur.ItemId = data_i[0];
            this.item_cur.originalId = data_i[1];
            this.item_cur.materialId = data_i[2];
            this.item_cur.userDataId = data_i[3];
            this.item_cur.matrixId = data_i[4];
            this.item_cur.type = data_i[5];
            this.item_cur.toData = data_i[6];

            var data_f = new Float32Array(this.itemBuffer, index * this.itemSize + 4 * 7, 6);
            this.pt_item_min.set(data_f[0], data_f[1], data_f[2]);
            this.pt_item_max.set(data_f[3], data_f[4], data_f[5]);
            this.item_cur.boundingBox.set(this.pt_item_min, this.pt_item_max);

            return this.item_cur;
        }
    },

    getMatrixInfo: function getMatrixInfo(index) {

        if (index == this.matr_cur_id) {
            return this.matr_cur;
        }

        if (index >= 0 && index < this.header.matrixCount) {

            var data = new Float32Array(this.matrixBuffer, index * this.matrixSize, 4 * 4);
            this.matr_cur.matrix.fromArray(data);

            this.matr_cur_id = index;
            return this.matr_cur;
        }
    },

    getGeomPipeInfo: function getGeomPipeInfo(offset) {

        if (offset >= 0 && offset < this.header.geomBuffSize) {

            var data = new Float32Array(this.geomBuffer, offset, 8);
            this.pipe_cur.startPt.set(data[0], data[1], data[2]);
            this.pipe_cur.endPt.set(data[3], data[4], data[5]);
            this.pipe_cur.radius = data[6];
            this.pipe_cur.thickness = data[7];

            return this.pipe_cur;
        }
    },

    getLayerInfo: function getLayerInfo(offset, size) {

        if (offset >= 0 && offset + size < this.header.layerBuffSize) {

            var data = new Uint32Array(this.layerBuffer, offset, size);
            return this.data;
        }
    },

    getMpkID: function getMpkID(mesh_id) {

        return parseInt(mesh_id / 65536);
    },

    getMeshIndex: function getMeshIndex(mesh_id) {

        return parseInt(mesh_id % 65536);
    }
};

CLOUD.TaskWorker = function (threadCount, finishCallback) {

    this.MaxThreadCount = threadCount || 8;

    var scope = this;
    scope.todoList = {};
    scope.todoCount = 0;
    scope.doingCount = 0;

    this.hasTask = function () {
        return scope.todoCount > 0;
    };

    this.addItem = function (id, item) {
        scope.todoList[id] = item;
        scope.todoCount++;
    };

    this.clearTasks = function () {
        scope.todoList = {};
        scope.todoCount = 0;
    };

    this.run = function (renderId, loader, sorter) {
        var scope = this;
        if (scope.doingCount > 0) {
            //console.log("busy");
            return;
        }

        var items = [];
        var todoList = scope.todoList;
        for (var name in todoList) {
            if (todoList.hasOwnProperty(name)) {
                items.push(name);
            }
        }
        //console.log(scope.todoCount + "/" + items.length);
        scope.todoList = {};
        scope.todoCount = 0;

        var itemCount = items.length;
        if (itemCount == 0) return;

        if (sorter) {
            items.sort(sorter);
        }

        itemCount = Math.min(itemCount, CLOUD.GlobalData.ConcurrencyRequestCount);

        var TASK_COUNT = Math.min(this.MaxThreadCount, itemCount);
        scope.doingCount = itemCount;

        function processItem(i) {

            if (i >= itemCount) {
                if (scope.doingCount < 1) {
                    finishCallback();
                }
                return;
            }

            var item = items[i];

            loader(item, i + TASK_COUNT, processItem);
        }

        for (var ii = 0; ii < TASK_COUNT; ++ii) {
            processItem(ii);
        }
    };
};

CLOUD.MpkTaskWorker = function (threadCount) {

    // var scope = this;

    this.MaxThreadCount = threadCount || 8;
    this.todoList = [];
    this.doingCount = 0;
    this.listners = [];

    this.addItem = function (mpkId) {

        if (mpkId === undefined) {
            console.log("undefined mpkId");
            return;
        }

        //if (this.todoList[mpkId] === undefined) {
        //    this.todoList[mpkId] = [];
        //}

        this.todoList.push(mpkId);
    };

    this.run = function (loader, onFinished) {

        if (this.doingCount > 0) {
            this.listners.push(onFinished);
            return;
        }

        var doingList = this.todoList;
        this.todoList = [];
        var items = [];
        for (var item in doingList) {
            if (doingList.hasOwnProperty(item)) {
                items.push(item);
            }
        }

        var scope = this;
        var itemCount = items.length;
        if (itemCount == 0) {
            onFinished();
            return;
        }

        var doingListners = this.listners;
        this.listners = [];
        scope.doingCount = itemCount;

        var TASK_COUNT = Math.min(this.MaxThreadCount, itemCount);

        function processItem(i) {

            if (i >= itemCount) {
                if (scope.doingCount < 1) {
                    // next loop
                    onFinished(0, itemCount);

                    for (var ii = 0, len = doingListners.length; ii < len; ++ii) {
                        doingListners[ii](0, itemCount);
                    }
                    doingListners = [];
                    scope.run(loader, function () {});
                } else {
                    onFinished(scope.doingCount, itemCount);
                }
                return;
            }

            if (i >= TASK_COUNT) {
                onFinished(scope.doingCount, itemCount);
            }

            var mpkId = items[i];
            //console.log(mpkId);
            loader(mpkId, i + TASK_COUNT, processItem);
        }

        for (var ii = 0; ii < TASK_COUNT; ++ii) {
            processItem(ii);
        }
    };
};

CLOUD.TaskManager = function (manager) {

    // var scope = this;
    this.manager = manager;
    // MPK
    this.mpkWorker = new CLOUD.MpkTaskWorker(8);
};

CLOUD.TaskManager.prototype = {

    constructor: CLOUD.TaskManager,

    addMpkTask: function addMpkTask(mpkId) {
        this.mpkWorker.addItem(mpkId);
    },

    processMpkTasks: function processMpkTasks(finishCallback) {

        var scope = this;
        //function on_load_mesh(client, item) {
        //
        //    if (item === null)
        //        return;
        //
        //    var mesh = client.cache.geometries[item.meshNode.meshId];
        //    if (mesh) {
        //        item.meshNode.updateGeometry(mesh);
        //    }
        //    else {
        //        console.log("err: " + item + " may be in other mpk");
        //    }
        //}

        function loader(mpkId, nextIdx, callback) {

            scope.manager.loadMpk(mpkId, function () {
                //if (items == undefined)
                //    console.log("error");
                //
                //for (var ii = 0, len = items.length; ii < len; ++ii) {
                //    on_load_mesh(client, items[ii]);
                //}


                --scope.mpkWorker.doingCount;
                // next task
                callback(nextIdx);
            });
        }

        this.mpkWorker.run(loader, finishCallback || function () {});
    }
};
// parameters = {serverUrl: xxx, databagId:xxx}
CLOUD.Loader.ModelLoader = function (model, parameters) {

    THREE.LoadingManager.call(this);

    this.model = model;
    this.taskManager = new CLOUD.TaskManager(this);
    this.url = new CLOUD.Loader.Url(parameters.serverUrl, parameters.databagId);
    this.loader = new THREE.FileLoader(this);
    this.loadTaskCount = 0;
    this.maxLoadTaskCount = 0; // TODO: change the way to flag resource loading finish flag.
    this.octreeRootNode = null;
    this.octreeRootNodeI = null;
    this.symbolReader = null;
    this.userIdReader = null;
    this.userDataReader = null;
    this.sceneReaderArray = null;
};

CLOUD.Loader.ModelLoader.prototype = Object.create(THREE.LoadingManager.prototype);
CLOUD.Loader.ModelLoader.prototype.constructor = CLOUD.Loader.ModelLoader;

CLOUD.Loader.ModelLoader.prototype._onTaskFinished = function () {

    var model = this.model;

    this.loadTaskCount++;

    if (this.notifyProgress) {

        var progress = {
            total: this.maxLoadTaskCount,
            loaded: this.loadTaskCount
        };

        model.dispatchEvent({ type: CLOUD.EVENTS.ON_LOAD_PROGRESS, progress: progress });
    }

    if (this.loadTaskCount >= this.maxLoadTaskCount) {

        model.loaded = true;

        var scene = this.model.manager.scene;
        if (CLOUD.GlobalData.IBL && scene.iblProbe != null && scene.iblProbe.isComputed) {
            this.model.updateMaterials();

            var IBLcfg = scene.IBLcfg;
            var keys = Object.keys(IBLcfg);
            var uniforms = IBLcfg[keys[scene.IBLIndex]];
            for (var id in uniforms) {
                this.model.updateMaterialsValue(id, uniforms[id]);
            }
        }

        model.dispatchEvent({ type: CLOUD.EVENTS.ON_LOAD_COMPLETE });
    }
};

CLOUD.Loader.ModelLoader.prototype._loadScene = function (loader, url, sceneId) {

    var scope = this;

    loader.setResponseType("arraybuffer");
    loader.load(url.sceneUrl(sceneId), function (data) {

        var sceneReader = new CLOUD.Loader.SceneReader(data);
        var blockId = sceneReader.header.blockId;

        if (blockId < scope.sceneCount) {
            scope.sceneReaderArray[blockId] = sceneReader;
        }

        sceneReader = null;
        // scope.model.dispatchEvent({type: CLOUD.EVENTS.ON_LOAD_START, sceneId: sceneId});

        scope._onTaskFinished();
    });
};

CLOUD.Loader.ModelLoader.prototype._loadMaterial = function (loader, url) {

    var scope = this;

    loader.setResponseType("arraybuffer");
    loader.load(url.materialUrl(), function (data) {

        scope._parseMaterial(data, url);
        scope._onTaskFinished();
    });
};

CLOUD.Loader.ModelLoader.prototype._loadSymbol = function (loader, url) {

    var scope = this;
    // TODO: maxLoadTaskCount should not be assigned with hard code at initialization (5).
    loader.setResponseType("arraybuffer");
    loader.load(url.symbolUrl(), function (data) {

        scope.symbolReader = new CLOUD.Loader.SymbolReader(data);
        scope._onTaskFinished();
    });
};

CLOUD.Loader.ModelLoader.prototype._loadOctreeInner = function (loader, url, matrixRoot) {

    var scope = this;

    // load spatial index
    loader.load(url.octreeUrl('i'), function (data) {

        scope._parseOctree(data, matrixRoot, true);
        scope._onTaskFinished();
    });
};

CLOUD.Loader.ModelLoader.prototype._loadOctreeOuter = function (loader, url, matrixRoot) {

    var scope = this;

    // load spatial index
    loader.load(url.octreeUrl('o'), function (data) {

        scope._parseOctree(data, matrixRoot, false);
        scope._onTaskFinished();
    });
};

CLOUD.Loader.ModelLoader.prototype._loadUserId = function (loader, url) {

    var scope = this;

    loader.setResponseType("arraybuffer");
    loader.load(url.userIdUrl(), function (data) {

        scope.userIdReader = new CLOUD.Loader.IdReader(data);
        scope._onTaskFinished();
    }, undefined, function (error) {

        scope._onTaskFinished();
    });
};

CLOUD.Loader.ModelLoader.prototype._loadUserData = function (loader, url) {

    var scope = this;

    loader.setResponseType("");
    loader.load(url.userDataUrl(), function (data) {

        scope.userDataReader = new CLOUD.Loader.UserDataReader(data);
        scope._onTaskFinished();
    });
};

CLOUD.Loader.ModelLoader.prototype._loadTexture = function (url, onLoad, onProgress, onError) {

    var texture;
    var loader = THREE.Loader.Handlers.get(url);
    var manager = this;

    if (loader !== null) {

        texture = loader.load(url, onLoad);
    } else {

        texture = new THREE.Texture();

        loader = new THREE.ImageLoader(manager);
        loader.setCrossOrigin("anonymous");
        loader.load(url, function (image) {

            texture.image = CLOUD.MaterialUtil.ensurePowerOfTwo(image);
            texture.needsUpdate = true;

            if (onLoad) onLoad(texture);
        }, onProgress, onError);
    }

    return texture;
};

CLOUD.Loader.ModelLoader.prototype._loadMpks = function (loader, url, count) {

    // Add MPKs to task manager
    var taskManager = this.taskManager;

    for (var i = 0; i < count; ++i) {
        taskManager.addMpkTask(i);
    }

    taskManager.processMpkTasks();
};

CLOUD.Loader.ModelLoader.prototype._parseMpk = function (data) {

    var referencedMeshCache = this.model.getReferencedMeshCache();
    var reader = new MPK.MPKReader(data);
    var count = reader.header.meshCount;

    for (var i = 0; i < count; ++i) {

        var position = reader.getPtBuffer(i);
        var index = reader.getIdxBuffer(i);
        var normal = reader.getNormalBuffer(i);
        var mesh = reader.getMeshData(i);
        var uv = reader.getUVBuffer(i);

        if (position == undefined || index == undefined || normal == undefined) {
            CLOUD.Logger.log("Error Geometry!");
            continue;
        }

        var id = mesh.mesh_id;

        referencedMeshCache[id] = {
            P: position, // position
            I: index, // index
            N: normal, // normal
            M: mesh, // mesh info
            UV: uv
        };
    }
    reader = null;
};

CLOUD.Loader.ModelLoader.prototype._parseMaterial = function (data, url) {

    var materials = this.model.getMaterials();
    var textures = this.model.getTextures();
    var reader = new CLOUD.Loader.MaterialReader(data);
    var len = reader.materialCount;

    if (len < 0) {
        return;
    }

    var scene = this.model.manager.scene;

    for (var i = 0; i < len; ++i) {

        var materialParameters = {};
        var materialData = reader.getMaterial(i);

        if (materialData.color !== undefined) {
            materialParameters.color = materialData.color;
        }

        if (materialData.opacity !== undefined) {
            materialParameters.opacity = materialData.opacity;

            if (materialData.opacity < 1.0) {
                materialParameters.transparent = true;
            }
        }

        if (materialData.side !== undefined && materialData.side) {
            materialParameters.side = THREE.DoubleSide;
        }

        if (materialData.emissive !== undefined) {
            materialParameters.emissive = materialData.emissive;
        }

        if (materialData.specular !== undefined) {
            materialParameters.specular = materialData.specular;
        }

        if (materialData.shininess !== undefined) {
            materialParameters.shininess = materialData.shininess;
        }

        var textureCount = materialData.texture_n;
        var textureData = null; // remark: 这里定义textureData后，一定要赋null值，否则textureData会保留上一次的值。

        if (textureCount > 0) {
            textureData = reader.getTexture(materialData.texture_id[0]);
        }

        if (textureData) {

            var textureId = textureData.id + textureData.file_name_ext;
            var texture = this._loadTexture(url.textureUrl(textureId));

            texture.repeat.fromArray([textureData.scale_u, textureData.scale_v]);
            texture.offset.fromArray([textureData.offset_u, textureData.offset_v]);

            if (texture.setRotateAngle) {
                texture.setRotateAngle(textureData.angle);
            }

            if (textureData.repeat_u) {
                texture.wrapS = THREE.RepeatWrapping;
            }

            if (textureData.repeat_v) {
                texture.wrapT = THREE.RepeatWrapping;
            }

            //materialParameters.map = texture;

            if (texture) {
                textures[i] = texture;
            }
        }

        if (CLOUD.GlobalData.IBL) {
            materialParameters.iblProbe = scene.iblProbe;
            var material = new ImageBasedLighting.IBLMaterial(materialParameters);
            material.type = 'IBL';
        } else {
            var material = CLOUD.MaterialUtil.createPhongMaterial(materialParameters);
        }

        material.name = i;
        materials[i] = material;
        materialParameters = null;
    }

    reader = null;
};

CLOUD.Loader.ModelLoader.prototype._parseOctree = function (data, matrixRoot, inner) {

    function setNodeByOctData(node, octData) {

        node.childStart = octData.child_s;
        node.childEnd = octData.child_e;

        // 如果模型数据经过了变换，则变换包围盒
        if (matrixRoot) {
            octData.boundingBox.applyMatrix4(matrixRoot);
        }

        var min = node.min = octData.boundingBox.min;
        var max = node.max = octData.boundingBox.max;

        node.center = new THREE.Vector3(0.5 * (max.x + min.x), 0.5 * (max.y + min.y), 0.5 * (max.z + min.z));

        var x = max.x - min.x;
        var y = max.y - min.y;
        var z = max.z - min.z;
        node.size = x * x + y * y + z * z;
    }

    function setNodeOctType(node, parent) {
        node.octType = 0;

        if (node.center.x < parent.center.x) {
            node.octType += 1;
        }
        if (node.center.y < parent.center.y) {
            node.octType += 2;
        }
        if (node.center.z < parent.center.z) {
            node.octType += 4;
        }
    }

    function traverse(parent, reader) {

        var childStart = parent.childStart;
        var childEnd = parent.childEnd;

        for (var i = childStart; i < childEnd; ++i) {

            var octData = reader.getNode(i);
            var octantId = octData.cell_id;
            var node = new CLOUD.Loader.OctreeNode(octantId, parent.depth);

            setNodeByOctData(node, octData);
            parent.add(node);
            setNodeOctType(node, parent);
            node.updateMaxDepth();
            traverse(node, reader);
        }
    }

    var rootNode = null;
    var reader = new CLOUD.Loader.OctreeReader(data);
    var count = reader.getCount();

    if (count > 0) {

        var octData = reader.getNode(0);
        var octantId = octData.cell_id;
        rootNode = new CLOUD.Loader.OctreeNode(octantId, 0);

        setNodeByOctData(rootNode, octData);
        traverse(rootNode, reader);
    }

    if (inner) {
        this.octreeRootNodeI = rootNode;
    } else {
        this.octreeRootNode = rootNode;
    }

    CLOUD.Logger.log("Maximum Depth:", CLOUD.GlobalData.MaximumDepth);
};

CLOUD.Loader.ModelLoader.prototype.destroy = function () {

    this.taskManager = null;
    this.url = null;
    this.model = null;
    this.loader = null;
    this.octreeRootNode = null;
    this.octreeRootNodeI = null;
    this.userIdReader = null;
    this.userDataReader = null;
    this.symbolReader = null;
    this.sceneReaderArray = null;
};

CLOUD.Loader.ModelLoader.prototype.getOctreeRootNodeInner = function () {
    return this.octreeRootNodeI;
};

CLOUD.Loader.ModelLoader.prototype.getOctreeRootNodeOuter = function () {
    return this.octreeRootNode;
};

CLOUD.Loader.ModelLoader.prototype.getSceneReaderArray = function () {
    return this.sceneReaderArray;
};

CLOUD.Loader.ModelLoader.prototype.getSymbolReader = function () {
    return this.symbolReader;
};

CLOUD.Loader.ModelLoader.prototype.getUserIdReader = function () {
    return this.userIdReader;
};

CLOUD.Loader.ModelLoader.prototype.getUserDataReader = function () {
    return this.userDataReader;
};

CLOUD.Loader.ModelLoader.prototype.setCrossOrigin = function (crossOrigin) {
    this.loader.setCrossOrigin(crossOrigin);
};

CLOUD.Loader.ModelLoader.prototype.load = function (notifyProgress) {

    var scope = this;
    var url = this.url;
    var loader = this.loader;
    var model = this.model;
    var scene = model.manager.scene;

    this.notifyProgress = notifyProgress;

    model.dispatchEvent({ type: CLOUD.EVENTS.ON_LOAD_START });

    loader.setResponseType("");
    loader.load(url.projectUrl(), function (text) {

        var cfg;

        model.loaded = false;

        try {
            cfg = JSON.parse(text);
        } catch (err) {
            console.log("Config data exceptions!");
            model.dispatchEvent({ type: CLOUD.EVENTS.ON_LOAD_INVALID_SCENE });
            return;
        }

        var metadata = cfg.metadata;
        var sceneCount = scope.sceneCount = metadata.scenes;
        // 空场景
        if (sceneCount === 0) {
            model.dispatchEvent({ type: CLOUD.EVENTS.ON_LOAD_EMPTY_SCENE });
            return;
        }

        var mpkCount = metadata.mpks;
        var symbolCount = metadata.symbol;
        var octreeCount_o = metadata.octree_o;
        var octreeCount_i = metadata.octree_i;
        var materialCount = metadata.material || 0;
        var userDataCount = metadata.userdata || 0; // userdata
        var userIdCount = 1; // userId

        var hasTransform = cfg.view.transform;

        scope.sceneReaderArray = new Array(sceneCount);

        // ------ 计算任务数 BEGIN ------ //
        scope.maxLoadTaskCount = 0;
        scope.maxLoadTaskCount += 1; //sceneCount;

        if (mpkCount > 0) {
            scope.maxLoadTaskCount += mpkCount;
        }

        scope.maxLoadTaskCount += symbolCount;
        scope.maxLoadTaskCount += octreeCount_o;
        scope.maxLoadTaskCount += octreeCount_i;
        scope.maxLoadTaskCount += materialCount;
        scope.maxLoadTaskCount += userDataCount;
        scope.maxLoadTaskCount += userIdCount;
        // ------ 计算任务数 END ------ //

        model.parseRootNode(cfg);

        scope._loadScene(loader, url, 0);
        scope._loadMpks(loader, url, mpkCount);
        scope._loadMaterial(loader, url);

        if (symbolCount > 0) {
            scope._loadSymbol(loader, url);
        }

        var matrixRoot;

        // 未定义或者1，表示数据经过变换
        if (hasTransform !== undefined && hasTransform !== 1) {
            matrixRoot = scene.getMatrixWorldGlobal();
        } else {
            matrixRoot = null;
        }

        if (octreeCount_o > 0) {
            scope._loadOctreeOuter(loader, url, matrixRoot);
        }

        if (octreeCount_i > 0) {
            scope._loadOctreeInner(loader, url, matrixRoot);
        }

        if (userIdCount > 0) {
            scope._loadUserId(loader, url);
        }

        if (userDataCount > 0) {
            scope._loadUserData(loader, url);
        }

        model.dispatchEvent({ type: CLOUD.EVENTS.ON_LOAD_CONFIG_FINISH });
    }, undefined, function () {
        console.log("config load error!");
        model.dispatchEvent({ type: CLOUD.EVENTS.ON_LOAD_INVALID_SCENE });
    });
};

CLOUD.Loader.ModelLoader.prototype.loadMpk = function (mpkId, callback) {

    var scope = this;
    var referencedMeshCache = this.model.getReferencedMeshCache();
    var loader = this.loader;
    var url = this.url;
    var mpkWorkerUrl = CLOUD.GlobalData.MpkWorkerUrl;
    var userWorker = CLOUD.GlobalData.UseMpkWorker;

    if (userWorker) {

        loader.setResponseType("arraybuffer");
        loader.load(url.mpkUrl(mpkId), function (data) {

            var worker = new Worker(mpkWorkerUrl);
            worker.onmessage = function (event) {
                //var mpkReader = event.data[0];
                //if (mpkReader.header.blockId < mpkCount) {
                //    scope.mpkArray[mpkReader.header.blockId] = mpkReader;
                //}

                var result = event.data;

                for (var key in result) {
                    if (result.hasOwnProperty(key)) {
                        referencedMeshCache[key] = result[key];
                    }
                }

                callback();

                // TODO: Notify Progress
                scope._onTaskFinished();
            };

            //worker.postMessage( {"msg": data, result:scope.result});
            worker.postMessage({ "msg": data });
        });
    } else {

        loader.setResponseType("arraybuffer");
        loader.load(url.mpkUrl(mpkId), function (data) {
            scope._parseMpk(data);
            callback();
            scope._onTaskFinished();
        });
    }
};
CLOUD.Model = function (manager, parameters) {

    this.manager = manager;
    this.databagId = parameters.databagId;
    this.loader = new CLOUD.Loader.ModelLoader(this, parameters);
    this.pool = manager.getObjectPool();

    this.renderableCount = 0;
    this.renderableTotal = CLOUD.GlobalData.maxObjectNumInPool;
    //statics data
    this.numOfElements = 0;
    this.numOfTriangles = 0;

    this.boundingBoxWorld = null;

    this.cache = {
        cells: {},
        geometries: {},
        materials: {},
        textures: {},

        vertices: [],
        indices: []
    };

    this.wireFrame = null;

    this.visibleOctant = [];

    this.occlusionVisibleOctant = [];

    this.containsCamera = false;
    this.loaded = false;
    this.visible = true;

    // cache overall referenced unique meshes
    this.referencedMeshCache = {};

    this.nodePriority = {
        high: [],
        medium: [],
        low: []
    };
};

CLOUD.Model.prototype.destroy = function () {

    this.loader.destroy();
    this.loader = null;

    this._clearNodePriority(true);
    this.nodePriority = null;

    this._clearCache();
    this.cache = null;

    this.pool = null;
    this.manager = null;

    this.visibleOctant = null;
    this.occlusionVisibleOctant = null;

    if (this.occlusionCamera) {
        this.occlusionCamera = null;
    }

    this.renderableTotal = CLOUD.GlobalData.maxObjectNumInPool;
    this.numOfElements = 0;
    this.numOfTriangles = 0;
};

CLOUD.Model.prototype._clearCache = function () {

    var cache = this.cache;
    var geometries = cache.geometries;
    var materials = cache.materials;

    var geometry, material;

    for (var id in geometries) {
        geometry = geometries[id];
        geometry.dispose();
    }

    for (id in materials) {
        material = materials[id];
        material.dispose();
    }

    cache.cells = {};
    cache.geometries = {};
    cache.materials = {};
    cache.textures = {};
};

// 支持动态控制纹理贴图
CLOUD.Model.prototype._updateTextureMapping = function () {

    var textureEnabled = CLOUD.GlobalData.EnableTextureMapping;

    if (this.lastTextureEnabled !== textureEnabled) {

        var textures = this.cache.textures;
        var materials = this.cache.materials;

        // 会影响效率
        var id;
        var material;
        if (textureEnabled) {

            for (id in materials) {

                if (materials.hasOwnProperty(id)) {

                    material = materials[id];
                    var map = textures[id];

                    // 材质贴图存在, 则更新材质贴图
                    if (map) {
                        material.map = map;
                        if (CLOUD.GlobalData.IBL) {
                            material.refreshUniforms();
                        }
                        material.needsUpdate = true; // 更新材质
                    }
                }
            }
        } else {

            for (id in materials) {

                if (materials.hasOwnProperty(id)) {

                    material = materials[id];

                    material.map = null;
                    material.needsUpdate = true; // 更新材质
                }
            }
        }

        this.lastTextureEnabled = textureEnabled;
    }
};

CLOUD.Model.prototype.getOctreeRoots = function (roots) {
    var loader = this.loader;
    var octreeRootNode = loader.getOctreeRootNodeOuter();

    if (octreeRootNode) {
        roots.push(octreeRootNode);
    }

    var octreeRootNodeI = loader.getOctreeRootNodeInner();
    if (octreeRootNodeI) {
        roots.push(octreeRootNodeI);
    }
};

CLOUD.Model.prototype._clearNodePriority = function (clearLow) {
    var nodePriority = this.nodePriority;
    nodePriority.high = [];
    nodePriority.medium = [];
    if (clearLow) {
        nodePriority.low = [];
    }
};

/**
 * 读取数据，构造mesh node
 *
 * @param {Object} reader - sceneReader or symbolReader ： 如果 itemParent === null或undefined 为sceneReader， 否则为 symbolReader
 * @param {number} cellId - 八叉树单元ID
 * @param {Object} item - 数据项
 * @param {Object} itemParent - 父节点参数项 {matrix : xxx, ItemId : xxx, originalId: xxx}
 * @param {string} categoryId - 分类编码 id
 * @param {number} cellDepth - 网格深度
 */
CLOUD.Model.prototype._readMeshInfo = function (reader, cellId, item, itemParent, categoryId, cellDepth) {

    var loader = this.loader;
    var cacheCell = this.cache.cells[cellId];
    var cacheGeometries = this.cache.geometries;
    // itemParent存在, 表示读取symbol数据
    var userDataId;
    var originalId;
    var mtlId;
    if (itemParent === null) {
        userDataId = item.userDataId;
        originalId = item.originalId;
        mtlId = item.materialId;
    } else {
        userDataId = itemParent.userDataId;
        originalId = itemParent.originalId;
        // BIMFACEDM-2599
        // symbol instance's material id: exist(>=0) or non-exist(-1)
        // if symbol instance get own material, all child element of symbol use instance'
        // material, else use child's own material
        mtlId = itemParent.materialId > -1 ? itemParent.materialId : item.materialId;
    }

    var userIdReader = loader.getUserIdReader();
    var userId = userIdReader ? userIdReader.getString(originalId) : originalId;

    var meshInfo = null;

    if (item.type === 1) {
        meshInfo = this._getMeshNodeAttribute(reader, item, itemParent);
    } else if (item.type === 2) {
        meshInfo = this._getMeshNodeAttrOfTube(cacheGeometries, reader, item, itemParent);
    } else if (item.type === 3) {
        meshInfo = this._getMeshNodeAttrOfPipe(cacheGeometries, reader, item, itemParent);
    } else if (item.type === 4) {
        meshInfo = this._getMeshNodeAttrOfBox(cacheGeometries, reader, item, itemParent);
    }

    if (!meshInfo) {
        return;
    }

    var nodeId = meshInfo.nodeId;

    var userDataReader = loader.getUserDataReader();
    var userData = userDataReader ? userDataReader.getUserData(userDataId) : null;
    var matrixCache = meshInfo.matrix.clone();

    var nodeInfo = {
        nodeId: nodeId,
        name: userId,
        userData: userData,
        meshId: meshInfo.meshId,
        matrix: matrixCache,
        materialId: mtlId,
        categoryId: categoryId,
        cellDepth: cellDepth
    };

    cacheCell.push(nodeInfo);
    meshInfo = null;
};

CLOUD.Model.prototype._readSymbolInfo = function (id, cellId, itemParent, categoryId, cellDepth) {

    var symbolReader = this.loader.getSymbolReader();

    if (!symbolReader) {
        return;
    }

    var symbolCount = symbolReader.header.symbolCount;

    if (id >= 0 && id < symbolCount) {
        var symbolCurrent = symbolReader.getSymbolInfo(id);

        for (var i = symbolCurrent.itemIndex; i < symbolCurrent.itemCount; ++i) {
            var item = symbolReader.getItemInfo(i);

            if (item.type === 0) {
                continue;
            }

            this._readMeshInfo(symbolReader, cellId, item, itemParent, categoryId, cellDepth);
        }
    }
};

CLOUD.Model.prototype._getMeshNodeAttribute = function (sceneOrSymbolReader, item, itemParent) {

    var matrix = sceneOrSymbolReader.getMatrixInfo(item.matrixId).matrix.clone();
    var nodeId = itemParent ? itemParent.ItemId + "_" + item.ItemId : item.ItemId;
    var meshId = item.toData;

    var refMeshCache = this.referencedMeshCache;
    var meshData = refMeshCache[meshId].M;

    if (meshData === undefined) {
        CLOUD.Logger.log("No mesh information.");
        return null;
    }

    var cacheGeometries = this.cache.geometries;
    var geometry = cacheGeometries[meshId];
    if (!geometry) {

        var positions = refMeshCache[meshId].P;
        var index = refMeshCache[meshId].I;
        var normal = refMeshCache[meshId].N;
        var uv = refMeshCache[meshId].UV;

        // if (positions == undefined || index == undefined) {
        //     CLOUD.Logger.log("empty mesh data");
        //     return null;
        // }

        geometry = new THREE.BufferGeometry();
        geometry.setIndex(new THREE.BufferAttribute(index, 1));
        geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));

        if (normal) {
            geometry.addAttribute('normal', new THREE.BufferAttribute(normal, 3));
        }

        if (uv) {
            geometry.addAttribute('uv', new THREE.BufferAttribute(uv, 2));
        }

        // geometry.computeVertexNormals(); // 计算法线，影响光照
        cacheGeometries[meshId] = geometry;
    }

    var matrixTmp = new THREE.Matrix4();
    matrixTmp.setPosition(new THREE.Vector3(meshData.baseX, meshData.baseY, meshData.baseZ));
    matrixTmp.scale(new THREE.Vector3(meshData.baseScale, meshData.baseScale, meshData.baseScale));

    if (meshData.baseScale !== 0.0) {
        matrix.multiply(matrixTmp);
    }

    if (itemParent) {
        matrix.multiplyMatrices(itemParent.matrix, matrix);
    }

    //meshData = null;
    //meshAttr = null;
    matrixTmp = null;

    return { nodeId: nodeId, meshId: meshId, matrix: matrix };
};

CLOUD.Model.prototype._getMeshNodeAttrOfTube = function (cacheGeometries, sceneOrSymbolReader, item, itemParent) {

    var geomAttr = sceneOrSymbolReader.getGeomPipeInfo(item.toData);
    var matrix = sceneOrSymbolReader.getMatrixInfo(item.matrixId).matrix.clone();
    var nodeId = itemParent ? itemParent.ItemId + "_" + item.ItemId : item.ItemId;
    var meshId = "tube";
    var geometry = cacheGeometries[meshId];

    if (!geometry) {
        geometry = CLOUD.GeomUtil.UnitCylinderInstance;
        cacheGeometries[meshId] = geometry;
    }

    var startPt = geomAttr.startPt;
    var endPt = geomAttr.endPt;

    var dir = new THREE.Vector3();
    dir.subVectors(endPt, startPt);

    var len = dir.length();
    dir.normalize();

    var radius = geomAttr.radius;
    if (radius <= 1) {
        radius = 100;
    }

    var unitY = new THREE.Vector3(0, 1, 0);
    var scale = new THREE.Vector3(radius, len, radius);
    var quaternion = new THREE.Quaternion().setFromUnitVectors(unitY, dir);
    var position = startPt.clone().addScaledVector(dir, len * 0.5);

    var matrixTmp = new THREE.Matrix4().compose(position, quaternion, scale);
    matrix.multiply(matrixTmp);

    if (itemParent) {
        matrix.multiplyMatrices(itemParent.matrix, matrix);
    }

    geomAttr = null;

    return { nodeId: nodeId, meshId: meshId, matrix: matrix };
};

CLOUD.Model.prototype._getMeshNodeAttrOfPipe = function (cacheGeometries, sceneOrSymbolReader, item, itemParent) {

    var geomAttr = sceneOrSymbolReader.getGeomPipeInfo(item.toData);
    var matrix = sceneOrSymbolReader.getMatrixInfo(item.matrixId).matrix.clone();
    var nodeId = itemParent ? itemParent.ItemId + "_" + item.ItemId : item.ItemId;
    var meshId = "pipe";
    var geometry = cacheGeometries[meshId];

    if (!geometry) {
        geometry = CLOUD.GeomUtil.UnitCylinderInstance;
        cacheGeometries[meshId] = geometry;
    }

    var startPt = geomAttr.startPt;
    var endPt = geomAttr.endPt;

    var dir = new THREE.Vector3();
    dir.subVectors(endPt, startPt);

    var len = dir.length();
    dir.normalize();

    var radius = geomAttr.radius;
    if (radius <= 1) {
        radius = 100;
    }

    var unitY = new THREE.Vector3(0, 1, 0);
    var scale = new THREE.Vector3(radius, len, radius);
    var quaternion = new THREE.Quaternion().setFromUnitVectors(unitY, dir);
    var position = startPt.clone().addScaledVector(dir, len * 0.5);

    var matrixTmp = new THREE.Matrix4().compose(position, quaternion, scale);
    matrix.multiply(matrixTmp);

    if (itemParent) {
        matrix.multiplyMatrices(itemParent.matrix, matrix);
    }

    geomAttr = null;

    return { nodeId: nodeId, meshId: meshId, matrix: matrix };
};

CLOUD.Model.prototype._getMeshNodeAttrOfBox = function (cacheGeometries, sceneOrSymbolReader, item, itemParent) {
    var matrix = sceneOrSymbolReader.getMatrixInfo(item.matrixId).matrix.clone();
    var bBox = item.boundingBox;
    var boxSize = bBox.getSize();
    var boxCenter = bBox.getCenter();
    var nodeId = itemParent ? itemParent.ItemId + "_" + item.ItemId : item.ItemId;
    var meshId = "box";
    var geometry = cacheGeometries[meshId];

    if (!geometry) {
        geometry = CLOUD.GeomUtil.UnitBoxInstance;
        cacheGeometries[meshId] = geometry;
    }

    var matrixTmp = new THREE.Matrix4().scale(new THREE.Vector3(boxSize.x, boxSize.y, boxSize.z));
    matrixTmp.setPosition(boxCenter);
    matrix.multiply(matrixTmp);

    if (itemParent) {
        matrix.multiplyMatrices(itemParent.matrix, matrix);
    }

    var vertices = CLOUD.GeomUtil.UnitBoxInstance.getAttribute('position');
    var array = vertices.array;
    var vertex = new THREE.Vector3();
    for (var i = 0; i < vertices.count; ++i) {

        vertex.set(array[i * 3], array[i * 3 + 1], array[i * 3 + 2]);
        vertex.applyMatrix4(matrix);
        this.cache.vertices.push(vertex.x, vertex.y, vertex.z);
    }

    var length = this.cache.indices.length / 2;
    for (var j = 0; j < 6; ++j) {

        this.cache.indices.push(j * 4 + length, j * 4 + 1 + length);
        this.cache.indices.push(j * 4 + 1 + length, j * 4 + 3 + length);
        this.cache.indices.push(j * 4 + 3 + length, j * 4 + 2 + length);
        this.cache.indices.push(j * 4 + 2 + length, j * 4 + length);
    }

    return { nodeId: nodeId, meshId: meshId, matrix: matrix };
};

CLOUD.Model.prototype._overrideOcclusionMaterial = function (meshNode) {

    var material = meshNode.material;

    if (material) {

        // 只处理不透明的构件
        if (material.transparent === false) {

            var materialEx = this.manager.acquireMaterial();
            var newMaterial = materialEx.material;

            if (material.color) {
                newMaterial.color.copy(material.color);
            } else {
                materialEx.resetColor();
            }

            newMaterial.opacity = CLOUD.GlobalData.OcclusionOpacity;
            meshNode.material = newMaterial;
            meshNode.material.needsUpdate = true;
        }
    }
};

/**
 * 遮挡测试
 *
 */
CLOUD.Model.prototype._occlusionTest = function () {

    if (CLOUD.GlobalData.OcclusionTranslucentEnabled) {

        var meshes = this.pool.getObjects();
        var objectMap = this.manager.octantToObjectMap;
        var octantLen = this.occlusionVisibleOctant.length;

        if (octantLen > 0) {

            var frustum = this.manager.getFrustumFromOcclusionCamera();

            for (var i = 0; i < octantLen; ++i) {

                var cellId = this.occlusionVisibleOctant[i].octantId;
                var indexes = objectMap[cellId];

                if (indexes && indexes.length > 0) {

                    for (j = 0; j < indexes.length; j += 2) {
                        for (var k = indexes[j]; k <= indexes[j + 1]; k++) {

                            var meshNode = meshes[k];

                            if (CLOUD.CameraUtil.intersectObjectWithFrustum(meshNode, frustum)) {

                                this._overrideOcclusionMaterial(meshNode);
                            }
                        }
                    }
                }
            }
        }
    }
};

CLOUD.Model.prototype._sortVisibleOctant = function (camera) {

    var scope = this;

    var ancestorAndNeighbors = null;
    if (scope.containsCamera && scope.loader.octreeRootNodeI != null) {
        var octUtil = new CLOUD.OctantNeighborUtil(camera, scope.loader.octreeRootNodeI);
        ancestorAndNeighbors = octUtil.getAncestorAndNeighbors();
    }

    this.visibleOctant.sort(function (a, b) {
        if (ancestorAndNeighbors != null) {
            if (ancestorAndNeighbors[a.octantId] != undefined) {
                return -1;
            }

            if (ancestorAndNeighbors[b.octantId] != undefined) {
                return 1;
            }
        }
        if (a.priority > b.priority) {
            //  sort a to a lower index than b, i.e. a comes first.
            return -1;
        } else if (a.priority < b.priority) {
            return 1;
        }
        // same priority
        return 0;
    });
};

CLOUD.Model.prototype._readItemData = function (sceneReader, idx, cellId, categoryId, cellDepth) {

    var item = sceneReader.getItemInfo(idx);

    if (item === undefined) {
        return;
    }

    if (item.type === 0) {

        var matrixParent = sceneReader.getMatrixInfo(item.matrixId).matrix.clone();
        var itemParent = {
            matrix: matrixParent,
            ItemId: item.ItemId,
            originalId: item.originalId,
            userDataId: item.userDataId,
            materialId: item.materialId
        };

        this._readSymbolInfo(item.toData, cellId, itemParent, categoryId, cellDepth);
        itemParent = null;
    } else {

        this._readMeshInfo(sceneReader, cellId, item, null, categoryId, cellDepth);
    }
};

CLOUD.Model.prototype._updateMeshNodes = function (totalNodeCount) {

    var pool = this.pool;
    var manager = this.manager;
    var filter = manager.filter;
    var bagId = this.databagId;

    var cache = this.cache;
    var cacheGeometries = cache.geometries;
    var cacheMaterials = cache.materials;

    var nodePriority = this.nodePriority;
    var priorityNodesSet = [nodePriority.high, nodePriority.medium, nodePriority.low];

    var matrix = new THREE.Matrix4();

    var hasLowPriorityOverride = filter._hasLowPriorityOverride();

    var counter = 0;

    var octantStartIndex = -1;
    var curOctantId = -1;
    for (var j = 0, count = priorityNodesSet.length; j < count; ++j) {

        var priorityNodes = priorityNodesSet[j];

        for (var i = 0, len = priorityNodes.length; i < len; ++i) {

            ++counter;

            if (counter > totalNodeCount) {
                break;
            }

            var cacheNode = priorityNodes[i];
            var nodeId = cacheNode.nodeId;
            var userId = cacheNode.name;
            var userData = cacheNode.userData;
            var meshId = cacheNode.meshId;
            matrix = cacheNode.matrix;

            var geometry = cacheGeometries[meshId];
            var materialId = cacheNode.materialId;

            // 材质过滤
            var material = null;
            if (hasLowPriorityOverride || j === 0) {
                material = filter._getOverrideMaterial(cacheNode);
            }
            material = material || cacheMaterials[materialId];

            var parameters = {
                databagId: bagId,
                nodeId: nodeId,
                userId: userId,
                userData: userData,
                geometry: geometry,
                matrix: matrix,
                material: material,
                renderOrder: CLOUD.GlobalData.MaximumDepth - cacheNode.cellDepth
            };

            var index = pool.get(parameters);
            if (index >= 0) {
                if (curOctantId !== cacheNode.octantId) {
                    if (index > 0) {
                        manager.addObjectRangeToOctantMap(curOctantId, octantStartIndex, index - 1);
                    }

                    octantStartIndex = index;
                    curOctantId = cacheNode.octantId;
                }
            }
            parameters = null;
        }
    }

    // add map for the last octant
    if (octantStartIndex !== -1) {
        manager.addObjectRangeToOctantMap(curOctantId, octantStartIndex, pool.counter - 1);
    }

    priorityNodesSet = null;
};

CLOUD.Model.prototype.load = function (notifyProgress) {
    this.loader.load(notifyProgress);
};

CLOUD.Model.prototype.setCrossOrigin = function (crossOrigin) {
    this.loader.setCrossOrigin(crossOrigin);
};

CLOUD.Model.prototype.setupWireframe = function () {
    if (CLOUD.GlobalData.WireFrame && this.wireFrame == null) {

        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute('position', new THREE.Float32BufferAttribute(this.cache.vertices, 3));
        geometry.setIndex(this.cache.indices);

        var material = new THREE.LineBasicMaterial({
            color: 0x000000,
            linewidth: 2
        });

        var lineMesh = new THREE.LineSegments(geometry, material);
        lineMesh.name = "Wireframes";
        lineMesh.customTag = true;
        lineMesh.frustumCulled = false;

        this.manager.scene.add(lineMesh);

        lineMesh.matrixWorld = this.manager.scene.rootNode.matrixWorld.clone();

        this.wireFrame = lineMesh;

        this.manager.scene.add(this.wireFrame);
    } else if (!CLOUD.GlobalData.WireFrame && this.wireFrame != null) {

        this.manager.scene.remove(this.wireFrame);
        this.wireFrame = null;
    }
};

CLOUD.Model.prototype.prepare = function (camera) {

    var sceneReaderArray = this.loader.getSceneReaderArray();
    var sceneCount = sceneReaderArray ? sceneReaderArray.length : 0;

    if (sceneCount < 1) {
        CLOUD.Logger.log("model load not started!");
        return;
    }

    // VAAS-100: Mesh and Other resource loading does not sync with reading process,
    // here do scene prepare after all of them loaded.
    // TODO: on-demand loading resource like mesh package, scene and material etc.
    if (!this.loaded) {
        console.log("model is not loaded!");
        return;
    }

    var sceneReader = sceneReaderArray[0];

    if (!sceneReader) {
        CLOUD.Logger.log("Empty scene");
        return;
    }

    CLOUD.Logger.time("prepareScene");
    // 清除优先级集合
    this._clearNodePriority(false);
    if (this.nodePriority.low.length === 0) {
        this.nodePriority.low.length = this.renderableCount;
    }
    var prioritizedNodeCount = 0;
    var currentLowNodeCount = 0;
    var cellCount = 0;
    var enableOctant = CLOUD.GlobalData.EnableOctant;
    if (enableOctant) {

        var indoor = this.containsCamera;
        if (indoor) {
            //reset octant array before next culling
            this.visibleOctant.length = 0;

            //indoor: spatial first [ keep legacy way: (1) frustum culling on indoor and outdoor (2) logic culling]
            var octreeRootI = this.loader.getOctreeRootNodeInner();
            if (octreeRootI !== undefined) {

                this._frustumCull(camera, octreeRootI, indoor);
            }

            var octreeRootNodeO = this.loader.getOctreeRootNodeOuter();
            if (octreeRootNodeO !== undefined) {

                this._frustumCull(camera, octreeRootNodeO, !indoor);
            }
            cellCount = this.visibleOctant.length;
            if (cellCount > 0) {

                this._sortVisibleOctant(camera);
                currentLowNodeCount = this._logicCull(sceneReader, indoor, currentLowNodeCount, cellCount);
            }
        } else {

            // outdoor first [ (1) frustum culling  followed by logic culling on outdoor (2) same way on indoor]
            var octreeRootNodeO = this.loader.getOctreeRootNodeOuter();
            if (octreeRootNodeO !== undefined) {

                //reset octant array before next culling
                this.visibleOctant.length = 0;
                this._frustumCull(camera, octreeRootNodeO, !indoor);
                cellCount = this.visibleOctant.length;
                if (cellCount > 0) {

                    this._sortVisibleOctant(camera);
                    currentLowNodeCount = this._logicCull(sceneReader, !indoor, currentLowNodeCount, cellCount);
                }
            }
            prioritizedNodeCount = currentLowNodeCount + this.nodePriority.high.length + this.nodePriority.medium.length;

            // then indoor
            CLOUD.Logger.log("mesh count outdoor:", prioritizedNodeCount);
            if (prioritizedNodeCount < this.renderableCount) {

                var octreeRootI = this.loader.getOctreeRootNodeInner();
                if (octreeRootI !== undefined) {
                    //reset octant array before next culling
                    this.visibleOctant.length = 0;
                    this._frustumCull(camera, octreeRootI, indoor, currentLowNodeCount);
                    cellCount = this.visibleOctant.length;
                    if (cellCount > 0) {

                        this._sortVisibleOctant(camera);
                        currentLowNodeCount = this._logicCull(sceneReader, indoor, currentLowNodeCount, cellCount);
                    }
                }
            }
        }
    } else {
        // read scene without space partition
        cellCount = sceneReader.header.cellCount;
        if (cellCount === 0) {
            return;
        }
        currentLowNodeCount = this._logicCull(sceneReader, true, currentLowNodeCount, cellCount);
    }
    prioritizedNodeCount = currentLowNodeCount + this.nodePriority.high.length + this.nodePriority.medium.length;

    this._updateTextureMapping();

    CLOUD.Logger.time("updateMeshNodes");
    if (prioritizedNodeCount > this.renderableCount) {
        prioritizedNodeCount = this.renderableCount;
    }
    this._updateMeshNodes(prioritizedNodeCount);
    CLOUD.Logger.timeEnd("updateMeshNodes");

    this.setupWireframe();

    this._occlusionTest();

    CLOUD.Logger.log("mesh count:", this.pool.counter, prioritizedNodeCount);
    CLOUD.Logger.timeEnd("prepareScene");
};

CLOUD.Model.prototype._frustumCull = function (camera, rootOctant, indoor) {

    if (!rootOctant) {
        CLOUD.Logger.log("octree load is not finish!");
        return false;
    }
    var scope = this;
    var manager = this.manager;
    manager.updateOctreeBox(rootOctant);

    var viewProjectionMatrix = camera.projScreenMatrix;
    var octantBox = new THREE.Box3();

    function intersectFrustum(root, frustum, depth) {

        var intersects;
        var node;

        if (frustum && root.depth < depth) {
            octantBox.set(root.min, root.max);
            intersects = frustum.intersectsBox(octantBox);
        }
        // if intersects
        if (intersects === true) {

            var screenBound = octantBox.applyMatrix4(viewProjectionMatrix);
            var screenSize = screenBound.getSize().length();

            // depth could less than 0, that's invalid. So we give an epsilon (0.000001).
            var nearDepth = screenBound.getCenter().z;
            nearDepth = nearDepth > 0.000001 ? nearDepth : 0.000001;
            root.priority = screenSize / nearDepth;

            // gather objects
            scope.visibleOctant.push(root);

            // search subtree
            for (var i = 0, length = root.childOctants.length; i < length; ++i) {

                node = root.childOctants[i];
                intersectFrustum(node, frustum, depth);
            }
        }
    }

    function intersectOcclusionFrustum(root, frustum, depth) {

        // test intersects
        var intersects;
        var node;

        if (frustum && root.depth < depth) {
            octantBox.set(root.min, root.max);
            intersects = frustum.intersectsBox(octantBox);
        }
        // if intersects
        if (intersects === true) {
            // gather objects
            scope.occlusionVisibleOctant.push(root);

            // search subtree
            for (var i = 0, length = root.childOctants.length; i < length; ++i) {

                node = root.childOctants[i];
                intersectOcclusionFrustum(node, frustum, depth);
            }
        }
    }

    // 'getFrustum' will updateMVP by default. Because MVP was not update in 'CameraControl::update'
    var frustum = camera.getFrustum(false);
    var depth = CLOUD.GlobalData.OctantDepth; // traverse till depth arrived.

    // -------------------- 遮挡视锥 -------------------- //

    var occlusionFrustum = null;
    var occlusionTranslucentEnabled = CLOUD.GlobalData.OcclusionTranslucentEnabled;

    if (occlusionTranslucentEnabled) {
        occlusionFrustum = this.manager.getFrustumFromOcclusionCamera();
    }

    this.occlusionVisibleOctant.length = 0;

    // ---------------------------------------------------- //

    if (rootOctant !== null) {
        intersectFrustum(rootOctant, frustum, depth);

        if (occlusionTranslucentEnabled) {
            intersectOcclusionFrustum(rootOctant, occlusionFrustum, depth);
        }
    }

    //CLOUD.Logger.log("Total Visible Octant Count: ", this.visibleOctant.length);

    return true;
};

CLOUD.Model.prototype._logicCull = function (sceneReader, indoor, curLowNodeCount, cellCount) {

    var manager = this.manager;

    var filter = manager.filter;

    var hasHiddenFileIdFilter = filter._hasHiddenFileIdFilter();
    var hasVisibleFilter = filter._hasVisibleFilter();
    var hasOverrideFilter = filter._hasOverrideMaterialFilter();

    var cacheCells = this.cache.cells;

    var nodePriorityHigh = this.nodePriority.high;
    var nodePriorityMedium = this.nodePriority.medium;
    var nodePriorityLow = this.nodePriority.low;
    var maxLowNodeCount = this.nodePriority.low.length;

    function collectNodeInfo(nodeInfo, priorityCategories) {

        var userData = nodeInfo.userData;
        var categoryId = userData ? userData.categoryId : undefined;

        var mediumPriority = false;

        // 文件过滤
        if (hasHiddenFileIdFilter && filter._isHiddenFileId(nodeInfo)) {
            return;
        }

        // 可见性过滤
        if (hasVisibleFilter && filter._isVisible(nodeInfo) === false) {
            return;
        }

        // 材质过滤
        var isHighlight = hasOverrideFilter && filter._hasHighPriorityOverrideMaterial(nodeInfo);

        if (priorityCategories && categoryId && priorityCategories[categoryId]) {
            mediumPriority = true;
        }

        if (isHighlight) {
            nodePriorityHigh.push(nodeInfo);
        } else if (mediumPriority) {
            nodePriorityMedium.push(nodeInfo);
        } else if (curLowNodeCount < maxLowNodeCount) {
            nodePriorityLow[curLowNodeCount] = nodeInfo;
            curLowNodeCount++;
        }
    }

    CLOUD.Logger.time("collectNodeInfo");

    var priorityCategories = manager.getCategoriesFromHighPriority("outer");
    if (indoor === true) {
        priorityCategories = manager.getCategoriesFromHighPriority("inner");
    }

    var enableOctant = CLOUD.GlobalData.EnableOctant;
    var j,
        len = 0;
    for (var i = 0; i < cellCount; ++i) {

        var cellId,
            cellDepth = 0;

        if (enableOctant) {
            cellId = this.visibleOctant[i].octantId;
            cellDepth = this.visibleOctant[i].depth;
        } else {
            cellId = i;
        }

        var cacheCell = cacheCells[cellId];

        if (cacheCell === undefined) {

            // 缓存node数据
            cacheCell = cacheCells[cellId] = [];

            var cell = sceneReader.getCellInfo(cellId);

            for (j = cell.itemIndex; j < cell.itemCount; ++j) {
                this._readItemData(sceneReader, j, cellId, undefined, cellDepth);
            }

            for (j = 0, len = cacheCell.length; j < len; ++j) {
                cacheCell[j].octantId = cellId;
            }
        }

        for (j = 0, len = cacheCell.length; j < len; ++j) {
            collectNodeInfo(cacheCell[j], priorityCategories);
        }
    }
    CLOUD.Logger.timeEnd("collectNodeInfo");
    return curLowNodeCount;
};

CLOUD.Model.prototype.clearCells = function () {
    this.cache.cells = {};
};

CLOUD.Model.prototype.dispatchEvent = function (event) {
    this.manager.dispatchEvent(event);
};

CLOUD.Model.prototype.parseRootNode = function (json) {

    var dataView = json.view;

    //
    if (json.count !== undefined) {

        if (json.count.mesh_face !== undefined) {
            this.numOfTriangles += json.count.mesh_face;
        }

        this.renderableTotal = 0;
        if (json.count.geom_box !== undefined && json.count.geom_pipe !== undefined && json.count.geom_tube !== undefined && json.count.mesh !== undefined) {

            this.renderableTotal += json.count.geom_box;
            this.renderableTotal += json.count.geom_pipe;
            this.renderableTotal += json.count.geom_tube;
            this.renderableTotal += json.count.mesh;

            this.numOfTriangles += json.count.geom_box * 12; // BoxBufferGeometry
            this.numOfTriangles += json.count.geom_pipe * 32; // CylinderBufferGeometry
            this.numOfTriangles += json.count.geom_tube * 32; // CylinderBufferGeometry
        } else if (json.count.geom !== undefined && json.count.mesh !== undefined) {

            this.renderableTotal += json.count.geom;
            this.renderableTotal += json.count.mesh;

            // Pipe and box is not notified in legacy data, so we use box as a estimated statics which is less than
            // real number of triangles..
            this.numOfTriangles += json.count.geom * 12; // BoxBufferGeometry

            // Legacy data does not contain the number of elements, we use the data of render primitives.
            this.numOfElements = this.renderableTotal;
        }

        if (json.count.item !== undefined) {
            this.numOfElements = json.count.item;
        }
    }

    this.boundingBoxWorld = CLOUD.Utils.box3FromArray(dataView.bbox);

    this.manager.parseSceneRootNode(json);
};

CLOUD.Model.prototype.getTextures = function () {
    return this.cache.textures;
};

CLOUD.Model.prototype.getMaterials = function () {
    return this.cache.materials;
};

CLOUD.Model.prototype.updateMaterials = function () {

    var materials = this.cache.materials;
    for (var id in materials) {
        if (materials.hasOwnProperty(id)) {
            var material = materials[id];
            material.iblProbe = this.manager.scene.iblProbe;
            material.refreshUniforms();
        }
    }
};

CLOUD.Model.prototype.updateMaterialsValue = function (type, value) {

    var materials = this.cache.materials;
    for (var id in materials) {
        if (materials.hasOwnProperty(id)) {
            var material = materials[id];
            if (material.hasOwnProperty(type)) {
                material[type] = value;
                material.refreshUniforms();
                material.needsUpdate = true;
            }
        }
    }
};

CLOUD.Model.prototype.changeAllMaterials = function (isIBL) {

    var materials = this.cache.materials;
    for (var id in materials) {
        if (materials.hasOwnProperty(id)) {
            var material = materials[id];
            var materialParameters = CLOUD.MaterialUtil.getMaterialParameters(material);
            var newMaterials;
            if (isIBL) {
                newMaterials = new ImageBasedLighting.IBLMaterial(materialParameters);
                newMaterials.type = 'IBL';
            } else {
                delete materialParameters.iblProbe;
                newMaterials = CLOUD.MaterialUtil.createPhongMaterial(materialParameters);
            }

            newMaterials.name = id;
            materials[id] = newMaterials;
            materialParameters = null;
        }
    }
};

CLOUD.Model.prototype.getReferencedMeshCache = function () {
    return this.referencedMeshCache;
};

CLOUD.Model.prototype.isLoaded = function () {
    return this.loaded;
};

CLOUD.Model.prototype.isVisible = function () {
    return this.visible;
};

CLOUD.Model.prototype.setVisible = function (visible) {
    this.visible = visible;
};

CLOUD.Model.prototype.calculateCameraModelRelation = function (cameraPos) {

    var octreeRootNodeInner = this.loader.getOctreeRootNodeInner();

    if (!octreeRootNodeInner) {
        return;
    }

    if (cameraPos.x < octreeRootNodeInner.min.x || cameraPos.x > octreeRootNodeInner.max.x || cameraPos.y < octreeRootNodeInner.min.y || cameraPos.y > octreeRootNodeInner.max.y || cameraPos.z < octreeRootNodeInner.min.z || cameraPos.z > octreeRootNodeInner.max.z) {
        // camera is outside of model's bound box
        this.containsCamera = false;
    } else {
        this.containsCamera = true;
    }
};

CLOUD.Model.prototype.getBoundingBoxWorld = function () {

    return this.boundingBoxWorld;
};

CLOUD.Model.prototype.getRenderableTotal = function () {

    return this.renderableTotal;
};

CLOUD.Model.prototype.setRenderableCount = function (count) {

    this.renderableCount = count;
};

/**
 * 模型管理类
 *
 * @class  CLOUD.ModelManager
 *
 */
CLOUD.ModelManager = function (filter) {

    // 考虑改进：GlobalData 中变量兼容多模型情况，需要在meshpool策略综合考虑
    // 默认为PC配置，假如应用层明确了是移动端，则配置为移动端
    // CLOUD.GlobalData.IsMobile 交由应用层设置
    if (CLOUD.GlobalData.IsMobile) {
        CLOUD.GlobalData.maxObjectNumInPool = 6000;
        CLOUD.GlobalData.maxDrawCacheNum = 4000;
    }
    this.scene = new CLOUD.Scene();
    this.crossOrigin = true;
    this.models = {};
    this.filter = filter;

    this.materialPool = new CLOUD.ExpandableObjectPool();
    this.materialPool.init(CLOUD.MaterialEx, 50);

    this.occlusionCamera = null; // 遮挡裁剪相机

    // Does camera locate inside the scene bound scope
    this.containsCamera = false;

    this.highPriorityCategories = { inner: {}, outer: {} };
    this.octantToObjectMap = {};

    this.sceneState = new CLOUD.SceneStateHelper(this, filter);
};

CLOUD.ModelManager.prototype.destroy = function () {

    for (var name in this.models) {
        this.models[name].destroy();
    }

    this.models = null;

    this.octantToObjectMap = null;

    this.scene.destroy();
    this.scene = null;

    this.materialPool.destroy();
    this.materialPool = null;

    if (this.occlusionCamera) {
        this.occlusionCamera = null;
    }
};

/**
 * 更新用于处理遮挡构件的相机状态
 *
 * @param {Object} camera - 场景相机
 * @private
 */
CLOUD.ModelManager.prototype._updateOcclusionCamera = function (camera) {

    var near = camera.near,
        far = camera.distanceFromWorldToDrawing(this.getMatrixWorldGlobal(), CLOUD.GlobalData.OcclusionDistanceToCamera);

    if (this.occlusionCamera) {
        this.occlusionCamera.copy(camera);
    } else {
        this.occlusionCamera = camera.clone();
    }

    this.occlusionCamera.setNearFar(near, far);
    this.occlusionCamera.updateMVP();
};

/**
 * 清除材质状态(仅仅将计数器置为1)
 *
 * @private
 */
CLOUD.ModelManager.prototype._clearMaterialPool = function () {

    this.materialPool.clear();
};

/**
 * 从对象池中取出可以使用的对象
 *
 * @return {Object} 对象池中的一个对象
 */
CLOUD.ModelManager.prototype.acquireMaterial = function () {

    return this.materialPool.acquire();
};

CLOUD.ModelManager.prototype.getObjectPool = function () {
    return this.scene.getObjectPool();
};

/**
 * 获得遮挡相机视锥
 *
 * @return {Object} 遮挡相机视锥
 */
CLOUD.ModelManager.prototype.getFrustumFromOcclusionCamera = function () {
    return this.occlusionCamera.getFrustum(false);
};

/**
 * 获得遮挡相机
 *
 * @return {Object} 遮挡相机
 */
CLOUD.ModelManager.prototype.getOcclusionCamera = function () {
    return this.occlusionCamera;
};

// add index of mesh object to the map, key is id of octant which contains the mesh.
// objIndex: object index in object pool
CLOUD.ModelManager.prototype.addObjectRangeToOctantMap = function (octantId, startIndex, endIndex) {
    var map = this.octantToObjectMap;

    if (map[octantId] === undefined) {
        map[octantId] = [];
    }

    map[octantId].push(startIndex);
    map[octantId].push(endIndex);
};

CLOUD.ModelManager.prototype.getOctreeRoots = function () {
    var roots = [];
    var models = this.models;
    for (var id in models) {
        if (models.hasOwnProperty(id)) {
            var model = models[id];
            if (model.isLoaded()) {
                model.getOctreeRoots(roots);
            }
        }
    }

    return roots;
};

CLOUD.ModelManager.prototype.prepareScene = function (camera) {

    var models = this.models;

    this.clearPool();
    this.octantToObjectMap = {};

    if (CLOUD.GlobalData.OcclusionTranslucentEnabled) {
        this._clearMaterialPool();
        this._updateOcclusionCamera(camera);
    }

    for (var id in models) {

        if (models.hasOwnProperty(id)) {

            var model = models[id];

            if (model.isLoaded() && model.isVisible()) {
                model.prepare(camera);
            }
        }
    }
};

/**
 * 清除对象池
 *
 */
CLOUD.ModelManager.prototype.clearPool = function () {

    this.scene.getObjectPool().clear();
};

/**
 * 加载模型
 *
 * @param {object} parameters - 加载配置项,包含 databagId, serverUrl, debug
 */
CLOUD.ModelManager.prototype.load = function (parameters) {

    // get from cache
    var model = this.models[parameters.databagId];

    if (model === undefined) {

        model = new CLOUD.Model(this, parameters);
        this.models[parameters.databagId] = model;
    } else {

        // 如果模型被隐藏了，重新加载显示模型
        if (!model.isVisible()) {

            model.setVisible(true);
            // 通知加载完成
            model.dispatchEvent({ type: CLOUD.EVENTS.ON_LOAD_COMPLETE });
        }

        return model;
    }

    model.load(parameters.notifyProgress);

    return model;
};

/**
 * 卸载模型
 *
 * @param {string} databagId - 数据包名
 */
CLOUD.ModelManager.prototype.unload = function (databagId) {

    // get from cache
    var model = this.models[databagId];

    if (model) {

        model.destroy();
        delete this.models[databagId];

        this.updateSceneBoundingBox();
        this.updateModelRenderable();

        return true;
    }

    return false;
};

/**
 * 卸载所有模型
 *
 */
CLOUD.ModelManager.prototype.unloadAll = function () {
    var ids = this.getDataBagIds();

    for (var i = 0, len = ids.length; i < len; ++i) {
        this.unload(ids[i]);
    }

    this.clearPool();

    this.models = {};
};

/**
 * 显示指定模型
 *
 * @param {String} databagId - 模型数据包名
 * @return {Boolean} true：模型存在，否则模型不存在
 */
CLOUD.ModelManager.prototype.showModel = function (databagId) {

    var model = this.models[databagId];

    if (model) {

        model.setVisible(true);

        return true;
    }

    return false;
};

/**
 * 隐藏指定模型
 *
 * @param {String} databagId - 模型数据包名
 * @return {Boolean} true：模型存在，否则模型不存在
 */
CLOUD.ModelManager.prototype.hideModel = function (databagId) {

    var model = this.models[databagId];

    if (model) {

        model.setVisible(false);

        return true;
    }

    return false;
};

/**
 * 获得所有模型包名
 *
 */
CLOUD.ModelManager.prototype.getDataBagIds = function () {

    var models = this.models;
    var ids = [];

    for (var id in models) {

        if (models.hasOwnProperty(id)) {

            ids.push(id);
        }
    }

    return ids;
};

/**
 * 更新场景包围盒
 *
 */
CLOUD.ModelManager.prototype.updateSceneBoundingBox = function () {

    var models = this.models;
    var boundingBox = new THREE.Box3();

    for (var id in models) {

        if (models.hasOwnProperty(id)) {

            var model = models[id];

            var boundingBoxTmp = model.getBoundingBoxWorld();

            if (boundingBox.isEmpty()) {

                boundingBox.copy(boundingBoxTmp);
            } else {

                boundingBox.expandByPoint(boundingBoxTmp.min);
                boundingBox.expandByPoint(boundingBoxTmp.max);
            }
        }
    }

    this.scene.setBoundingBoxWorld(boundingBox);
};

/**
 * 解析场景根节点
 *
 */
CLOUD.ModelManager.prototype.parseSceneRootNode = function (json) {

    this.scene.parseRootNode(json);
    // this.updateSceneBoundingBox();
    this.updateModelRenderable();
};

/**
 * 更新模型可以进入对象池的数目, 暂时采用模型构件数的比例进行分配的策略
 *
 */
CLOUD.ModelManager.prototype.updateModelRenderable = function () {

    var models = this.models;
    var poolSize = CLOUD.GlobalData.maxObjectNumInPool;
    var ids = [];
    var renderableTotal = 0;

    for (var id in models) {

        if (models.hasOwnProperty(id)) {

            var model = models[id];
            renderableTotal += model.getRenderableTotal();

            ids.push(id);
        }
    }

    var realTotal = 0;

    for (var i = 0, len = ids.length; i < len; ++i) {

        var id = ids[i];
        var model = models[id];
        var renderableCount = Math.floor(model.getRenderableTotal() / renderableTotal * poolSize);
        if (renderableCount > model.getRenderableTotal()) {
            renderableCount = model.getRenderableTotal();
        }

        model.setRenderableCount(renderableCount);
        realTotal += renderableCount;
    }

    this.scene.resizePool(realTotal > poolSize ? poolSize : realTotal);
};

CLOUD.ModelManager.prototype.updateMaterials = function () {

    var models = this.models;
    for (var id in this.models) {
        if (models.hasOwnProperty(id)) {
            var model = models[id];
            if (model.isLoaded()) {
                model.updateMaterials();
            }
        }
    }
};

CLOUD.ModelManager.prototype.updateMaterialsValue = function (type, value) {

    var models = this.models;
    for (var id in this.models) {
        if (models.hasOwnProperty(id)) {
            var model = models[id];
            if (model.isLoaded()) {
                model.updateMaterialsValue(type, value);
            }
        }
    }
};

CLOUD.ModelManager.prototype.changeAllMaterials = function (isIBL) {

    var models = this.models;
    for (var id in this.models) {
        if (models.hasOwnProperty(id)) {
            var model = models[id];
            model.changeAllMaterials(isIBL);
        }
    }
};

CLOUD.ModelManager.prototype.clearScene = function () {

    var models = this.models;

    for (var id in models) {

        if (models.hasOwnProperty(id)) {

            var model = models[id];
            model.clearCells();
        }
    }
};

// 跨域设置
CLOUD.ModelManager.prototype.setCrossOrigin = function (crossOrigin) {
    this.crossOrigin = crossOrigin;
};

CLOUD.ModelManager.prototype.getMatrixWorldGlobal = function () {
    return this.scene.getMatrixWorldGlobal();
};

// 获取场景变换前的相机对应的Frustum
CLOUD.ModelManager.prototype.getWorldFrustum = function (camera, transform) {

    var matrixWorldInverse = new THREE.Matrix4();
    var frustum = new THREE.Frustum();

    if (transform) {

        matrixWorldInverse.getInverse(camera.matrixWorld);
        frustum.setFromMatrix(new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, matrixWorldInverse));
    } else {

        var worldCamera = camera.clone();
        var targetPost = camera.target;
        // 计算场景变换后的相机位置和目标点的距离
        var distancePost = targetPost.clone().sub(camera.position).length();
        // 获得场景 root node 变换矩阵
        var matrixWorldRoot = this.getMatrixWorldGlobal();
        // 逆矩阵
        var matrixInverseRoot = new THREE.Matrix4();
        matrixInverseRoot.getInverse(matrixWorldRoot);

        // 抽取旋转矩阵
        var matrixRotation = new THREE.Matrix4();
        matrixRotation.extractRotation(matrixWorldRoot);
        var quaternion = new THREE.Quaternion();
        quaternion.setFromRotationMatrix(matrixRotation);
        quaternion.inverse(); // 反转

        // 计算场景变换前的相机位置
        worldCamera.position.applyMatrix4(matrixInverseRoot);

        // 计算场景变换前的目标位置
        var targetPre = targetPost.clone();
        targetPre.applyMatrix4(matrixInverseRoot);

        // 计算场景变换前的相机方向
        // var dirPre = camera.getWorldDirection();
        // dirPre.applyQuaternion(quaternion).normalize();
        var dirPre = targetPre.clone().sub(worldCamera.position);

        // 计算场景变换前的相机位置和目标点的距离
        var distancePre = dirPre.length();

        dirPre.normalize();

        // 计算场景变换前的相机 near 和 far
        var scaleCoe = distancePre / distancePost;
        // worldCamera.near = camera.near * scaleCoe;
        worldCamera.far = camera.far * scaleCoe;

        // 计算场景变换前的相机up和realUpw
        // var up = camera.position.clone().add(camera.up);
        // up.applyMatrix4(inverseMatrix).sub(worldCamera.position).normalize();
        // var realUp = camera.position.clone().add(camera.realUp);
        // realUp.applyMatrix4(inverseMatrix).sub(worldCamera.position).normalize();
        // worldCamera.up.copy(up);
        // worldCamera.realUp.copy(realUp);
        worldCamera.up.applyQuaternion(quaternion).normalize();
        worldCamera.realUp.applyQuaternion(quaternion).normalize();
        worldCamera.updateProjectionMatrix();
        worldCamera.updateMatrixWorld();

        matrixWorldInverse.getInverse(worldCamera.matrixWorld);
        frustum.setFromMatrix(new THREE.Matrix4().multiplyMatrices(worldCamera.projectionMatrix, matrixWorldInverse));

        worldCamera = null;
    }

    return frustum;
};

CLOUD.ModelManager.prototype.hasModel = function () {

    var models = this.models;

    for (var id in models) {
        if (models.hasOwnProperty(id)) {
            var model = models[id];
            if (model.isLoaded()) {
                return true;
            }
        }
    }

    return false;
};

CLOUD.ModelManager.prototype.getModel = function (id) {

    var model = this.models[id];

    if (model && model.isLoaded()) {
        return model;
    }

    return null;
};
CLOUD.ModelManager.prototype.updateOctreeBox = function (rootNode) {

    this.scene.updateOctreeBox(rootNode);
};

CLOUD.ModelManager.prototype.setCategoriesToHighPriority = function (categories, side) {

    var len = categories.length;

    if (len < 1) {
        return;
    }

    var highPriorityCategories = this.highPriorityCategories[side] = {};

    for (var i = 0; i < len; ++i) {
        highPriorityCategories[categories[i]] = true;
    }
};

CLOUD.ModelManager.prototype.getCategoriesFromHighPriority = function (side) {
    return this.highPriorityCategories[side];
};

CLOUD.ModelManager.prototype.clearCategoriesFromHighPriority = function (side) {
    this.highPriorityCategories[side] = {};
};

CLOUD.ModelManager.prototype.clearAllCategoriesFromHighPriority = function () {
    this.clearCategoriesFromHighPriority("inner");
    this.clearCategoriesFromHighPriority("outer");
};

CLOUD.ModelManager.prototype.calculateCameraModelRelation = function (cameraPos) {

    // if one of models contains camera, then camera is inside the model.
    var contains = false;
    var models = this.models;

    for (var id in models) {

        if (models.hasOwnProperty(id)) {

            var model = models[id];
            // TODO: 遍历所有模型，因为每个模型的 containsCamera 值都应该计算
            model.calculateCameraModelRelation(cameraPos);
            contains = contains || model.containsCamera;
        }
    }

    this.containsCamera = contains;
};
CLOUD.ModelManager.prototype.getNumOfElements = function () {

    var models = this.models;
    var numOfElements = 0;
    for (var id in this.models) {
        if (models.hasOwnProperty(id)) {
            var model = models[id];
            numOfElements += model.numOfElements;
        }
    }
    return numOfElements;
};

CLOUD.ModelManager.prototype.getNumOfRenderables = function () {

    var models = this.models;
    var numOfRenderables = 0;
    for (var id in this.models) {
        if (models.hasOwnProperty(id)) {
            var model = models[id];
            numOfRenderables += model.renderableTotal;
        }
    }
    return numOfRenderables;
};

CLOUD.ModelManager.prototype.getNumOfTriangles = function () {

    var models = this.models;
    var numOfTriangles = 0;
    for (var id in this.models) {
        if (models.hasOwnProperty(id)) {
            var model = models[id];
            numOfTriangles += model.numOfTriangles;
        }
    }
    return numOfTriangles;
};
// THREE.EventDispatcher.prototype.apply(CLOUD.ModelManager.prototype);
Object.assign(CLOUD.ModelManager.prototype, THREE.EventDispatcher.prototype);
/**
 * @author muwj 2016/12/15
 * @editor xiaoj 2017/03/24  remove THREE.Vector dependency for web worker usage
 */
var MPK = MPK || {};

MPK.MPKHeader = function (buffer) {

    var header = new Uint32Array(buffer, 0, 6);

    this.blockId = header[0];
    this.vtFormat = header[1];
    this.meshCount = header[2];
    this.meshOffset = header[3];
    this.bufferSize = header[4];
    this.bufferOffset = header[5];

    header = null;
};

MPK.MeshData = function (buffer, offset) {

    var mesh_info = new Uint32Array(buffer, offset, 5);

    this.mesh_id = mesh_info[0];
    this.ptCount = mesh_info[1];
    this.idxCount = mesh_info[2];
    this.dataOffset = mesh_info[3];
    this.vertexFormat = mesh_info[4];

    var base_info = new Float32Array(buffer, offset + 4 * 5, 4);

    this.baseScale = base_info[0];
    this.baseX = base_info[1];
    this.baseY = base_info[2];
    this.baseZ = base_info[3];

    mesh_info = null;
    base_info = null;
};

MPK.MPKReader = function (buffer) {

    this.header = new MPK.MPKHeader(buffer);

    this.meshSize = 4 * 9;
    this.maxSize = 4 * 64;
    this.meshBuffer = buffer.slice(this.header.meshOffset, this.header.meshOffset + this.header.meshCount * this.meshSize);
    this.geomBuffer = buffer.slice(this.header.bufferOffset, this.header.bufferOffset + this.header.bufferSize);

    // for data reading
    this.mesh_cur_id = -1;
    var tmp_buffer = new ArrayBuffer(this.maxSize);
    this.mesh_cur = new MPK.MeshData(tmp_buffer, 0);
};

MPK.MPKReader.prototype = {

    constructor: MPK.MPKReader,

    getMeshData: function getMeshData(index) {

        if (index >= 0 && index < this.header.meshCount) {

            return new MPK.MeshData(this.meshBuffer, index * this.meshSize);
        }
    },

    getMeshInfo: function getMeshInfo(index) {

        if (index == this.mesh_cur_id) {
            return this.mesh_cur;
        }

        if (index >= 0 && index < this.header.meshCount) {

            var data_i = new Uint32Array(this.meshBuffer, index * this.meshSize, 5);
            this.mesh_cur.mesh_id = data_i[0];
            this.mesh_cur.ptCount = data_i[1];
            this.mesh_cur.idxCount = data_i[2];
            this.mesh_cur.dataOffset = data_i[3];
            this.mesh_cur.vertexFormat = data_i[4];

            var data_f = new Float32Array(this.meshBuffer, index * this.meshSize + 4 * 5, 4);
            this.mesh_cur.baseScale = data_f[0];

            //this.mesh_cur.baseVector.set(data_f[1], data_f[2], data_f[3]);
            this.mesh_cur.baseX = data_f[1];
            this.mesh_cur.baseY = data_f[2];
            this.mesh_cur.baseZ = data_f[3];

            this.mesh_cur_id = index;
            return this.mesh_cur;
        }
    },

    getPtBuffer: function getPtBuffer(index) {

        if (index >= 0 && index < this.header.meshCount) {

            var mesh = this.getMeshInfo(index);
            if (mesh === undefined) {
                return undefined;
            }

            if (mesh.baseScale == 0.0) {
                return new Float32Array(this.geomBuffer, mesh.dataOffset, mesh.ptCount * 3);
            } else {
                return new Uint16Array(this.geomBuffer, mesh.dataOffset, mesh.ptCount * 3);
            }
        }
    },

    getIdxBuffer: function getIdxBuffer(index) {

        if (index >= 0 && index < this.header.meshCount) {

            var mesh = this.getMeshInfo(index);
            if (mesh === undefined) {
                return undefined;
            }

            var offset = mesh.dataOffset;
            if (mesh.baseScale == 0.0) {
                offset += mesh.ptCount * 3 * 4;
            } else {
                offset += mesh.ptCount * 3 * 2;
                if (mesh.ptCount % 2 == 1) {
                    offset += 2;
                }
            }

            if (mesh.ptCount > 65535) {
                return new Uint32Array(this.geomBuffer, offset, mesh.idxCount);
            } else {
                return new Uint16Array(this.geomBuffer, offset, mesh.idxCount);
            }
        }
    },

    getNormalBuffer: function getNormalBuffer(index) {

        if ((this.header.vtFormat & 2) == 2 && index >= 0 && index < this.header.meshCount) {

            var mesh = this.getMeshInfo(index);
            if (mesh === undefined) {
                return undefined;
            }

            var offset = mesh.dataOffset;
            if (mesh.baseScale == 0.0) {
                offset += mesh.ptCount * 3 * 4;
            } else {
                offset += mesh.ptCount * 3 * 2;
                if (mesh.ptCount % 2 == 1) {
                    offset += 2;
                }
            }

            if (mesh.ptCount > 65535) {
                offset += mesh.idxCount * 4;
            } else {
                offset += mesh.idxCount * 2;
                if (mesh.idxCount % 2 == 1) {
                    offset += 2;
                }
            }

            return new Float32Array(this.geomBuffer, offset, mesh.ptCount * 3);
        }
    },

    getUVBuffer: function getUVBuffer(index) {

        if (index >= 0 && index < this.header.meshCount) {

            var mesh = this.getMeshInfo(index);
            if (mesh === undefined || (mesh.vertexFormat & 4) != 4) {
                return undefined;
            }

            var offset = mesh.dataOffset;
            if (mesh.baseScale == 0.0) {
                offset += mesh.ptCount * 3 * 4;
            } else {
                offset += mesh.ptCount * 3 * 2;
                if (mesh.ptCount % 2 == 1) {
                    offset += 2;
                }
            }

            if (mesh.ptCount > 65535) {
                offset += mesh.idxCount * 4;
            } else {
                offset += mesh.idxCount * 2;
                if (mesh.idxCount % 2 == 1) {
                    offset += 2;
                }
            }

            if ((this.header.vtFormat & 2) == 2) {
                offset += mesh.ptCount * 3 * 4;
            }

            return new Float32Array(this.geomBuffer, offset, mesh.ptCount * 2);
        }
    }
};
CLOUD.ClipPlanes = function (size, center) {
    THREE.Object3D.call(this);

    var faceName = [];
    faceName.push("clipPlane_right");
    faceName.push("clipPlane_left");
    faceName.push("clipPlane_top");
    faceName.push("clipPlane_bottom");
    faceName.push("clipPlane_front");
    faceName.push("clipPlane_back");

    this.cubeSize = size.clone();
    this.center = center.clone();

    this.visible = false;
    this.rotatable = false;

    this.selectIndex = null;

    this.planeOffset = new Array(6);

    this.uniforms = {
        iClipPlane: { type: "i", value: 0 },
        vClipPlane: {
            type: "v4v",
            value: new Array(new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4())
        }
    };

    this.clipplanes = null;

    this.calculation = true;

    this.getPlaneNormal = function (face) {
        var planeNormal = new THREE.Vector4();
        var index = Math.floor(face / 2);
        var mod = face % 2;
        planeNormal.setComponent(index, Math.pow(-1, mod));
        planeNormal["w"] = -this.cubeSize.getComponent(index) * 0.5;
        this.planeOffset[face] = 0;
        return planeNormal;
    };

    this.planeMaterial = new CLOUD.PhongLightingMaterial({
        color: 0x6699CC,
        opacity: 0.3,
        transparent: true,
        side: THREE.DoubleSide,
        lights: true
    });

    this.planeHighLightMatrial = new CLOUD.PhongLightingMaterial({
        color: 0x00FF80,
        opacity: 0.3,
        transparent: true,
        side: THREE.DoubleSide,
        lights: true
    });

    this.initPlaneModel = function (face) {
        var index = Math.floor(face / 2);
        var mod = face % 2;

        var width = index == 0 ? this.cubeSize.z : this.cubeSize.x;
        var height = index == 1 ? this.cubeSize.z : this.cubeSize.y;

        var plane = new THREE.PlaneGeometry(width, height);
        var planeMesh = new THREE.Mesh(plane, this.planeMaterial.clone());
        planeMesh.name = faceName[face];
        planeMesh.customTag = true;
        planeMesh.position.setComponent(index, Math.pow(-1, mod) * this.cubeSize.getComponent(index) * 0.5);
        if (index == 0) planeMesh.rotation.y = Math.pow(-1, mod) * Math.PI * 0.5;else if (index == 1) planeMesh.rotation.x = Math.pow(-1, mod) * Math.PI * 0.5;
        //else if (index == 2 && mod == 0) planeMesh.rotation.x = Math.PI;

        this.add(planeMesh);
    };

    this.initWireframes = function () {
        var vertexs = [-this.cubeSize.x * 0.5, -this.cubeSize.y * 0.5, -this.cubeSize.z * 0.5, this.cubeSize.x * 0.5, -this.cubeSize.y * 0.5, -this.cubeSize.z * 0.5, this.cubeSize.x * 0.5, this.cubeSize.y * 0.5, -this.cubeSize.z * 0.5, -this.cubeSize.x * 0.5, this.cubeSize.y * 0.5, -this.cubeSize.z * 0.5, -this.cubeSize.x * 0.5, -this.cubeSize.y * 0.5, this.cubeSize.z * 0.5, this.cubeSize.x * 0.5, -this.cubeSize.y * 0.5, this.cubeSize.z * 0.5, this.cubeSize.x * 0.5, this.cubeSize.y * 0.5, this.cubeSize.z * 0.5, -this.cubeSize.x * 0.5, this.cubeSize.y * 0.5, this.cubeSize.z * 0.5];

        var colors = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0];
        var indices = [0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 3, 7, 1, 5, 2, 6];

        var geometry = new THREE.BufferGeometry();
        var material = new CLOUD.PhongLightingMaterial({
            color: 0xFFFFFF,
            lights: true
        });

        geometry.setIndex(indices);
        geometry.addAttribute('position', new THREE.Float32BufferAttribute(vertexs, 3));
        geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.computeBoundingSphere();

        var lineMesh = new THREE.LineSegments(geometry, material);
        lineMesh.name = "Wireframes";
        lineMesh.customTag = true;

        this.add(lineMesh);
    };

    this.updateClippingParams = function (uniforms) {};

    this.enable = function (enable, visible) {
        this.visible = visible;
        this.uniforms.iClipPlane.value = enable ? 6 : 0;
        this.updateClippingParams(this.uniforms);
    };

    this.isEnabled = function () {
        return this.uniforms.iClipPlane.value == 0 ? false : true;
    };

    var ClipPlanesInfo = function ClipPlanesInfo(enable, visible, rotatable, calculation, planeOffset, position, scale, quaternion, cubeSize, center) {
        this.enable = enable;
        this.visible = visible;
        this.rotatable = rotatable;
        this.calculation = calculation;
        this.planeOffset = planeOffset.slice(0);
        this.position = position;
        this.scale = scale;
        this.quaternion = quaternion;
        this.cubeSize = cubeSize;
        this.center = center;
    };

    this.store = function () {
        return new ClipPlanesInfo(this.uniforms.iClipPlane.value ? true : false, this.visible, this.rotatable, this.calculation, this.planeOffset, this.position.clone(), this.scale.clone(), this.quaternion.clone(), this.cubeSize.clone(), this.center.clone());
    };

    this.restore = function (info) {
        this.calculation = true;
        this.calculationPlanes(info.cubeSize, info.center);

        this.enable(info.enable, info.visible);
        this.rotatable = info.rotatable;
        this.calculation = info.calculation;

        for (var i = 0; i < 6; ++i) {
            this.planeOffset[i] = info.planeOffset[i];
        }
        this.position.copy(info.position);
        this.scale.copy(info.scale);

        this.quaternion._w = info.quaternion._w;
        this.quaternion._x = info.quaternion._x;
        this.quaternion._y = info.quaternion._y;
        this.quaternion._z = info.quaternion._z;

        this.update();
    };

    this.reset = function () {
        this.calculation = true;
        for (var i = 0; i < 6; ++i) {
            this.planeOffset[i] = 0;
        }
        this.position.copy(this.center);
        this.scale.copy(new THREE.Vector3(1.0, 1.0, 1.0));
        this.quaternion.copy(new THREE.Quaternion());
        this.update();
    };

    this.calculationPlanes = function (size, center) {
        if (!this.calculation) return;

        this.cubeSize.copy(size);
        this.center.copy(center);

        var len = this.children.length;
        for (var i = len - 1; i >= 0; --i) {
            this.remove(this.children[i]);
        }

        for (var i = 0; i < 6; ++i) {
            this.uniforms.vClipPlane.value[i] = this.getPlaneNormal(i);
            this.initPlaneModel(i);
        }

        this.initWireframes();

        this.clipplanes = this.uniforms.vClipPlane.value.slice(0);

        this.reset();
    };

    this.update = function () {
        this.updateMatrixWorld();
        var m = new THREE.Matrix4();
        m.getInverse(this.matrix);
        m.transpose();
        for (var i = 0; i < 6; ++i) {
            this.uniforms.vClipPlane.value[i] = this.clipplanes[i].clone().applyMatrix4(m);
        }
        this.updateClippingParams(this.uniforms);
    };

    this.offset = function (face, offset) {
        this.calculation = false;

        var index = Math.floor(face / 2);
        var mod = face % 2;
        this.planeOffset[face] += offset;

        var size = this.cubeSize.getComponent(index) * 0.5;
        if (mod == 0 && this.planeOffset[face] > size) {
            this.planeOffset[face] -= offset;
            offset = size - this.planeOffset[face];
            this.planeOffset[face] = size;
        } else if (mod == 1 && this.planeOffset[face] < -size) {
            this.planeOffset[face] -= offset;
            offset = -size - this.planeOffset[face];
            this.planeOffset[face] = -size;
        }

        var centerOffset = new THREE.Vector3();
        for (var i = 0; i < 6; ++i) {
            var normal = this.clipplanes[i].clone();
            var planeOffset = this.planeOffset[i];
            var deltaOffset = new THREE.Vector3(normal.x * planeOffset, normal.y * planeOffset, normal.z * planeOffset);
            centerOffset.add(deltaOffset);
        }

        var scale = 1 + centerOffset.getComponent(index) / this.cubeSize.getComponent(index);
        if (scale > 0.0 && scale < 2.0) {
            this.scale.setComponent(index, scale);
            var tempClipPlane = this.uniforms.vClipPlane.value[face].clone();
            var tempNormal = new THREE.Vector3(tempClipPlane.x, tempClipPlane.y, tempClipPlane.z);
            tempNormal.normalize();
            var deltaOffset = offset;
            var offsetVector = new THREE.Vector3(tempNormal.x * deltaOffset, tempNormal.y * deltaOffset, tempNormal.z * deltaOffset);
            if (face % 2 == 1) {
                this.position.sub(offsetVector.multiplyScalar(0.5));
            } else {
                this.position.add(offsetVector.multiplyScalar(0.5));
            }

            this.update();
        } else {
            this.planeOffset[face] -= offset;
        }
    };

    var tempQuaternion = new THREE.Quaternion();

    var unitX = new THREE.Vector3(1.0, 0.0, 0.0);
    this.rotX = function (rot) {
        this.calculation = false;
        tempQuaternion.setFromAxisAngle(unitX, rot);
        this.quaternion.multiply(tempQuaternion);
        this.update();
    };

    var unitY = new THREE.Vector3(0.0, 1.0, 0.0);
    this.rotY = function (rot) {
        this.calculation = false;
        tempQuaternion.setFromAxisAngle(unitY, rot);
        this.quaternion.multiply(tempQuaternion);
        this.update();
    };

    this.highLight = function () {
        if (this.selectIndex == null) return;
        this.children[this.selectIndex].material = this.planeHighLightMatrial.clone();
    };

    this.cancelHighLight = function () {
        if (this.selectIndex == null) return;
        this.children[this.selectIndex].material = this.planeMaterial.clone();
        this.selectIndex = null;
    };
};

CLOUD.ClipPlanes.prototype = Object.create(THREE.Object3D.prototype);
CLOUD.ClipPlanes.prototype.constructor = CLOUD.ClipPlanes;

CLOUD.ClipPlanes.prototype.init = function () {
    this.calculationPlanes(this.cubeSize, this.center);
};

CLOUD.ClipPlanes.prototype.hitTest = function (raycaster) {
    var minDistance = null;
    var minSign = null;

    this.raycast(raycaster);
    if (this.selectIndex != null) {
        var ray = raycaster.ray;
        var plane = new THREE.Plane();
        var v4 = this.uniforms.vClipPlane.value[this.selectIndex];
        plane.setComponents(v4.x, v4.y, v4.z, v4.w);
        minDistance = ray.distanceToPlane(plane);
        minSign = ray.direction.dot(plane.normal) < 0;
    }

    return { sign: minSign, distance: minDistance };
};

CLOUD.ClipPlanes.prototype.raycast = function () {
    return function (raycaster, intersects) {
        var planeIntersects = [];
        var selectPlane;
        for (var i = 0, len = 6; i < len; i++) {
            CLOUD.CameraUtil.intersectObject(this.children[i], raycaster, planeIntersects, true);
            if (planeIntersects.length > 0) {
                if (!selectPlane) {
                    selectPlane = planeIntersects.pop();
                    this.selectIndex = i;
                } else {
                    var plane = planeIntersects.pop();
                    if (plane.distance < selectPlane.distance) {
                        selectPlane = plane;
                        this.selectIndex = i;
                    }
                }
            }
        }

        if (!selectPlane) this.selectIndex = null;

        return false;
    };
}();
CLOUD.FillClipPlane = function (size, center) {
    THREE.Object3D.call(this);

    this.cubeSize = size.clone();
    this.center = center.clone();

    this.planeOffset = 0.0;

    this.visible = false;
    this.rotatable = false;

    this.hit = false;

    this.clipplane = new THREE.Vector4();

    this.uniforms = {
        iClipPlane: { value: 0 },
        vClipPlane: { value: new Array(new THREE.Vector4()) }
    };

    this.planeMaterial = new CLOUD.PhongLightingMaterial({
        color: 0x6699CC,
        opacity: 0.3,
        transparent: true,
        side: THREE.DoubleSide,
        lights: true
    });

    this.planeHighLightMatrial = new CLOUD.PhongLightingMaterial({
        color: 0x00FF80,
        opacity: 0.3,
        transparent: true,
        side: THREE.DoubleSide,
        lights: true
    });

    this.initPlaneModel = function () {
        var max = Math.max(this.cubeSize.x, this.cubeSize.y);
        var plane = new THREE.PlaneGeometry(max, max);
        var planeMesh = new THREE.Mesh(plane, this.planeMaterial.clone());
        planeMesh.name = "fillClipPlane";
        planeMesh.customTag = true;

        this.position.copy(this.center);

        this.clipplane.set(0, 0, 1, 0);

        this.add(planeMesh);
    };

    this.updateClippingParams = function (uniforms) {};

    this.enable = function (enable, visible) {
        this.visible = visible;
        this.uniforms.iClipPlane.value = enable ? 1 : 0;
        this.updateClippingParams(this.uniforms);
    };

    this.isEnabled = function () {
        return this.uniforms.iClipPlane.value == 0 ? false : true;
    };

    this.update = function () {
        this.updateMatrixWorld();
        var m = new THREE.Matrix4();
        m.getInverse(this.matrix);
        m.transpose();
        this.uniforms.vClipPlane.value[0] = this.clipplane.clone().applyMatrix4(m);
        this.updateClippingParams(this.uniforms);
    };

    this.offset = function (offset) {
        var tempClipPlane = this.uniforms.vClipPlane.value[0].clone();
        var tempNormal = new THREE.Vector3(tempClipPlane.x, tempClipPlane.y, tempClipPlane.z);
        tempNormal.normalize();
        var offsetVector = new THREE.Vector3(tempNormal.x * offset, tempNormal.y * offset, tempNormal.z * offset);
        this.position.add(offsetVector);

        this.update();
    };

    this.setOffset = function (offset) {
        var tempClipPlane = this.uniforms.vClipPlane.value[0].clone();
        var tempNormal = new THREE.Vector3(tempClipPlane.x, tempClipPlane.y, tempClipPlane.z);
        tempNormal.normalize();
        var offsetVector = new THREE.Vector3(tempNormal.x * offset, tempNormal.y * offset, tempNormal.z * offset);
        this.position.copy(this.center).add(offsetVector);

        this.update();
    };

    //模型坐标系是Z轴朝上，OpenGL坐标系是Y轴朝上，平面模型在模型坐标系中是XOZ平面-Y法线
    this.changeNormal = function (index) {

        var mesh = this.children[0];
        if (index == 0) {
            this.clipplane.set(1, 0, 0, 0); // OpenGL中的X法线
            mesh.rotation.set(0.0, Math.PI / 2, 0.0); // 旋转到模型YOZ平面
        } else if (index == 1) {
            this.clipplane.set(-1, 0, 0, 0); // OpenGL中的-X法线
            mesh.rotation.set(0.0, -Math.PI / 2, 0.0); // 旋转到模型YOZ平面
        } else if (index == 2) {
            this.clipplane.set(0, 0, -1, 0); // OpenGL中的-Z法线
            mesh.rotation.set(Math.PI, 0.0, 0.0); // 旋转到模型XOZ平面
        } else if (index == 3) {
            this.clipplane.set(0, 0, 1, 0); // OpenGL中的Z法线
            mesh.rotation.set(0.0, 0.0, 0.0); // 旋转到模型XOZ平面
        } else if (index == 4) {
            this.clipplane.set(0, 1, 0, 0); // OpenGL中的Y法线
            mesh.rotation.set(-Math.PI / 2, 0.0, 0.0); // 旋转到模型XOY平面
        } else if (index == 5) {
            this.clipplane.set(0, -1, 0, 0); // OpenGL中的-Y法线
            mesh.rotation.set(Math.PI / 2, 0.0, 0.0); // 旋转到模型XOY平面
        }

        mesh.updateMatrixWorld();
        this.update();
    };

    var tempQuaternion = new THREE.Quaternion();

    var unitX = new THREE.Vector3(1.0, 0.0, 0.0);
    this.rotX = function (rot) {
        tempQuaternion.setFromAxisAngle(unitX, rot);
        this.quaternion.multiply(tempQuaternion);
        this.update();
    };

    var unitY = new THREE.Vector3(0.0, 1.0, 0.0);
    this.rotY = function (rot) {
        tempQuaternion.setFromAxisAngle(unitY, rot);
        this.quaternion.multiply(tempQuaternion);
        this.update();
    };

    this.highLight = function () {
        this.children[0].material = this.planeHighLightMatrial.clone();
    };

    this.cancelHighLight = function () {
        this.children[0].material = this.planeMaterial.clone();
        this.hit = false;
    };
};

CLOUD.FillClipPlane.prototype = Object.create(THREE.Object3D.prototype);
CLOUD.FillClipPlane.prototype.constructor = CLOUD.FillClipPlane;

CLOUD.FillClipPlane.prototype.init = function () {
    this.initPlaneModel();
};

CLOUD.FillClipPlane.prototype.hitTest = function (raycaster) {
    var minDistance = null;
    var minSign = null;

    this.raycast(raycaster);
    if (this.hit) {
        var ray = raycaster.ray;
        var plane = new THREE.Plane();
        var v4 = this.uniforms.vClipPlane.value[0];
        plane.setComponents(v4.x, v4.y, v4.z, v4.w);
        minDistance = ray.distanceToPlane(plane);
        minSign = ray.direction.dot(plane.normal) < 0;
    }

    return { sign: minSign, distance: minDistance };
};

CLOUD.FillClipPlane.prototype.raycast = function () {
    return function (raycaster, intersects) {
        this.hit = false;
        var planeIntersects = [];
        CLOUD.CameraUtil.intersectObject(this.children[0], raycaster, planeIntersects, true);
        if (planeIntersects.length > 0) {
            this.hit = true;
        }

        return false;
    };
}();
CLOUD.ClipPlaneService = function (viewer) {

    this.viewer = viewer;
    this.planes = [];

    for (var ii = 0; ii < 6; ++ii) {
        this.planes.push(new THREE.Plane());
    }
};

CLOUD.ClipPlaneService.prototype = {

    construtor: CLOUD.ClipPlaneService,

    destroy: function destroy() {
        this.viewer = null;
        this.planes = [];
    },

    update: function update(camera) {

        var editor = this.getEditor();

        if (editor) {
            editor.update(camera);
            this.viewer.render();
        }
    },

    getEditor: function getEditor() {
        var editors = viewer.editorManager.editors;
        var editor = editors[CLOUD.EditorMode.CLIP_BY_BOX];
        return editor;
    },

    toggle: function toggle(enable, visible) {
        var editor = this.getEditor();
        editor.toggle(enable, visible);
    },

    // 显示/隐藏切面
    setVisible: function setVisible(enable) {
        var editor = this.getEditor();
        editor.visible(enable);
    },

    setRotatable: function setRotatable(enable) {
        var editor = this.getEditor();
        editor.rotatable(enable);
    },

    enablePick: function enablePick(enable) {
        var editor = this.getEditor();
        editor.enablePick = enable;
    },

    saveState: function saveState() {
        var editor = this.getEditor();
        return editor.store();
    },

    loadState: function loadState(info) {
        var editor = this.getEditor();
        editor.restore(info);
    },

    reset: function reset() {
        var editor = this.getEditor();
        editor.reset();
    }
};
var ImageBasedLighting = ImageBasedLighting || {};

ImageBasedLighting.brdf_vs = ["varying vec2 vUV;", "void main() {", "	vUV = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "}"].join('\n');

ImageBasedLighting.brdf_fs = ["varying vec2 vUV;", "uniform sampler2D HammersleyTable;", "const float PI = 3.14159265358979;", "float GGX(float NdotV, float alpha)", "{", "	float alpha2 = pow(alpha, 2.0);", "	return 2.0 * NdotV / (NdotV + sqrt(alpha2 + (1.0 - alpha2) * NdotV * NdotV));", "}", "float G_Smith(float NdotV, float NdotL, float roughness)", "{", "	float alpha = pow(roughness, 2.0);", "	return GGX(NdotV, alpha) * GGX(NdotL, alpha);", "}", "vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)", "{", "	float a = roughness * roughness;", "	float Phi = 2.0 * PI * Xi.x; ", "	float CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y)); ", "	float SinTheta = sqrt(1.0 - CosTheta * CosTheta);", "	vec3 H;", "	H.x = SinTheta * cos(Phi); ", "	H.y = SinTheta * sin(Phi); ", "	H.z = CosTheta;", "	vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0); ", "	vec3 TangentX = normalize(cross(UpVector, N)); ", "	vec3 TangentY = cross(N, TangentX);",

// Tangent to world space
"	return normalize(TangentX * H.x + TangentY * H.y + N * H.z);", "}", "vec2 IntegrateBRDF(float NdotV, float roughness)", "{", "	vec3 N = vec3(0.0, 0.0, 1.0);", "	vec3 V = vec3(sqrt(1.0 - NdotV * NdotV), 0.0, NdotV);", "	vec2 result = vec2(0.0, 0.0);", "	const int NumSamples = 1024;", "	for (int i = 0; i < NumSamples; i++)", "	{", "		float u = float(i) / float(NumSamples);", "		vec2 Xi = vec2(u, texture2D(HammersleyTable, vec2(u)).r);", "		vec3 H = ImportanceSampleGGX(Xi, N, roughness);", "		vec3 L = 2.0 * dot(V, H) * H - V;", "		float NdotL = saturate(L.z);", "		float NdotH = saturate(H.z);", "		float VdotH = saturate(dot(V, H));", "		float NdotV = saturate(dot(N, V));", "		if (NdotL > 0.0)", "		{", "			float G = G_Smith(NdotV, NdotL, roughness);", "			float G_Vis = G * VdotH / (NdotH * NdotV); ", "			float F = pow(1.0 - VdotH, 5.0);", "			result.x += (1.0 - F) * G_Vis;", "			result.y += F * G_Vis;", "		}", "	}", "	return result / float(NumSamples);", "}", "void main()", "{", "	vec2 brdf = IntegrateBRDF(vUV.x, vUV.y);", "	gl_FragColor = vec4(brdf, 0.0, 1.0);", "}"].join('\n');

ImageBasedLighting.BRDFMap = function (hammersleyTable, resolution) {

    this.texture = null;

    this.resolution = resolution || 512;

    this.brdfMaterial = new THREE.ShaderMaterial({
        vertexShader: ImageBasedLighting.brdf_vs,
        fragmentShader: ImageBasedLighting.brdf_fs,
        uniforms: {
            HammersleyTable: { value: hammersleyTable }
        },
        lights: false
    });

    this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(window.innerWidth, window.innerHeight), this.brdfMaterial);
    this.quad.position.z = -100;
};

ImageBasedLighting.BRDFMap.prototype.constructor = ImageBasedLighting.BRDFMap;

ImageBasedLighting.BRDFMap.prototype.generateMap = function (renderer) {

    var scene = new THREE.Scene();
    scene.add(this.quad);

    var camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -10000, 10000);
    camera.position.z = 100;

    var rtt = new THREE.WebGLRenderTarget(this.resolution, this.resolution, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat });
    renderer.render(scene, camera, rtt, true);

    this.texture = rtt.texture;
};
/**
* @author Prashant Sharma / spidersharma03
* @author Ben Houston / http://clara.io / bhouston
*/

THREE.HDRCubeTextureLoader = function (manager) {

    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
    // override in sub classes
    this.hdrLoader = new THREE.RGBELoader();
};

THREE.HDRCubeTextureLoader.prototype.load = function (type, urls, onLoad, onProgress, onError) {

    var RGBEByteToRGBFloat = function RGBEByteToRGBFloat(sourceArray, sourceOffset, destArray, destOffset) {

        var e = sourceArray[sourceOffset + 3];
        var scale = Math.pow(2.0, e - 128.0) / 255.0;

        destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
        destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
        destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
    };

    var RGBEByteToRGBHalf = function () {

        // Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

        var floatView = new Float32Array(1);
        var int32View = new Int32Array(floatView.buffer);

        /* This method is faster than the OpenEXR implementation (very often
         * used, eg. in Ogre), with the additional benefit of rounding, inspired
         * by James Tursa?s half-precision code. */
        function toHalf(val) {

            floatView[0] = val;
            var x = int32View[0];

            var bits = x >> 16 & 0x8000; /* Get the sign */
            var m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */
            var e = x >> 23 & 0xff; /* Using int is faster here */

            /* If zero, or denormal, or exponent underflows too much for a denormal
             * half, return signed zero. */
            if (e < 103) return bits;

            /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
            if (e > 142) {

                bits |= 0x7c00;
                /* If exponent was 0xff and one mantissa bit was set, it means NaN,
                		 * not Inf, so make sure we set one mantissa bit too. */
                bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
                return bits;
            }

            /* If exponent underflows but not too much, return a denormal */
            if (e < 113) {

                m |= 0x0800;
                /* Extra rounding may overflow and set mantissa to 0 and exponent
                 * to 1, which is OK. */
                bits |= (m >> 114 - e) + (m >> 113 - e & 1);
                return bits;
            }

            bits |= e - 112 << 10 | m >> 1;
            /* Extra rounding. An overflow will set mantissa to 0 and increment
             * the exponent, which is OK. */
            bits += m & 1;
            return bits;
        }

        return function (sourceArray, sourceOffset, destArray, destOffset) {

            var e = sourceArray[sourceOffset + 3];
            var scale = Math.pow(2.0, e - 128.0) / 255.0;

            destArray[destOffset + 0] = toHalf(sourceArray[sourceOffset + 0] * scale);
            destArray[destOffset + 1] = toHalf(sourceArray[sourceOffset + 1] * scale);
            destArray[destOffset + 2] = toHalf(sourceArray[sourceOffset + 2] * scale);
        };
    }();

    //

    var texture = new THREE.CubeTexture();

    texture.type = type;
    texture.encoding = type === THREE.UnsignedByteType ? THREE.RGBEEncoding : THREE.LinearEncoding;
    texture.format = type === THREE.UnsignedByteType ? THREE.RGBAFormat : THREE.RGBFormat;
    texture.minFilter = texture.encoding === THREE.RGBEEncoding ? THREE.NearestFilter : THREE.LinearFilter;
    texture.magFilter = texture.encoding === THREE.RGBEEncoding ? THREE.NearestFilter : THREE.LinearFilter;
    texture.generateMipmaps = texture.encoding !== THREE.RGBEEncoding;
    texture.anisotropy = 0;

    var scope = this.hdrLoader;

    var loaded = 0;

    function loadHDRData(i, onLoad, onProgress, onError) {

        var loader = new THREE.FileLoader(this.manager);
        loader.setResponseType('arraybuffer');
        loader.load(urls[i], function (buffer) {

            loaded++;

            var texData = scope._parser(buffer);

            if (!texData) return;

            if (type === THREE.FloatType) {

                var numElements = texData.data.length / 4 * 3;
                var floatdata = new Float32Array(numElements);

                for (var j = 0; j < numElements; j++) {

                    RGBEByteToRGBFloat(texData.data, j * 4, floatdata, j * 3);
                }

                texData.data = floatdata;
            } else if (type === THREE.HalfFloatType) {

                var numElements = texData.data.length / 4 * 3;
                var halfdata = new Uint16Array(numElements);

                for (var j = 0; j < numElements; j++) {

                    RGBEByteToRGBHalf(texData.data, j * 4, halfdata, j * 3);
                }

                texData.data = halfdata;
            }

            if (undefined !== texData.image) {

                texture[i].images = texData.image;
            } else if (undefined !== texData.data) {

                var dataTexture = new THREE.DataTexture(texData.data, texData.width, texData.height);
                dataTexture.format = texture.format;
                dataTexture.type = texture.type;
                dataTexture.encoding = texture.encoding;
                dataTexture.minFilter = texture.minFilter;
                dataTexture.magFilter = texture.magFilter;
                dataTexture.generateMipmaps = texture.generateMipmaps;

                texture.images[i] = dataTexture;
            }

            if (loaded === 6) {

                texture.needsUpdate = true;
                if (onLoad) onLoad(texture);
            }
        }, onProgress, onError);
    }

    for (var i = 0; i < urls.length; i++) {

        loadHDRData(i, onLoad, onProgress, onError);
    }

    return texture;
};

ImageBasedLighting.HDRTextureLoader = function (manager) {

    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
    // override in sub classes
    this.hdrLoader = new THREE.RGBELoader();
};

ImageBasedLighting.HDRTextureLoader.prototype.load = function (url, onLoad, onProgress, onError) {

    var RGBEByteToRGBFloat = function RGBEByteToRGBFloat(sourceArray, sourceOffset, destArray, destOffset) {

        var e = sourceArray[sourceOffset + 3];
        var scale = Math.pow(2.0, e - 128.0) / 255.0;

        destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
        destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
        destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
    };

    var texture = new THREE.DataTexture();

    this.hdrLoader.load(url, function (tex, texData) {
        tex.flipY = true;
        tex.type = THREE.FloatType;
        tex.format = THREE.RGBFormat;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;

        var RGBEByteToRGBFloat = function RGBEByteToRGBFloat(sourceArray, sourceOffset, destArray, destOffset) {

            var e = sourceArray[sourceOffset + 3];
            var scale = Math.pow(2.0, e - 128.0) / 256.0;

            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
        };

        var numElements = tex.image.width * tex.image.height * 3;
        var floatdata = new Float32Array(numElements);

        for (var j = 0; j < numElements; j++) {

            RGBEByteToRGBFloat(tex.image.data, j * 4, floatdata, j * 3);
        }

        tex.image.data = floatdata;

        texture = tex;

        if (onLoad) onLoad(texture);
    }, onProgress, onError);

    return texture;
};
ImageBasedLighting.equirectangular_vs = ["varying vec3 pos;", "void main() {", "	pos = vec3(modelMatrix * vec4(position, 1.0));", "	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "}"].join('\n');

ImageBasedLighting.equirectangular_fs = ["varying vec3 pos;", "uniform sampler2D map;", "const float PI = 3.14159265358979;", "const float INV_PI = 1.0 / PI;", "vec2 sampleSphericalMap(vec3 v)", "{", "	vec2 uv = vec2(atan(v.z, v.x), asin(v.y));", "	uv *= vec2(INV_PI * 0.5, INV_PI);", "	uv += 0.5;", "	return uv;", "}", "void main() {", "	vec2 uv = sampleSphericalMap(normalize(pos));", "	vec4 color = texture2D(map, uv);", "	gl_FragColor = vec4(color.rgb, 1.0);", "}"].join('\n');

ImageBasedLighting.EquirectangularMaterial = function (parameters) {

    THREE.ShaderMaterial.call(this);

    this.type = 'EquirectangularMaterial';

    this.map = null;

    this.lights = false;

    this.side = THREE.BackSide;

    this.defines = {};
    this.uniforms = THREE.UniformsUtils.merge([{
        map: { value: null }
    }]);

    this.vertexShader = ImageBasedLighting.equirectangular_vs;

    this.fragmentShader = ImageBasedLighting.equirectangular_fs;

    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    this.defaultAttributeValues = {
        'color': [1, 1, 1],
        'uv': [0, 0],
        'uv2': [0, 0]
    };

    if (parameters !== undefined) {

        if (parameters.attributes !== undefined) {

            console.error('IBLMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
        }

        this.setValues(parameters);
    }

    this.refreshUniforms();
};

ImageBasedLighting.EquirectangularMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
ImageBasedLighting.EquirectangularMaterial.prototype.constructor = ImageBasedLighting.EquirectangularMaterial;

ImageBasedLighting.EquirectangularMaterial.prototype.isShaderMaterial = true;

ImageBasedLighting.EquirectangularMaterial.prototype.copy = function (source) {

    THREE.ShaderMaterial.prototype.copy.call(this, source);

    this.map = source.map;

    return this;
};

ImageBasedLighting.EquirectangularMaterial.prototype.refreshUniforms = function () {

    this.uniforms.map.value = this.map;
};

ImageBasedLighting.HDRToCubeMap = function (map, renderer, isHDR, resolution) {
    var camera = new THREE.CubeCamera(0.1, 10.0, resolution || 512);
    if (isHDR) {
        var options = { type: THREE.FloatType, format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };
        camera.renderTarget = new THREE.WebGLRenderTargetCube(resolution || 512, resolution || 512, options);
    }

    var scene = new THREE.Scene();

    var material = new EquirectangularMaterial({ map: map });

    var cube = new THREE.Mesh(new THREE.BoxBufferGeometry(2.0, 2.0, 2.0), material);
    scene.add(cube);

    camera.updateCubeMap(renderer, scene);

    return camera.renderTarget.texture;
};
ImageBasedLighting.IBLMaterial = function (parameters) {

    THREE.ShaderMaterial.call(this);

    this.type = 'IBLMaterial';

    this.debug = 0;

    this.gamma = 1.0;

    this.color = new THREE.Color(0xffffff);

    this.roughness = 0.8;
    this.metallic = 0.4;

    this.opacity = 1.0;

    this.map = null;

    this.iblProbe = null;

    this.shift = 0.18;
    this.A = 0.27;
    this.B = 0.29;
    this.C = 0.052;
    this.D = 0.2;
    this.E = 0.0;
    this.F = 0.18;
    this.scale = 0.897105;

    this.emissive = new THREE.Color();
    this.specular = new THREE.Color();
    this.shininess = 0;

    this.defines = {};
    this.uniforms = THREE.UniformsUtils.merge([{
        clippingPlanes: { value: null },

        debug: { value: 0 },

        gamma: { value: 1.0 },

        albedo: { value: new THREE.Color(0xffffff) },

        metallic: { value: 0.8 },
        roughness: { value: 0.4 },

        opacity: { value: 1.0 },

        map: { value: null },

        irradianceMap: { value: null },
        prefilterMap: { value: null },
        brdfMap: { value: null },

        shift: { value: 0.18 },
        A: { value: 0.27 },
        B: { value: 0.29 },
        C: { value: 0.052 },
        D: { value: 0.2 },
        E: { value: 0.0 },
        F: { value: 0.18 },
        scale: { value: 0.897105 }
    }]);

    this.lights = false;

    this.vertexShader = ImageBasedLighting.IBLVertexShader;

    this.fragmentShader = ImageBasedLighting.IBLFragmentShader;

    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    this.defaultAttributeValues = {
        'color': [1, 1, 1],
        'uv': [0, 0],
        'uv2': [0, 0]
    };

    if (parameters !== undefined) {

        if (parameters.attributes !== undefined) {

            console.error('IBLMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
        }

        this.setValues(parameters);
    }

    //this.refreshUniforms();
};

ImageBasedLighting.IBLMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
ImageBasedLighting.IBLMaterial.prototype.constructor = ImageBasedLighting.IBLMaterial;

ImageBasedLighting.IBLMaterial.prototype.isShaderMaterial = true;

ImageBasedLighting.IBLMaterial.prototype.copy = function (source) {

    THREE.ShaderMaterial.prototype.copy.call(this, source);

    this.debug = source.debug;

    this.gamma = source.gamma;

    this.color.copy(source.color);

    this.metallic = source.metallic;
    this.roughness = source.roughness;

    this.opacity = source.opacity;

    this.map = source.map;

    this.iblProbe = source.iblProbe;

    this.shift = source.shift;
    this.A = source.A;
    this.B = source.B;
    this.C = source.C;
    this.D = source.D;
    this.E = source.E;
    this.F = source.F;
    this.scale = source.scale;

    return this;
};

ImageBasedLighting.IBLMaterial.prototype.refreshUniforms = function () {

    this.uniforms.clippingPlanes.value = this.clippingPlanes;

    this.uniforms.debug.value = this.debug;
    this.uniforms.gamma.value = this.gamma;

    this.uniforms.albedo.value.set(this.color);

    this.uniforms.metallic.value = this.metallic;
    this.uniforms.roughness.value = this.roughness;

    this.uniforms.opacity.value = this.opacity;

    this.uniforms.map.value = this.map;

    this.uniforms.irradianceMap.value = this.iblProbe.irradianceMap.cubeTexture;
    this.uniforms.prefilterMap.value = this.iblProbe.prefilterMap.cubeTexture;
    this.uniforms.brdfMap.value = this.iblProbe.brdfMap.texture;

    this.uniforms.shift.value = this.shift;
    this.uniforms.A.value = this.A;
    this.uniforms.B.value = this.B;
    this.uniforms.C.value = this.C;
    this.uniforms.D.value = this.D;
    this.uniforms.E.value = this.E;
    this.uniforms.F.value = this.F;
    this.uniforms.scale.value = this.scale;
};
ImageBasedLighting.IBLProbe = function (envMap, hammersleyUrl, onSuccess, irradianceResolution, prefilterResolution, brdfResolution, maxMipLevel) {

    this.environmentMap = envMap;

    this.hammersleyTable = null;
    this.irradianceMap = null;
    this.prefilterMap = null;
    this.brdfMap = null;

    this.hammersleyUrl = hammersleyUrl;

    this.irradianceResolution = irradianceResolution || 32;
    this.prefilterResolution = prefilterResolution || 128;
    this.brdfResolution = brdfResolution || 512;
    this.maxMipLevel = maxMipLevel || 1;

    this.isHDR = false;
    this.isComputed = false;

    this.onSuccess = onSuccess;

    this.loadHammersleyTable();
};

ImageBasedLighting.IBLProbe.prototype.constructor = ImageBasedLighting.IBLProbe;

ImageBasedLighting.IBLProbe.prototype.loadHammersleyTable = function () {

    var scope = this;

    var loader = new THREE.TextureLoader();
    loader.load(this.hammersleyUrl, function onSuccess(texture) {
        scope.hammersleyTable = texture;
        scope.initMap();
        if (scope.onSuccess) {
            scope.onSuccess();
        }
    });
};

ImageBasedLighting.IBLProbe.prototype.initMap = function () {
    this.irradianceMap = new ImageBasedLighting.IrradianceMap(this.environmentMap, this.irradianceResolution);
    this.prefilterMap = new ImageBasedLighting.PrefilterMap(this.environmentMap, this.hammersleyTable, this.prefilterResolution, this.maxMipLevel);
    this.brdfMap = new ImageBasedLighting.BRDFMap(this.hammersleyTable, this.brdfResolution);
};

ImageBasedLighting.IBLProbe.prototype.setEnvironmentMap = function (environmentMap) {
    this.environmentMap = environmentMap;

    this.irradianceMap.irradianceMaterial.uniforms.environmentMap.value = this.environmentMap;
    this.prefilterMap.prefilterMaterial.uniforms.environmentMap.value = this.environmentMap;
};

ImageBasedLighting.IBLProbe.prototype.computed = function (renderer) {

    this.irradianceMap.generateMap(renderer, this.isHDR);
    this.prefilterMap.generateMap(renderer, this.isHDR);
    this.brdfMap.generateMap(renderer);

    this.isComputed = true;
};
ImageBasedLighting.IBLVertexShader = ["varying vec2 vUV;", "varying vec3 Normal;", "varying vec3 Pos;", "varying vec3 mvPosition;", "void main()", "{", "	vUV = uv;", "	Pos = vec3(modelMatrix * vec4(position, 1.0));", "	Normal = normalize(mat3(modelMatrix) * normal);", "	mvPosition = vec3(modelViewMatrix * vec4(position, 1.0));", "	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "}"].join('\n');

ImageBasedLighting.IBLFragmentShader = ["varying vec2 vUV;", "varying vec3 Normal;", "varying vec3 Pos;", "varying vec3 mvPosition;", "#if NUM_CLIPPING_PLANES > 0", "	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];", "#endif", "uniform int debug;", "uniform float gamma;", "uniform vec3 albedo;", "uniform float metallic;", "uniform float roughness;", "uniform float opacity;", "#ifdef USE_MAP", "	uniform sampler2D map;", "#endif", "uniform samplerCube irradianceMap;", "uniform samplerCube prefilterMap;", "uniform sampler2D brdfMap;", "uniform float shift;", "uniform float A;", "uniform float B;", "uniform float C;", "uniform float D;", "uniform float E;", "uniform float F;", "uniform float scale;", "const float PI = 3.14159265358979;", "float D_GGX(float NdotH, float roughness)", "{", "	float alpha = pow(roughness, 2.0);", "	float alpha2 = pow(alpha, 2.0);", "	return alpha2 / (PI * pow(NdotH * NdotH * (alpha2 - 1.0) + 1.0, 2.0));", "}", "float GGX_Schlick(float NdotV, float alpha)", "{", "	float k = alpha * 0.5;", "	return NdotV / (NdotV * (1.0 - k) + k);", "}", "float G_Smith(float NdotV, float NdotL, float roughness)", "{", "	float alpha = pow(roughness, 2.0);", "	return GGX_Schlick(NdotV, alpha) * GGX_Schlick(NdotL, alpha);", "}", "float F_Schlick(float F0, float HdotV)", "{", "	return F0 + (1.0 - F0) * pow((1.0 - HdotV), 5.0);", "}", "vec3 F_SchlickRoughness(float NdotV, vec3 F0, float roughness)", "{", "	return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - NdotV, 5.0);", "}", "vec3 toneMapCanonFilmic(vec3 color)", "{", "	color *= (1.0 / shift);", "	return (((color * (A * color + C * B)) / (color * (A * color + B) + D * F))) * (1.0 / scale);",

// "	const float Shift = 1.0 / 0.18;",
// "	color *= Shift;",

// "	const float A = 0.27;",
// "	const float B = 0.29;",
// "	const float C = 0.052;",
// "	const float D = 0.2;",
// "	const float E = 0.00;",
// "	const float F = 0.18;",
// "	const float scale = 1.0/0.897105;",

// "	return (((color * (A * color + C * B)) / (color * (A * color + B) + D * F)));",
"}", "void main()", "{", "#if NUM_CLIPPING_PLANES > 0", " vec3 vViewPosition = -mvPosition;", "	for ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {", "		vec4 plane = clippingPlanes[ i ];", "		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;", "	}", "	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES", "		bool clipped = true;", "		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {", "			vec4 plane = clippingPlanes[ i ];", "			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;", "		}", "		if ( clipped ) discard;", "	#endif", "#endif", "	vec3 N = Normal;", "	vec3 V = normalize(cameraPosition - Pos);", "	vec3 R = reflect(-V, N);", "	vec3 baseColor = albedo;", "#ifdef USE_MAP", "	baseColor = texture2D(map, vUV).rgb;", "#endif", "	vec3 F0 = vec3(0.04);", "	F0 = mix(F0, baseColor, metallic);", "	vec3 F = F_SchlickRoughness(max(dot(N, V), 0.0), F0, roughness);", "	vec3 kS = F;", "	vec3 kD = 1.0 - kS;", "	kD *= 1.0 - metallic;", "	vec3 irradiance = textureCube(irradianceMap, N, 0.0).rgb;", "	irradiance = pow(irradiance, vec3(gamma));", "	vec3 diffuse = irradiance * baseColor;", "	const float MAX_REFLECTION_LOD = 1.0;", "	vec3 prefilteredColor = textureCube(prefilterMap, R, roughness * MAX_REFLECTION_LOD).rgb;", "	prefilteredColor = pow(prefilteredColor, vec3(gamma));", "	vec2 brdf = texture2D(brdfMap, vec2(max(dot(N, V), 0.0), roughness)).rg;", "	vec3 specular = prefilteredColor * (F * brdf.x + brdf.y);", "	vec3 color = kD * diffuse + specular;", "	color = toneMapCanonFilmic(color);", "	color = pow(color, vec3(1.0 / gamma));", "	if (debug == 1) ", "	{", "		gl_FragColor = vec4(baseColor, opacity);", "	}", "	else if (debug == 2)", "	{", "		gl_FragColor = vec4(irradiance, opacity);", "	}", "	else if (debug == 3)", "	{", "		gl_FragColor = vec4(prefilteredColor, opacity);", "	}", "	else if (debug == 4)", "	{", "		gl_FragColor = vec4(diffuse, opacity);", "	}", "	else if (debug == 5)", "	{", "		gl_FragColor = vec4(specular, opacity);", "	}", "	else if (debug == 6)", "	{", "		gl_FragColor = vec4(brdf, 0.0, opacity);", "	}", "	else if (debug == 7)", "	{", "		gl_FragColor = vec4(Normal, opacity);", "	}", "	else", "	{", "		gl_FragColor = vec4(color, opacity);", "	}", "}"].join('\n');

ImageBasedLighting.cube_vs = ["varying vec3 pos;", "void main() {", "	pos = position;", "	gl_Position = projectionMatrix * mat4(mat3(viewMatrix)) * modelMatrix * vec4(position, 1.0);", "	gl_Position = gl_Position.xyww;", "}"].join('\n');

ImageBasedLighting.cube_fs = ["varying vec3 pos;", "uniform samplerCube environmentMap;", "uniform bool hdr;", "uniform float shift;", "uniform float A;", "uniform float B;", "uniform float C;", "uniform float D;", "uniform float E;", "uniform float F;", "uniform float scale;", "vec3 toneMapCanonFilmic(vec3 color)", "{", "	color *= (1.0 / shift);", "	return (((color * (A * color + C * B)) / (color * (A * color + B) + D * F))) * (1.0 / scale);",

// "	const float Shift = 1.0 / 0.18;",
// "	color *= Shift;",

// "	const float A = 0.27;",
// "	const float B = 0.29;",
// "	const float C = 0.052;",
// "	const float D = 0.2;",
// "	const float E = 0.00;",
// "	const float F = 0.18;",
// "	const float scale = 1.0/0.897105;",

// "	return (((color * (A * color + C * B)) / (color * (A * color + B) + D * F))) * scale;",
"}", "void main() {", "	vec3 envColor = textureCube(environmentMap, pos, 0.0).rgb;", "	if (hdr)", "	{", "		envColor = toneMapCanonFilmic(envColor);", "	}", "	gl_FragColor = vec4(envColor, 1.0);", "}"].join('\n');
ImageBasedLighting.irradiance_vs = ["varying vec3 pos;",
//"varying vec3 Normal;",

"void main() {", "	pos = vec3(modelMatrix * vec4(position, 1.0));",
//"	Normal = mat3(modelMatrix) * normal;",
"	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "}"].join('\n');

ImageBasedLighting.irradiance_fs = ["varying vec3 pos;", "uniform samplerCube environmentMap;",
//"uniform sampler2D HammersleyTable;",

"const float PI = 3.14159265358979;",
//"const float INV_PI = 1.0 / PI;",

"vec3 caluIrradiance(vec3 normal, vec3 up, vec3 right)", "{", "	vec3 irradiance = vec3(0.0);", "	int count = 0;", "	const int phiSampleCount = 1024;", "	const int thetaSampleCount = phiSampleCount / 4;", "	float phiDelta = 2.0 * PI / float(phiSampleCount);", "	float thetaDelta = 0.5 * PI / float(thetaSampleCount);", "	for(int i = 0; i < phiSampleCount; ++i)", "	{", "		float phi = float(i) * phiDelta;", "		for(int j = 0; j < thetaSampleCount; ++j)", "		{", "			float theta = float(j) * thetaDelta;", "			vec3 tangentSample = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));", "			vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal; ", "			irradiance += textureCube(environmentMap, sampleVec, 0.0).rgb * cos(theta) * sin(theta);", "			++count;", "		}", "	}", "	irradiance = PI * irradiance * (1.0 / float(count));", "	return irradiance;", "}", "void main()", "{", "	vec3 normal = normalize(pos);", "	vec3 up = vec3(0.0, 1.0, 0.0);", "	vec3 right = cross(up, normal);", "	up = cross(normal, right);", "	vec3 irradiance = caluIrradiance(normal, up, right);", "	gl_FragColor = vec4(irradiance, 1.0);", "}"].join('\n');

ImageBasedLighting.IrradianceMap = function (envMap, resolution) {

    this.cubeTexture = null;

    this.resolution = resolution || 32;

    this.irradianceMaterial = new THREE.ShaderMaterial({
        vertexShader: ImageBasedLighting.irradiance_vs,
        fragmentShader: ImageBasedLighting.irradiance_fs,
        uniforms: {
            environmentMap: { value: envMap }
        },

        lights: false,
        side: THREE.BackSide
    });

    this.cube = new THREE.Mesh(new THREE.BoxBufferGeometry(2.0, 2.0, 2.0), this.irradianceMaterial);
};

ImageBasedLighting.IrradianceMap.prototype.constructor = ImageBasedLighting.IrradianceMap;

ImageBasedLighting.IrradianceMap.prototype.generateMap = function (renderer, isHDR) {

    var scene = new THREE.Scene();
    scene.add(this.cube);

    var cubecamera = new THREE.CubeCamera(0.1, 10.0, this.resolution);
    if (isHDR) {
        var options = { type: THREE.FloatType, format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };
        cubecamera.renderTarget = new THREE.WebGLRenderTargetCube(this.resolution, this.resolution, options);
    }

    cubecamera.updateCubeMap(renderer, scene);
    this.cubeTexture = cubecamera.renderTarget.texture;
};
ImageBasedLighting.prefilter_vs = ["varying vec3 pos;", "varying vec3 Normal;", "void main() {", "	pos = vec3(modelMatrix * vec4(position, 1.0));", "	Normal = mat3(modelMatrix) * normal;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "}"].join('\n');

ImageBasedLighting.prefilter_fs = ["varying vec3 pos;", "varying vec3 Normal;", "uniform float roughness;", "uniform samplerCube environmentMap;", "uniform sampler2D HammersleyTable;", "const float PI = 3.14159265358979;",
//"const float INV_PI = 1.0 / PI;",

"float D_GGX(float NdotH, float roughness)", "{", "	float alpha = pow(roughness, 2.0);", "	float alpha2 = pow(alpha, 2.0);", "	return alpha2 / (PI * pow(NdotH * NdotH * (alpha2 - 1.0) + 1.0, 2.0));", "}", "vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness) ", "{", "	float a = roughness * roughness;", "	float Phi = 2.0 * PI * Xi.x; ", "	float CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y)); ", "	float SinTheta = sqrt(1.0 - CosTheta * CosTheta);", "	vec3 H;", "	H.x = SinTheta * cos(Phi); ", "	H.y = SinTheta * sin(Phi); ", "	H.z = CosTheta;", "	vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0); ", "	vec3 TangentX = normalize(cross(UpVector, N)); ", "	vec3 TangentY = cross(N, TangentX);",

// Tangent to world space
"	return normalize(TangentX * H.x + TangentY * H.y + N * H.z);", "}", "void main()", "{", "	vec3 N = normalize(pos);", "	vec3 R = N;", "	vec3 V = R;", "	const int sampleCount = 1024;", "	float totalWeight = 0.0;", "	vec3 prefilteredColor = vec3(0.0);", "	for (int i = 0; i < sampleCount; ++i) {", "		float u = float(i) / float(sampleCount);", "		vec2 Xi = vec2(u, texture2D(HammersleyTable, vec2(u)).r);", "		vec3 H = ImportanceSampleGGX(Xi, N, roughness);", "		vec3 L = normalize(2.0 * dot(V, H) * H - V);", "		float NdotL = max(dot(N, L), 0.0);", "		if(NdotL > 0.0)", "		{", "			float NdotH = max(dot(N, H), 0.0);", "			float D = D_GGX(NdotH, roughness);", "			float HdotV = max(dot(H, V), 0.0);", "			float pdf = D * NdotH / (4.0 * HdotV);", "			float resolution = 2048.0; // resolution of source cubemap (per face)", "			float solidAngleTexel= 4.0 * PI / (6.0 * resolution * resolution);", "			float solidAngleSample = 1.0 / (float(sampleCount) * pdf);", "			float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(solidAngleSample / solidAngleTexel);", "			prefilteredColor += textureCube(environmentMap, L, mipLevel).rgb * NdotL;", "			totalWeight += NdotL;", "		}", "	}", "	prefilteredColor = prefilteredColor / totalWeight;", "	gl_FragColor = vec4(prefilteredColor, 1.0);", "}"].join('\n');

ImageBasedLighting.PrefilterMap = function (envMap, hammersleyTable, resolution, maxMipLevel) {

    this.cubeTexture = null;

    this.resolution = resolution || 128;
    this.maxMipLevel = maxMipLevel || 1;

    this.prefilterMaterial = new THREE.ShaderMaterial({
        vertexShader: ImageBasedLighting.prefilter_vs,
        fragmentShader: ImageBasedLighting.prefilter_fs,
        uniforms: {
            roughness: { value: 0.0 },
            environmentMap: { value: envMap },
            HammersleyTable: { value: hammersleyTable }
        },

        lights: false,
        side: THREE.BackSide
    });

    this.cube = new THREE.Mesh(new THREE.BoxBufferGeometry(2.0, 2.0, 2.0), this.prefilterMaterial);
};

ImageBasedLighting.PrefilterMap.prototype.constructor = ImageBasedLighting.PrefilterMap;

ImageBasedLighting.PrefilterMap.prototype.generateMap = function (renderer, isHDR) {

    var scene = new THREE.Scene();
    scene.add(this.cube);

    var cubecamera = new THREE.CubeCamera(0.1, 10.0, this.resolution);
    if (isHDR) {
        var options = { type: THREE.FloatType, format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };
        cubecamera.renderTarget = new THREE.WebGLRenderTargetCube(this.resolution, this.resolution, options);
    }

    var maxLevel = this.maxMipLevel <= 1.0 ? 1.0 : this.maxMipLevel - 1.0;
    for (var i = 0; i < this.maxMipLevel; i++) {
        var width = this.resolution * Math.pow(0.5, i);
        cubecamera.renderTarget.width = cubecamera.renderTarget.height = width;

        var roughness = i / maxLevel;
        this.prefilterMaterial.uniforms.roughness.value = roughness;

        cubecamera.renderTarget.activeMipMapLevel = i;
        cubecamera.updateCubeMap(renderer, scene);
    }

    this.cubeTexture = cubecamera.renderTarget.texture;
};
/**
 * @author Nikos M. / https://github.com/foo123/
 */

// https://github.com/mrdoob/three.js/issues/5552
// http://en.wikipedia.org/wiki/RGBE_image_format

THREE.HDRLoader = THREE.RGBELoader = function (manager) {

    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};

// extend THREE.DataTextureLoader
THREE.RGBELoader.prototype = Object.create(THREE.DataTextureLoader.prototype);

// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
THREE.RGBELoader.prototype._parser = function (buffer) {

    var
    /* return codes for rgbe routines */
    RGBE_RETURN_SUCCESS = 0,
        RGBE_RETURN_FAILURE = -1,


    /* default error routine.  change this to change error handling */
    rgbe_read_error = 1,
        rgbe_write_error = 2,
        rgbe_format_error = 3,
        rgbe_memory_error = 4,
        rgbe_error = function rgbe_error(rgbe_error_code, msg) {

        switch (rgbe_error_code) {
            case rgbe_read_error:
                console.error("THREE.RGBELoader Read Error: " + (msg || ''));
                break;
            case rgbe_write_error:
                console.error("THREE.RGBELoader Write Error: " + (msg || ''));
                break;
            case rgbe_format_error:
                console.error("THREE.RGBELoader Bad File Format: " + (msg || ''));
                break;
            default:
            case rgbe_memory_error:
                console.error("THREE.RGBELoader: Error: " + (msg || ''));
        }
        return RGBE_RETURN_FAILURE;
    },


    /* offsets to red, green, and blue components in a data (float) pixel */
    RGBE_DATA_RED = 0,
        RGBE_DATA_GREEN = 1,
        RGBE_DATA_BLUE = 2,


    /* number of floats per pixel, use 4 since stored in rgba image format */
    RGBE_DATA_SIZE = 4,


    /* flags indicating which fields in an rgbe_header_info are valid */
    RGBE_VALID_PROGRAMTYPE = 1,
        RGBE_VALID_FORMAT = 2,
        RGBE_VALID_DIMENSIONS = 4,
        NEWLINE = "\n",
        fgets = function fgets(buffer, lineLimit, consume) {

        lineLimit = !lineLimit ? 1024 : lineLimit;
        var p = buffer.pos,
            i = -1,
            len = 0,
            s = '',
            chunkSize = 128,
            chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));
        while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {

            s += chunk;len += chunk.length;
            p += chunkSize;
            chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));
        }

        if (-1 < i) {

            /*for (i=l-1; i>=0; i--) {
            	byteCode = m.charCodeAt(i);
            	if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
            	else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
            	if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
            }*/
            if (false !== consume) buffer.pos += len + i + 1;
            return s + chunk.slice(0, i);
        }
        return false;
    },


    /* minimal header reading.  modify if you want to parse more information */
    RGBE_ReadHeader = function RGBE_ReadHeader(buffer) {

        var line,
            match,


        // regexes to parse header info fields
        magic_token_re = /^#\?(\S+)$/,
            gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
            exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
            format_re = /^\s*FORMAT=(\S+)\s*$/,
            dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,


        // RGBE format header struct
        header = {

            valid: 0, /* indicate which fields are valid */

            string: '', /* the actual header string */

            comments: '', /* comments found in header */

            programtype: 'RGBE', /* listed at beginning of file to identify it
                                 * after "#?".  defaults to "RGBE" */

            format: '', /* RGBE format, default 32-bit_rle_rgbe */

            gamma: 1.0, /* image has already been gamma corrected with
                        * given gamma.  defaults to 1.0 (no correction) */

            exposure: 1.0, /* a value of 1.0 in an image corresponds to
                           * <exposure> watts/steradian/m^2.
                           * defaults to 1.0 */

            width: 0, height: 0 /* image dimensions, width/height */

        };

        if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {

            return rgbe_error(rgbe_read_error, "no header found");
        }
        /* if you want to require the magic token then uncomment the next line */
        if (!(match = line.match(magic_token_re))) {

            return rgbe_error(rgbe_format_error, "bad initial token");
        }
        header.valid |= RGBE_VALID_PROGRAMTYPE;
        header.programtype = match[1];
        header.string += line + "\n";

        while (true) {

            line = fgets(buffer);
            if (false === line) break;
            header.string += line + "\n";

            if ('#' === line.charAt(0)) {

                header.comments += line + "\n";
                continue; // comment line
            }

            if (match = line.match(gamma_re)) {

                header.gamma = parseFloat(match[1], 10);
            }
            if (match = line.match(exposure_re)) {

                header.exposure = parseFloat(match[1], 10);
            }
            if (match = line.match(format_re)) {

                header.valid |= RGBE_VALID_FORMAT;
                header.format = match[1]; //'32-bit_rle_rgbe';
            }
            if (match = line.match(dimensions_re)) {

                header.valid |= RGBE_VALID_DIMENSIONS;
                header.height = parseInt(match[1], 10);
                header.width = parseInt(match[2], 10);
            }

            if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;
        }

        if (!(header.valid & RGBE_VALID_FORMAT)) {

            return rgbe_error(rgbe_format_error, "missing format specifier");
        }
        if (!(header.valid & RGBE_VALID_DIMENSIONS)) {

            return rgbe_error(rgbe_format_error, "missing image size specifier");
        }

        return header;
    },
        RGBE_ReadPixels_RLE = function RGBE_ReadPixels_RLE(buffer, w, h) {

        var data_rgba,
            offset,
            pos,
            count,
            byteValue,
            scanline_buffer,
            ptr,
            ptr_end,
            i,
            l,
            off,
            isEncodedRun,
            scanline_width = w,
            num_scanlines = h,
            rgbeStart;

        if (
        // run length encoding is not allowed so read flat
        scanline_width < 8 || scanline_width > 0x7fff ||
        // this file is not run length encoded
        2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {

            // return the flat buffer
            return new Uint8Array(buffer);
        }

        if (scanline_width !== (buffer[2] << 8 | buffer[3])) {

            return rgbe_error(rgbe_format_error, "wrong scanline width");
        }

        data_rgba = new Uint8Array(4 * w * h);

        if (!data_rgba || !data_rgba.length) {

            return rgbe_error(rgbe_memory_error, "unable to allocate buffer space");
        }

        offset = 0;pos = 0;ptr_end = 4 * scanline_width;
        rgbeStart = new Uint8Array(4);
        scanline_buffer = new Uint8Array(ptr_end);

        // read in each successive scanline
        while (num_scanlines > 0 && pos < buffer.byteLength) {

            if (pos + 4 > buffer.byteLength) {

                return rgbe_error(rgbe_read_error);
            }

            rgbeStart[0] = buffer[pos++];
            rgbeStart[1] = buffer[pos++];
            rgbeStart[2] = buffer[pos++];
            rgbeStart[3] = buffer[pos++];

            if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {

                return rgbe_error(rgbe_format_error, "bad rgbe scanline format");
            }

            // read each of the four channels for the scanline into the buffer
            // first red, then green, then blue, then exponent
            ptr = 0;
            while (ptr < ptr_end && pos < buffer.byteLength) {

                count = buffer[pos++];
                isEncodedRun = count > 128;
                if (isEncodedRun) count -= 128;

                if (0 === count || ptr + count > ptr_end) {

                    return rgbe_error(rgbe_format_error, "bad scanline data");
                }

                if (isEncodedRun) {

                    // a (encoded) run of the same value
                    byteValue = buffer[pos++];
                    for (i = 0; i < count; i++) {

                        scanline_buffer[ptr++] = byteValue;
                    }
                    //ptr += count;
                } else {

                    // a literal-run
                    scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);
                    ptr += count;pos += count;
                }
            }

            // now convert data from buffer into rgba
            // first red, then green, then blue, then exponent (alpha)
            l = scanline_width; //scanline_buffer.byteLength;
            for (i = 0; i < l; i++) {

                off = 0;
                data_rgba[offset] = scanline_buffer[i + off];
                off += scanline_width; //1;
                data_rgba[offset + 1] = scanline_buffer[i + off];
                off += scanline_width; //1;
                data_rgba[offset + 2] = scanline_buffer[i + off];
                off += scanline_width; //1;
                data_rgba[offset + 3] = scanline_buffer[i + off];
                offset += 4;
            }

            num_scanlines--;
        }

        return data_rgba;
    };

    var byteArray = new Uint8Array(buffer),
        byteLength = byteArray.byteLength;
    byteArray.pos = 0;
    var rgbe_header_info = RGBE_ReadHeader(byteArray);

    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {

        var w = rgbe_header_info.width,
            h = rgbe_header_info.height,
            image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);
        if (RGBE_RETURN_FAILURE !== image_rgba_data) {

            return {
                width: w, height: h,
                data: image_rgba_data,
                header: rgbe_header_info.string,
                gamma: rgbe_header_info.gamma,
                exposure: rgbe_header_info.exposure,
                format: THREE.RGBEFormat, // handled as THREE.RGBAFormat in shaders
                type: THREE.UnsignedByteType
            };
        }
    }
    return null;
};

/**
 * 模型浏览类
 *
 * @class  CLOUD.Viewer
 *
 */
CLOUD.Viewer = function () {
    "use strict";

    this.domElement = null;
    this.camera = null;
    this.renderer = null;

    // 增量绘制
    this.countRenderRequest = 0;
    this.maxCountRenderRequest = 10000;
    this.rendering = false;
    this.incrementRenderHandle = 0;

    this.callbacks = {};
    this.services = {};

    // this.isModelLoaded = false;

    this.tmpBox = new THREE.Box3();

    this.enableCameraNearFar = true; // 允许动态计算裁剪面
    this.currentHomeView = CLOUD.EnumStandardView.ISO; // home视图设置
    this.initialView = CLOUD.EnumStandardView.ISO; // init视图设置

    this.filter = new CLOUD.FilterManager();
    this.modelManager = new CLOUD.ModelManager(this.filter);
    this.editorManager = new CLOUD.EditorManager();

    this.isRecalculationPlanes = false;
    this.calculationPlanesBind = this.calculationPlanes.bind(this);
    this.addRenderFinishedCallback(this.calculationPlanesBind);

    // 内部 debug 使用
    // this.debugInfoDiv = null;
    // this.lastDebugInfoDivShow = false;

    this.isHDR = true;
    this.environmentCubeMap = null;
    this.cubeMesh = null;
    var scope = this;

    function initializeView() {

        scope.goToInitialView();
        scope.zoomAll();
        scope.modelManager.removeEventListener(CLOUD.EVENTS.ON_LOAD_CONFIG_FINISH, initializeView);
    }

    this.modelManager.addEventListener(CLOUD.EVENTS.ON_LOAD_CONFIG_FINISH, initializeView);
};

/**
 * @lends CLOUD.Viewer.prototype
 *
 */
CLOUD.Viewer.prototype = {

    constructor: CLOUD.Viewer,

    // ------ 注册自定义回调函数 S -------------- //
    /**
     * 注册回调函数
     *
     * @param {String} type - 回调函数类型
     * @param {function()} callback - 回调函数
     */
    addCallbacks: function addCallbacks(type, callback) {

        var list = this.callbacks[type];

        if (!list) {
            list = [];
            this.callbacks[type] = list;
        }

        if (list.indexOf(callback) === -1) {
            list.push(callback);
        }
    },

    /**
     * 取消某类型回调函数注册
     *
     * @param {String} type - 回调函数类型
     * @param {function()} callback - 回调函数
     */
    removeCallbacks: function removeCallbacks(type, callback) {

        var list = this.callbacks[type];

        if (!list) {
            return;
        }

        var index = list.indexOf(callback);

        if (index !== -1) {
            list.splice(index, 1);
        }
    },

    /**
     * 取消所有注册
     *
     */
    removeAllCallbacks: function removeAllCallbacks() {

        for (var type in this.callbacks) {

            var list = this.callbacks[type];

            for (var i = 0, length = list.length; i < length; i++) {
                list.splice(0, 1);
            }
        }

        for (var type in this.callbacks) {

            delete this.callbacks[type];
        }

        this.callbacks = {};
    },

    /**
     * 响应回调
     *
     */
    onCallbacks: function onCallbacks(type) {

        var list = this.callbacks[type];

        if (!list) {
            return;
        }

        // remark：回调函数内部注销回调会造成遍历错误，
        // 这里每次遍历都判断列表长度，实际上这样处理只是避免了系统崩溃，结果其实错误的，因为会漏掉一部分函数处理。
        // 避免回调事件函数内部注销自己(或其它函数事件)
        for (var i = 0; i < list.length; i++) {
            list[i] && list[i]();
        }
    },

    // ------ 注册自定义回调函数 E -------------- //

    // ------ 管理外部插件的render S -------------- //

    /**
     * 注册 render 回调函数
     *
     * @param {function()} callback - render 回调函数
     */
    addRenderCallback: function addRenderCallback(callback) {
        this.addCallbacks("render", callback);
    },

    /**
     * 取消 render 回调注册
     *
     * @param {function()} callback - render 回调函数
     */
    removeRenderCallback: function removeRenderCallback(callback) {
        this.removeCallbacks("render", callback);
    },

    /**
     * 响应 render 回调
     *
     */
    onRenderCallback: function onRenderCallback() {
        this.onCallbacks("render");
    },

    /**
     * 注册 render Finished
     *
     */
    addRenderFinishedCallback: function addRenderFinishedCallback(callback) {
        this.addCallbacks("renderFinished", callback);
    },

    /**
     * 取消 render Finished 注册
     *
     * @param {function()} callback - render finished 回调函数
     */
    removeRenderFinishedCallback: function removeRenderFinishedCallback(callback) {
        this.removeCallbacks("renderFinished", callback);
    },

    /**
     * 响应 render Finished
     *
     */
    onRenderFinishedCallback: function onRenderFinishedCallback() {
        this.onCallbacks("renderFinished");
    },

    // ------ 管理外部插件的render E -------------- //

    /**
     * 释放资源
     *
     */
    destroy: function destroy() {

        this.removeAllCallbacks();
        this.editorManager.unregisterDomEventListeners(this.domElement);
        this.domElement.removeChild(this.domElement.childNodes[0]);
        this.domElement = null;

        for (var id in this.services) {
            var service = this.services[id];
            service.destroy();
        }

        this.services = {};
        this.editorManager.destroy();
        this.modelManager.destroy();

        if (this.renderer && this.renderer.destroy) {
            this.renderer.destroy();
        }

        this.renderer = null;
        this.modelManager = null;
        this.editorManager = null;
    },

    /**
     * 初始化
     *
     * @param {dom} domElement - dom容器
     */
    init: function init(domElement) {

        console.log("Web3D: " + CLOUD.Version);

        var scope = this;
        this.domElement = domElement;

        var incrementRenderEnabled = CLOUD.GlobalData.IncrementRender;
        var maxDrawCacheNum = CLOUD.GlobalData.maxDrawCacheNum;
        var settings = { alpha: true, preserveDrawingBuffer: true, antialias: true, maxDrawCacheNum: maxDrawCacheNum };

        //if (!CLOUD.GlobalData.disableAntialias)
        //    settings.antialias = true;

        var canvas;

        try {
            canvas = document.createElement('canvas');
            var webglContext = canvas.getContext('webgl', settings) || canvas.getContext('experimental-webgl', settings);

            if (!webglContext) {
                settings.antialias = false;
            }
        } catch (e) {
            return false;
        }

        CLOUD.GeomUtil.initializeUnitInstances();

        settings.canvas = canvas;

        if (incrementRenderEnabled) {
            this.renderer = new THREE.WebGLRendererByIncrement(settings);
            this.orderedRenderer = new CLOUD.OrderedRenderer(this.filter);
            this.renderer.setRenderer(this.orderedRenderer);
            this.renderer.setRenderTicket(0);
        } else {
            this.renderer = new THREE.WebGLRenderer(settings);
            CLOUD.GlobalData.IncrementRender = false;
        }

        this.renderer.domElement.addEventListener("webglcontextlost", function (event) {
            event.preventDefault();
            if (scope.incrementRenderHandle > 0) {
                cancelAnimationFrame(scope.incrementRenderHandle);
                console.log("---------------- webglcontextlost --------------");
            }
        }, false);

        // window.innerWidth, window.innerHeight
        var viewportWidth = domElement.offsetWidth;
        var viewportHeight = domElement.offsetHeight;

        this.renderer.setClearColor(0x000000, 0);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(viewportWidth, viewportHeight);

        this.renderer.toneMapping = CLOUD.GlobalData.ToneMapping;

        // Added by xmh begin
        // 允许获得焦点，将键盘事件注册到父容器（之前注册到window上会存在各种联动问题），鼠标点击父容器，激活canvas
        this.renderer.domElement.setAttribute('tabindex', '0');
        this.renderer.domElement.setAttribute('id', 'cloud-main-canvas');
        // Added by xmh end
        this.domElement.appendChild(this.renderer.domElement);

        // Camera
        this.camera = new CLOUD.Camera(viewportWidth, viewportHeight, 45, 0.1, CLOUD.GlobalData.SceneSize * 20.0);
        var camera = this.camera;
        this.cameraControl = new CLOUD.CameraControl(this, camera, domElement, function () {
            scope.render();
        });

        this.setEditorDefault();

        // Register Events
        this.editorManager.registerDomEventListeners(this.domElement);

        this.modelManager.onUpdateViewer = function () {
            scope.render(true);
        };

        // this.goToInitialView();
        if (CLOUD.GlobalData.IBL) {
            this.loadIBLcfg("data/IBLConfig.json");
        }

        //this.editorManager.registerDomEventListeners(canvas);
        return true;
    },

    /**
     *  刷新渲染模型
     *
     */
    render: function render() {

        // console.time("viewer.render");
        var scope = this;
        var camera = this.camera;
        var modelManager = this.modelManager;
        var renderer = this.renderer;
        var scene = this.getScene();
        var incrementRenderEnabled = CLOUD.GlobalData.IncrementRender;

        // 没有模型加载,返回
        if (!this.isModelLoaded) {

            if (modelManager.hasModel()) {
                this.isModelLoaded = true;
            } else {
                CLOUD.Logger.log("model not loaded!");
                return;
            }
        }

        if (CLOUD.GlobalData.IBL && this.getScene().iblProbe != null && !this.getScene().iblProbe.isComputed) {
            return;
        }

        // 增量绘制
        if (incrementRenderEnabled) {
            // 设置更新状态

            var incrementRender = function incrementRender(callId, autoClear) {

                var renderId = callId;

                return function () {

                    // var renderer = scope.renderer;
                    renderer.autoClear = autoClear;

                    if (scope.editorManager.cameraChange) {

                        renderer.resetIncrementRender(); // 重置增量绘制状态
                        renderer.autoClear = true;
                        scope.editorManager.cameraChange = false;
                    } else {

                        renderer.autoClear = autoClear;
                    }

                    // var timeTag = "IncrementRender_";
                    // timeTag += renderId;

                    // console.time(timeTag);

                    var isFinished = renderer.render(scene, camera);

                    // console.timeEnd(timeTag);

                    if (!isFinished && renderId === scope.countRenderRequest) {

                        scope.incrementRenderHandle = requestAnimationFrame(incrementRender(renderId, false));
                    } else {

                        scope.rendering = false;

                        // CLOUD.Logger.timeEnd("incrementRender");

                        if (renderId !== scope.countRenderRequest) {
                            scope.render();
                        } else {

                            // console.log("------------ finished rendering ------------");
                            // 结束后回调函数
                            scope.onRenderFinishedCallback();
                        }
                    }
                };
            };

            ++this.countRenderRequest;

            if (this.countRenderRequest > this.maxCountRenderRequest) this.countRenderRequest = 0;

            if (this.rendering) {
                return;
            }

            this.rendering = true;

            // update camera's inner/outer status, both "calculateNearFar" and "prepareScene" will use this info.
            modelManager.calculateCameraModelRelation(camera.position);

            this.calculateNearFar();

            for (var sid in this.services) {
                var service = this.services[sid];
                service.update(camera);
            }

            scene.updateLights(camera);

            var isUpdateRenderList = this.editorManager.isUpdateRenderList;

            renderer.resetIncrementRender(); // 重置增量绘制状态
            renderer.setObjectListUpdateState(isUpdateRenderList);

            this.incrementRenderHandle = requestAnimationFrame(incrementRender(scope.countRenderRequest, true));

            if (isUpdateRenderList) {
                modelManager.prepareScene(camera);
            }

            this.onRenderCallback();
        } else {
            // 正常绘制

            this.calculateNearFar();
            scene.updateLights(camera);
            modelManager.prepareScene(camera);
            CLOUD.Logger.time("webgl render");
            renderer.render(scene, camera);
            CLOUD.Logger.timeEnd("webgl render");
            this.onRenderCallback();
            this.onRenderFinishedCallback(); // 结束后回调函数
        }

        // console.timeEnd("viewer.render");
    },

    /**
     * 窗口大小变化回调事件
     *
     * @param {Number} width - 窗口宽
     * @param {Number} height - 窗口高
     */
    resize: function resize(width, height) {

        var camera = this.camera;
        camera.setSize(width, height);
        camera.updateProjectionMatrix();

        this.renderer.setSize(width, height);
        this.editorManager.resize();
        this.onCallbacks("resize");
        this.render();
    },

    /**
     * 动态计算相机远近裁剪面
     *
     */
    calculateNearFar: function calculateNearFar() {

        var scene = this.getScene();
        var boundingBox = scene.getBoundingBoxWorld();
        var camera = this.camera;

        // reducing z-fighting by dynamically adjust near/far
        if (boundingBox != null) {

            var box = this.tmpBox;
            box.copy(boundingBox);
            box.applyMatrix4(scene.getMatrixGlobal());

            var target = box.getCenter();
            var position = camera.position;

            var newPos = position.clone().sub(target);
            var length = newPos.length();

            var maxLength = Math.sqrt((box.max.x - box.min.x) * (box.max.x - box.min.x) + (box.max.y - box.min.y) * (box.max.y - box.min.y) + (box.max.z - box.min.z) * (box.max.z - box.min.z));

            if (this.modelManager.containsCamera || !this.enableCameraNearFar) {

                camera.setNearFar(0.1, maxLength);
            } else {
                var delta = 0.001;
                var zNear = (length * length + length * delta) / ((1 << 24) * delta);

                camera.setNearFar(zNear, length + maxLength / 2);
            }
        }
    },

    /**
     *  注册Dom事件
     *
     */
    registerDomEventListeners: function registerDomEventListeners() {
        if (this.domElement) {
            this.editorManager.registerDomEventListeners(this.domElement);
        }
    },

    /**
     *  取消Dom事件
     *
     */
    unregisterDomEventListeners: function unregisterDomEventListeners() {
        if (this.domElement) {
            this.editorManager.unregisterDomEventListeners(this.domElement);
        }
    },

    /**
     *  注册模型事件监听器
     *
     */
    registerEventListener: function registerEventListener(type, callback) {
        this.modelManager.addEventListener(type, callback);
    },

    /**
     * 加载模型
     *
     * @param {String} databagId - 模型包名
     * @param {String} serverUrl - 服务器地址
     * @param {Boolean} notifyProgress - 是否通知加载进度，默认true
     * @param {Boolean} debug - 是否调试，可选
     */
    load: function load(databagId, serverUrl, notifyProgress, debug) {

        notifyProgress = notifyProgress || true;

        return this.modelManager.load({
            databagId: databagId,
            serverUrl: serverUrl,
            notifyProgress: notifyProgress,
            debug: debug
        });
    },

    /**
     * 卸载模型
     *
     * @param {String} databagId - 模型包名
     */
    unload: function unload(databagId) {

        var success = this.modelManager.unload(databagId);

        if (success) {
            this.render();
        }
    },

    /**
     * 卸载所有模型
     *
     */
    unloadAll: function unloadAll() {

        this.modelManager.unloadAll();
        this.render();
    },

    /**
     * 显示指定模型
     *
     * @param {String} databagId - 模型包名
     */
    showModel: function showModel(databagId) {

        var success = this.modelManager.showModel(databagId);

        if (success) {
            this.render();
        }
    },

    /**
     * 隐藏指定模型
     *
     * @param {String} databagId - 模型包名
     */
    hideModel: function hideModel(databagId) {

        var success = this.modelManager.hideModel(databagId);

        if (success) {
            this.render();
        }
    },

    /**
     * 隐藏或显示模型
     *
     * @param {Object} model - 模型对象
     *@param {Boolean} bVisible - 是否可见
     */
    showScene: function showScene(model, bVisible) {

        if (model) {

            model.setVisible(bVisible);
            this.render();
        }
    },

    /**
     * 清除场景数据
     *
     */
    clearAll: function clearAll() {
        this.getScene().clearAll();
    },

    /**
     * 获得场景对象
     *
     */
    getScene: function getScene() {
        return this.modelManager.scene;
    },

    /**
     * 获得过滤器对象
     *
     */
    getFilters: function getFilters() {
        return this.filter;
    },

    /**
     * 获得当前 Editor 名字标识
     *
     * @return {String} Editor 名字标识
     */
    getCurrentEditorName: function getCurrentEditorName() {
        return this.editorManager.getCurrentEditorName();
    },

    /**
     * 获得 Editor 模式
     *
     * @returns {Object} Editor 模式
     */
    getCurrentEditorMode: function getCurrentEditorMode() {

        return this.editorManager.getCurrentEditorMode();
    },

    /**
     * 设置 Editor 模式
     *
     * @param {String} name - Editor 名字标识 {@link CLOUD.EditorMode}
     */
    setEditorMode: function setEditorMode(name) {
        this.editorManager.setEditorMode(this, name);
        this.render();
    },

    /**
     * 设置缺省的Editor模式（框选模式 - RectPick Editor）
     *
     */
    setEditorDefault: function setEditorDefault() {
        this.setEditorMode(CLOUD.EditorMode.PICK_BY_RECT);
    },

    /**
     * 设置单选模式 - Pick Editor
     *
     */
    setPickMode: function setPickMode() {
        console.warn('CLOUD.Viewer.setPickMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.PICK);
    },

    /**
     * 设置框选模式 - RectPick Editor
     *
     */
    setRectPickMode: function setRectPickMode() {
        console.warn('CLOUD.Viewer.setRectPickMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.PICK_BY_RECT);
    },

    /**
     * 设置自由旋转模式 - Orbit Editor
     *
     */
    setOrbitMode: function setOrbitMode() {
        console.warn('CLOUD.Viewer.setOrbitMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.ORBIT);
    },

    /**
     * 设置缩放模式 - Zoom Editor
     *
     */
    setZoomMode: function setZoomMode() {
        console.warn('CLOUD.Viewer.setZoomMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.ZOOM);
    },

    /**
     * 设置框选缩放模式 - RectZoom Editor
     *
     */
    setRectZoomMode: function setRectZoomMode() {
        console.warn('CLOUD.Viewer.setRectZoomMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.ZOOM_BY_RECT);
    },

    /**
     * 设置平移模式 - Pan Editor
     *
     */
    setPanMode: function setPanMode() {
        console.warn('CLOUD.Viewer.setPanMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.PAN);
    },

    /**
     * 设置飞行模式 - Fly Editor
     *
     */
    setFlyMode: function setFlyMode() {
        console.warn('CLOUD.Viewer.setFlyMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.FLY);
    },

    /**
     * 设置切面模式 - ClipPlanes Editor
     *
     */
    setClipPlanesMode: function setClipPlanesMode() {
        console.warn('CLOUD.Viewer.setClipPlanesMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.CLIP_BY_BOX);
    },

    /**
     * 获得场景包围盒(变换前)
     *
     * @return {THREE.Box3} 场景包围盒
     */
    getBoundingBoxWorld: function getBoundingBoxWorld() {
        return this.getScene().getBoundingBoxWorld();
    },

    /**
     * 获得场景包围盒(变换后)
     *
     * @return {THREE.Box3} 场景包围盒
     */
    getBoundingBox: function getBoundingBox() {
        return this.getScene().getBoundingBox();
    },

    /**
     * 放大
     *
     * @param {Number} factor - 放大因子
     */
    zoomIn: function zoomIn(factor) {
        this.editorManager.zoomIn(factor, this);
    },

    /**
     * 缩小
     *
     * @param {Number} factor - 缩小因子
     */
    zoomOut: function zoomOut(factor) {
        this.editorManager.zoomOut(factor, this);
    },

    /**
     * 缩放到场景包围盒大小
     *
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    zoomAll: function zoomAll(margin, ratio) {
        var box = this.getScene().getBoundingBox();
        this.editorManager.zoomToBBox(this, box, margin, ratio);
    },

    /**
     * 缩放到场景内部包围盒大小
     *
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    zoomToBuilding: function zoomToBuilding(margin, ratio) {

        this.zoomAll(margin, ratio);
    },

    /**
     * 缩放到选中构件包围盒大小
     *
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    zoomToSelection: function zoomToSelection(margin, ratio) {
        var box = this.renderer.computeSelectionBBox();

        if (box == null || box.isEmpty()) {
            box = this.getScene().getBoundingBox();
        }

        this.editorManager.zoomToBBox(this, box, margin, ratio);
    },

    /**
     * 缩放到指定包围包围盒大小
     *
     * @param {THREE.Box3} box - 包围盒（世界坐标系）
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    zoomToBBox: function zoomToBBox(box, margin, ratio) {

        if (!box) {
            box = this.getScene().getBoundingBox();
        } else {
            box.applyMatrix4(this.getScene().getMatrixGlobal());
        }

        this.editorManager.zoomToBBox(this, box, margin, ratio);
    },

    /**
     * 根据观察方向缩放到指定包围盒范围
     *
     * @param {THREE.Box3} box - 包围盒（世界坐标系）
     * @param {THREE.Vector3} direction - 观察方向（从包围盒中心指向某个参考点）
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    zoomToBBoxByDirection: function zoomToBBoxByDirection(box, direction, margin, ratio) {

        if (!direction) {
            this.zoomToBBox(box, margin, ratio);
            return;
        }

        if (direction && box) {
            var zoomBox = box.clone();
            var refPoint = zoomBox.getCenter().clone().add(direction);

            zoomBox.applyMatrix4(this.getScene().getMatrixGlobal());
            refPoint.applyMatrix4(this.getScene().getMatrixGlobal());

            var newDirection = refPoint.clone().sub(zoomBox.getCenter());

            if (newDirection.length() > 0.0001) {
                newDirection.normalize();
                viewer.camera.realUp.copy(THREE.Object3D.DefaultUp); // 先调整相机up方向,使得一直朝上
                this.editorManager.zoomToBBox(this, zoomBox, margin, ratio, newDirection);
            } else {
                this.editorManager.zoomToBBox(this, zoomBox, margin, ratio);
            }
        }
    },

    /**
     * 根据外围大包围盒和指定包围盒缩放到指定包围盒范围
     *
     * @param {THREE.Box3} box - 指定构件包围盒（世界坐标系）
     * @param {THREE.Box3} outerBox - 外围大包围盒
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    zoomToBBoxWithOuterBox: function zoomToBBoxWithOuterBox(box, outerBox, margin, ratio) {

        if (!outerBox) {
            this.zoomToBBox(box, margin, ratio);
            return;
        }

        if (outerBox && box) {
            var zoomBox = box.clone();
            var refPoint = outerBox.getCenter();

            zoomBox.applyMatrix4(this.getScene().getMatrixGlobal());
            refPoint.applyMatrix4(this.getScene().getMatrixGlobal());

            var newDirection = refPoint.clone().sub(zoomBox.getCenter());

            if (newDirection.length() > 0.0001) {
                newDirection.normalize();
                this.camera.realUp.copy(THREE.Object3D.DefaultUp); // 先调整相机up方向,使得一直朝上
                this.editorManager.zoomToBBox(this, zoomBox, margin, ratio, newDirection);
            } else {
                this.editorManager.zoomToBBox(this, zoomBox, margin, ratio);
            }
        }
    },

    /**
     * 设置视角
     *
     * @param {Number} stdView - 视角（CLOUD.EnumStandardView.ISO， CLOUD.EnumStandardView.Top etc）
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Function} callback() - 回调函数
     */
    setStandardView: function setStandardView(stdView, margin, callback) {

        // var scene = this.getScene();
        //
        // if (scene.isLoaded()) {
        //     this.editorManager.setStandardView(stdView, this, margin, callback);
        // } else {
        //     this.camera.setStandardView(stdView);
        // }

        this.editorManager.setStandardView(stdView, this, margin, callback);
    },

    /**
     * 根据指定视角及包围盒缩放
     *
     * @param {Number} stdView - 视角（CLOUD.EnumStandardView.ISO， CLOUD.EnumStandardView.Top etc）
     * @param {THREE.Box3} box - 原始（未变换的）世界包围盒
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    setStandardViewWithBox: function setStandardViewWithBox(stdView, box, margin, ratio) {

        if (box) {
            box.applyMatrix4(this.getScene().getMatrixGlobal());
        } else {
            box = this.getScene().getBoundingBox();
        }

        this.editorManager.setStandardViewWithBox(this, stdView, box, margin, ratio);
    },

    /**
     * 根据 Top 视角及包围盒缩放(注意：这里名字有误导， 其实被设成了 ISO 视角)
     *
     * @param {THREE.Box3} box - 原始（未变换的）世界包围盒
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    setTopView: function setTopView(box, margin, ratio) {
        this.setStandardViewWithBox(CLOUD.EnumStandardView.ISO, box, margin, ratio);
    },

    /**
     * 设置初始视角
     *
     * @param {Number} viewType - 视角（CLOUD.EnumStandardView.ISO， CLOUD.EnumStandardView.Top etc）
     */
    setInitialViewType: function setInitialViewType(viewType) {

        console.warn('CLOUD.Viewer.setInitialViewType() has been deprecated. Use CLOUD.Viewer.setInitialView() instead.');
        this.setInitialView(viewType);
    },

    /**
     * 设置初始视角
     *
     * @param {Number} viewType - 视角（CLOUD.EnumStandardView.ISO， CLOUD.EnumStandardView.Top etc）
     */
    setInitialView: function setInitialView(viewType) {
        this.initialView = viewType;
    },

    /**
     * 切换到初始视图
     *
     */
    goToInitialView: function goToInitialView(margin) {
        this.setStandardView(this.initialView, margin, null);
    },

    /**
     * 设置 home 视图类型
     *
     * @param {Number} viewType - 视角（CLOUD.EnumStandardView.ISO， CLOUD.EnumStandardView.Top etc）
     */
    setHomeViewType: function setHomeViewType(viewType) {
        console.warn('CLOUD.Viewer.setHomeViewType() has been deprecated. Use CLOUD.Viewer.setHomeView() instead.');
        this.setHomeView(viewType);
    },

    /**
     * 设置 home 视图类型
     *
     * @param {Number} viewType - 视角（CLOUD.EnumStandardView.ISO， CLOUD.EnumStandardView.Top etc）
     */
    setHomeView: function setHomeView(viewType) {
        this.currentHomeView = viewType;
    },

    /**
     * 切换到 home 视图
     *
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.05
     */
    goToHomeView: function goToHomeView(margin) {
        this.setStandardView(this.currentHomeView, margin, null);
    },

    /**
     * 设置相机观察点
     *
     * @param {THREE.Vector3} position - 相机位置
     * @param {THREE.Vector3} target - 相机观察目标位置
     * @param {THREE.Vector3} up - 相机向上位置
     */
    lookAt: function lookAt(position, target, up) {
        var dir = new THREE.Vector3();
        dir.subVectors(target, position);

        this.camera.LookAt(target, dir, up);
        this.cameraControl.updateCamera(target);
        this.render();
    },

    /**
     * 设置图片资源的路径。默认在“images/”
     *
     * @param {String} path - 资源路径
     */
    setImageResPath: function setImageResPath(path) {
        CLOUD.GlobalData.TextureResRoot = path;
    },

    /**
     * 设置场景中所有灯光的光照强度的调整系数
     *
     * @param {Number} factor - 灯光强度系数
     */
    setLightIntensityFactor: function setLightIntensityFactor(factor) {
        CLOUD.GlobalData.LightIntensityFactor = factor;
    },

    /**
     * 设置每帧的最大耗时
     *
     * @param {Number} limitTime - 最长时间
     */
    setLimitFrameTime: function setLimitFrameTime(limitTime) {
        if (CLOUD.GlobalData.IncrementRender) {

            if (limitTime <= 0) {
                limitTime = 30;
            }

            CLOUD.GlobalData.LimitFrameTime = limitTime;
        }
    },

    /**
     * 限制帧率
     *
     * @param {Number} frameRate - 最大帧率
     */
    limitFrameRate: function limitFrameRate(frameRate) {

        if (CLOUD.GlobalData.IncrementRender) {

            if (frameRate <= 0) {
                frameRate = 4;
            }

            CLOUD.GlobalData.LimitFrameTime = 1000 / frameRate;
        }
    },

    /**
     * 相机变换 - 将世界系相机位置变化到绘图空间
     *
     * @param {Object} camera - 相机状态JSON对象
     *                          （{"position":"26513.603437903, -14576.4810728955, 15107.6582255056",
     *                          "direction":"-220.050259546712, 169.277369901229, -125.801809656091",
     *                          "up":"0, 0, 304.8"})
     * @return {Object} 新相机信息
     */
    transformCamera: function transformCamera(camera) {
        return CLOUD.CameraUtil.transformCamera(camera, this.modelManager.scene);
    },

    /**
     * 获得世界空间的相机状态
     *
     * @return {String} 相机信息字符串
     */
    getCamera: function getCamera() {
        // return this.cameraControl.getCameraInfo();

        var scene = this.getScene();
        var matrixScene = scene.getMatrixGlobal();

        var camera = this.cameraControl.getCamera();
        var camInfo = new CLOUD.CameraInfo(camera.position, camera.target, camera.up);

        camInfo = CLOUD.Camera.drawingToWorld(camInfo, matrixScene);

        var newCameraInfo = new CLOUD.CameraInfo(camInfo.position, camInfo.target, camInfo.up);

        return JSON.stringify(newCameraInfo);
    },

    /**
     * 设置世界空间(兼容绘图空间，无版本号的数据为绘图空间数据)的相机状态
     *
     * @param {String} jsonStr - 相机信息字符串
     */
    setCamera: function setCamera(jsonStr) {

        // var camInfo = CLOUD.CameraUtil.parseCameraInfo(jsonStr);
        // this.lookAt(camInfo.position, camInfo.target, camInfo.up);

        var camInfo = CLOUD.CameraUtil.parseCameraInfo(jsonStr);

        if (camInfo.version) {

            var scene = this.getScene();
            var matrixScene = scene.getMatrixGlobal();
            camInfo = CLOUD.Camera.worldToDrawing(camInfo, matrixScene);
        }

        this.lookAt(camInfo.position, camInfo.target, camInfo.up);
    },

    /**
     * 获得render buffer base64图形数据
     *
     * @param {Color} backgroundClr - 背景颜色
     * @param {Function} callback - 回调函数（参数为截取的 base64 图形数据）
     * @return {String} 如果存在回调函数，则返回 null， 否则 返回 base64 图形数据
     */
    getRenderBufferScreenShot: function getRenderBufferScreenShot(backgroundClr, callback) {

        // 在高分屏上toDataURL直接获得图片数据比实际的图片大
        var domElement = this.renderer.domElement;
        var dataUrl = domElement.toDataURL("image/png");
        var canvasWidth = domElement.width;
        var canvasHeight = domElement.height;
        var pixelRatio = window.devicePixelRatio || 1;
        var w = canvasWidth / pixelRatio;
        var h = canvasHeight / pixelRatio;

        if (!w || !h) {

            if (callback) {
                callback(dataUrl);
                return null;
            } else {
                return dataUrl;
            }
        }

        var nw,
            nh,
            nx = 0,
            ny = 0;

        if (w > h || canvasWidth / canvasHeight < w / h) {
            nw = w;
            nh = canvasHeight / canvasWidth * w;
            ny = h / 2 - nh / 2;
        } else {
            nh = h;
            nw = canvasWidth / canvasHeight * h;
            nx = w / 2 - nw / 2;
        }

        if (callback) {

            var newImage = new Image();
            newImage.onload = function () {

                var tmpCanvas = document.createElement("canvas");
                var ctx = tmpCanvas.getContext("2d");
                tmpCanvas.width = w;
                tmpCanvas.height = h;

                if (backgroundClr) {
                    ctx.fillStyle = backgroundClr;
                    ctx.fillRect(0, 0, w, h);
                }

                ctx.drawImage(newImage, nx, ny, nw, nh);

                var newURL = tmpCanvas.toDataURL("image/png");

                callback(newURL);
            };

            newImage.src = dataUrl;

            return null;
        }

        var newImage = new Image();

        newImage.src = dataUrl;

        var tmpCanvas = document.createElement("canvas");
        var ctx = tmpCanvas.getContext("2d");
        tmpCanvas.width = w;
        tmpCanvas.height = h;

        if (backgroundClr) {
            ctx.fillStyle = backgroundClr;
            ctx.fillRect(0, 0, w, h);
        }

        ctx.drawImage(newImage, nx, ny, nw, nh);

        var newURL = tmpCanvas.toDataURL("image/png");

        return newURL;
    },

    /**
     * 截取指定大小的base64图形
     *
     * @param {Number} width - 截图宽度
     * @param {Number} height - 背景颜色
     * @param {Function} callback - 回调函数（参数为截取的 base64 图形数据）
     * @return {String} 如果存在回调函数，则返回 null， 否则 返回 base64 图形数据
     */
    screenShot: function screenShot(width, height, callback) {
        var scope = this;

        function getRenderBufferScreenShot(width, height, callback) {
            var domElement = scope.renderer.domElement;
            var dataUrl = domElement.toDataURL("image/png");
            var canvasWidth = domElement.width;
            var canvasHeight = domElement.height;
            var pixelRatio = window.devicePixelRatio || 1;
            var w = width;
            var h = height;

            if (!w || !h) {
                if (callback) {
                    callback(dataUrl);
                    return null;
                } else {
                    return dataUrl;
                }
            }

            var nw,
                nh,
                nx = 0,
                ny = 0;

            if (w > h || canvasWidth / canvasHeight < w / h) {
                nw = w;
                nh = canvasHeight / canvasWidth * w;
                ny = h / 2 - nh / 2;
            } else {
                nh = h;
                nw = canvasWidth / canvasHeight * h;
                nx = w / 2 - nw / 2;
            }

            if (callback) {

                var newImage = new Image();
                newImage.onload = function () {

                    var tmpCanvas = document.createElement("canvas");
                    var ctx = tmpCanvas.getContext("2d");
                    tmpCanvas.width = w;
                    tmpCanvas.height = h;
                    ctx.drawImage(newImage, nx, ny, nw, nh);

                    var newURL = tmpCanvas.toDataURL("image/png");
                    callback(newURL);
                };

                newImage.src = dataUrl;

                return null;
            }
        }

        var dataUrl = getRenderBufferScreenShot(width, height, callback);

        this.render();

        return dataUrl;
    },

    /**
     * 获得render buffer base64图形数据
     *
     * @param {Color} backgroundClr - 背景颜色
     * @param {Function} callback(dataUrl) - 回调函数（参数为截取的 base64 图形数据）
     * @return {String} 如果存在回调函数，则返回 null， 否则 返回 base64 图形数据
     */
    canvas2image: function canvas2image(backgroundClr, callback) {

        var dataUrl;
        var scope = this;

        if (callback) {

            this.getRenderBufferScreenShot(backgroundClr, function (dataUrl) {

                callback(dataUrl);

                // 每次获得截图后，缓存数据貌似被清除了
                // 所以在每次调用后render一次
                scope.render();
            });
        } else {

            dataUrl = this.getRenderBufferScreenShot(backgroundClr);
            // 在chrome中多调用几次，会出现图片显示不正常（显示空白，原因是转换的值变得不正常了），
            // 每次获得截图后，缓存数据貌似被清除了
            // 所以在每次调用后render一次
            this.render();

            return dataUrl;
        }

        return null;
    },

    /**
     * 是否锁定Z轴
     *
     * @param {Boolean} isLock - true 锁定， 否则 解锁
     */
    lockAxisZ: function lockAxisZ(isLock) {

        if (this.cameraControl) {
            this.cameraControl.lockAxisZ(isLock);
        }
    },

    /**
     * 允许双击半透明
     *
     * @param {Boolean} enable - true 允许
     */
    enableTranslucentByDClick: function enableTranslucentByDClick(enable) {
        CLOUD.GlobalData.EnableDemolishByDClick = enable;
    },

    /**
     * 是否禁止旋转
     *
     * @param {Boolean} enable - true 禁止
     */
    disableRotate: function disableRotate(disable) {

        if (this.cameraControl) {
            this.cameraControl.disableRotate(disable);
        }
    },

    /**
     *  旋转照相机
     *
     * @param {THREE.Vector2} rotationDelta - rotation value, pixel value in the screen coordinate
     */
    rotateCamera: function rotateCamera(rotationDelta) {
        this.cameraControl.processRotate(rotationDelta);
    },

    /**
     * 取得照相机信息，包括照相机的朝向和up轴方向
     */
    getActiveCameraInfo: function getActiveCameraInfo() {
        var info = {};
        info.up = new THREE.Vector3();
        info.dir = new THREE.Vector3();

        var mainCamera = this.camera;

        // 获得相机方向向量
        var dir = mainCamera.getWorldDirection();

        info.up.copy(mainCamera.realUp || mainCamera.up);
        info.dir.copy(dir);

        return info;
    },

    /**
     * 计算切面
     *
     */
    calculationPlanes: function calculationPlanes() {

        if (this.isRecalculationPlanes) {
            this.isRecalculationPlanes = false;
            var scene = this.getScene();
            var box = this.renderer.computeRenderObjectsBox();
            scene.getClipPlanes().calculationPlanes(box.getSize(), box.getCenter());
            this.render();
        }
    },

    /**
     * 重置切面状态
     *
     */
    recalculationPlanes: function recalculationPlanes() {
        this.isRecalculationPlanes = true;
    },

    /**
     * 设置octree 深度
     *
     * @param {Number} depth - 深度
     */
    setOctantDepth: function setOctantDepth(depth) {
        CLOUD.GlobalData.OctantDepth = depth;
    },

    /**
     * 重置对象池大小
     *
     * @param {Number} size - 对象池对象数
     */
    resizePool: function resizePool(size) {
        CLOUD.GlobalData.maxObjectNumInPool = size;
        this.modelManager.updateModelRenderable();
    },

    /**
     * 设置高优先级
     *
     * @param {Array} categories - 高优先级category
     * @param {Number} region - 内外部（0：内部，1：外部）
     */
    setCategoriesToHighPriority: function setCategoriesToHighPriority(categories, region) {
        var side = region == 0 ? "inner" : "outer";
        this.modelManager.setCategoriesToHighPriority(categories, side);
    },

    /**
     * 清除内部或者外部 category 高优先级
     *
     * @param {Number} region - 内外部（0：内部，1：外部）
     */
    clearCategoriesFromHighPriority: function clearCategoriesFromHighPriority(region) {
        var side = region == 0 ? "inner" : "outer";
        this.modelManager.clearCategoriesFromHighPriority(side);
    },

    /**
     * 清除内外部 category 高优先级
     *
     */
    clearAllCategoriesFromHighPriority: function clearAllCategoriesFromHighPriority() {
        this.modelManager.clearAllCategoriesFromHighPriority();
    },

    /**
     * 按条件隔离构件
     *
     * @param {Array} conditions    - 多个条件对象数组，单个数组取交集，多个数组取并集
     *                                  [{"categoryId":-2001340},{"specialty":"AR"},{"categoryId":-2321500,"levelName":"F03"}]
     * @param {String} state        - 隔离的方式 "hide"：其他隐藏，"translucent"：其他半透明
     */
    isolate: function isolate(conditions, state) {

        var filter = this.getFilters();

        switch (state) {
            case "hide":
                filter.setIsolateConditions(conditions, CLOUD.EnumIsolateState.HIDDEN_OTHERS);
                break;
            case "translucent":
                filter.setIsolateConditions(conditions, CLOUD.EnumIsolateState.TRANSLUCENT_OTHERS);
                break;
            default:
                console.log("no this isolate state : " + state);
                break;
        }
    },

    /**
     * 设置隔离构件材质
     *
     * @param {Object} params - 材质参数
     *         params = {color: 0x888888, opacity: 0.1, transparent: true, side: THREE.DoubleSide}
     */
    setIsolateMaterial: function setIsolateMaterial(params) {

        var filter = this.getFilters();
        filter.setIsolateMaterial(params);
    },

    /**
     * 重置隔离材质
     *
     */
    resetIsolateMaterial: function resetIsolateMaterial() {

        var filter = this.getFilters();
        filter.resetIsolateMaterial();
    },

    /**
     * 设置左右键
     *
     * @param {String} button - 左右键标识 ("left"," right")
     */
    setOrbitButton: function setOrbitButton(button) {

        if (button === "left") {

            this.editorManager.updateButtons({
                ORBIT: THREE.MOUSE.LEFT,
                PAN2: THREE.MOUSE.MIDDLE,
                PAN: THREE.MOUSE.RIGHT
            });
        } else if (button === "right") {

            this.editorManager.updateButtons({
                ORBIT: THREE.MOUSE.RIGHT,
                PAN2: THREE.MOUSE.MIDDLE,
                PAN: THREE.MOUSE.LEFT
            });
        }
    },

    /**
     * 显示轴网信息
     *
     * @param {Object} intersect - 相交信息对象, 来源pick, 参考ON_CLICK_PICK事件的返回对象
     */
    showPickedInformation: function showPickedInformation(intersect) {

        CLOUD.UIHelper.showPickedInformation(intersect);
    },

    //callback函数中只包含一个intersect参数，intersect是一个对象包含以下变量
    //databagId, distance, face, faceIndex, object:MeshEx, point userId, worldBoundingBox, worldPosition
    setSelectPadCallback: function setSelectPadCallback(callback) {

        //var selectPad = this.editorManager.editors[CLOUD.BaseEditor.EditorType.PickWithRect].selectPad;

        var editor = this.editorManager.editors[CLOUD.EditorMode.PICK_BY_RECT];

        if (editor && editor.selectPad) {
            editor.selectPad.callback = callback;
        }
    },
    /**
     * 设置客户端设备是否是移动端，
     *
     * @param isMobile, true 表示客户端运行在移动设备上。false 表示非移动端（一般指PC）
     */
    setDeviceMobile: function setDeviceMobile(isMobile) {
        CLOUD.GlobalData.IsMobile = isMobile || false;
    },

    /**
     * 设置绕点旋转模式
     *
     * @param {Number} mode - 模式 参见CLOUD.PointRotateMode
     */
    setPointRotateMode: function setPointRotateMode(mode) {

        if (this.cameraControl) {
            this.cameraControl.setPointRotateMode(mode);
        }
    },

    /**
     * 世界坐标转绘图空间(场景变换后)坐标
     *
     * @param {object} point - 世界坐标下的点集 {x:0, y:0, z:0}
     * @return {object} 绘图区域坐标 {x:0, y:0, z:0}
     */
    worldToDrawing: function worldToDrawing(point) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return null;
        }

        var scene = this.getScene();
        var retPoint = scene.worldToDrawing(point);

        return { x: retPoint.x, y: retPoint.y, z: retPoint.z };
    },

    /**
     * 绘图空间(场景变换后)坐标转世界坐标
     *
     * @param {object} point - 绘图区域坐标下的点集 {x:0, y:0, z:0}。
     * @return {object} 世界坐标 {x:0, y:0, z:0}
     */
    drawingToWorld: function drawingToWorld(point) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return null;
        }

        // 转世界坐标
        var scene = this.getScene();
        var retPoint = scene.drawingToWorld(point);

        return { x: retPoint.x, y: retPoint.y, z: retPoint.z };
    },

    /**
     * 世界坐标转客户坐标(相对于canvas区域)
     *
     * @param {object} wPoint - 世界坐标下的点集 {x:0, y:0, z:0}
     * @return {object} 客户区域坐标 {x:0, y:0, z:0}, 没有转换则返回null
     */
    worldToCanvas: function worldToCanvas(wPoint) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return null;
        }

        var clientRect = cameraControl.getContainerDimensions();

        if (!clientRect) {
            return null;
        }

        var camera = cameraControl.getCamera();
        var scene = this.getScene();

        // 转绘图空间坐标(场景变换)
        var point = scene.worldToDrawing(wPoint);

        // 转相对于canvas的坐标
        var result = CLOUD.CameraUtil.drawingToCanvas(camera, point, clientRect.width, clientRect.height);

        return result;
    },

    /**
     * 客户区域坐标(相对于canvas区域)转世界坐标
     *
     * @param {object} cPoint - 客户区域坐标下的点集 {x:0, y:0, z:0}, 其中z为进行反投影是的深度，默认为 0。
     * @return {object} 世界坐标 {x:0, y:0, z:0}, 没有转换则返回null
     */
    canvasToWorld: function canvasToWorld(cPoint) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return null;
        }

        var clientRect = cameraControl.getContainerDimensions();

        if (!clientRect) {
            return null;
        }

        var camera = cameraControl.getCamera();
        var scene = this.getScene();

        // 转绘图空间坐标
        var point = CLOUD.CameraUtil.canvasToDrawing(camera, cPoint, clientRect.width, clientRect.height);

        // 转世界坐标
        var result = scene.drawingToWorld(point);

        return { x: result.x, y: result.y, z: result.z };
    },

    /**
     * 世界坐标(原始坐标)转客户区域坐标(相对于窗口客户区域)
     *
     * @param {object} wPoint - 世界坐标下的点集 {x:0, y:0, z:0}
     * @return {object} 客户区域坐标 {x:0, y:0, z:0}, 没有转换则返回null
     */
    worldToClient: function worldToClient(wPoint) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return null;
        }

        var clientRect = cameraControl.getContainerDimensions();

        if (!clientRect) {
            return null;
        }

        var camera = cameraControl.getCamera();
        var scene = this.getScene();

        // 转绘图空间坐标(场景变换)
        var point = scene.worldToDrawing(wPoint);

        // 转相对于canvas的坐标
        var result = CLOUD.CameraUtil.drawingToCanvas(camera, point, clientRect.width, clientRect.height);

        if (result) {

            // 转客户区域坐标
            result.x += clientRect.left;
            result.y += clientRect.top;

            return result;
        }

        return null;
    },

    /**
     * 客户区域坐标(相对于窗口客户区域)转世界坐标(原始坐标)
     *
     * @param {object} cPoint - 客户区域坐标下的点集 {x:0, y:0, z:0}, 其中z为进行反投影是的深度，默认为 0。
     * @return {object} 世界坐标 {x:0, y:0, z:0}, 没有转换则返回null
     */
    clientToWorld: function clientToWorld(cPoint) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return null;
        }

        var clientRect = cameraControl.getContainerDimensions();

        if (!clientRect) {
            return null;
        }

        var point = { x: cPoint.x, y: cPoint.y, z: cPoint.z };

        // 转相对于canvas的坐标
        point.x -= clientRect.left;
        point.y -= clientRect.top;

        var camera = cameraControl.getCamera();
        var scene = this.getScene();

        // 转绘图空间坐标
        var point = CLOUD.CameraUtil.canvasToDrawing(camera, point, clientRect.width, clientRect.height);

        // 转世界坐标
        var result = scene.drawingToWorld(point);

        return { x: result.x, y: result.y, z: result.z };
    },

    /**
     * 世界坐标(原始坐标)点含在相机视锥中
     *
     * @param {object} wPoint - 世界坐标 {x:0, y:0, z:0}
     * @return {Boolean} 在相机视锥中，返回true，否则，返回false
     */
    insideCamera: function insideCamera(wPoint) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return false;
        }

        var scene = this.getScene();

        // 转换到绘制空间的坐标
        var point = scene.worldToDrawing(wPoint);
        var frustum = cameraControl.getFrustum();

        return frustum.containsPoint(point);
    },

    /**
     * 根据给定世界系中的点以平行视线方向定位
     *
     * @param {Object} wPoint - 世界系坐标点 {x: 0, y:0, z:0}
     */
    locateToPointWithParallelEye: function locateToPointWithParallelEye(wPoint) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return false;
        }

        var scene = this.getScene();
        var point = scene.worldToDrawing(wPoint);

        cameraControl.flyToPointWithParallelEye(point);
    },

    /**
     * 根据给定世界系中的点保持视角进行定位
     *
     * @param {Object} wPoint - 世界系坐标点 {x: 0, y:0, z:0}
     */
    locateToPoint: function locateToPoint(wPoint) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return false;
        }

        var scene = this.getScene();
        var point = scene.worldToDrawing(wPoint);

        cameraControl.flyToPoint(point);
    },

    /**
     * 是否启用鼠标hover
     *
     * @param {Boolean} enable - 启用或禁止
     */
    enableHover: function enableHover(enable) {
        CLOUD.GlobalData.Hover = enable;
    },

    enableIBL: function enableIBL(isEnable) {

        if (CLOUD.GlobalData.IBL === isEnable) {
            return;
        }

        CLOUD.GlobalData.IBL = isEnable;
        this.modelManager.changeAllMaterials(isEnable);
        if (isEnable) {
            this.initIBLByIndex(this.getScene().IBLIndex);
        } else {
            this.removeCubeMap();
        }
    },

    loadIBLcfg: function loadIBLcfg(url) {

        var scope = this;
        var loader = new THREE.FileLoader();
        loader.load(url, function (text) {
            scope.getScene().IBLcfg = JSON.parse(text);
            if (CLOUD.GlobalData.IBL) {
                scope.initIBLByIndex(0);
            }
        });
    },

    initIBLByIndex: function initIBLByIndex(index) {

        if (!CLOUD.GlobalData.IBL) {
            return;
        }

        var IBLcfg = this.getScene().IBLcfg;
        if (IBLcfg != null) {

            var keys = Object.keys(IBLcfg);
            if (keys.length > index) {
                var cfg = IBLcfg[keys[index]];
                this.loadIBLMaps(cfg.url, cfg.isHDR, cfg.uniforms);
                this.getScene().IBLIndex = index;
            } else {
                new Error("Index is out of range.");
            }
        } else {
            new Error("IBLConfig is not exist");
        }
    },

    // initIBL: function(envUrl, isCubeMap, isHDR, uniforms) {

    //     var scope = this;

    //     if (isCubeMap) {
    //         var cubeMapLoader = new THREE.CubeTextureLoader();

    //         var envMap = cubeMapLoader.load([
    //             envUrl + "posx.jpg",
    //             envUrl + "negx.jpg",
    //             envUrl + "posy.jpg",
    //             envUrl + "negy.jpg",
    //             envUrl + "posz.jpg",
    //             envUrl + "negz.jpg"
    //         ],
    //             function onSuccess(texture) {
    //                 scope.environmentCubeMap = texture;
    //                 scope.environmentCubeMap.mapping = THREE.CubeReflectionMapping;

    //                 scope.initIBLProbe(isHDR, uniforms);
    //             }
    //         );
    //     }
    //     else {
    //         var loader = isHDR ? new HDRTextureLoader() : new THREE.TextureLoader();
    //         loader.load(envUrl, function onSuccess(texture) {
    //             scope.environmentCubeMap = HDRToCubeMap(texture, scope.renderer, isHDR);
    //             scope.environmentCubeMap.mapping = THREE.CubeReflectionMapping;

    //             scope.initIBLProbe(isHDR, uniforms);
    //         });
    //     }

    // },

    // initIBLProbe: function(isHDR, uniforms) {

    //     var scope = this;
    //     var renderer = this.renderer;
    //     var scene = this.getScene();
    //     if (scene.iblProbe == null) {
    //         scene.iblProbe = new IBLProbe(scope.environmentCubeMap, 'images/Hammersley.jpg', function onSuccess(texture) {
    //             scene.iblProbe.isHDR = isHDR;
    //             scene.iblProbe.computed(renderer);
    //             scope.modelManager.updateMaterials();

    //             for (var id in uniforms) {
    //                 scope.modelManager.updateMaterialsValue(id, uniforms[id]);
    //             }

    //             scope.addCubeMap(isHDR, uniforms);
    //         });
    //     }
    //     else {
    //         scene.iblProbe.isHDR = isHDR;
    //         scene.iblProbe.setEnvironmentMap(scope.environmentCubeMap);
    //         scene.iblProbe.computed(renderer);
    //         scope.modelManager.updateMaterials();

    //         for (var id in uniforms) {
    //             scope.modelManager.updateMaterialsValue(id, uniforms[id]);
    //         }

    //         scope.addCubeMap(isHDR, uniforms);
    //     }

    // },

    loadIBLMaps: function loadIBLMaps(url, isHDR, uniforms) {

        if (!CLOUD.GlobalData.IBL) {
            return;
        }

        var scope = this;
        var renderer = this.renderer;
        var scene = this.getScene();

        function loadMaps() {
            var mapUrl = ["posx.hdr", "negx.hdr", "posy.hdr", "negy.hdr", "posz.hdr", "negz.hdr"];
            var envMapUrl = [];
            for (var i = 0; i < 6; ++i) {
                envMapUrl.push(url + "/EnvMap_" + mapUrl[i]);
            }

            var cubeTextureLoader = isHDR ? new THREE.HDRCubeTextureLoader() : new THREE.CubeTextureLoader();

            cubeTextureLoader.load(THREE.FloatType, envMapUrl, function (hdrCubeMap) {
                scene.iblProbe.environmentMap = hdrCubeMap;
                scope.environmentCubeMap = hdrCubeMap;
                scope.addCubeMap(isHDR, uniforms);

                var irradianceMapUrl = [];
                for (var i = 0; i < 6; ++i) {
                    irradianceMapUrl.push(url + "/IrradianceMap_" + mapUrl[i]);
                }

                cubeTextureLoader.load(THREE.FloatType, irradianceMapUrl, function (hdrCubeMap) {
                    scene.iblProbe.irradianceMap.cubeTexture = hdrCubeMap;

                    var prefilterMapUrl = [];
                    for (var i = 0; i < 6; ++i) {
                        prefilterMapUrl.push(url + "/PrefilterMap_" + mapUrl[i]);
                    }

                    cubeTextureLoader.load(THREE.FloatType, prefilterMapUrl, function (hdrCubeMap) {
                        scene.iblProbe.prefilterMap.cubeTexture = hdrCubeMap;

                        var textureLoader = isHDR ? new ImageBasedLighting.HDRTextureLoader() : new THREE.TextureLoader();
                        var brdfUrl = isHDR ? url + "/brdf.hdr" : url + "/brdf.png";
                        textureLoader.load(brdfUrl, function (texture) {
                            scene.iblProbe.brdfMap.texture = texture;
                            scene.iblProbe.isComputed = true;
                            scope.modelManager.updateMaterials();

                            for (var id in uniforms) {
                                scope.modelManager.updateMaterialsValue(id, uniforms[id]);
                            }

                            scope.render();
                        });
                    });
                });
            });
        }

        if (scene.iblProbe == null) {
            scene.iblProbe = new ImageBasedLighting.IBLProbe(scope.environmentCubeMap, 'images/Hammersley.jpg', function onSuccess(texture) {
                scene.iblProbe.isHDR = isHDR;
                loadMaps();
            });
        } else {
            loadMaps();
        }
    },

    addCubeMap: function addCubeMap(isHDR, uniforms) {

        var isHDR = isHDR || this.isHDR;
        this.isHDR = isHDR;

        if (this.cubeMesh == null) {

            this.cubeMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(2000.0, 2000.0, 2000.0), new THREE.ShaderMaterial({
                uniforms: {
                    environmentMap: { value: this.environmentCubeMap },
                    hdr: { value: isHDR },
                    shift: { value: 0.18 },
                    A: { value: 0.27 },
                    B: { value: 0.29 },
                    C: { value: 0.052 },
                    D: { value: 0.2 },
                    E: { value: 0.0 },
                    F: { value: 0.18 },
                    scale: { value: 0.897105 }
                },
                vertexShader: ImageBasedLighting.cube_vs,
                fragmentShader: ImageBasedLighting.cube_fs,
                side: THREE.BackSide,
                depthTest: true,
                depthWrite: true,
                fog: false
            }));
        } else {
            this.cubeMesh.material.uniforms.environmentMap.value = this.environmentCubeMap;
            this.cubeMesh.material.uniforms.hdr.value = isHDR;
        }

        if (uniforms) {

            var material = this.cubeMesh.material;
            for (var id in uniforms) {
                if (material.uniforms.hasOwnProperty(id)) {
                    material.uniforms[id].value = uniforms[id];
                }
            }
        }

        this.getScene().add(this.cubeMesh);
        this.render();
    },

    removeCubeMap: function removeCubeMap() {

        if (this.cubeMesh != null) {
            this.getScene().remove(this.cubeMesh);
            this.render();
        }
    },

    /**
     * 添加带纹理的平面(世界系坐标，Z轴朝上)
     *
     * @param {THREE.Vector3} min - 最小点
     * @param {THREE.Vector3} max - 最大点
     * @param {String} url - 贴图路径
     * @return {THREE.Mesh} 请自行保存生成的平面, visible属性控制平面是否显示
     */
    addPlane: function addPlane(min, max, url) {
        var center = new THREE.Vector3();
        center.addVectors(new THREE.Vector3(min.x, min.y, min.z), new THREE.Vector3(max.x, max.y, max.z));
        center.multiplyScalar(0.5);

        var plane = new THREE.PlaneBufferGeometry(max.x - min.x, max.y - min.y);

        var mesh = new THREE.Mesh(plane, new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent: true, depthTest: true }));
        //mesh.rotation.x = -Math.PI * 0.5;
        mesh.position.copy(center);
        mesh.renderOrder = 10; // give a higher priority

        var scene = this.getScene();
        scene.rootNode.add(mesh);
        mesh.updateMatrixWorld(true);

        var loader = new THREE.TextureLoader();
        loader.load(url, function onSuccess(texture) {
            mesh.material.map = texture;
            mesh.material.needsUpdate = true;
        });

        return mesh;
    },

    /**
     * 移除带纹理的平面
     *
     * @param {THREE.Mesh} plane - 传入使用addPlane函数返回的对象，用于在场景中删除平面
     */
    removePlane: function removePlane(plane) {
        var scene = this.getScene();
        scene.rootNode.remove(plane);
    },

    /**
     * 是否启用纹理贴图
     *
     * @param {Boolean} enable - true 启用，false：禁用
     */
    enableTextureMapping: function enableTextureMapping(enable) {

        CLOUD.GlobalData.EnableTextureMapping = enable;

        // var needsUpdate = this.modelManager.updateTextureMapping(enable);
        //
        // if (needsUpdate) {
        //     this.render();
        // }
    },

    /**
     * 设置鼠标滚轮方向
     * 默认滚轮方向 - 前滚：相机前进， 后滚：相机回退
     * 反转滚轮方向 - 前滚：相机回退， 后滚：相机前进
     *
     * @param {Boolean} state - 是否反转
     */
    setReverseWheelDirection: function setReverseWheelDirection(state) {

        CLOUD.GlobalData.ReverseWheelDirection = !!state;
    },

    /**
     * 获得鼠标滚轮反转状态
     *
     * @return {Boolean} 反转状态
     */
    getReverseWheelDirection: function getReverseWheelDirection() {

        return CLOUD.GlobalData.ReverseWheelDirection;
    },

    /**
     * 设置移动速度倍率
     *
     * @param {Number} rate - 倍数, 0.25 - x0.25, 是原来的1/4速度, 4.0 - x4.0, 是原来速度的4倍.
     */
    setMovementSpeedRate: function setMovementSpeedRate(rate) {

        if (rate === undefined) {
            return;
        }

        CLOUD.GlobalData.MovementSpeedRate = rate;
    },

    /**
     * 获得移动速度倍率
     *
     * @return {Number} 倍数
     */
    getMovementSpeedRate: function getMovementSpeedRate() {

        return CLOUD.GlobalData.MovementSpeedRate;
    },

    /**
     * 相机移动
     *
     * @param {Number} direction 移动方向 {@link CLOUD.MoveDirection}
     */
    moveTo: function moveTo(direction) {

        var editor = this.editorManager.editor;

        // if (editor && editor.slaveEditor) {
        //     editor.slaveEditor.moveTo(direction);
        // }

        if (editor) {
            editor.moveTo(direction);
        }
    },

    /**
     * 是否启用半透明遮挡视线的构件
     *
     * @param {Boolean} enable - true 启用，false：禁用
     */
    enableOcclusionTranslucent: function enableOcclusionTranslucent(enable) {
        CLOUD.GlobalData.OcclusionTranslucentEnabled = !!enable;
    },

    /**
     * 设置遮挡视线的构件的不透明度
     *
     * @param {Number} opacity - 不透明度
     */
    setOcclusionOpacity: function setOcclusionOpacity(opacity) {
        CLOUD.GlobalData.OcclusionOpacity = opacity;
    },

    /**
     * 设置遮挡视线的构件的距离阈值，超过该阈值，则半透明遮挡物
     *
     * @param {Number} distance - 距离阈值
     */
    setOcclusionDistanceToCamera: function setOcclusionDistanceToCamera(distance) {
        CLOUD.GlobalData.OcclusionDistanceToCamera = distance;
    },

    /**
     * 根据选中的构件进行fit及绕其旋转
     *
     */
    fitAndRotateBySelection: function fitAndRotateBySelection() {

        if (this.cameraControl) {
            this.cameraControl.fitAndRotateBySelection();
        }
    },

    /**
     * 设置漫游行走时相机的高度
     *
     * @param {Array} elevations - 参考标高数组（从小到大的排序）
     * @param {Number} height - 相机相对高度(世界系中的高度)
     */
    setRoamingWalkHeight: function setRoamingWalkHeight(elevations, height) {

        if (this.cameraControl) {
            this.cameraControl.setRoamingWalkHeight(elevations, height);
        }
    },

    /**
     * 设置漫游行走时相机的绝对高度
     *
     * @param {Number} height - 相机绝对高度(世界系中的高度)
     */
    setRoamingWalkAbsoluteHeight: function setRoamingWalkAbsoluteHeight(height) {

        if (this.cameraControl) {
            this.cameraControl.setRoamingWalkAbsoluteHeight(height);
        }
    },

    /**
     * 移动相机到某个位置
     *
     * @param {Object} position - 相机位置(世界系中的位置)
     */
    moveCameraToLocate: function moveCameraToLocate(position) {

        if (this.cameraControl) {

            this.cameraControl.locateToPointWithParallelEye(position);
        }
    },

    /**
     * 沿选中构件点所在的三角面对应的法线方向求两个pick点
     *
     * @param {Object} point - 客户坐标点({x:0, y: 0})
     * @param {Function} callback(intersects) - 回调函数，参数为两个构件对象或者null
     */
    pickByPointWithNormal: function pickByPointWithNormal(point, callback) {

        var scene = this.getScene();
        var cameraControl = this.cameraControl;

        if (cameraControl.enabled === false) return false;

        var clientPos = new THREE.Vector2(point.x, point.y);
        var pickContext = cameraControl.getIntersectContext(clientPos);

        cameraControl.intersector.pick(pickContext, function (intersect) {

            if (!intersect) {

                callback(null);
                return;
            }

            // 将位置和包围转换到世界系
            scene.intersectToWorld(intersect);

            intersect.cx = clientPos.x;
            intersect.cy = clientPos.y;

            var intersects = [];
            intersects.push(intersect);

            // 计算第二个构件
            var sceneMatrix = scene.getMatrixGlobal();
            var direction = intersect.face.normal.clone();
            var origin = intersect.worldPosition.clone();
            var ray = new THREE.Ray(origin, direction);

            ray.applyMatrix4(sceneMatrix);

            var intersectEnd = cameraControl.intersector.getIntersectByRay(pickContext, ray);

            if (intersectEnd) {
                // 将位置和包围转换到世界系
                scene.intersectToWorld(intersectEnd);
                intersects.push(intersectEnd);
            }

            callback(intersects);
        });
    },

    /**
     * 将老版本批注信息转换成V3版
     *
     * @param {String} jsonStr - 批注信息字符串表示
     */
    convertAnnotationsToV3: function convertAnnotationsToV3(jsonStr) {

        var jsonObj = JSON.parse(jsonStr);

        function convertCamera(camera, matrixTransform, matrixScene) {

            var newCamera;

            if ("string" === typeof camera) {
                newCamera = JSON.parse(window.atob(camera));
            } else {
                newCamera = {
                    position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                    target: { x: camera.target.x, y: camera.target.y, z: camera.target.z },
                    up: { x: camera.up.x, y: camera.up.y, z: camera.up.z }
                };
            }

            var position = new THREE.Vector3(newCamera.position.x, newCamera.position.y, newCamera.position.z);
            var target = new THREE.Vector3(newCamera.target.x, newCamera.target.y, newCamera.target.z);
            var up = new THREE.Vector3(newCamera.up.x, newCamera.up.y, newCamera.up.z);

            var cameraInfo = new CLOUD.CameraInfo(position, target, up);
            cameraInfo = CLOUD.Camera.drawingToWorld(cameraInfo, matrixTransform);
            cameraInfo = new CLOUD.CameraInfo(cameraInfo.position, cameraInfo.target, cameraInfo.up);
            cameraInfo = CLOUD.Camera.worldToDrawing(cameraInfo, matrixScene);

            newCamera.position.x = cameraInfo.position.x;
            newCamera.position.y = cameraInfo.position.y;
            newCamera.position.z = cameraInfo.position.z;

            newCamera.target.x = cameraInfo.target.x;
            newCamera.target.y = cameraInfo.target.y;
            newCamera.target.z = cameraInfo.target.z;

            newCamera.up.x = cameraInfo.up.x;
            newCamera.up.y = cameraInfo.up.y;
            newCamera.up.z = cameraInfo.up.z;

            if ("string" === typeof camera) {
                newCamera = window.btoa(JSON.stringify(newCamera));
            }

            return newCamera;
        }

        // 只能根据过滤器中的标志来判断版本信息
        if (jsonObj.filter) {

            var jsonFilter = JSON.parse(jsonObj.filter);

            if (jsonFilter.filter || jsonFilter.basicIds) {

                var scene = this.getScene();
                var matrixTransform = scene.getTransformMatrixGlobal();
                var matrixTransformInv = new THREE.Matrix4();
                matrixTransformInv.getInverse(matrixTransform);

                var matrixScene = scene.getMatrixGlobal();
                var matrixSceneInv = new THREE.Matrix4();
                matrixSceneInv.getInverse(matrixScene);

                // camera 不做变换，批注使用保存的camera信息，否则批注对象的转换相当复杂而且容易出错
                // json.camera = convertCamera(json.camera, matrixTransform, matrixScene);

                // 处理批注
                // if (json.obj) {
                //
                //     var annotationInfoList = json.obj;
                //
                //     for (var i = 0, len = annotationInfoList.length; i < len; i++) {
                //
                //         var info = annotationInfoList[i];
                //         var newPosition = new THREE.Vector3(info.position.x, info.position.y, info.position.z);
                //         newPosition.applyMatrix4(matrixTransformInv).applyMatrix4(matrixScene);
                //
                //         var lt = new THREE.Vector3(info.position.x - 0.5 * info.size.width, info.position.y - 0.5 * info.size.height, info.position.z);
                //         var rb = new THREE.Vector3(info.position.x + 0.5 * info.size.width, info.position.y + 0.5 * info.size.height, info.position.z);
                //         lt.applyMatrix4(matrixTransformInv).applyMatrix4(matrixScene);
                //         rb.applyMatrix4(matrixTransformInv).applyMatrix4(matrixScene);
                //
                //         info.position.x = newPosition.x;
                //         info.position.y = newPosition.y;
                //         info.position.z = newPosition.z;
                //
                //         info.size.width = Math.abs(rb.x - lt.x);
                //         info.size.height = Math.abs(rb.y - lt.y);
                //
                //         if (info.originSize) {
                //
                //             var ltOrigin = new THREE.Vector3(info.position.x - 0.5 * info.originSize.width, info.position.y - 0.5 * info.originSize.height, info.position.z);
                //             var rbOrigin = new THREE.Vector3(info.position.x + 0.5 * info.originSize.width, info.position.y + 0.5 * info.originSize.height, info.position.z);
                //
                //             ltOrigin.applyMatrix4(matrixTransformInv).applyMatrix4(matrixScene);
                //             rbOrigin.applyMatrix4(matrixTransformInv).applyMatrix4(matrixScene);
                //
                //             info.originSize.width = Math.abs(rbOrigin.x - ltOrigin.x);
                //             info.originSize.height = Math.abs(rbOrigin.y - ltOrigin.y);
                //         }
                //
                //     }
                //
                // }

                var enumFilterType = this.getFilters().getFilterType();
                var objFilter = {};
                objFilter.state = {};

                // v1 - > v3
                if (jsonFilter.filter) {

                    if (jsonFilter.fileFilter) {
                        objFilter.state[enumFilterType.FILE_HIDDEN] = jsonFilter.fileFilter;
                    }

                    if (jsonFilter.selectionSet) {
                        objFilter.state[enumFilterType.SELECTED] = jsonFilter.selectionSet;
                    }

                    if (jsonFilter.filter.visibleIds) {
                        objFilter.state[enumFilterType.VISIBLE] = jsonFilter.filter.visibleIds;
                    }

                    if (jsonFilter.filter.invisibleIds) {
                        objFilter.state[enumFilterType.HIDDEN] = jsonFilter.filter.invisibleIds;
                    }

                    if (jsonFilter.filter.conditions) {
                        objFilter.state[enumFilterType.CONDITION_HIDDEN_OTHERS] = jsonFilter.filter.conditions;
                    }

                    if (jsonFilter.filter.filters) {
                        objFilter.state[enumFilterType.USER_HIDDEN] = jsonFilter.filter.filters;
                    }

                    if (jsonFilter.frozenSet) {
                        objFilter.state[enumFilterType.FROZENFILTER] = jsonFilter.frozenSet;
                    }

                    if (jsonFilter.isolateSet) {
                        objFilter.state[enumFilterType.ISOLATE_HIDDEN_OTHERS] = jsonFilter.isolateSet;
                    }

                    if (jsonFilter.overriderByIds) {
                        objFilter.state[enumFilterType.OVERRIDEFILTER] = jsonFilter.overriderByIds;
                    }

                    if (jsonFilter.overriderByData) {
                        objFilter.state[enumFilterType.USER_OVERRIDE] = jsonFilter.overriderByData;
                    }

                    if (jsonFilter.overriderCondition) {
                        objFilter.state[enumFilterType.CONDITION_OVERRIDE] = jsonFilter.overriderCondition;
                    }

                    if (jsonFilter.isolateCondition) {
                        objFilter.state[enumFilterType.ISOLATE_CONDITION_HIDDEN_OTHERS] = jsonFilter.isolateCondition;
                    }

                    objFilter.state.sceneState = jsonFilter.overriderByScene;
                } else if (jsonFilter.basicIds) {
                    // v2 - > v3

                    if (jsonFilter.basicIds[1]) {
                        objFilter.state[enumFilterType.FILE_HIDDEN] = jsonFilter.basicIds[1];
                    }

                    if (jsonFilter.basicIds[2]) {
                        objFilter.state[enumFilterType.SELECTED] = jsonFilter.basicIds[2];
                    }

                    if (jsonFilter.basicIds[3]) {
                        objFilter.state[enumFilterType.VISIBLE] = jsonFilter.basicIds[3];
                    }

                    if (jsonFilter.basicIds[4]) {
                        objFilter.state[enumFilterType.HIDDEN] = jsonFilter.basicIds[4];
                    }

                    if (jsonFilter.conditions[0]) {
                        objFilter.state[enumFilterType.CONDITION_HIDDEN_OTHERS] = jsonFilter.conditions[0];
                    }

                    if (jsonFilter.userHiddenIds) {
                        objFilter.state[enumFilterType.USER_HIDDEN] = jsonFilter.userHiddenIds;
                    }

                    if (jsonFilter.frozenIds) {
                        objFilter.state[enumFilterType.FROZENFILTER] = jsonFilter.frozenIds;
                    }

                    if (jsonFilter.isolateIds) {
                        objFilter.state[enumFilterType.ISOLATE_HIDDEN_OTHERS] = jsonFilter.isolateIds;
                    }

                    if (jsonFilter.overrideByIds) {
                        objFilter.state[enumFilterType.OVERRIDEFILTER] = jsonFilter.overrideByIds;
                    }

                    if (jsonFilter.overrideByData) {
                        objFilter.state[enumFilterType.USER_OVERRIDE] = jsonFilter.overrideByData;
                    }

                    if (jsonFilter.conditions[2]) {
                        objFilter.state[enumFilterType.CONDITION_OVERRIDE] = jsonFilter.conditions[2];
                    }

                    if (jsonFilter.isolateConditions) {

                        if (jsonFilter.isolateConditions[0]) {
                            objFilter.state[enumFilterType.ISOLATE_CONDITION_HIDDEN] = jsonFilter.isolateConditions[0];
                        }

                        if (jsonFilter.isolateConditions[1]) {
                            objFilter.state[enumFilterType.ISOLATE_CONDITION_HIDDEN_OTHERS] = jsonFilter.isolateConditions[1];
                        }

                        if (jsonFilter.isolateConditions[2]) {
                            objFilter.state[enumFilterType.ISOLATE_CONDITION_TRANSLUCENT] = jsonFilter.isolateConditions[2];
                        }

                        if (jsonFilter.isolateConditions[3]) {
                            objFilter.state[enumFilterType.ISOLATE_CONDITION_TRANSLUCENT_OTHERS] = jsonFilter.isolateConditions[3];
                        }
                    }

                    objFilter.state.sceneState = jsonFilter.sceneState;
                }

                if (jsonFilter.camera) {
                    objFilter.camera = convertCamera(jsonFilter.camera, matrixTransform, matrixScene);
                } else {
                    objFilter.camera = convertCamera(jsonObj.camera, matrixTransform, matrixScene);
                }

                jsonFilter = objFilter;

                jsonObj.filter = JSON.stringify(jsonFilter);
            }
        }

        return jsonObj;
    },

    /*=====================  API for selection Begin =======================*/

    /**
     * Clear all selected object to unselected state.
     *
     * If the selection object list of the scene is changed, ON_SELECTION_CHANGED event is triggered.
     */
    clearSelection: function clearSelection() {
        this.modelManager.sceneState.clearSelection();
    },

    /**
     * Add objects to selection list of the scene. These object will be selected.
     * If the selection object list of the scene is changed, ON_SELECTION_CHANGED event is triggered.
     *
     * @param {Array} objIdList - Object Ids.
     *
     */
    addToSelection: function addToSelection(objIdList) {
        this.modelManager.sceneState.addSelection(objIdList);
    },

    /**
     * Remove objects from selection list of the scene. These object will be unselected.
     * If the selection object list of the scene is changed, ON_SELECTION_CHANGED event is triggered.
     *
     * @param {Array} objIdList - Object Ids.
     *
     */
    removeFromSelection: function removeFromSelection(objIdList) {
        this.modelManager.sceneState.removeSelection(objIdList);
    },

    /**
     * Replace selection list of the scene with the object Id list. These object will be selected.
     * If the selection object list of the scene is changed, ON_SELECTION_CHANGED event is triggered.
     *
     * @param {Array} objIdList - Object Ids.
     *
     */
    setSelection: function setSelection(objIdList) {
        this.modelManager.sceneState.setSelection(objIdList);
    },

    /**
     * Add objects to selection list of the scene. These object will be selected.
     * If the selection object list of the scene is changed, ON_SELECTION_CHANGED event is triggered.
     *
     * @returns {Array} Selected object Ids.
     */
    getSelection: function getSelection() {
        return this.modelManager.sceneState.getSelection();
    },

    /*=====================  API for selection End =======================*/

    /**
     * Return the number of elements of all loaded models
     */
    getNumOfElements: function getNumOfElements() {
        return this.modelManager.getNumOfElements();
    },
    /**
     * Return the number of renderables of all loaded models
     */
    getNumOfRenderables: function getNumOfRenderables() {
        return this.modelManager.getNumOfRenderables();
    },
    /**
     * Return the number of triangles of all loaded models
     */
    getNumOfTriangles: function getNumOfTriangles() {
        return this.modelManager.getNumOfTriangles();
    },

    /**
     * 锁定行走高度
     *
     * @param {Boolean} lock - 是否锁定
     * @returns {Boolean} true - 成功，false - 失败（当前不是行走模型）
     */
    setWalkHeightLocked: function setWalkHeightLocked(lock) {

        var editor = this.getCurrentEditorMode();

        if (editor && editor.name === CLOUD.EditorMode.WALK) {
            editor.setHeightLocked(lock);
            return true;
        }

        return false;
    },

    /**
     * 鼠标按下行走观察
     *
     * @param {Boolean} press - 是否按下
     * @returns {Boolean} true - 成功，false - 失败（当前不是行走模型）
     */
    setWalkLookMousePressed: function setWalkLookMousePressed(press) {

        var editor = this.getCurrentEditorMode();

        if (editor && editor.name === CLOUD.EditorMode.WALK) {
            editor.setLookMousePressed(press);
            return true;
        }

        return false;
    },

    /**
     * 设置行走倍率
     *
     * @param {Number} rate - 倍率
     * @returns {Boolean} true - 成功，false - 失败（当前不是行走模型）
     */
    setWalkSpeedRate: function setWalkSpeedRate(rate) {

        var editor = this.getCurrentEditorMode();

        if (editor && editor.name === CLOUD.EditorMode.WALK) {
            editor.setSpeedRate(rate);
            return true;
        }

        return false;
    },

    /**
     * 是否禁用pick
     *
     * @param {Boolean} disable - true 禁用, false 启用
     */
    setPickDisabled: function setPickDisabled(disable) {
        CLOUD.GlobalData.DisablePick = disable;
    }
};

// 如果独立web2d,这个通用库需要提出来

CLOUD.Version2D = "20161009";

CLOUD.DomUtil = CLOUD.DomUtil || {
    /**
     * split string on whitespace
     * @param {String} str
     * @returns {Array} words
     */
    splitStr: function splitStr(str) {
        return str.trim().split(/\s+/g);
    },

    /**
     * get the container offset relative to client
     * @param {object} domElement
     * @returns {object}
     */
    getContainerOffsetToClient: function getContainerOffsetToClient(domElement) {
        var offsetObj;

        // 获取相对于视口(客户区域)的偏移量
        var getOffsetSum = function getOffsetSum(ele) {
            var top = 0,
                left = 0;

            // 遍历父元素,获取相对与document的偏移量
            while (ele) {
                top += ele.offsetTop;
                left += ele.offsetLeft;
                ele = ele.offsetParent;
            }

            // 只处理document的滚动条(一般也用不着内部滚动条)
            var body = document.body,
                docElem = document.documentElement;

            //获取页面的scrollTop,scrollLeft(兼容性写法)
            var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
                scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;

            // 减掉滚动距离，获得相对于客户区域的偏移量
            top -= scrollTop;
            left -= scrollLeft;

            return {
                top: top,
                left: left
            };
        };

        // 获取相对于视口(客户区域)的偏移量(viewpoint), 不加页面的滚动量(scroll)
        var getOffsetRect = function getOffsetRect(ele) {
            // getBoundingClientRect返回一个矩形对象，包含四个属性：left、top、right和bottom。分别表示元素各边与页面上边和左边的距离。
            //注意：IE、Firefox3+、Opera9.5、Chrome、Safari支持，在IE中，默认坐标从(2,2)开始计算，导致最终距离比其他浏览器多出两个像素，我们需要做个兼容。
            var box = ele.getBoundingClientRect();
            var body = document.body,
                docElem = document.documentElement;

            //获取页面的scrollTop,scrollLeft(兼容性写法)
            //var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
            //    scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
            var clientTop = docElem.clientTop || body.clientTop,
                clientLeft = docElem.clientLeft || body.clientLeft;
            var top = box.top - clientTop,
                left = box.left - clientLeft;

            return {
                //Math.round 兼容火狐浏览器bug
                top: Math.round(top),
                left: Math.round(left)
            };
        };

        //获取元素相对于页面的偏移
        var getOffset = function getOffset(ele) {
            if (ele.getBoundingClientRect) {
                return getOffsetRect(ele);
            } else {
                return getOffsetSum(ele);
            }
        };

        if (domElement != document) {

            // 这种方式的目的是为了让外部直接传入clientX,clientY,然后计算出相对父容器的offsetX,offsetY值,
            // 即 offsetX = clientX - offsetV.left, offsetY = clientY - offsetV.top
            var offsetV = getOffset(domElement);

            // domElement.offsetLeft（offsetTop）是相对父容器的偏移量，如果用相对坐标表示，直接传回0
            //offset	: [ domElement.offsetLeft,  domElement.offsetTop ]
            offsetObj = {
                width: domElement.offsetWidth,
                height: domElement.offsetHeight,
                left: offsetV.left,
                top: offsetV.top
            };
        } else {

            offsetObj = {
                width: window.innerWidth,
                height: window.innerHeight,
                left: 0,
                top: 0
            };
        }

        return offsetObj;
    },

    /**
     * set css class name
     * @param {String} id
     * @param {String} cssName
     */
    setClassName: function setClassName(id, cssName) {
        var dom = document.getElementById(id);
        if (dom) {
            dom.className = cssName;
        }
    },

    /**
     * add css class name
     * @param {String} id
     * @param {String} cssName
     */
    addClassName: function addClassName(id, cssName) {
        var a, b, c;
        var i, j;
        var s = /\s+/;
        var dom = document.getElementById(id);
        if (dom) {

            b = dom;

            if (cssName && typeof cssName == "string") {
                a = cssName.split(s);

                // 如果节点是元素节点，则 nodeType 属性将返回 1。
                // 如果节点是属性节点，则 nodeType 属性将返回 2。
                if (b.nodeType === 1) {
                    if (!b.className && a.length === 1) {
                        b.className = cssName;
                    } else {
                        c = " " + b.className + " ";

                        for (i = 0, j = a.length; i < j; ++i) {
                            c.indexOf(" " + a[i] + " ") < 0 && (c += a[0] + " ");
                        }

                        b.className = String.trim(c);
                    }
                }
            }
        }
    },

    /**
     * remove css class name
     * @param {String} id
     * @param {String} cssName
     */
    removeClassName: function removeClassName(id, className) {
        var a, b, c;
        var i, j;
        var s = /\s+/;
        var dom = document.getElementById(id);
        if (dom) {
            c = dom;

            if (className && typeof className == "string") {
                a = (className || "").split(s);

                if (c.nodeType === 1 && c.className) {
                    b = (" " + c.className + " ").replace(O, " ");
                    for (i = 0, j = a.length; i < j; i++) {
                        while (b.indexOf(" " + a[i] + " ") >= 0) {
                            b = b.replace(" " + a[i] + " ", " ");
                        }
                    }
                    c.className = className ? String.trim(b) : "";
                }
            }
        }
    },

    /**
     * show or hide element
     * @param {String} id
     * @param {Boolean} isShow
     */
    showOrHideElement: function showOrHideElement(id, isShow) {
        var dom = document.getElementById(id);
        if (dom) {
            if (isShow) {
                dom.style.display = "";
            } else {
                dom.style.display = "none";
            }
        }
    },
    getStyleString: function getStyleString(style) {

        var elements = [];

        for (var key in style) {

            var val = style[key];

            elements.push(key);
            elements.push(':');
            elements.push(val);
            elements.push('; ');
        }

        return elements.join('');
    },
    cloneStyle: function cloneStyle(style) {

        var clone = {};

        for (var key in style) {
            clone[key] = style[key];
        }

        return clone;
    },
    removeStyleAttribute: function removeStyleAttribute(style, attrs) {

        if (!Array.isArray(attrs)) {
            attrs = [attrs];
        }

        attrs.forEach(function (key) {
            if (key in style) {
                delete style[key];
            }
        });
    },
    trimRight: function trimRight(text) {

        if (text.length === 0) {
            return "";
        }

        var lastNonSpace = text.length - 1;

        for (var i = lastNonSpace; i >= 0; --i) {
            if (text.charAt(i) !== ' ') {
                lastNonSpace = i;
                break;
            }
        }

        return text.substr(0, lastNonSpace + 1);
    },
    trimLeft: function trimLeft(text) {

        if (text.length === 0) {
            return "";
        }

        var firstNonSpace = 0;

        for (var i = 0; i < text.length; ++i) {
            if (text.charAt(i) !== ' ') {
                firstNonSpace = i;
                break;
            }
        }

        return text.substr(firstNonSpace);
    },
    matchesSelector: function matchesSelector(domElem, selector) {

        if (domElem.matches) {
            return domElem.matches(selector);
        }

        if (domElem.matchesSelector) {
            return domElem.matchesSelector(selector);
        }

        if (domElem.webkitMatchesSelector) {
            return domElem.webkitMatchesSelector(selector);
        }

        if (domElem.msMatchesSelector) {
            return domElem.msMatchesSelector(selector);
        }

        if (domElem.mozMatchesSelector) {
            return domElem.mozMatchesSelector(selector);
        }

        if (domElem.oMatchesSelector) {
            return domElem.oMatchesSelector(selector);
        }

        if (domElem.querySelectorAll) {

            var matches = (domElem.document || domElem.ownerDocument).querySelectorAll(selector),
                i = 0;

            while (matches[i] && matches[i] !== element) {
                i++;
            }return matches[i] ? true : false;
        }

        return false;
    },
    toTranslate3d: function toTranslate3d(x, y) {

        return 'translate3d(' + x + 'px,' + y + 'px,0)';
    },
    setCursorStyle: function setCursorStyle(element, direction) {

        var cursor;

        switch (direction) {
            case 'n':
            case 's':
                cursor = 'ns-resize';
                break;
            case 'w':
            case 'e':
                cursor = 'ew-resize';
                break;
            case 'ne':
            case 'sw':
                cursor = 'nesw-resize';
                break;
            case 'nw':
            case 'se':
                cursor = 'nwse-resize';
                break;
        }

        element.style.cursor = cursor;
    }
};
/*
  html2canvas 0.5.0-beta3 <http://html2canvas.hertzen.com>
  Copyright (c) 2016 Niklas von Hertzen

  Released under  License
*/

!function (e) {
    if ("object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module) module.exports = e();else if ("function" == typeof define && define.amd) define([], e);else {
        var f;"undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.html2canvas = e();
    }
}(function () {
    var define, module, exports;return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
                }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                    var n = t[o][1][e];return s(n ? n : e);
                }, l, l.exports, e, t, n, r);
            }return n[o].exports;
        }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
            s(r[o]);
        }return s;
    }({ 1: [function (_dereq_, module, exports) {
            (function (global) {
                /*! http://mths.be/punycode v1.2.4 by @mathias */
                (function (root) {

                    /** Detect free variables */
                    var freeExports = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == 'object' && exports;
                    var freeModule = (typeof module === "undefined" ? "undefined" : _typeof(module)) == 'object' && module && module.exports == freeExports && module;
                    var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global;
                    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
                        root = freeGlobal;
                    }

                    /**
                     * The `punycode` object.
                     * @name punycode
                     * @type Object
                     */
                    var punycode,


                    /** Highest positive signed 32-bit float value */
                    maxInt = 2147483647,
                        // aka. 0x7FFFFFFF or 2^31-1

                    /** Bootstring parameters */
                    base = 36,
                        tMin = 1,
                        tMax = 26,
                        skew = 38,
                        damp = 700,
                        initialBias = 72,
                        initialN = 128,
                        // 0x80
                    delimiter = '-',
                        // '\x2D'

                    /** Regular expressions */
                    regexPunycode = /^xn--/,
                        regexNonASCII = /[^ -~]/,
                        // unprintable ASCII chars + non-ASCII chars
                    regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g,
                        // RFC 3490 separators

                    /** Error messages */
                    errors = {
                        'overflow': 'Overflow: input needs wider integers to process',
                        'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                        'invalid-input': 'Invalid input'
                    },


                    /** Convenience shortcuts */
                    baseMinusTMin = base - tMin,
                        floor = Math.floor,
                        stringFromCharCode = String.fromCharCode,


                    /** Temporary variable */
                    key;

                    /*--------------------------------------------------------------------------*/

                    /**
                     * A generic error utility function.
                     * @private
                     * @param {String} type The error type.
                     * @returns {Error} Throws a `RangeError` with the applicable error message.
                     */
                    function error(type) {
                        throw RangeError(errors[type]);
                    }

                    /**
                     * A generic `Array#map` utility function.
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} callback The function that gets called for every array
                     * item.
                     * @returns {Array} A new array of values returned by the callback function.
                     */
                    function map(array, fn) {
                        var length = array.length;
                        while (length--) {
                            array[length] = fn(array[length]);
                        }
                        return array;
                    }

                    /**
                     * A simple `Array#map`-like wrapper to work with domain name strings.
                     * @private
                     * @param {String} domain The domain name.
                     * @param {Function} callback The function that gets called for every
                     * character.
                     * @returns {Array} A new string of characters returned by the callback
                     * function.
                     */
                    function mapDomain(string, fn) {
                        return map(string.split(regexSeparators), fn).join('.');
                    }

                    /**
                     * Creates an array containing the numeric code points of each Unicode
                     * character in the string. While JavaScript uses UCS-2 internally,
                     * this function will convert a pair of surrogate halves (each of which
                     * UCS-2 exposes as separate characters) into a single code point,
                     * matching UTF-16.
                     * @see `punycode.ucs2.encode`
                     * @see <http://mathiasbynens.be/notes/javascript-encoding>
                     * @memberOf punycode.ucs2
                     * @name decode
                     * @param {String} string The Unicode input string (UCS-2).
                     * @returns {Array} The new array of code points.
                     */
                    function ucs2decode(string) {
                        var output = [],
                            counter = 0,
                            length = string.length,
                            value,
                            extra;
                        while (counter < length) {
                            value = string.charCodeAt(counter++);
                            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                                // high surrogate, and there is a next character
                                extra = string.charCodeAt(counter++);
                                if ((extra & 0xFC00) == 0xDC00) {
                                    // low surrogate
                                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                                } else {
                                    // unmatched surrogate; only append this code unit, in case the next
                                    // code unit is the high surrogate of a surrogate pair
                                    output.push(value);
                                    counter--;
                                }
                            } else {
                                output.push(value);
                            }
                        }
                        return output;
                    }

                    /**
                     * Creates a string based on an array of numeric code points.
                     * @see `punycode.ucs2.decode`
                     * @memberOf punycode.ucs2
                     * @name encode
                     * @param {Array} codePoints The array of numeric code points.
                     * @returns {String} The new Unicode string (UCS-2).
                     */
                    function ucs2encode(array) {
                        return map(array, function (value) {
                            var output = '';
                            if (value > 0xFFFF) {
                                value -= 0x10000;
                                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                                value = 0xDC00 | value & 0x3FF;
                            }
                            output += stringFromCharCode(value);
                            return output;
                        }).join('');
                    }

                    /**
                     * Converts a basic code point into a digit/integer.
                     * @see `digitToBasic()`
                     * @private
                     * @param {Number} codePoint The basic numeric code point value.
                     * @returns {Number} The numeric value of a basic code point (for use in
                     * representing integers) in the range `0` to `base - 1`, or `base` if
                     * the code point does not represent a value.
                     */
                    function basicToDigit(codePoint) {
                        if (codePoint - 48 < 10) {
                            return codePoint - 22;
                        }
                        if (codePoint - 65 < 26) {
                            return codePoint - 65;
                        }
                        if (codePoint - 97 < 26) {
                            return codePoint - 97;
                        }
                        return base;
                    }

                    /**
                     * Converts a digit/integer into a basic code point.
                     * @see `basicToDigit()`
                     * @private
                     * @param {Number} digit The numeric value of a basic code point.
                     * @returns {Number} The basic code point whose value (when used for
                     * representing integers) is `digit`, which needs to be in the range
                     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
                     * used; else, the lowercase form is used. The behavior is undefined
                     * if `flag` is non-zero and `digit` has no uppercase form.
                     */
                    function digitToBasic(digit, flag) {
                        //  0..25 map to ASCII a..z or A..Z
                        // 26..35 map to ASCII 0..9
                        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                    }

                    /**
                     * Bias adaptation function as per section 3.4 of RFC 3492.
                     * http://tools.ietf.org/html/rfc3492#section-3.4
                     * @private
                     */
                    function adapt(delta, numPoints, firstTime) {
                        var k = 0;
                        delta = firstTime ? floor(delta / damp) : delta >> 1;
                        delta += floor(delta / numPoints);
                        for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
                            delta = floor(delta / baseMinusTMin);
                        }
                        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                    }

                    /**
                     * Converts a Punycode string of ASCII-only symbols to a string of Unicode
                     * symbols.
                     * @memberOf punycode
                     * @param {String} input The Punycode string of ASCII-only symbols.
                     * @returns {String} The resulting string of Unicode symbols.
                     */
                    function decode(input) {
                        // Don't use UCS-2
                        var output = [],
                            inputLength = input.length,
                            out,
                            i = 0,
                            n = initialN,
                            bias = initialBias,
                            basic,
                            j,
                            index,
                            oldi,
                            w,
                            k,
                            digit,
                            t,

                        /** Cached calculation results */
                        baseMinusT;

                        // Handle the basic code points: let `basic` be the number of input code
                        // points before the last delimiter, or `0` if there is none, then copy
                        // the first basic code points to the output.

                        basic = input.lastIndexOf(delimiter);
                        if (basic < 0) {
                            basic = 0;
                        }

                        for (j = 0; j < basic; ++j) {
                            // if it's not a basic code point
                            if (input.charCodeAt(j) >= 0x80) {
                                error('not-basic');
                            }
                            output.push(input.charCodeAt(j));
                        }

                        // Main decoding loop: start just after the last delimiter if any basic code
                        // points were copied; start at the beginning otherwise.

                        for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

                            // `index` is the index of the next character to be consumed.
                            // Decode a generalized variable-length integer into `delta`,
                            // which gets added to `i`. The overflow checking is easier
                            // if we increase `i` as we go, then subtract off its starting
                            // value at the end to obtain `delta`.
                            for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

                                if (index >= inputLength) {
                                    error('invalid-input');
                                }

                                digit = basicToDigit(input.charCodeAt(index++));

                                if (digit >= base || digit > floor((maxInt - i) / w)) {
                                    error('overflow');
                                }

                                i += digit * w;
                                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                                if (digit < t) {
                                    break;
                                }

                                baseMinusT = base - t;
                                if (w > floor(maxInt / baseMinusT)) {
                                    error('overflow');
                                }

                                w *= baseMinusT;
                            }

                            out = output.length + 1;
                            bias = adapt(i - oldi, out, oldi == 0);

                            // `i` was supposed to wrap around from `out` to `0`,
                            // incrementing `n` each time, so we'll fix that now:
                            if (floor(i / out) > maxInt - n) {
                                error('overflow');
                            }

                            n += floor(i / out);
                            i %= out;

                            // Insert `n` at position `i` of the output
                            output.splice(i++, 0, n);
                        }

                        return ucs2encode(output);
                    }

                    /**
                     * Converts a string of Unicode symbols to a Punycode string of ASCII-only
                     * symbols.
                     * @memberOf punycode
                     * @param {String} input The string of Unicode symbols.
                     * @returns {String} The resulting Punycode string of ASCII-only symbols.
                     */
                    function encode(input) {
                        var n,
                            delta,
                            handledCPCount,
                            basicLength,
                            bias,
                            j,
                            m,
                            q,
                            k,
                            t,
                            currentValue,
                            output = [],

                        /** `inputLength` will hold the number of code points in `input`. */
                        inputLength,

                        /** Cached calculation results */
                        handledCPCountPlusOne,
                            baseMinusT,
                            qMinusT;

                        // Convert the input in UCS-2 to Unicode
                        input = ucs2decode(input);

                        // Cache the length
                        inputLength = input.length;

                        // Initialize the state
                        n = initialN;
                        delta = 0;
                        bias = initialBias;

                        // Handle the basic code points
                        for (j = 0; j < inputLength; ++j) {
                            currentValue = input[j];
                            if (currentValue < 0x80) {
                                output.push(stringFromCharCode(currentValue));
                            }
                        }

                        handledCPCount = basicLength = output.length;

                        // `handledCPCount` is the number of code points that have been handled;
                        // `basicLength` is the number of basic code points.

                        // Finish the basic string - if it is not empty - with a delimiter
                        if (basicLength) {
                            output.push(delimiter);
                        }

                        // Main encoding loop:
                        while (handledCPCount < inputLength) {

                            // All non-basic code points < n have been handled already. Find the next
                            // larger one:
                            for (m = maxInt, j = 0; j < inputLength; ++j) {
                                currentValue = input[j];
                                if (currentValue >= n && currentValue < m) {
                                    m = currentValue;
                                }
                            }

                            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                            // but guard against overflow
                            handledCPCountPlusOne = handledCPCount + 1;
                            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                                error('overflow');
                            }

                            delta += (m - n) * handledCPCountPlusOne;
                            n = m;

                            for (j = 0; j < inputLength; ++j) {
                                currentValue = input[j];

                                if (currentValue < n && ++delta > maxInt) {
                                    error('overflow');
                                }

                                if (currentValue == n) {
                                    // Represent delta as a generalized variable-length integer
                                    for (q = delta, k = base;; /* no condition */k += base) {
                                        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                        if (q < t) {
                                            break;
                                        }
                                        qMinusT = q - t;
                                        baseMinusT = base - t;
                                        output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                                        q = floor(qMinusT / baseMinusT);
                                    }

                                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                    delta = 0;
                                    ++handledCPCount;
                                }
                            }

                            ++delta;
                            ++n;
                        }
                        return output.join('');
                    }

                    /**
                     * Converts a Punycode string representing a domain name to Unicode. Only the
                     * Punycoded parts of the domain name will be converted, i.e. it doesn't
                     * matter if you call it on a string that has already been converted to
                     * Unicode.
                     * @memberOf punycode
                     * @param {String} domain The Punycode domain name to convert to Unicode.
                     * @returns {String} The Unicode representation of the given Punycode
                     * string.
                     */
                    function toUnicode(domain) {
                        return mapDomain(domain, function (string) {
                            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                        });
                    }

                    /**
                     * Converts a Unicode string representing a domain name to Punycode. Only the
                     * non-ASCII parts of the domain name will be converted, i.e. it doesn't
                     * matter if you call it with a domain that's already in ASCII.
                     * @memberOf punycode
                     * @param {String} domain The domain name to convert, as a Unicode string.
                     * @returns {String} The Punycode representation of the given domain name.
                     */
                    function toASCII(domain) {
                        return mapDomain(domain, function (string) {
                            return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
                        });
                    }

                    /*--------------------------------------------------------------------------*/

                    /** Define the public API */
                    punycode = {
                        /**
                         * A string representing the current Punycode.js version number.
                         * @memberOf punycode
                         * @type String
                         */
                        'version': '1.2.4',
                        /**
                         * An object of methods to convert from JavaScript's internal character
                         * representation (UCS-2) to Unicode code points, and back.
                         * @see <http://mathiasbynens.be/notes/javascript-encoding>
                         * @memberOf punycode
                         * @type Object
                         */
                        'ucs2': {
                            'decode': ucs2decode,
                            'encode': ucs2encode
                        },
                        'decode': decode,
                        'encode': encode,
                        'toASCII': toASCII,
                        'toUnicode': toUnicode
                    };

                    /** Expose `punycode` */
                    // Some AMD build optimizers, like r.js, check for specific condition patterns
                    // like the following:
                    if (typeof define == 'function' && _typeof(define.amd) == 'object' && define.amd) {
                        define('punycode', function () {
                            return punycode;
                        });
                    } else if (freeExports && !freeExports.nodeType) {
                        if (freeModule) {
                            // in Node.js or RingoJS v0.8.0+
                            freeModule.exports = punycode;
                        } else {
                            // in Narwhal or RingoJS v0.7.0-
                            for (key in punycode) {
                                punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                            }
                        }
                    } else {
                        // in Rhino or a web browser
                        root.punycode = punycode;
                    }
                })(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}], 2: [function (_dereq_, module, exports) {
            var log = _dereq_('./log');

            function restoreOwnerScroll(ownerDocument, x, y) {
                if (ownerDocument.defaultView && (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
                    ownerDocument.defaultView.scrollTo(x, y);
                }
            }

            function cloneCanvasContents(canvas, clonedCanvas) {
                try {
                    if (clonedCanvas) {
                        clonedCanvas.width = canvas.width;
                        clonedCanvas.height = canvas.height;
                        clonedCanvas.getContext("2d").putImageData(canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                    }
                } catch (e) {
                    log("Unable to copy canvas content from", canvas, e);
                }
            }

            function cloneNode(node, javascriptEnabled) {
                var clone = node.nodeType === 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false);

                var child = node.firstChild;
                while (child) {
                    if (javascriptEnabled === true || child.nodeType !== 1 || child.nodeName !== 'SCRIPT') {
                        clone.appendChild(cloneNode(child, javascriptEnabled));
                    }
                    child = child.nextSibling;
                }

                if (node.nodeType === 1) {
                    clone._scrollTop = node.scrollTop;
                    clone._scrollLeft = node.scrollLeft;
                    if (node.nodeName === "CANVAS") {
                        cloneCanvasContents(node, clone);
                    } else if (node.nodeName === "TEXTAREA" || node.nodeName === "SELECT") {
                        clone.value = node.value;
                    }
                }

                return clone;
            }

            function initNode(node) {
                if (node.nodeType === 1) {
                    node.scrollTop = node._scrollTop;
                    node.scrollLeft = node._scrollLeft;

                    var child = node.firstChild;
                    while (child) {
                        initNode(child);
                        child = child.nextSibling;
                    }
                }
            }

            module.exports = function (ownerDocument, containerDocument, width, height, options, x, y) {
                var documentElement = cloneNode(ownerDocument.documentElement, options.javascriptEnabled);
                var container = containerDocument.createElement("iframe");

                container.className = "html2canvas-container";
                container.style.visibility = "hidden";
                container.style.position = "fixed";
                container.style.left = "-10000px";
                container.style.top = "0px";
                container.style.border = "0";
                container.width = width;
                container.height = height;
                container.scrolling = "no"; // ios won't scroll without it
                containerDocument.body.appendChild(container);

                return new Promise(function (resolve) {
                    var documentClone = container.contentWindow.document;

                    /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
                     if window url is about:blank, we can assign the url to current by writing onto the document
                     */
                    container.contentWindow.onload = container.onload = function () {
                        var interval = setInterval(function () {
                            if (documentClone.body.childNodes.length > 0) {
                                initNode(documentClone.documentElement);
                                clearInterval(interval);
                                if (options.type === "view") {
                                    container.contentWindow.scrollTo(x, y);
                                    if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (container.contentWindow.scrollY !== y || container.contentWindow.scrollX !== x)) {
                                        documentClone.documentElement.style.top = -y + "px";
                                        documentClone.documentElement.style.left = -x + "px";
                                        documentClone.documentElement.style.position = 'absolute';
                                    }
                                }
                                resolve(container);
                            }
                        }, 50);
                    };

                    documentClone.open();
                    documentClone.write("<!DOCTYPE html><html></html>");
                    // Chrome scrolls the parent document for some reason after the write to the cloned window???
                    restoreOwnerScroll(ownerDocument, x, y);
                    documentClone.replaceChild(documentClone.adoptNode(documentElement), documentClone.documentElement);
                    documentClone.close();
                });
            };
        }, { "./log": 13 }], 3: [function (_dereq_, module, exports) {
            // http://dev.w3.org/csswg/css-color/

            function Color(value) {
                this.r = 0;
                this.g = 0;
                this.b = 0;
                this.a = null;
                var result = this.fromArray(value) || this.namedColor(value) || this.rgb(value) || this.rgba(value) || this.hex6(value) || this.hex3(value);
            }

            Color.prototype.darken = function (amount) {
                var a = 1 - amount;
                return new Color([Math.round(this.r * a), Math.round(this.g * a), Math.round(this.b * a), this.a]);
            };

            Color.prototype.isTransparent = function () {
                return this.a === 0;
            };

            Color.prototype.isBlack = function () {
                return this.r === 0 && this.g === 0 && this.b === 0;
            };

            Color.prototype.fromArray = function (array) {
                if (Array.isArray(array)) {
                    this.r = Math.min(array[0], 255);
                    this.g = Math.min(array[1], 255);
                    this.b = Math.min(array[2], 255);
                    if (array.length > 3) {
                        this.a = array[3];
                    }
                }

                return Array.isArray(array);
            };

            var _hex3 = /^#([a-f0-9]{3})$/i;

            Color.prototype.hex3 = function (value) {
                var match = null;
                if ((match = value.match(_hex3)) !== null) {
                    this.r = parseInt(match[1][0] + match[1][0], 16);
                    this.g = parseInt(match[1][1] + match[1][1], 16);
                    this.b = parseInt(match[1][2] + match[1][2], 16);
                }
                return match !== null;
            };

            var _hex6 = /^#([a-f0-9]{6})$/i;

            Color.prototype.hex6 = function (value) {
                var match = null;
                if ((match = value.match(_hex6)) !== null) {
                    this.r = parseInt(match[1].substring(0, 2), 16);
                    this.g = parseInt(match[1].substring(2, 4), 16);
                    this.b = parseInt(match[1].substring(4, 6), 16);
                }
                return match !== null;
            };

            var _rgb = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;

            Color.prototype.rgb = function (value) {
                var match = null;
                if ((match = value.match(_rgb)) !== null) {
                    this.r = Number(match[1]);
                    this.g = Number(match[2]);
                    this.b = Number(match[3]);
                }
                return match !== null;
            };

            var _rgba = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?\.?\d+)\s*\)$/;

            Color.prototype.rgba = function (value) {
                var match = null;
                if ((match = value.match(_rgba)) !== null) {
                    this.r = Number(match[1]);
                    this.g = Number(match[2]);
                    this.b = Number(match[3]);
                    this.a = Number(match[4]);
                }
                return match !== null;
            };

            Color.prototype.toString = function () {
                return this.a !== null && this.a !== 1 ? "rgba(" + [this.r, this.g, this.b, this.a].join(",") + ")" : "rgb(" + [this.r, this.g, this.b].join(",") + ")";
            };

            Color.prototype.namedColor = function (value) {
                value = value.toLowerCase();
                var color = colors[value];
                if (color) {
                    this.r = color[0];
                    this.g = color[1];
                    this.b = color[2];
                } else if (value === "transparent") {
                    this.r = this.g = this.b = this.a = 0;
                    return true;
                }

                return !!color;
            };

            Color.prototype.isColor = true;

            // JSON.stringify([].slice.call($$('.named-color-table tr'), 1).map(function(row) { return [row.childNodes[3].textContent, row.childNodes[5].textContent.trim().split(",").map(Number)] }).reduce(function(data, row) {data[row[0]] = row[1]; return data}, {}))
            var colors = {
                "aliceblue": [240, 248, 255],
                "antiquewhite": [250, 235, 215],
                "aqua": [0, 255, 255],
                "aquamarine": [127, 255, 212],
                "azure": [240, 255, 255],
                "beige": [245, 245, 220],
                "bisque": [255, 228, 196],
                "black": [0, 0, 0],
                "blanchedalmond": [255, 235, 205],
                "blue": [0, 0, 255],
                "blueviolet": [138, 43, 226],
                "brown": [165, 42, 42],
                "burlywood": [222, 184, 135],
                "cadetblue": [95, 158, 160],
                "chartreuse": [127, 255, 0],
                "chocolate": [210, 105, 30],
                "coral": [255, 127, 80],
                "cornflowerblue": [100, 149, 237],
                "cornsilk": [255, 248, 220],
                "crimson": [220, 20, 60],
                "cyan": [0, 255, 255],
                "darkblue": [0, 0, 139],
                "darkcyan": [0, 139, 139],
                "darkgoldenrod": [184, 134, 11],
                "darkgray": [169, 169, 169],
                "darkgreen": [0, 100, 0],
                "darkgrey": [169, 169, 169],
                "darkkhaki": [189, 183, 107],
                "darkmagenta": [139, 0, 139],
                "darkolivegreen": [85, 107, 47],
                "darkorange": [255, 140, 0],
                "darkorchid": [153, 50, 204],
                "darkred": [139, 0, 0],
                "darksalmon": [233, 150, 122],
                "darkseagreen": [143, 188, 143],
                "darkslateblue": [72, 61, 139],
                "darkslategray": [47, 79, 79],
                "darkslategrey": [47, 79, 79],
                "darkturquoise": [0, 206, 209],
                "darkviolet": [148, 0, 211],
                "deeppink": [255, 20, 147],
                "deepskyblue": [0, 191, 255],
                "dimgray": [105, 105, 105],
                "dimgrey": [105, 105, 105],
                "dodgerblue": [30, 144, 255],
                "firebrick": [178, 34, 34],
                "floralwhite": [255, 250, 240],
                "forestgreen": [34, 139, 34],
                "fuchsia": [255, 0, 255],
                "gainsboro": [220, 220, 220],
                "ghostwhite": [248, 248, 255],
                "gold": [255, 215, 0],
                "goldenrod": [218, 165, 32],
                "gray": [128, 128, 128],
                "green": [0, 128, 0],
                "greenyellow": [173, 255, 47],
                "grey": [128, 128, 128],
                "honeydew": [240, 255, 240],
                "hotpink": [255, 105, 180],
                "indianred": [205, 92, 92],
                "indigo": [75, 0, 130],
                "ivory": [255, 255, 240],
                "khaki": [240, 230, 140],
                "lavender": [230, 230, 250],
                "lavenderblush": [255, 240, 245],
                "lawngreen": [124, 252, 0],
                "lemonchiffon": [255, 250, 205],
                "lightblue": [173, 216, 230],
                "lightcoral": [240, 128, 128],
                "lightcyan": [224, 255, 255],
                "lightgoldenrodyellow": [250, 250, 210],
                "lightgray": [211, 211, 211],
                "lightgreen": [144, 238, 144],
                "lightgrey": [211, 211, 211],
                "lightpink": [255, 182, 193],
                "lightsalmon": [255, 160, 122],
                "lightseagreen": [32, 178, 170],
                "lightskyblue": [135, 206, 250],
                "lightslategray": [119, 136, 153],
                "lightslategrey": [119, 136, 153],
                "lightsteelblue": [176, 196, 222],
                "lightyellow": [255, 255, 224],
                "lime": [0, 255, 0],
                "limegreen": [50, 205, 50],
                "linen": [250, 240, 230],
                "magenta": [255, 0, 255],
                "maroon": [128, 0, 0],
                "mediumaquamarine": [102, 205, 170],
                "mediumblue": [0, 0, 205],
                "mediumorchid": [186, 85, 211],
                "mediumpurple": [147, 112, 219],
                "mediumseagreen": [60, 179, 113],
                "mediumslateblue": [123, 104, 238],
                "mediumspringgreen": [0, 250, 154],
                "mediumturquoise": [72, 209, 204],
                "mediumvioletred": [199, 21, 133],
                "midnightblue": [25, 25, 112],
                "mintcream": [245, 255, 250],
                "mistyrose": [255, 228, 225],
                "moccasin": [255, 228, 181],
                "navajowhite": [255, 222, 173],
                "navy": [0, 0, 128],
                "oldlace": [253, 245, 230],
                "olive": [128, 128, 0],
                "olivedrab": [107, 142, 35],
                "orange": [255, 165, 0],
                "orangered": [255, 69, 0],
                "orchid": [218, 112, 214],
                "palegoldenrod": [238, 232, 170],
                "palegreen": [152, 251, 152],
                "paleturquoise": [175, 238, 238],
                "palevioletred": [219, 112, 147],
                "papayawhip": [255, 239, 213],
                "peachpuff": [255, 218, 185],
                "peru": [205, 133, 63],
                "pink": [255, 192, 203],
                "plum": [221, 160, 221],
                "powderblue": [176, 224, 230],
                "purple": [128, 0, 128],
                "rebeccapurple": [102, 51, 153],
                "red": [255, 0, 0],
                "rosybrown": [188, 143, 143],
                "royalblue": [65, 105, 225],
                "saddlebrown": [139, 69, 19],
                "salmon": [250, 128, 114],
                "sandybrown": [244, 164, 96],
                "seagreen": [46, 139, 87],
                "seashell": [255, 245, 238],
                "sienna": [160, 82, 45],
                "silver": [192, 192, 192],
                "skyblue": [135, 206, 235],
                "slateblue": [106, 90, 205],
                "slategray": [112, 128, 144],
                "slategrey": [112, 128, 144],
                "snow": [255, 250, 250],
                "springgreen": [0, 255, 127],
                "steelblue": [70, 130, 180],
                "tan": [210, 180, 140],
                "teal": [0, 128, 128],
                "thistle": [216, 191, 216],
                "tomato": [255, 99, 71],
                "turquoise": [64, 224, 208],
                "violet": [238, 130, 238],
                "wheat": [245, 222, 179],
                "white": [255, 255, 255],
                "whitesmoke": [245, 245, 245],
                "yellow": [255, 255, 0],
                "yellowgreen": [154, 205, 50]
            };

            module.exports = Color;
        }, {}], 4: [function (_dereq_, module, exports) {
            var Support = _dereq_('./support');
            var CanvasRenderer = _dereq_('./renderers/canvas');
            var ImageLoader = _dereq_('./imageloader');
            var NodeParser = _dereq_('./nodeparser');
            var NodeContainer = _dereq_('./nodecontainer');
            var log = _dereq_('./log');
            var utils = _dereq_('./utils');
            var createWindowClone = _dereq_('./clone');
            var loadUrlDocument = _dereq_('./proxy').loadUrlDocument;
            var getBounds = utils.getBounds;

            var html2canvasNodeAttribute = "data-html2canvas-node";
            var html2canvasCloneIndex = 0;

            function html2canvas(nodeList, options) {
                var index = html2canvasCloneIndex++;
                options = options || {};
                if (options.logging) {
                    log.options.logging = true;
                    log.options.start = Date.now();
                }

                options.async = typeof options.async === "undefined" ? true : options.async;
                options.allowTaint = typeof options.allowTaint === "undefined" ? false : options.allowTaint;
                options.removeContainer = typeof options.removeContainer === "undefined" ? true : options.removeContainer;
                options.javascriptEnabled = typeof options.javascriptEnabled === "undefined" ? false : options.javascriptEnabled;
                options.imageTimeout = typeof options.imageTimeout === "undefined" ? 10000 : options.imageTimeout;
                options.renderer = typeof options.renderer === "function" ? options.renderer : CanvasRenderer;
                options.strict = !!options.strict;

                if (typeof nodeList === "string") {
                    if (typeof options.proxy !== "string") {
                        return Promise.reject("Proxy must be used when rendering url");
                    }
                    var width = options.width != null ? options.width : window.innerWidth;
                    var height = options.height != null ? options.height : window.innerHeight;
                    return loadUrlDocument(absoluteUrl(nodeList), options.proxy, document, width, height, options).then(function (container) {
                        return renderWindow(container.contentWindow.document.documentElement, container, options, width, height);
                    });
                }

                var node = (nodeList === undefined ? [document.documentElement] : nodeList.length ? nodeList : [nodeList])[0];
                node.setAttribute(html2canvasNodeAttribute + index, index);
                return renderDocument(node.ownerDocument, options, node.ownerDocument.defaultView.innerWidth, node.ownerDocument.defaultView.innerHeight, index).then(function (canvas) {
                    if (typeof options.onrendered === "function") {
                        log("options.onrendered is deprecated, html2canvas returns a Promise containing the canvas");
                        options.onrendered(canvas);
                    }
                    return canvas;
                });
            }

            html2canvas.CanvasRenderer = CanvasRenderer;
            html2canvas.NodeContainer = NodeContainer;
            html2canvas.log = log;
            html2canvas.utils = utils;

            var html2canvasExport = typeof document === "undefined" || typeof Object.create !== "function" || typeof document.createElement("canvas").getContext !== "function" ? function () {
                return Promise.reject("No canvas support");
            } : html2canvas;

            module.exports = html2canvasExport;

            if (typeof define === 'function' && define.amd) {
                define('html2canvas', [], function () {
                    return html2canvasExport;
                });
            }

            function renderDocument(document, options, windowWidth, windowHeight, html2canvasIndex) {
                return createWindowClone(document, document, windowWidth, windowHeight, options, document.defaultView.pageXOffset, document.defaultView.pageYOffset).then(function (container) {
                    log("Document cloned");
                    var attributeName = html2canvasNodeAttribute + html2canvasIndex;
                    var selector = "[" + attributeName + "='" + html2canvasIndex + "']";
                    document.querySelector(selector).removeAttribute(attributeName);
                    var clonedWindow = container.contentWindow;
                    var node = clonedWindow.document.querySelector(selector);
                    var oncloneHandler = typeof options.onclone === "function" ? Promise.resolve(options.onclone(clonedWindow.document)) : Promise.resolve(true);
                    return oncloneHandler.then(function () {
                        return renderWindow(node, container, options, windowWidth, windowHeight);
                    });
                });
            }

            function renderWindow(node, container, options, windowWidth, windowHeight) {
                var clonedWindow = container.contentWindow;
                var support = new Support(clonedWindow.document);
                var imageLoader = new ImageLoader(options, support);
                var bounds = getBounds(node);
                var width = options.type === "view" ? windowWidth : documentWidth(clonedWindow.document);
                var height = options.type === "view" ? windowHeight : documentHeight(clonedWindow.document);
                var renderer = new options.renderer(width, height, imageLoader, options, document);
                var parser = new NodeParser(node, renderer, support, imageLoader, options);
                return parser.ready.then(function () {
                    log("Finished rendering");
                    var canvas;

                    if (options.type === "view") {
                        canvas = crop(renderer.canvas, { width: renderer.canvas.width, height: renderer.canvas.height, top: 0, left: 0, x: 0, y: 0 });
                    } else if (node === clonedWindow.document.body || node === clonedWindow.document.documentElement || options.canvas != null) {
                        canvas = renderer.canvas;
                    } else {
                        canvas = crop(renderer.canvas, { width: options.width != null ? options.width : bounds.width, height: options.height != null ? options.height : bounds.height, top: bounds.top, left: bounds.left, x: 0, y: 0 });
                    }

                    cleanupContainer(container, options);
                    return canvas;
                });
            }

            function cleanupContainer(container, options) {
                if (options.removeContainer) {
                    container.parentNode.removeChild(container);
                    log("Cleaned up container");
                }
            }

            function crop(canvas, bounds) {
                var croppedCanvas = document.createElement("canvas");
                var x1 = Math.min(canvas.width - 1, Math.max(0, bounds.left));
                var x2 = Math.min(canvas.width, Math.max(1, bounds.left + bounds.width));
                var y1 = Math.min(canvas.height - 1, Math.max(0, bounds.top));
                var y2 = Math.min(canvas.height, Math.max(1, bounds.top + bounds.height));
                croppedCanvas.width = bounds.width;
                croppedCanvas.height = bounds.height;
                var width = x2 - x1;
                var height = y2 - y1;
                log("Cropping canvas at:", "left:", bounds.left, "top:", bounds.top, "width:", width, "height:", height);
                log("Resulting crop with width", bounds.width, "and height", bounds.height, "with x", x1, "and y", y1);
                croppedCanvas.getContext("2d").drawImage(canvas, x1, y1, width, height, bounds.x, bounds.y, width, height);
                return croppedCanvas;
            }

            function documentWidth(doc) {
                return Math.max(Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth), Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth), Math.max(doc.body.clientWidth, doc.documentElement.clientWidth));
            }

            function documentHeight(doc) {
                return Math.max(Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight), Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight), Math.max(doc.body.clientHeight, doc.documentElement.clientHeight));
            }

            function absoluteUrl(url) {
                var link = document.createElement("a");
                link.href = url;
                link.href = link.href;
                return link;
            }
        }, { "./clone": 2, "./imageloader": 11, "./log": 13, "./nodecontainer": 14, "./nodeparser": 15, "./proxy": 16, "./renderers/canvas": 20, "./support": 22, "./utils": 26 }], 5: [function (_dereq_, module, exports) {
            var log = _dereq_('./log');
            var smallImage = _dereq_('./utils').smallImage;

            function DummyImageContainer(src) {
                this.src = src;
                log("DummyImageContainer for", src);
                if (!this.promise || !this.image) {
                    log("Initiating DummyImageContainer");
                    DummyImageContainer.prototype.image = new Image();
                    var image = this.image;
                    DummyImageContainer.prototype.promise = new Promise(function (resolve, reject) {
                        image.onload = resolve;
                        image.onerror = reject;
                        image.src = smallImage();
                        if (image.complete === true) {
                            resolve(image);
                        }
                    });
                }
            }

            module.exports = DummyImageContainer;
        }, { "./log": 13, "./utils": 26 }], 6: [function (_dereq_, module, exports) {
            var smallImage = _dereq_('./utils').smallImage;

            function Font(family, size) {
                var container = document.createElement('div'),
                    img = document.createElement('img'),
                    span = document.createElement('span'),
                    sampleText = 'Hidden Text',
                    baseline,
                    middle;

                container.style.visibility = "hidden";
                container.style.fontFamily = family;
                container.style.fontSize = size;
                container.style.margin = 0;
                container.style.padding = 0;

                document.body.appendChild(container);

                img.src = smallImage();
                img.width = 1;
                img.height = 1;

                img.style.margin = 0;
                img.style.padding = 0;
                img.style.verticalAlign = "baseline";

                span.style.fontFamily = family;
                span.style.fontSize = size;
                span.style.margin = 0;
                span.style.padding = 0;

                span.appendChild(document.createTextNode(sampleText));
                container.appendChild(span);
                container.appendChild(img);
                baseline = img.offsetTop - span.offsetTop + 1;

                container.removeChild(span);
                container.appendChild(document.createTextNode(sampleText));

                container.style.lineHeight = "normal";
                img.style.verticalAlign = "super";

                middle = img.offsetTop - container.offsetTop + 1;

                document.body.removeChild(container);

                this.baseline = baseline;
                this.lineWidth = 1;
                this.middle = middle;
            }

            module.exports = Font;
        }, { "./utils": 26 }], 7: [function (_dereq_, module, exports) {
            var Font = _dereq_('./font');

            function FontMetrics() {
                this.data = {};
            }

            FontMetrics.prototype.getMetrics = function (family, size) {
                if (this.data[family + "-" + size] === undefined) {
                    this.data[family + "-" + size] = new Font(family, size);
                }
                return this.data[family + "-" + size];
            };

            module.exports = FontMetrics;
        }, { "./font": 6 }], 8: [function (_dereq_, module, exports) {
            var utils = _dereq_('./utils');
            var getBounds = utils.getBounds;
            var loadUrlDocument = _dereq_('./proxy').loadUrlDocument;

            function FrameContainer(container, sameOrigin, options) {
                this.image = null;
                this.src = container;
                var self = this;
                var bounds = getBounds(container);
                this.promise = (!sameOrigin ? this.proxyLoad(options.proxy, bounds, options) : new Promise(function (resolve) {
                    if (container.contentWindow.document.URL === "about:blank" || container.contentWindow.document.documentElement == null) {
                        container.contentWindow.onload = container.onload = function () {
                            resolve(container);
                        };
                    } else {
                        resolve(container);
                    }
                })).then(function (container) {
                    var html2canvas = _dereq_('./core');
                    return html2canvas(container.contentWindow.document.documentElement, { type: 'view', width: container.width, height: container.height, proxy: options.proxy, javascriptEnabled: options.javascriptEnabled, removeContainer: options.removeContainer, allowTaint: options.allowTaint, imageTimeout: options.imageTimeout / 2 });
                }).then(function (canvas) {
                    return self.image = canvas;
                });
            }

            FrameContainer.prototype.proxyLoad = function (proxy, bounds, options) {
                var container = this.src;
                return loadUrlDocument(container.src, proxy, container.ownerDocument, bounds.width, bounds.height, options);
            };

            module.exports = FrameContainer;
        }, { "./core": 4, "./proxy": 16, "./utils": 26 }], 9: [function (_dereq_, module, exports) {
            function GradientContainer(imageData) {
                this.src = imageData.value;
                this.colorStops = [];
                this.type = null;
                this.x0 = 0.5;
                this.y0 = 0.5;
                this.x1 = 0.5;
                this.y1 = 0.5;
                this.promise = Promise.resolve(true);
            }

            GradientContainer.TYPES = {
                LINEAR: 1,
                RADIAL: 2
            };

            // TODO: support hsl[a], negative %/length values
            // TODO: support <angle> (e.g. -?\d{1,3}(?:\.\d+)deg, etc. : https://developer.mozilla.org/docs/Web/CSS/angle )
            GradientContainer.REGEXP_COLORSTOP = /^\s*(rgba?\(\s*\d{1,3},\s*\d{1,3},\s*\d{1,3}(?:,\s*[0-9\.]+)?\s*\)|[a-z]{3,20}|#[a-f0-9]{3,6})(?:\s+(\d{1,3}(?:\.\d+)?)(%|px)?)?(?:\s|$)/i;

            module.exports = GradientContainer;
        }, {}], 10: [function (_dereq_, module, exports) {
            function ImageContainer(src, cors) {
                this.src = src;
                this.image = new Image();
                var self = this;
                this.tainted = null;
                this.promise = new Promise(function (resolve, reject) {
                    self.image.onload = resolve;
                    self.image.onerror = reject;
                    if (cors) {
                        self.image.crossOrigin = "anonymous";
                    }
                    self.image.src = src;
                    if (self.image.complete === true) {
                        resolve(self.image);
                    }
                });
            }

            module.exports = ImageContainer;
        }, {}], 11: [function (_dereq_, module, exports) {
            var log = _dereq_('./log');
            var ImageContainer = _dereq_('./imagecontainer');
            var DummyImageContainer = _dereq_('./dummyimagecontainer');
            var ProxyImageContainer = _dereq_('./proxyimagecontainer');
            var FrameContainer = _dereq_('./framecontainer');
            var SVGContainer = _dereq_('./svgcontainer');
            var SVGNodeContainer = _dereq_('./svgnodecontainer');
            var LinearGradientContainer = _dereq_('./lineargradientcontainer');
            var WebkitGradientContainer = _dereq_('./webkitgradientcontainer');
            var bind = _dereq_('./utils').bind;

            function ImageLoader(options, support) {
                this.link = null;
                this.options = options;
                this.support = support;
                this.origin = this.getOrigin(window.location.href);
            }

            ImageLoader.prototype.findImages = function (nodes) {
                var images = [];
                nodes.reduce(function (imageNodes, container) {
                    switch (container.node.nodeName) {
                        case "IMG":
                            return imageNodes.concat([{
                                args: [container.node.src],
                                method: "url"
                            }]);
                        case "svg":
                        case "IFRAME":
                            return imageNodes.concat([{
                                args: [container.node],
                                method: container.node.nodeName
                            }]);
                    }
                    return imageNodes;
                }, []).forEach(this.addImage(images, this.loadImage), this);
                return images;
            };

            ImageLoader.prototype.findBackgroundImage = function (images, container) {
                container.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(images, this.loadImage), this);
                return images;
            };

            ImageLoader.prototype.addImage = function (images, callback) {
                return function (newImage) {
                    newImage.args.forEach(function (image) {
                        if (!this.imageExists(images, image)) {
                            images.splice(0, 0, callback.call(this, newImage));
                            log('Added image #' + images.length, typeof image === "string" ? image.substring(0, 100) : image);
                        }
                    }, this);
                };
            };

            ImageLoader.prototype.hasImageBackground = function (imageData) {
                return imageData.method !== "none";
            };

            ImageLoader.prototype.loadImage = function (imageData) {
                if (imageData.method === "url") {
                    var src = imageData.args[0];
                    if (this.isSVG(src) && !this.support.svg && !this.options.allowTaint) {
                        return new SVGContainer(src);
                    } else if (src.match(/data:image\/.*;base64,/i)) {
                        return new ImageContainer(src.replace(/url\(['"]{0,}|['"]{0,}\)$/ig, ''), false);
                    } else if (this.isSameOrigin(src) || this.options.allowTaint === true || this.isSVG(src)) {
                        return new ImageContainer(src, false);
                    } else if (this.support.cors && !this.options.allowTaint && this.options.useCORS) {
                        return new ImageContainer(src, true);
                    } else if (this.options.proxy) {
                        return new ProxyImageContainer(src, this.options.proxy);
                    } else {
                        return new DummyImageContainer(src);
                    }
                } else if (imageData.method === "linear-gradient") {
                    return new LinearGradientContainer(imageData);
                } else if (imageData.method === "gradient") {
                    return new WebkitGradientContainer(imageData);
                } else if (imageData.method === "svg") {
                    return new SVGNodeContainer(imageData.args[0], this.support.svg);
                } else if (imageData.method === "IFRAME") {
                    return new FrameContainer(imageData.args[0], this.isSameOrigin(imageData.args[0].src), this.options);
                } else {
                    return new DummyImageContainer(imageData);
                }
            };

            ImageLoader.prototype.isSVG = function (src) {
                return src.substring(src.length - 3).toLowerCase() === "svg" || SVGContainer.prototype.isInline(src);
            };

            ImageLoader.prototype.imageExists = function (images, src) {
                return images.some(function (image) {
                    return image.src === src;
                });
            };

            ImageLoader.prototype.isSameOrigin = function (url) {
                return this.getOrigin(url) === this.origin;
            };

            ImageLoader.prototype.getOrigin = function (url) {
                var link = this.link || (this.link = document.createElement("a"));
                link.href = url;
                link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
                return link.protocol + link.hostname + link.port;
            };

            ImageLoader.prototype.getPromise = function (container) {
                return this.timeout(container, this.options.imageTimeout)['catch'](function () {
                    var dummy = new DummyImageContainer(container.src);
                    return dummy.promise.then(function (image) {
                        container.image = image;
                    });
                });
            };

            ImageLoader.prototype.get = function (src) {
                var found = null;
                return this.images.some(function (img) {
                    return (found = img).src === src;
                }) ? found : null;
            };

            ImageLoader.prototype.fetch = function (nodes) {
                this.images = nodes.reduce(bind(this.findBackgroundImage, this), this.findImages(nodes));
                this.images.forEach(function (image, index) {
                    image.promise.then(function () {
                        log("Succesfully loaded image #" + (index + 1), image);
                    }, function (e) {
                        log("Failed loading image #" + (index + 1), image, e);
                    });
                });
                this.ready = Promise.all(this.images.map(this.getPromise, this));
                log("Finished searching images");
                return this;
            };

            ImageLoader.prototype.timeout = function (container, timeout) {
                var timer;
                var promise = Promise.race([container.promise, new Promise(function (res, reject) {
                    timer = setTimeout(function () {
                        log("Timed out loading image", container);
                        reject(container);
                    }, timeout);
                })]).then(function (container) {
                    clearTimeout(timer);
                    return container;
                });
                promise['catch'](function () {
                    clearTimeout(timer);
                });
                return promise;
            };

            module.exports = ImageLoader;
        }, { "./dummyimagecontainer": 5, "./framecontainer": 8, "./imagecontainer": 10, "./lineargradientcontainer": 12, "./log": 13, "./proxyimagecontainer": 17, "./svgcontainer": 23, "./svgnodecontainer": 24, "./utils": 26, "./webkitgradientcontainer": 27 }], 12: [function (_dereq_, module, exports) {
            var GradientContainer = _dereq_('./gradientcontainer');
            var Color = _dereq_('./color');

            function LinearGradientContainer(imageData) {
                GradientContainer.apply(this, arguments);
                this.type = GradientContainer.TYPES.LINEAR;

                var hasDirection = LinearGradientContainer.REGEXP_DIRECTION.test(imageData.args[0]) || !GradientContainer.REGEXP_COLORSTOP.test(imageData.args[0]);

                if (hasDirection) {
                    imageData.args[0].split(/\s+/).reverse().forEach(function (position, index) {
                        switch (position) {
                            case "left":
                                this.x0 = 0;
                                this.x1 = 1;
                                break;
                            case "top":
                                this.y0 = 0;
                                this.y1 = 1;
                                break;
                            case "right":
                                this.x0 = 1;
                                this.x1 = 0;
                                break;
                            case "bottom":
                                this.y0 = 1;
                                this.y1 = 0;
                                break;
                            case "to":
                                var y0 = this.y0;
                                var x0 = this.x0;
                                this.y0 = this.y1;
                                this.x0 = this.x1;
                                this.x1 = x0;
                                this.y1 = y0;
                                break;
                            case "center":
                                break; // centered by default
                            // Firefox internally converts position keywords to percentages:
                            // http://www.w3.org/TR/2010/WD-CSS2-20101207/colors.html#propdef-background-position
                            default:
                                // percentage or absolute length
                                // TODO: support absolute start point positions (e.g., use bounds to convert px to a ratio)
                                var ratio = parseFloat(position, 10) * 1e-2;
                                if (isNaN(ratio)) {
                                    // invalid or unhandled value
                                    break;
                                }
                                if (index === 0) {
                                    this.y0 = ratio;
                                    this.y1 = 1 - this.y0;
                                } else {
                                    this.x0 = ratio;
                                    this.x1 = 1 - this.x0;
                                }
                                break;
                        }
                    }, this);
                } else {
                    this.y0 = 0;
                    this.y1 = 1;
                }

                this.colorStops = imageData.args.slice(hasDirection ? 1 : 0).map(function (colorStop) {
                    var colorStopMatch = colorStop.match(GradientContainer.REGEXP_COLORSTOP);
                    var value = +colorStopMatch[2];
                    var unit = value === 0 ? "%" : colorStopMatch[3]; // treat "0" as "0%"
                    return {
                        color: new Color(colorStopMatch[1]),
                        // TODO: support absolute stop positions (e.g., compute gradient line length & convert px to ratio)
                        stop: unit === "%" ? value / 100 : null
                    };
                });

                if (this.colorStops[0].stop === null) {
                    this.colorStops[0].stop = 0;
                }

                if (this.colorStops[this.colorStops.length - 1].stop === null) {
                    this.colorStops[this.colorStops.length - 1].stop = 1;
                }

                // calculates and fills-in explicit stop positions when omitted from rule
                this.colorStops.forEach(function (colorStop, index) {
                    if (colorStop.stop === null) {
                        this.colorStops.slice(index).some(function (find, count) {
                            if (find.stop !== null) {
                                colorStop.stop = (find.stop - this.colorStops[index - 1].stop) / (count + 1) + this.colorStops[index - 1].stop;
                                return true;
                            } else {
                                return false;
                            }
                        }, this);
                    }
                }, this);
            }

            LinearGradientContainer.prototype = Object.create(GradientContainer.prototype);

            // TODO: support <angle> (e.g. -?\d{1,3}(?:\.\d+)deg, etc. : https://developer.mozilla.org/docs/Web/CSS/angle )
            LinearGradientContainer.REGEXP_DIRECTION = /^\s*(?:to|left|right|top|bottom|center|\d{1,3}(?:\.\d+)?%?)(?:\s|$)/i;

            module.exports = LinearGradientContainer;
        }, { "./color": 3, "./gradientcontainer": 9 }], 13: [function (_dereq_, module, exports) {
            var logger = function logger() {
                if (logger.options.logging && window.console && window.console.log) {
                    Function.prototype.bind.call(window.console.log, window.console).apply(window.console, [Date.now() - logger.options.start + "ms", "html2canvas:"].concat([].slice.call(arguments, 0)));
                }
            };

            logger.options = { logging: false };
            module.exports = logger;
        }, {}], 14: [function (_dereq_, module, exports) {
            var Color = _dereq_('./color');
            var utils = _dereq_('./utils');
            var getBounds = utils.getBounds;
            var parseBackgrounds = utils.parseBackgrounds;
            var offsetBounds = utils.offsetBounds;

            function NodeContainer(node, parent) {
                this.node = node;
                this.parent = parent;
                this.stack = null;
                this.bounds = null;
                this.borders = null;
                this.clip = [];
                this.backgroundClip = [];
                this.offsetBounds = null;
                this.visible = null;
                this.computedStyles = null;
                this.colors = {};
                this.styles = {};
                this.backgroundImages = null;
                this.transformData = null;
                this.transformMatrix = null;
                this.isPseudoElement = false;
                this.opacity = null;
            }

            NodeContainer.prototype.cloneTo = function (stack) {
                stack.visible = this.visible;
                stack.borders = this.borders;
                stack.bounds = this.bounds;
                stack.clip = this.clip;
                stack.backgroundClip = this.backgroundClip;
                stack.computedStyles = this.computedStyles;
                stack.styles = this.styles;
                stack.backgroundImages = this.backgroundImages;
                stack.opacity = this.opacity;
            };

            NodeContainer.prototype.getOpacity = function () {
                return this.opacity === null ? this.opacity = this.cssFloat('opacity') : this.opacity;
            };

            NodeContainer.prototype.assignStack = function (stack) {
                this.stack = stack;
                stack.children.push(this);
            };

            NodeContainer.prototype.isElementVisible = function () {
                return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : this.css('display') !== "none" && this.css('visibility') !== "hidden" && !this.node.hasAttribute("data-html2canvas-ignore") && (this.node.nodeName !== "INPUT" || this.node.getAttribute("type") !== "hidden");
            };

            NodeContainer.prototype.css = function (attribute) {
                if (!this.computedStyles) {
                    this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ":before" : ":after") : this.computedStyle(null);
                }

                return this.styles[attribute] || (this.styles[attribute] = this.computedStyles[attribute]);
            };

            NodeContainer.prototype.prefixedCss = function (attribute) {
                var prefixes = ["webkit", "moz", "ms", "o"];
                var value = this.css(attribute);
                if (value === undefined) {
                    prefixes.some(function (prefix) {
                        value = this.css(prefix + attribute.substr(0, 1).toUpperCase() + attribute.substr(1));
                        return value !== undefined;
                    }, this);
                }
                return value === undefined ? null : value;
            };

            NodeContainer.prototype.computedStyle = function (type) {
                return this.node.ownerDocument.defaultView.getComputedStyle(this.node, type);
            };

            NodeContainer.prototype.cssInt = function (attribute) {
                var value = parseInt(this.css(attribute), 10);
                return isNaN(value) ? 0 : value; // borders in old IE are throwing 'medium' for demo.html
            };

            NodeContainer.prototype.color = function (attribute) {
                return this.colors[attribute] || (this.colors[attribute] = new Color(this.css(attribute)));
            };

            NodeContainer.prototype.cssFloat = function (attribute) {
                var value = parseFloat(this.css(attribute));
                return isNaN(value) ? 0 : value;
            };

            NodeContainer.prototype.fontWeight = function () {
                var weight = this.css("fontWeight");
                switch (parseInt(weight, 10)) {
                    case 401:
                        weight = "bold";
                        break;
                    case 400:
                        weight = "normal";
                        break;
                }
                return weight;
            };

            NodeContainer.prototype.parseClip = function () {
                var matches = this.css('clip').match(this.CLIP);
                if (matches) {
                    return {
                        top: parseInt(matches[1], 10),
                        right: parseInt(matches[2], 10),
                        bottom: parseInt(matches[3], 10),
                        left: parseInt(matches[4], 10)
                    };
                }
                return null;
            };

            NodeContainer.prototype.parseBackgroundImages = function () {
                return this.backgroundImages || (this.backgroundImages = parseBackgrounds(this.css("backgroundImage")));
            };

            NodeContainer.prototype.cssList = function (property, index) {
                var value = (this.css(property) || '').split(',');
                value = value[index || 0] || value[0] || 'auto';
                value = value.trim().split(' ');
                if (value.length === 1) {
                    value = [value[0], isPercentage(value[0]) ? 'auto' : value[0]];
                }
                return value;
            };

            NodeContainer.prototype.parseBackgroundSize = function (bounds, image, index) {
                var size = this.cssList("backgroundSize", index);
                var width, height;

                if (isPercentage(size[0])) {
                    width = bounds.width * parseFloat(size[0]) / 100;
                } else if (/contain|cover/.test(size[0])) {
                    var targetRatio = bounds.width / bounds.height,
                        currentRatio = image.width / image.height;
                    return targetRatio < currentRatio ^ size[0] === 'contain' ? { width: bounds.height * currentRatio, height: bounds.height } : { width: bounds.width, height: bounds.width / currentRatio };
                } else {
                    width = parseInt(size[0], 10);
                }

                if (size[0] === 'auto' && size[1] === 'auto') {
                    height = image.height;
                } else if (size[1] === 'auto') {
                    height = width / image.width * image.height;
                } else if (isPercentage(size[1])) {
                    height = bounds.height * parseFloat(size[1]) / 100;
                } else {
                    height = parseInt(size[1], 10);
                }

                if (size[0] === 'auto') {
                    width = height / image.height * image.width;
                }

                return { width: width, height: height };
            };

            NodeContainer.prototype.parseBackgroundPosition = function (bounds, image, index, backgroundSize) {
                var position = this.cssList('backgroundPosition', index);
                var left, top;

                if (isPercentage(position[0])) {
                    left = (bounds.width - (backgroundSize || image).width) * (parseFloat(position[0]) / 100);
                } else {
                    left = parseInt(position[0], 10);
                }

                if (position[1] === 'auto') {
                    top = left / image.width * image.height;
                } else if (isPercentage(position[1])) {
                    top = (bounds.height - (backgroundSize || image).height) * parseFloat(position[1]) / 100;
                } else {
                    top = parseInt(position[1], 10);
                }

                if (position[0] === 'auto') {
                    left = top / image.height * image.width;
                }

                return { left: left, top: top };
            };

            NodeContainer.prototype.parseBackgroundRepeat = function (index) {
                return this.cssList("backgroundRepeat", index)[0];
            };

            NodeContainer.prototype.parseTextShadows = function () {
                var textShadow = this.css("textShadow");
                var results = [];

                if (textShadow && textShadow !== 'none') {
                    var shadows = textShadow.match(this.TEXT_SHADOW_PROPERTY);
                    for (var i = 0; shadows && i < shadows.length; i++) {
                        var s = shadows[i].match(this.TEXT_SHADOW_VALUES);
                        results.push({
                            color: new Color(s[0]),
                            offsetX: s[1] ? parseFloat(s[1].replace('px', '')) : 0,
                            offsetY: s[2] ? parseFloat(s[2].replace('px', '')) : 0,
                            blur: s[3] ? s[3].replace('px', '') : 0
                        });
                    }
                }
                return results;
            };

            NodeContainer.prototype.parseTransform = function () {
                if (!this.transformData) {
                    if (this.hasTransform()) {
                        var offset = this.parseBounds();
                        var origin = this.prefixedCss("transformOrigin").split(" ").map(removePx).map(asFloat);
                        origin[0] += offset.left;
                        origin[1] += offset.top;
                        this.transformData = {
                            origin: origin,
                            matrix: this.parseTransformMatrix()
                        };
                    } else {
                        this.transformData = {
                            origin: [0, 0],
                            matrix: [1, 0, 0, 1, 0, 0]
                        };
                    }
                }
                return this.transformData;
            };

            NodeContainer.prototype.parseTransformMatrix = function () {
                if (!this.transformMatrix) {
                    var transform = this.prefixedCss("transform");
                    var matrix = transform ? parseMatrix(transform.match(this.MATRIX_PROPERTY)) : null;
                    this.transformMatrix = matrix ? matrix : [1, 0, 0, 1, 0, 0];
                }
                return this.transformMatrix;
            };

            NodeContainer.prototype.parseBounds = function () {
                return this.bounds || (this.bounds = this.hasTransform() ? offsetBounds(this.node) : getBounds(this.node));
            };

            NodeContainer.prototype.hasTransform = function () {
                return this.parseTransformMatrix().join(",") !== "1,0,0,1,0,0" || this.parent && this.parent.hasTransform();
            };

            NodeContainer.prototype.getValue = function () {
                var value = this.node.value || "";
                if (this.node.tagName === "SELECT") {
                    value = selectionValue(this.node);
                } else if (this.node.type === "password") {
                    value = Array(value.length + 1).join("\u2022"); // jshint ignore:line
                }
                return value.length === 0 ? this.node.placeholder || "" : value;
            };

            NodeContainer.prototype.MATRIX_PROPERTY = /(matrix|matrix3d)\((.+)\)/;
            NodeContainer.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g;
            NodeContainer.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g;
            NodeContainer.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/;

            function selectionValue(node) {
                var option = node.options[node.selectedIndex || 0];
                return option ? option.text || "" : "";
            }

            function parseMatrix(match) {
                if (match && match[1] === "matrix") {
                    return match[2].split(",").map(function (s) {
                        return parseFloat(s.trim());
                    });
                } else if (match && match[1] === "matrix3d") {
                    var matrix3d = match[2].split(",").map(function (s) {
                        return parseFloat(s.trim());
                    });
                    return [matrix3d[0], matrix3d[1], matrix3d[4], matrix3d[5], matrix3d[12], matrix3d[13]];
                }
            }

            function isPercentage(value) {
                return value.toString().indexOf("%") !== -1;
            }

            function removePx(str) {
                return str.replace("px", "");
            }

            function asFloat(str) {
                return parseFloat(str);
            }

            module.exports = NodeContainer;
        }, { "./color": 3, "./utils": 26 }], 15: [function (_dereq_, module, exports) {
            var log = _dereq_('./log');
            var punycode = _dereq_('punycode');
            var NodeContainer = _dereq_('./nodecontainer');
            var TextContainer = _dereq_('./textcontainer');
            var PseudoElementContainer = _dereq_('./pseudoelementcontainer');
            var FontMetrics = _dereq_('./fontmetrics');
            var Color = _dereq_('./color');
            var StackingContext = _dereq_('./stackingcontext');
            var utils = _dereq_('./utils');
            var bind = utils.bind;
            var getBounds = utils.getBounds;
            var parseBackgrounds = utils.parseBackgrounds;
            var offsetBounds = utils.offsetBounds;

            function NodeParser(element, renderer, support, imageLoader, options) {
                log("Starting NodeParser");
                this.renderer = renderer;
                this.options = options;
                this.range = null;
                this.support = support;
                this.renderQueue = [];
                this.stack = new StackingContext(true, 1, element.ownerDocument, null);
                var parent = new NodeContainer(element, null);
                if (options.background) {
                    renderer.rectangle(0, 0, renderer.width, renderer.height, new Color(options.background));
                }
                if (element === element.ownerDocument.documentElement) {
                    // http://www.w3.org/TR/css3-background/#special-backgrounds
                    var canvasBackground = new NodeContainer(parent.color('backgroundColor').isTransparent() ? element.ownerDocument.body : element.ownerDocument.documentElement, null);
                    renderer.rectangle(0, 0, renderer.width, renderer.height, canvasBackground.color('backgroundColor'));
                }
                parent.visibile = parent.isElementVisible();
                this.createPseudoHideStyles(element.ownerDocument);
                this.disableAnimations(element.ownerDocument);
                this.nodes = flatten([parent].concat(this.getChildren(parent)).filter(function (container) {
                    return container.visible = container.isElementVisible();
                }).map(this.getPseudoElements, this));
                this.fontMetrics = new FontMetrics();
                log("Fetched nodes, total:", this.nodes.length);
                log("Calculate overflow clips");
                this.calculateOverflowClips();
                log("Start fetching images");
                this.images = imageLoader.fetch(this.nodes.filter(isElement));
                this.ready = this.images.ready.then(bind(function () {
                    log("Images loaded, starting parsing");
                    log("Creating stacking contexts");
                    this.createStackingContexts();
                    log("Sorting stacking contexts");
                    this.sortStackingContexts(this.stack);
                    this.parse(this.stack);
                    log("Render queue created with " + this.renderQueue.length + " items");
                    return new Promise(bind(function (resolve) {
                        if (!options.async) {
                            this.renderQueue.forEach(this.paint, this);
                            resolve();
                        } else if (typeof options.async === "function") {
                            options.async.call(this, this.renderQueue, resolve);
                        } else if (this.renderQueue.length > 0) {
                            this.renderIndex = 0;
                            this.asyncRenderer(this.renderQueue, resolve);
                        } else {
                            resolve();
                        }
                    }, this));
                }, this));
            }

            NodeParser.prototype.calculateOverflowClips = function () {
                this.nodes.forEach(function (container) {
                    if (isElement(container)) {
                        if (isPseudoElement(container)) {
                            container.appendToDOM();
                        }
                        container.borders = this.parseBorders(container);
                        var clip = container.css('overflow') === "hidden" ? [container.borders.clip] : [];
                        var cssClip = container.parseClip();
                        if (cssClip && ["absolute", "fixed"].indexOf(container.css('position')) !== -1) {
                            clip.push([["rect", container.bounds.left + cssClip.left, container.bounds.top + cssClip.top, cssClip.right - cssClip.left, cssClip.bottom - cssClip.top]]);
                        }
                        container.clip = hasParentClip(container) ? container.parent.clip.concat(clip) : clip;
                        container.backgroundClip = container.css('overflow') !== "hidden" ? container.clip.concat([container.borders.clip]) : container.clip;
                        if (isPseudoElement(container)) {
                            container.cleanDOM();
                        }
                    } else if (isTextNode(container)) {
                        container.clip = hasParentClip(container) ? container.parent.clip : [];
                    }
                    if (!isPseudoElement(container)) {
                        container.bounds = null;
                    }
                }, this);
            };

            function hasParentClip(container) {
                return container.parent && container.parent.clip.length;
            }

            NodeParser.prototype.asyncRenderer = function (queue, resolve, asyncTimer) {
                asyncTimer = asyncTimer || Date.now();
                this.paint(queue[this.renderIndex++]);
                if (queue.length === this.renderIndex) {
                    resolve();
                } else if (asyncTimer + 20 > Date.now()) {
                    this.asyncRenderer(queue, resolve, asyncTimer);
                } else {
                    setTimeout(bind(function () {
                        this.asyncRenderer(queue, resolve);
                    }, this), 0);
                }
            };

            NodeParser.prototype.createPseudoHideStyles = function (document) {
                this.createStyles(document, '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: "" !important; display: none !important; }' + '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: "" !important; display: none !important; }');
            };

            NodeParser.prototype.disableAnimations = function (document) {
                this.createStyles(document, '* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; ' + '-webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}');
            };

            NodeParser.prototype.createStyles = function (document, styles) {
                var hidePseudoElements = document.createElement('style');
                hidePseudoElements.innerHTML = styles;
                document.body.appendChild(hidePseudoElements);
            };

            NodeParser.prototype.getPseudoElements = function (container) {
                var nodes = [[container]];
                if (container.node.nodeType === Node.ELEMENT_NODE) {
                    var before = this.getPseudoElement(container, ":before");
                    var after = this.getPseudoElement(container, ":after");

                    if (before) {
                        nodes.push(before);
                    }

                    if (after) {
                        nodes.push(after);
                    }
                }
                return flatten(nodes);
            };

            function toCamelCase(str) {
                return str.replace(/(\-[a-z])/g, function (match) {
                    return match.toUpperCase().replace('-', '');
                });
            }

            NodeParser.prototype.getPseudoElement = function (container, type) {
                var style = container.computedStyle(type);
                if (!style || !style.content || style.content === "none" || style.content === "-moz-alt-content" || style.display === "none") {
                    return null;
                }

                var content = stripQuotes(style.content);
                var isImage = content.substr(0, 3) === 'url';
                var pseudoNode = document.createElement(isImage ? 'img' : 'html2canvaspseudoelement');
                var pseudoContainer = new PseudoElementContainer(pseudoNode, container, type);

                for (var i = style.length - 1; i >= 0; i--) {
                    var property = toCamelCase(style.item(i));
                    pseudoNode.style[property] = style[property];
                }

                pseudoNode.className = PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER;

                if (isImage) {
                    pseudoNode.src = parseBackgrounds(content)[0].args[0];
                    return [pseudoContainer];
                } else {
                    var text = document.createTextNode(content);
                    pseudoNode.appendChild(text);
                    return [pseudoContainer, new TextContainer(text, pseudoContainer)];
                }
            };

            NodeParser.prototype.getChildren = function (parentContainer) {
                return flatten([].filter.call(parentContainer.node.childNodes, renderableNode).map(function (node) {
                    var container = [node.nodeType === Node.TEXT_NODE ? new TextContainer(node, parentContainer) : new NodeContainer(node, parentContainer)].filter(nonIgnoredElement);
                    return node.nodeType === Node.ELEMENT_NODE && container.length && node.tagName !== "TEXTAREA" ? container[0].isElementVisible() ? container.concat(this.getChildren(container[0])) : [] : container;
                }, this));
            };

            NodeParser.prototype.newStackingContext = function (container, hasOwnStacking) {
                var stack = new StackingContext(hasOwnStacking, container.getOpacity(), container.node, container.parent);
                container.cloneTo(stack);
                var parentStack = hasOwnStacking ? stack.getParentStack(this) : stack.parent.stack;
                parentStack.contexts.push(stack);
                container.stack = stack;
            };

            NodeParser.prototype.createStackingContexts = function () {
                this.nodes.forEach(function (container) {
                    if (isElement(container) && (this.isRootElement(container) || hasOpacity(container) || isPositionedForStacking(container) || this.isBodyWithTransparentRoot(container) || container.hasTransform())) {
                        this.newStackingContext(container, true);
                    } else if (isElement(container) && (isPositioned(container) && zIndex0(container) || isInlineBlock(container) || isFloating(container))) {
                        this.newStackingContext(container, false);
                    } else {
                        container.assignStack(container.parent.stack);
                    }
                }, this);
            };

            NodeParser.prototype.isBodyWithTransparentRoot = function (container) {
                return container.node.nodeName === "BODY" && container.parent.color('backgroundColor').isTransparent();
            };

            NodeParser.prototype.isRootElement = function (container) {
                return container.parent === null;
            };

            NodeParser.prototype.sortStackingContexts = function (stack) {
                stack.contexts.sort(zIndexSort(stack.contexts.slice(0)));
                stack.contexts.forEach(this.sortStackingContexts, this);
            };

            NodeParser.prototype.parseTextBounds = function (container) {
                return function (text, index, textList) {
                    if (container.parent.css("textDecoration").substr(0, 4) !== "none" || text.trim().length !== 0) {
                        if (this.support.rangeBounds && !container.parent.hasTransform()) {
                            var offset = textList.slice(0, index).join("").length;
                            return this.getRangeBounds(container.node, offset, text.length);
                        } else if (container.node && typeof container.node.data === "string") {
                            var replacementNode = container.node.splitText(text.length);
                            var bounds = this.getWrapperBounds(container.node, container.parent.hasTransform());
                            container.node = replacementNode;
                            return bounds;
                        }
                    } else if (!this.support.rangeBounds || container.parent.hasTransform()) {
                        container.node = container.node.splitText(text.length);
                    }
                    return {};
                };
            };

            NodeParser.prototype.getWrapperBounds = function (node, transform) {
                var wrapper = node.ownerDocument.createElement('html2canvaswrapper');
                var parent = node.parentNode,
                    backupText = node.cloneNode(true);

                wrapper.appendChild(node.cloneNode(true));
                parent.replaceChild(wrapper, node);
                var bounds = transform ? offsetBounds(wrapper) : getBounds(wrapper);
                parent.replaceChild(backupText, wrapper);
                return bounds;
            };

            NodeParser.prototype.getRangeBounds = function (node, offset, length) {
                var range = this.range || (this.range = node.ownerDocument.createRange());
                range.setStart(node, offset);
                range.setEnd(node, offset + length);
                return range.getBoundingClientRect();
            };

            function ClearTransform() {}

            NodeParser.prototype.parse = function (stack) {
                // http://www.w3.org/TR/CSS21/visuren.html#z-index
                var negativeZindex = stack.contexts.filter(negativeZIndex); // 2. the child stacking contexts with negative stack levels (most negative first).
                var descendantElements = stack.children.filter(isElement);
                var descendantNonFloats = descendantElements.filter(not(isFloating));
                var nonInlineNonPositionedDescendants = descendantNonFloats.filter(not(isPositioned)).filter(not(inlineLevel)); // 3 the in-flow, non-inline-level, non-positioned descendants.
                var nonPositionedFloats = descendantElements.filter(not(isPositioned)).filter(isFloating); // 4. the non-positioned floats.
                var inFlow = descendantNonFloats.filter(not(isPositioned)).filter(inlineLevel); // 5. the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.
                var stackLevel0 = stack.contexts.concat(descendantNonFloats.filter(isPositioned)).filter(zIndex0); // 6. the child stacking contexts with stack level 0 and the positioned descendants with stack level 0.
                var text = stack.children.filter(isTextNode).filter(hasText);
                var positiveZindex = stack.contexts.filter(positiveZIndex); // 7. the child stacking contexts with positive stack levels (least positive first).
                negativeZindex.concat(nonInlineNonPositionedDescendants).concat(nonPositionedFloats).concat(inFlow).concat(stackLevel0).concat(text).concat(positiveZindex).forEach(function (container) {
                    this.renderQueue.push(container);
                    if (isStackingContext(container)) {
                        this.parse(container);
                        this.renderQueue.push(new ClearTransform());
                    }
                }, this);
            };

            NodeParser.prototype.paint = function (container) {
                try {
                    if (container instanceof ClearTransform) {
                        this.renderer.ctx.restore();
                    } else if (isTextNode(container)) {
                        if (isPseudoElement(container.parent)) {
                            container.parent.appendToDOM();
                        }
                        this.paintText(container);
                        if (isPseudoElement(container.parent)) {
                            container.parent.cleanDOM();
                        }
                    } else {
                        this.paintNode(container);
                    }
                } catch (e) {
                    log(e);
                    if (this.options.strict) {
                        throw e;
                    }
                }
            };

            NodeParser.prototype.paintNode = function (container) {
                if (isStackingContext(container)) {
                    this.renderer.setOpacity(container.opacity);
                    this.renderer.ctx.save();
                    if (container.hasTransform()) {
                        this.renderer.setTransform(container.parseTransform());
                    }
                }

                if (container.node.nodeName === "INPUT" && container.node.type === "checkbox") {
                    this.paintCheckbox(container);
                } else if (container.node.nodeName === "INPUT" && container.node.type === "radio") {
                    this.paintRadio(container);
                } else {
                    this.paintElement(container);
                }
            };

            NodeParser.prototype.paintElement = function (container) {
                var bounds = container.parseBounds();
                this.renderer.clip(container.backgroundClip, function () {
                    this.renderer.renderBackground(container, bounds, container.borders.borders.map(getWidth));
                }, this);

                this.renderer.clip(container.clip, function () {
                    this.renderer.renderBorders(container.borders.borders);
                }, this);

                this.renderer.clip(container.backgroundClip, function () {
                    switch (container.node.nodeName) {
                        case "svg":
                        case "IFRAME":
                            var imgContainer = this.images.get(container.node);
                            if (imgContainer) {
                                this.renderer.renderImage(container, bounds, container.borders, imgContainer);
                            } else {
                                log("Error loading <" + container.node.nodeName + ">", container.node);
                            }
                            break;
                        case "IMG":
                            var imageContainer = this.images.get(container.node.src);
                            if (imageContainer) {
                                this.renderer.renderImage(container, bounds, container.borders, imageContainer);
                            } else {
                                log("Error loading <img>", container.node.src);
                            }
                            break;
                        case "CANVAS":
                            this.renderer.renderImage(container, bounds, container.borders, { image: container.node });
                            break;
                        case "SELECT":
                        case "INPUT":
                        case "TEXTAREA":
                            this.paintFormValue(container);
                            break;
                    }
                }, this);
            };

            NodeParser.prototype.paintCheckbox = function (container) {
                var b = container.parseBounds();

                var size = Math.min(b.width, b.height);
                var bounds = { width: size - 1, height: size - 1, top: b.top, left: b.left };
                var r = [3, 3];
                var radius = [r, r, r, r];
                var borders = [1, 1, 1, 1].map(function (w) {
                    return { color: new Color('#A5A5A5'), width: w };
                });

                var borderPoints = calculateCurvePoints(bounds, radius, borders);

                this.renderer.clip(container.backgroundClip, function () {
                    this.renderer.rectangle(bounds.left + 1, bounds.top + 1, bounds.width - 2, bounds.height - 2, new Color("#DEDEDE"));
                    this.renderer.renderBorders(calculateBorders(borders, bounds, borderPoints, radius));
                    if (container.node.checked) {
                        this.renderer.font(new Color('#424242'), 'normal', 'normal', 'bold', size - 3 + "px", 'arial');
                        this.renderer.text("\u2714", bounds.left + size / 6, bounds.top + size - 1);
                    }
                }, this);
            };

            NodeParser.prototype.paintRadio = function (container) {
                var bounds = container.parseBounds();

                var size = Math.min(bounds.width, bounds.height) - 2;

                this.renderer.clip(container.backgroundClip, function () {
                    this.renderer.circleStroke(bounds.left + 1, bounds.top + 1, size, new Color('#DEDEDE'), 1, new Color('#A5A5A5'));
                    if (container.node.checked) {
                        this.renderer.circle(Math.ceil(bounds.left + size / 4) + 1, Math.ceil(bounds.top + size / 4) + 1, Math.floor(size / 2), new Color('#424242'));
                    }
                }, this);
            };

            NodeParser.prototype.paintFormValue = function (container) {
                var value = container.getValue();
                if (value.length > 0) {
                    var document = container.node.ownerDocument;
                    var wrapper = document.createElement('html2canvaswrapper');
                    var properties = ['lineHeight', 'textAlign', 'fontFamily', 'fontWeight', 'fontSize', 'color', 'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'width', 'height', 'borderLeftStyle', 'borderTopStyle', 'borderLeftWidth', 'borderTopWidth', 'boxSizing', 'whiteSpace', 'wordWrap'];

                    properties.forEach(function (property) {
                        try {
                            wrapper.style[property] = container.css(property);
                        } catch (e) {
                            // Older IE has issues with "border"
                            log("html2canvas: Parse: Exception caught in renderFormValue: " + e.message);
                        }
                    });
                    var bounds = container.parseBounds();
                    wrapper.style.position = "fixed";
                    wrapper.style.left = bounds.left + "px";
                    wrapper.style.top = bounds.top + "px";
                    wrapper.textContent = value;
                    document.body.appendChild(wrapper);
                    this.paintText(new TextContainer(wrapper.firstChild, container));
                    document.body.removeChild(wrapper);
                }
            };

            NodeParser.prototype.paintText = function (container) {
                container.applyTextTransform();
                var characters = punycode.ucs2.decode(container.node.data);
                var textList = (!this.options.letterRendering || noLetterSpacing(container)) && !hasUnicode(container.node.data) ? getWords(characters) : characters.map(function (character) {
                    return punycode.ucs2.encode([character]);
                });

                var weight = container.parent.fontWeight();
                var size = container.parent.css('fontSize');
                var family = container.parent.css('fontFamily');
                var shadows = container.parent.parseTextShadows();

                this.renderer.font(container.parent.color('color'), container.parent.css('fontStyle'), container.parent.css('fontVariant'), weight, size, family);
                if (shadows.length) {
                    // TODO: support multiple text shadows
                    this.renderer.fontShadow(shadows[0].color, shadows[0].offsetX, shadows[0].offsetY, shadows[0].blur);
                } else {
                    this.renderer.clearShadow();
                }

                this.renderer.clip(container.parent.clip, function () {
                    textList.map(this.parseTextBounds(container), this).forEach(function (bounds, index) {
                        if (bounds) {
                            this.renderer.text(textList[index], bounds.left, bounds.bottom);
                            this.renderTextDecoration(container.parent, bounds, this.fontMetrics.getMetrics(family, size));
                        }
                    }, this);
                }, this);
            };

            NodeParser.prototype.renderTextDecoration = function (container, bounds, metrics) {
                switch (container.css("textDecoration").split(" ")[0]) {
                    case "underline":
                        // Draws a line at the baseline of the font
                        // TODO As some browsers display the line as more than 1px if the font-size is big, need to take that into account both in position and size
                        this.renderer.rectangle(bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, container.color("color"));
                        break;
                    case "overline":
                        this.renderer.rectangle(bounds.left, Math.round(bounds.top), bounds.width, 1, container.color("color"));
                        break;
                    case "line-through":
                        // TODO try and find exact position for line-through
                        this.renderer.rectangle(bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, container.color("color"));
                        break;
                }
            };

            var borderColorTransforms = {
                inset: [["darken", 0.60], ["darken", 0.10], ["darken", 0.10], ["darken", 0.60]]
            };

            NodeParser.prototype.parseBorders = function (container) {
                var nodeBounds = container.parseBounds();
                var radius = getBorderRadiusData(container);
                var borders = ["Top", "Right", "Bottom", "Left"].map(function (side, index) {
                    var style = container.css('border' + side + 'Style');
                    var color = container.color('border' + side + 'Color');
                    if (style === "inset" && color.isBlack()) {
                        color = new Color([255, 255, 255, color.a]); // this is wrong, but
                    }
                    var colorTransform = borderColorTransforms[style] ? borderColorTransforms[style][index] : null;
                    return {
                        width: container.cssInt('border' + side + 'Width'),
                        color: colorTransform ? color[colorTransform[0]](colorTransform[1]) : color,
                        args: null
                    };
                });
                var borderPoints = calculateCurvePoints(nodeBounds, radius, borders);

                return {
                    clip: this.parseBackgroundClip(container, borderPoints, borders, radius, nodeBounds),
                    borders: calculateBorders(borders, nodeBounds, borderPoints, radius)
                };
            };

            function calculateBorders(borders, nodeBounds, borderPoints, radius) {
                return borders.map(function (border, borderSide) {
                    if (border.width > 0) {
                        var bx = nodeBounds.left;
                        var by = nodeBounds.top;
                        var bw = nodeBounds.width;
                        var bh = nodeBounds.height - borders[2].width;

                        switch (borderSide) {
                            case 0:
                                // top border
                                bh = borders[0].width;
                                border.args = drawSide({
                                    c1: [bx, by],
                                    c2: [bx + bw, by],
                                    c3: [bx + bw - borders[1].width, by + bh],
                                    c4: [bx + borders[3].width, by + bh]
                                }, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner);
                                break;
                            case 1:
                                // right border
                                bx = nodeBounds.left + nodeBounds.width - borders[1].width;
                                bw = borders[1].width;

                                border.args = drawSide({
                                    c1: [bx + bw, by],
                                    c2: [bx + bw, by + bh + borders[2].width],
                                    c3: [bx, by + bh],
                                    c4: [bx, by + borders[0].width]
                                }, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner);
                                break;
                            case 2:
                                // bottom border
                                by = by + nodeBounds.height - borders[2].width;
                                bh = borders[2].width;
                                border.args = drawSide({
                                    c1: [bx + bw, by + bh],
                                    c2: [bx, by + bh],
                                    c3: [bx + borders[3].width, by],
                                    c4: [bx + bw - borders[3].width, by]
                                }, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner);
                                break;
                            case 3:
                                // left border
                                bw = borders[3].width;
                                border.args = drawSide({
                                    c1: [bx, by + bh + borders[2].width],
                                    c2: [bx, by],
                                    c3: [bx + bw, by + borders[0].width],
                                    c4: [bx + bw, by + bh]
                                }, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner);
                                break;
                        }
                    }
                    return border;
                });
            }

            NodeParser.prototype.parseBackgroundClip = function (container, borderPoints, borders, radius, bounds) {
                var backgroundClip = container.css('backgroundClip'),
                    borderArgs = [];

                switch (backgroundClip) {
                    case "content-box":
                    case "padding-box":
                        parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width);
                        parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width);
                        parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width);
                        parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width);
                        break;

                    default:
                        parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top);
                        parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top);
                        parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height);
                        parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height);
                        break;
                }

                return borderArgs;
            };

            function getCurvePoints(x, y, r1, r2) {
                var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
                var ox = r1 * kappa,
                    // control point offset horizontal
                oy = r2 * kappa,
                    // control point offset vertical
                xm = x + r1,
                    // x-middle
                ym = y + r2; // y-middle
                return {
                    topLeft: bezierCurve({ x: x, y: ym }, { x: x, y: ym - oy }, { x: xm - ox, y: y }, { x: xm, y: y }),
                    topRight: bezierCurve({ x: x, y: y }, { x: x + ox, y: y }, { x: xm, y: ym - oy }, { x: xm, y: ym }),
                    bottomRight: bezierCurve({ x: xm, y: y }, { x: xm, y: y + oy }, { x: x + ox, y: ym }, { x: x, y: ym }),
                    bottomLeft: bezierCurve({ x: xm, y: ym }, { x: xm - ox, y: ym }, { x: x, y: y + oy }, { x: x, y: y })
                };
            }

            function calculateCurvePoints(bounds, borderRadius, borders) {
                var x = bounds.left,
                    y = bounds.top,
                    width = bounds.width,
                    height = bounds.height,
                    tlh = borderRadius[0][0] < width / 2 ? borderRadius[0][0] : width / 2,
                    tlv = borderRadius[0][1] < height / 2 ? borderRadius[0][1] : height / 2,
                    trh = borderRadius[1][0] < width / 2 ? borderRadius[1][0] : width / 2,
                    trv = borderRadius[1][1] < height / 2 ? borderRadius[1][1] : height / 2,
                    brh = borderRadius[2][0] < width / 2 ? borderRadius[2][0] : width / 2,
                    brv = borderRadius[2][1] < height / 2 ? borderRadius[2][1] : height / 2,
                    blh = borderRadius[3][0] < width / 2 ? borderRadius[3][0] : width / 2,
                    blv = borderRadius[3][1] < height / 2 ? borderRadius[3][1] : height / 2;

                var topWidth = width - trh,
                    rightHeight = height - brv,
                    bottomWidth = width - brh,
                    leftHeight = height - blv;

                return {
                    topLeftOuter: getCurvePoints(x, y, tlh, tlv).topLeft.subdivide(0.5),
                    topLeftInner: getCurvePoints(x + borders[3].width, y + borders[0].width, Math.max(0, tlh - borders[3].width), Math.max(0, tlv - borders[0].width)).topLeft.subdivide(0.5),
                    topRightOuter: getCurvePoints(x + topWidth, y, trh, trv).topRight.subdivide(0.5),
                    topRightInner: getCurvePoints(x + Math.min(topWidth, width + borders[3].width), y + borders[0].width, topWidth > width + borders[3].width ? 0 : trh - borders[3].width, trv - borders[0].width).topRight.subdivide(0.5),
                    bottomRightOuter: getCurvePoints(x + bottomWidth, y + rightHeight, brh, brv).bottomRight.subdivide(0.5),
                    bottomRightInner: getCurvePoints(x + Math.min(bottomWidth, width - borders[3].width), y + Math.min(rightHeight, height + borders[0].width), Math.max(0, brh - borders[1].width), brv - borders[2].width).bottomRight.subdivide(0.5),
                    bottomLeftOuter: getCurvePoints(x, y + leftHeight, blh, blv).bottomLeft.subdivide(0.5),
                    bottomLeftInner: getCurvePoints(x + borders[3].width, y + leftHeight, Math.max(0, blh - borders[3].width), blv - borders[2].width).bottomLeft.subdivide(0.5)
                };
            }

            function bezierCurve(start, startControl, endControl, end) {
                var lerp = function lerp(a, b, t) {
                    return {
                        x: a.x + (b.x - a.x) * t,
                        y: a.y + (b.y - a.y) * t
                    };
                };

                return {
                    start: start,
                    startControl: startControl,
                    endControl: endControl,
                    end: end,
                    subdivide: function subdivide(t) {
                        var ab = lerp(start, startControl, t),
                            bc = lerp(startControl, endControl, t),
                            cd = lerp(endControl, end, t),
                            abbc = lerp(ab, bc, t),
                            bccd = lerp(bc, cd, t),
                            dest = lerp(abbc, bccd, t);
                        return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];
                    },
                    curveTo: function curveTo(borderArgs) {
                        borderArgs.push(["bezierCurve", startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);
                    },
                    curveToReversed: function curveToReversed(borderArgs) {
                        borderArgs.push(["bezierCurve", endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);
                    }
                };
            }

            function drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {
                var borderArgs = [];

                if (radius1[0] > 0 || radius1[1] > 0) {
                    borderArgs.push(["line", outer1[1].start.x, outer1[1].start.y]);
                    outer1[1].curveTo(borderArgs);
                } else {
                    borderArgs.push(["line", borderData.c1[0], borderData.c1[1]]);
                }

                if (radius2[0] > 0 || radius2[1] > 0) {
                    borderArgs.push(["line", outer2[0].start.x, outer2[0].start.y]);
                    outer2[0].curveTo(borderArgs);
                    borderArgs.push(["line", inner2[0].end.x, inner2[0].end.y]);
                    inner2[0].curveToReversed(borderArgs);
                } else {
                    borderArgs.push(["line", borderData.c2[0], borderData.c2[1]]);
                    borderArgs.push(["line", borderData.c3[0], borderData.c3[1]]);
                }

                if (radius1[0] > 0 || radius1[1] > 0) {
                    borderArgs.push(["line", inner1[1].end.x, inner1[1].end.y]);
                    inner1[1].curveToReversed(borderArgs);
                } else {
                    borderArgs.push(["line", borderData.c4[0], borderData.c4[1]]);
                }

                return borderArgs;
            }

            function parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {
                if (radius1[0] > 0 || radius1[1] > 0) {
                    borderArgs.push(["line", corner1[0].start.x, corner1[0].start.y]);
                    corner1[0].curveTo(borderArgs);
                    corner1[1].curveTo(borderArgs);
                } else {
                    borderArgs.push(["line", x, y]);
                }

                if (radius2[0] > 0 || radius2[1] > 0) {
                    borderArgs.push(["line", corner2[0].start.x, corner2[0].start.y]);
                }
            }

            function negativeZIndex(container) {
                return container.cssInt("zIndex") < 0;
            }

            function positiveZIndex(container) {
                return container.cssInt("zIndex") > 0;
            }

            function zIndex0(container) {
                return container.cssInt("zIndex") === 0;
            }

            function inlineLevel(container) {
                return ["inline", "inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
            }

            function isStackingContext(container) {
                return container instanceof StackingContext;
            }

            function hasText(container) {
                return container.node.data.trim().length > 0;
            }

            function noLetterSpacing(container) {
                return (/^(normal|none|0px)$/.test(container.parent.css("letterSpacing"))
                );
            }

            function getBorderRadiusData(container) {
                return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function (side) {
                    var value = container.css('border' + side + 'Radius');
                    var arr = value.split(" ");
                    if (arr.length <= 1) {
                        arr[1] = arr[0];
                    }
                    return arr.map(asInt);
                });
            }

            function renderableNode(node) {
                return node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE;
            }

            function isPositionedForStacking(container) {
                var position = container.css("position");
                var zIndex = ["absolute", "relative", "fixed"].indexOf(position) !== -1 ? container.css("zIndex") : "auto";
                return zIndex !== "auto";
            }

            function isPositioned(container) {
                return container.css("position") !== "static";
            }

            function isFloating(container) {
                return container.css("float") !== "none";
            }

            function isInlineBlock(container) {
                return ["inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
            }

            function not(callback) {
                var context = this;
                return function () {
                    return !callback.apply(context, arguments);
                };
            }

            function isElement(container) {
                return container.node.nodeType === Node.ELEMENT_NODE;
            }

            function isPseudoElement(container) {
                return container.isPseudoElement === true;
            }

            function isTextNode(container) {
                return container.node.nodeType === Node.TEXT_NODE;
            }

            function zIndexSort(contexts) {
                return function (a, b) {
                    return a.cssInt("zIndex") + contexts.indexOf(a) / contexts.length - (b.cssInt("zIndex") + contexts.indexOf(b) / contexts.length);
                };
            }

            function hasOpacity(container) {
                return container.getOpacity() < 1;
            }

            function asInt(value) {
                return parseInt(value, 10);
            }

            function getWidth(border) {
                return border.width;
            }

            function nonIgnoredElement(nodeContainer) {
                return nodeContainer.node.nodeType !== Node.ELEMENT_NODE || ["SCRIPT", "HEAD", "TITLE", "OBJECT", "BR", "OPTION"].indexOf(nodeContainer.node.nodeName) === -1;
            }

            function flatten(arrays) {
                return [].concat.apply([], arrays);
            }

            function stripQuotes(content) {
                var first = content.substr(0, 1);
                return first === content.substr(content.length - 1) && first.match(/'|"/) ? content.substr(1, content.length - 2) : content;
            }

            function getWords(characters) {
                var words = [],
                    i = 0,
                    onWordBoundary = false,
                    word;
                while (characters.length) {
                    if (isWordBoundary(characters[i]) === onWordBoundary) {
                        word = characters.splice(0, i);
                        if (word.length) {
                            words.push(punycode.ucs2.encode(word));
                        }
                        onWordBoundary = !onWordBoundary;
                        i = 0;
                    } else {
                        i++;
                    }

                    if (i >= characters.length) {
                        word = characters.splice(0, i);
                        if (word.length) {
                            words.push(punycode.ucs2.encode(word));
                        }
                    }
                }
                return words;
            }

            function isWordBoundary(characterCode) {
                return [32, // <space>
                13, // \r
                10, // \n
                9, // \t
                45 // -
                ].indexOf(characterCode) !== -1;
            }

            function hasUnicode(string) {
                return (/[^\u0000-\u00ff]/.test(string)
                );
            }

            module.exports = NodeParser;
        }, { "./color": 3, "./fontmetrics": 7, "./log": 13, "./nodecontainer": 14, "./pseudoelementcontainer": 18, "./stackingcontext": 21, "./textcontainer": 25, "./utils": 26, "punycode": 1 }], 16: [function (_dereq_, module, exports) {
            var XHR = _dereq_('./xhr');
            var utils = _dereq_('./utils');
            var log = _dereq_('./log');
            var createWindowClone = _dereq_('./clone');
            var decode64 = utils.decode64;

            function Proxy(src, proxyUrl, document) {
                var supportsCORS = 'withCredentials' in new XMLHttpRequest();
                if (!proxyUrl) {
                    return Promise.reject("No proxy configured");
                }
                var callback = createCallback(supportsCORS);
                var url = createProxyUrl(proxyUrl, src, callback);

                return supportsCORS ? XHR(url) : jsonp(document, url, callback).then(function (response) {
                    return decode64(response.content);
                });
            }
            var proxyCount = 0;

            function ProxyURL(src, proxyUrl, document) {
                var supportsCORSImage = 'crossOrigin' in new Image();
                var callback = createCallback(supportsCORSImage);
                var url = createProxyUrl(proxyUrl, src, callback);
                return supportsCORSImage ? Promise.resolve(url) : jsonp(document, url, callback).then(function (response) {
                    return "data:" + response.type + ";base64," + response.content;
                });
            }

            function jsonp(document, url, callback) {
                return new Promise(function (resolve, reject) {
                    var s = document.createElement("script");
                    var cleanup = function cleanup() {
                        delete window.html2canvas.proxy[callback];
                        document.body.removeChild(s);
                    };
                    window.html2canvas.proxy[callback] = function (response) {
                        cleanup();
                        resolve(response);
                    };
                    s.src = url;
                    s.onerror = function (e) {
                        cleanup();
                        reject(e);
                    };
                    document.body.appendChild(s);
                });
            }

            function createCallback(useCORS) {
                return !useCORS ? "html2canvas_" + Date.now() + "_" + ++proxyCount + "_" + Math.round(Math.random() * 100000) : "";
            }

            function createProxyUrl(proxyUrl, src, callback) {
                return proxyUrl + "?url=" + encodeURIComponent(src) + (callback.length ? "&callback=html2canvas.proxy." + callback : "");
            }

            function documentFromHTML(src) {
                return function (html) {
                    var parser = new DOMParser(),
                        doc;
                    try {
                        doc = parser.parseFromString(html, "text/html");
                    } catch (e) {
                        log("DOMParser not supported, falling back to createHTMLDocument");
                        doc = document.implementation.createHTMLDocument("");
                        try {
                            doc.open();
                            doc.write(html);
                            doc.close();
                        } catch (ee) {
                            log("createHTMLDocument write not supported, falling back to document.body.innerHTML");
                            doc.body.innerHTML = html; // ie9 doesnt support writing to documentElement
                        }
                    }

                    var b = doc.querySelector("base");
                    if (!b || !b.href.host) {
                        var base = doc.createElement("base");
                        base.href = src;
                        doc.head.insertBefore(base, doc.head.firstChild);
                    }

                    return doc;
                };
            }

            function loadUrlDocument(src, proxy, document, width, height, options) {
                return new Proxy(src, proxy, window.document).then(documentFromHTML(src)).then(function (doc) {
                    return createWindowClone(doc, document, width, height, options, 0, 0);
                });
            }

            exports.Proxy = Proxy;
            exports.ProxyURL = ProxyURL;
            exports.loadUrlDocument = loadUrlDocument;
        }, { "./clone": 2, "./log": 13, "./utils": 26, "./xhr": 28 }], 17: [function (_dereq_, module, exports) {
            var ProxyURL = _dereq_('./proxy').ProxyURL;

            function ProxyImageContainer(src, proxy) {
                var link = document.createElement("a");
                link.href = src;
                src = link.href;
                this.src = src;
                this.image = new Image();
                var self = this;
                this.promise = new Promise(function (resolve, reject) {
                    self.image.crossOrigin = "Anonymous";
                    self.image.onload = resolve;
                    self.image.onerror = reject;

                    new ProxyURL(src, proxy, document).then(function (url) {
                        self.image.src = url;
                    })['catch'](reject);
                });
            }

            module.exports = ProxyImageContainer;
        }, { "./proxy": 16 }], 18: [function (_dereq_, module, exports) {
            var NodeContainer = _dereq_('./nodecontainer');

            function PseudoElementContainer(node, parent, type) {
                NodeContainer.call(this, node, parent);
                this.isPseudoElement = true;
                this.before = type === ":before";
            }

            PseudoElementContainer.prototype.cloneTo = function (stack) {
                PseudoElementContainer.prototype.cloneTo.call(this, stack);
                stack.isPseudoElement = true;
                stack.before = this.before;
            };

            PseudoElementContainer.prototype = Object.create(NodeContainer.prototype);

            PseudoElementContainer.prototype.appendToDOM = function () {
                if (this.before) {
                    this.parent.node.insertBefore(this.node, this.parent.node.firstChild);
                } else {
                    this.parent.node.appendChild(this.node);
                }
                this.parent.node.className += " " + this.getHideClass();
            };

            PseudoElementContainer.prototype.cleanDOM = function () {
                this.node.parentNode.removeChild(this.node);
                this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), "");
            };

            PseudoElementContainer.prototype.getHideClass = function () {
                return this["PSEUDO_HIDE_ELEMENT_CLASS_" + (this.before ? "BEFORE" : "AFTER")];
            };

            PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
            PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";

            module.exports = PseudoElementContainer;
        }, { "./nodecontainer": 14 }], 19: [function (_dereq_, module, exports) {
            var log = _dereq_('./log');

            function Renderer(width, height, images, options, document) {
                this.width = width;
                this.height = height;
                this.images = images;
                this.options = options;
                this.document = document;
            }

            Renderer.prototype.renderImage = function (container, bounds, borderData, imageContainer) {
                var paddingLeft = container.cssInt('paddingLeft'),
                    paddingTop = container.cssInt('paddingTop'),
                    paddingRight = container.cssInt('paddingRight'),
                    paddingBottom = container.cssInt('paddingBottom'),
                    borders = borderData.borders;

                var width = bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight);
                var height = bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom);
                this.drawImage(imageContainer, 0, 0, imageContainer.image.width || width, imageContainer.image.height || height, bounds.left + paddingLeft + borders[3].width, bounds.top + paddingTop + borders[0].width, width, height);
            };

            Renderer.prototype.renderBackground = function (container, bounds, borderData) {
                if (bounds.height > 0 && bounds.width > 0) {
                    this.renderBackgroundColor(container, bounds);
                    this.renderBackgroundImage(container, bounds, borderData);
                }
            };

            Renderer.prototype.renderBackgroundColor = function (container, bounds) {
                var color = container.color("backgroundColor");
                if (!color.isTransparent()) {
                    this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, color);
                }
            };

            Renderer.prototype.renderBorders = function (borders) {
                borders.forEach(this.renderBorder, this);
            };

            Renderer.prototype.renderBorder = function (data) {
                if (!data.color.isTransparent() && data.args !== null) {
                    this.drawShape(data.args, data.color);
                }
            };

            Renderer.prototype.renderBackgroundImage = function (container, bounds, borderData) {
                var backgroundImages = container.parseBackgroundImages();
                backgroundImages.reverse().forEach(function (backgroundImage, index, arr) {
                    switch (backgroundImage.method) {
                        case "url":
                            var image = this.images.get(backgroundImage.args[0]);
                            if (image) {
                                this.renderBackgroundRepeating(container, bounds, image, arr.length - (index + 1), borderData);
                            } else {
                                log("Error loading background-image", backgroundImage.args[0]);
                            }
                            break;
                        case "linear-gradient":
                        case "gradient":
                            var gradientImage = this.images.get(backgroundImage.value);
                            if (gradientImage) {
                                this.renderBackgroundGradient(gradientImage, bounds, borderData);
                            } else {
                                log("Error loading background-image", backgroundImage.args[0]);
                            }
                            break;
                        case "none":
                            break;
                        default:
                            log("Unknown background-image type", backgroundImage.args[0]);
                    }
                }, this);
            };

            Renderer.prototype.renderBackgroundRepeating = function (container, bounds, imageContainer, index, borderData) {
                var size = container.parseBackgroundSize(bounds, imageContainer.image, index);
                var position = container.parseBackgroundPosition(bounds, imageContainer.image, index, size);
                var repeat = container.parseBackgroundRepeat(index);
                switch (repeat) {
                    case "repeat-x":
                    case "repeat no-repeat":
                        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + borderData[3], bounds.top + position.top + borderData[0], 99999, size.height, borderData);
                        break;
                    case "repeat-y":
                    case "no-repeat repeat":
                        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + borderData[0], size.width, 99999, borderData);
                        break;
                    case "no-repeat":
                        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + position.top + borderData[0], size.width, size.height, borderData);
                        break;
                    default:
                        this.renderBackgroundRepeat(imageContainer, position, size, { top: bounds.top, left: bounds.left }, borderData[3], borderData[0]);
                        break;
                }
            };

            module.exports = Renderer;
        }, { "./log": 13 }], 20: [function (_dereq_, module, exports) {
            var Renderer = _dereq_('../renderer');
            var LinearGradientContainer = _dereq_('../lineargradientcontainer');
            var log = _dereq_('../log');

            function CanvasRenderer(width, height) {
                Renderer.apply(this, arguments);
                this.canvas = this.options.canvas || this.document.createElement("canvas");
                if (!this.options.canvas) {
                    this.canvas.width = width;
                    this.canvas.height = height;
                }
                this.ctx = this.canvas.getContext("2d");
                this.taintCtx = this.document.createElement("canvas").getContext("2d");
                this.ctx.textBaseline = "bottom";
                this.variables = {};
                log("Initialized CanvasRenderer with size", width, "x", height);
            }

            CanvasRenderer.prototype = Object.create(Renderer.prototype);

            CanvasRenderer.prototype.setFillStyle = function (fillStyle) {
                this.ctx.fillStyle = (typeof fillStyle === "undefined" ? "undefined" : _typeof(fillStyle)) === "object" && !!fillStyle.isColor ? fillStyle.toString() : fillStyle;
                return this.ctx;
            };

            CanvasRenderer.prototype.rectangle = function (left, top, width, height, color) {
                this.setFillStyle(color).fillRect(left, top, width, height);
            };

            CanvasRenderer.prototype.circle = function (left, top, size, color) {
                this.setFillStyle(color);
                this.ctx.beginPath();
                this.ctx.arc(left + size / 2, top + size / 2, size / 2, 0, Math.PI * 2, true);
                this.ctx.closePath();
                this.ctx.fill();
            };

            CanvasRenderer.prototype.circleStroke = function (left, top, size, color, stroke, strokeColor) {
                this.circle(left, top, size, color);
                this.ctx.strokeStyle = strokeColor.toString();
                this.ctx.stroke();
            };

            CanvasRenderer.prototype.drawShape = function (shape, color) {
                this.shape(shape);
                this.setFillStyle(color).fill();
            };

            CanvasRenderer.prototype.taints = function (imageContainer) {
                if (imageContainer.tainted === null) {
                    this.taintCtx.drawImage(imageContainer.image, 0, 0);
                    try {
                        this.taintCtx.getImageData(0, 0, 1, 1);
                        imageContainer.tainted = false;
                    } catch (e) {
                        this.taintCtx = document.createElement("canvas").getContext("2d");
                        imageContainer.tainted = true;
                    }
                }

                return imageContainer.tainted;
            };

            CanvasRenderer.prototype.drawImage = function (imageContainer, sx, sy, sw, sh, dx, dy, dw, dh) {
                if (!this.taints(imageContainer) || this.options.allowTaint) {
                    this.ctx.drawImage(imageContainer.image, sx, sy, sw, sh, dx, dy, dw, dh);
                }
            };

            CanvasRenderer.prototype.clip = function (shapes, callback, context) {
                this.ctx.save();
                shapes.filter(hasEntries).forEach(function (shape) {
                    this.shape(shape).clip();
                }, this);
                callback.call(context);
                this.ctx.restore();
            };

            CanvasRenderer.prototype.shape = function (shape) {
                this.ctx.beginPath();
                shape.forEach(function (point, index) {
                    if (point[0] === "rect") {
                        this.ctx.rect.apply(this.ctx, point.slice(1));
                    } else {
                        this.ctx[index === 0 ? "moveTo" : point[0] + "To"].apply(this.ctx, point.slice(1));
                    }
                }, this);
                this.ctx.closePath();
                return this.ctx;
            };

            CanvasRenderer.prototype.font = function (color, style, variant, weight, size, family) {
                this.setFillStyle(color).font = [style, variant, weight, size, family].join(" ").split(",")[0];
            };

            CanvasRenderer.prototype.fontShadow = function (color, offsetX, offsetY, blur) {
                this.setVariable("shadowColor", color.toString()).setVariable("shadowOffsetY", offsetX).setVariable("shadowOffsetX", offsetY).setVariable("shadowBlur", blur);
            };

            CanvasRenderer.prototype.clearShadow = function () {
                this.setVariable("shadowColor", "rgba(0,0,0,0)");
            };

            CanvasRenderer.prototype.setOpacity = function (opacity) {
                this.ctx.globalAlpha = opacity;
            };

            CanvasRenderer.prototype.setTransform = function (transform) {
                this.ctx.translate(transform.origin[0], transform.origin[1]);
                this.ctx.transform.apply(this.ctx, transform.matrix);
                this.ctx.translate(-transform.origin[0], -transform.origin[1]);
            };

            CanvasRenderer.prototype.setVariable = function (property, value) {
                if (this.variables[property] !== value) {
                    this.variables[property] = this.ctx[property] = value;
                }

                return this;
            };

            CanvasRenderer.prototype.text = function (text, left, bottom) {
                this.ctx.fillText(text, left, bottom);
            };

            CanvasRenderer.prototype.backgroundRepeatShape = function (imageContainer, backgroundPosition, size, bounds, left, top, width, height, borderData) {
                var shape = [["line", Math.round(left), Math.round(top)], ["line", Math.round(left + width), Math.round(top)], ["line", Math.round(left + width), Math.round(height + top)], ["line", Math.round(left), Math.round(height + top)]];
                this.clip([shape], function () {
                    this.renderBackgroundRepeat(imageContainer, backgroundPosition, size, bounds, borderData[3], borderData[0]);
                }, this);
            };

            CanvasRenderer.prototype.renderBackgroundRepeat = function (imageContainer, backgroundPosition, size, bounds, borderLeft, borderTop) {
                var offsetX = Math.round(bounds.left + backgroundPosition.left + borderLeft),
                    offsetY = Math.round(bounds.top + backgroundPosition.top + borderTop);
                this.setFillStyle(this.ctx.createPattern(this.resizeImage(imageContainer, size), "repeat"));
                this.ctx.translate(offsetX, offsetY);
                this.ctx.fill();
                this.ctx.translate(-offsetX, -offsetY);
            };

            CanvasRenderer.prototype.renderBackgroundGradient = function (gradientImage, bounds) {
                if (gradientImage instanceof LinearGradientContainer) {
                    var gradient = this.ctx.createLinearGradient(bounds.left + bounds.width * gradientImage.x0, bounds.top + bounds.height * gradientImage.y0, bounds.left + bounds.width * gradientImage.x1, bounds.top + bounds.height * gradientImage.y1);
                    gradientImage.colorStops.forEach(function (colorStop) {
                        gradient.addColorStop(colorStop.stop, colorStop.color.toString());
                    });
                    this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, gradient);
                }
            };

            CanvasRenderer.prototype.resizeImage = function (imageContainer, size) {
                var image = imageContainer.image;
                if (image.width === size.width && image.height === size.height) {
                    return image;
                }

                var ctx,
                    canvas = document.createElement('canvas');
                canvas.width = size.width;
                canvas.height = size.height;
                ctx = canvas.getContext("2d");
                ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, size.width, size.height);
                return canvas;
            };

            function hasEntries(array) {
                return array.length > 0;
            }

            module.exports = CanvasRenderer;
        }, { "../lineargradientcontainer": 12, "../log": 13, "../renderer": 19 }], 21: [function (_dereq_, module, exports) {
            var NodeContainer = _dereq_('./nodecontainer');

            function StackingContext(hasOwnStacking, opacity, element, parent) {
                NodeContainer.call(this, element, parent);
                this.ownStacking = hasOwnStacking;
                this.contexts = [];
                this.children = [];
                this.opacity = (this.parent ? this.parent.stack.opacity : 1) * opacity;
            }

            StackingContext.prototype = Object.create(NodeContainer.prototype);

            StackingContext.prototype.getParentStack = function (context) {
                var parentStack = this.parent ? this.parent.stack : null;
                return parentStack ? parentStack.ownStacking ? parentStack : parentStack.getParentStack(context) : context.stack;
            };

            module.exports = StackingContext;
        }, { "./nodecontainer": 14 }], 22: [function (_dereq_, module, exports) {
            function Support(document) {
                this.rangeBounds = this.testRangeBounds(document);
                this.cors = this.testCORS();
                this.svg = this.testSVG();
            }

            Support.prototype.testRangeBounds = function (document) {
                var range,
                    testElement,
                    rangeBounds,
                    rangeHeight,
                    support = false;

                if (document.createRange) {
                    range = document.createRange();
                    if (range.getBoundingClientRect) {
                        testElement = document.createElement('boundtest');
                        testElement.style.height = "123px";
                        testElement.style.display = "block";
                        document.body.appendChild(testElement);

                        range.selectNode(testElement);
                        rangeBounds = range.getBoundingClientRect();
                        rangeHeight = rangeBounds.height;

                        if (rangeHeight === 123) {
                            support = true;
                        }
                        document.body.removeChild(testElement);
                    }
                }

                return support;
            };

            Support.prototype.testCORS = function () {
                return typeof new Image().crossOrigin !== "undefined";
            };

            Support.prototype.testSVG = function () {
                var img = new Image();
                var canvas = document.createElement("canvas");
                var ctx = canvas.getContext("2d");
                img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";

                try {
                    ctx.drawImage(img, 0, 0);
                    canvas.toDataURL();
                } catch (e) {
                    return false;
                }
                return true;
            };

            module.exports = Support;
        }, {}], 23: [function (_dereq_, module, exports) {
            var XHR = _dereq_('./xhr');
            var decode64 = _dereq_('./utils').decode64;

            function SVGContainer(src) {
                this.src = src;
                this.image = null;
                var self = this;

                this.promise = this.hasFabric().then(function () {
                    return self.isInline(src) ? Promise.resolve(self.inlineFormatting(src)) : XHR(src);
                }).then(function (svg) {
                    return new Promise(function (resolve) {
                        window.html2canvas.svg.fabric.loadSVGFromString(svg, self.createCanvas.call(self, resolve));
                    });
                });
            }

            SVGContainer.prototype.hasFabric = function () {
                return !window.html2canvas.svg || !window.html2canvas.svg.fabric ? Promise.reject(new Error("html2canvas.svg.js is not loaded, cannot render svg")) : Promise.resolve();
            };

            SVGContainer.prototype.inlineFormatting = function (src) {
                return (/^data:image\/svg\+xml;base64,/.test(src) ? this.decode64(this.removeContentType(src)) : this.removeContentType(src)
                );
            };

            SVGContainer.prototype.removeContentType = function (src) {
                return src.replace(/^data:image\/svg\+xml(;base64)?,/, '');
            };

            SVGContainer.prototype.isInline = function (src) {
                return (/^data:image\/svg\+xml/i.test(src)
                );
            };

            SVGContainer.prototype.createCanvas = function (resolve) {
                var self = this;
                return function (objects, options) {
                    var canvas = new window.html2canvas.svg.fabric.StaticCanvas('c');
                    self.image = canvas.lowerCanvasEl;
                    canvas.setWidth(options.width).setHeight(options.height).add(window.html2canvas.svg.fabric.util.groupSVGElements(objects, options)).renderAll();
                    resolve(canvas.lowerCanvasEl);
                };
            };

            SVGContainer.prototype.decode64 = function (str) {
                return typeof window.atob === "function" ? window.atob(str) : decode64(str);
            };

            module.exports = SVGContainer;
        }, { "./utils": 26, "./xhr": 28 }], 24: [function (_dereq_, module, exports) {
            var SVGContainer = _dereq_('./svgcontainer');

            function SVGNodeContainer(node, _native) {
                this.src = node;
                this.image = null;
                var self = this;

                this.promise = _native ? new Promise(function (resolve, reject) {
                    self.image = new Image();
                    self.image.onload = resolve;
                    self.image.onerror = reject;
                    self.image.src = "data:image/svg+xml," + new XMLSerializer().serializeToString(node);
                    if (self.image.complete === true) {
                        resolve(self.image);
                    }
                }) : this.hasFabric().then(function () {
                    return new Promise(function (resolve) {
                        window.html2canvas.svg.fabric.parseSVGDocument(node, self.createCanvas.call(self, resolve));
                    });
                });
            }

            SVGNodeContainer.prototype = Object.create(SVGContainer.prototype);

            module.exports = SVGNodeContainer;
        }, { "./svgcontainer": 23 }], 25: [function (_dereq_, module, exports) {
            var NodeContainer = _dereq_('./nodecontainer');

            function TextContainer(node, parent) {
                NodeContainer.call(this, node, parent);
            }

            TextContainer.prototype = Object.create(NodeContainer.prototype);

            TextContainer.prototype.applyTextTransform = function () {
                this.node.data = this.transform(this.parent.css("textTransform"));
            };

            TextContainer.prototype.transform = function (transform) {
                var text = this.node.data;
                switch (transform) {
                    case "lowercase":
                        return text.toLowerCase();
                    case "capitalize":
                        return text.replace(/(^|\s|:|-|\(|\))([a-z])/g, capitalize);
                    case "uppercase":
                        return text.toUpperCase();
                    default:
                        return text;
                }
            };

            function capitalize(m, p1, p2) {
                if (m.length > 0) {
                    return p1 + p2.toUpperCase();
                }
            }

            module.exports = TextContainer;
        }, { "./nodecontainer": 14 }], 26: [function (_dereq_, module, exports) {
            exports.smallImage = function smallImage() {
                return "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
            };

            exports.bind = function (callback, context) {
                return function () {
                    return callback.apply(context, arguments);
                };
            };

            /*
             * base64-arraybuffer
             * https://github.com/niklasvh/base64-arraybuffer
             *
             * Copyright (c) 2012 Niklas von Hertzen
             * Licensed under the MIT license.
             */

            exports.decode64 = function (base64) {
                var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                var len = base64.length,
                    i,
                    encoded1,
                    encoded2,
                    encoded3,
                    encoded4,
                    byte1,
                    byte2,
                    byte3;

                var output = "";

                for (i = 0; i < len; i += 4) {
                    encoded1 = chars.indexOf(base64[i]);
                    encoded2 = chars.indexOf(base64[i + 1]);
                    encoded3 = chars.indexOf(base64[i + 2]);
                    encoded4 = chars.indexOf(base64[i + 3]);

                    byte1 = encoded1 << 2 | encoded2 >> 4;
                    byte2 = (encoded2 & 15) << 4 | encoded3 >> 2;
                    byte3 = (encoded3 & 3) << 6 | encoded4;
                    if (encoded3 === 64) {
                        output += String.fromCharCode(byte1);
                    } else if (encoded4 === 64 || encoded4 === -1) {
                        output += String.fromCharCode(byte1, byte2);
                    } else {
                        output += String.fromCharCode(byte1, byte2, byte3);
                    }
                }

                return output;
            };

            exports.getBounds = function (node) {
                if (node.getBoundingClientRect) {
                    var clientRect = node.getBoundingClientRect();
                    var width = node.offsetWidth == null ? clientRect.width : node.offsetWidth;
                    return {
                        top: clientRect.top,
                        bottom: clientRect.bottom || clientRect.top + clientRect.height,
                        right: clientRect.left + width,
                        left: clientRect.left,
                        width: width,
                        height: node.offsetHeight == null ? clientRect.height : node.offsetHeight
                    };
                }
                return {};
            };

            exports.offsetBounds = function (node) {
                var parent = node.offsetParent ? exports.offsetBounds(node.offsetParent) : { top: 0, left: 0 };

                return {
                    top: node.offsetTop + parent.top,
                    bottom: node.offsetTop + node.offsetHeight + parent.top,
                    right: node.offsetLeft + parent.left + node.offsetWidth,
                    left: node.offsetLeft + parent.left,
                    width: node.offsetWidth,
                    height: node.offsetHeight
                };
            };

            exports.parseBackgrounds = function (backgroundImage) {
                var whitespace = ' \r\n\t',
                    method,
                    definition,
                    prefix,
                    prefix_i,
                    block,
                    results = [],
                    mode = 0,
                    numParen = 0,
                    quote,
                    args;
                var appendResult = function appendResult() {
                    if (method) {
                        if (definition.substr(0, 1) === '"') {
                            definition = definition.substr(1, definition.length - 2);
                        }
                        if (definition) {
                            args.push(definition);
                        }
                        if (method.substr(0, 1) === '-' && (prefix_i = method.indexOf('-', 1) + 1) > 0) {
                            prefix = method.substr(0, prefix_i);
                            method = method.substr(prefix_i);
                        }
                        results.push({
                            prefix: prefix,
                            method: method.toLowerCase(),
                            value: block,
                            args: args,
                            image: null
                        });
                    }
                    args = [];
                    method = prefix = definition = block = '';
                };
                args = [];
                method = prefix = definition = block = '';
                backgroundImage.split("").forEach(function (c) {
                    if (mode === 0 && whitespace.indexOf(c) > -1) {
                        return;
                    }
                    switch (c) {
                        case '"':
                            if (!quote) {
                                quote = c;
                            } else if (quote === c) {
                                quote = null;
                            }
                            break;
                        case '(':
                            if (quote) {
                                break;
                            } else if (mode === 0) {
                                mode = 1;
                                block += c;
                                return;
                            } else {
                                numParen++;
                            }
                            break;
                        case ')':
                            if (quote) {
                                break;
                            } else if (mode === 1) {
                                if (numParen === 0) {
                                    mode = 0;
                                    block += c;
                                    appendResult();
                                    return;
                                } else {
                                    numParen--;
                                }
                            }
                            break;

                        case ',':
                            if (quote) {
                                break;
                            } else if (mode === 0) {
                                appendResult();
                                return;
                            } else if (mode === 1) {
                                if (numParen === 0 && !method.match(/^url$/i)) {
                                    args.push(definition);
                                    definition = '';
                                    block += c;
                                    return;
                                }
                            }
                            break;
                    }

                    block += c;
                    if (mode === 0) {
                        method += c;
                    } else {
                        definition += c;
                    }
                });

                appendResult();
                return results;
            };
        }, {}], 27: [function (_dereq_, module, exports) {
            var GradientContainer = _dereq_('./gradientcontainer');

            function WebkitGradientContainer(imageData) {
                GradientContainer.apply(this, arguments);
                this.type = imageData.args[0] === "linear" ? GradientContainer.TYPES.LINEAR : GradientContainer.TYPES.RADIAL;
            }

            WebkitGradientContainer.prototype = Object.create(GradientContainer.prototype);

            module.exports = WebkitGradientContainer;
        }, { "./gradientcontainer": 9 }], 28: [function (_dereq_, module, exports) {
            function XHR(url) {
                return new Promise(function (resolve, reject) {
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', url);

                    xhr.onload = function () {
                        if (xhr.status === 200) {
                            resolve(xhr.responseText);
                        } else {
                            reject(new Error(xhr.statusText));
                        }
                    };

                    xhr.onerror = function () {
                        reject(new Error("Network Error"));
                    };

                    xhr.send();
                });
            }

            module.exports = XHR;
        }, {}] }, {}, [4])(4);
});
/**
  * @require /libsH5/js/libs/three.js
  * @require /libsH5/js/libs/WebViewer.js
*/

CLOUD.Extensions = CLOUD.Extensions || {};
CLOUD.Extensions.Utils = CLOUD.Extensions.Utils || {};

CLOUD.Extensions.Utils.Geometric = {

    isInsideBounds: function isInsideBounds(x, y, bounds) {

        return x >= bounds.x && x <= bounds.x + bounds.width && y >= bounds.y && y <= bounds.y + bounds.height;
    },
    getAngleBetweenPoints: function getAngleBetweenPoints(p1, p2) {

        return Math.atan2(p2.y - p1.y, p2.x - p1.x);
    },
    // 判断是否同一个点
    isEqualBetweenPoints: function isEqualBetweenPoints(p1, p2, epsilon) {

        epsilon = epsilon || 0.0001;

        var dx = p1.x - p2.x;
        var dy = p1.y - p2.y;
        var dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > epsilon) {
            return false;
        }

        return true;
    }
};

CLOUD.Extensions = CLOUD.Extensions || {};
CLOUD.Extensions.Utils = CLOUD.Extensions.Utils || {};

CLOUD.Extensions.Utils.Shape2D = {

    createSvgElement: function createSvgElement(type) {

        var xmlns = 'http://www.w3.org/2000/svg';
        var svg = document.createElementNS(xmlns, type);
        svg.setAttribute('pointer-events', 'inherit');

        return svg;
    },
    getRGBAString: function getRGBAString(hexRGBString, opacity) {

        if (opacity <= 0) {
            return 'none';
        }

        var rgba = ['rgba(' + parseInt('0x' + hexRGBString.substr(1, 2)), ',', parseInt('0x' + hexRGBString.substr(3, 2)), ',', parseInt('0x' + hexRGBString.substr(5, 2)), ',', opacity, ')'].join('');

        return rgba;
    },
    makeFlag: function makeFlag() {

        var path = "M0 0 L0 -20 L15 -13 L4 -6.87 L4 0Z";
        var shape = this.createSvgElement('path');
        shape.setAttribute('d', path);

        return shape;
    },
    makeBubble: function makeBubble() {

        var path = "m0.0035,-19.88544c-3.838253,0 -6.95,2.581968 -6.95,5.766754c0,3.185555 6.95,13.933247 6.95,13.933247s6.95,-10.747692 6.95,-13.933247c0,-3.184786 -3.11082,-5.766754 -6.95,-5.766754z";
        var shape = this.createSvgElement('path');
        shape.setAttribute('d', path);

        return shape;
    },
    makeCommon: function makeCommon(url, size) {

        var shape = this.createSvgElement('image');
        shape.href.baseVal = url;
        shape.setAttribute('height', size.toString() + 'px');
        shape.setAttribute('width', size.toString() + 'px');

        return shape;
    }
};

CLOUD.DomUtilEx = {

    create: function create(tagName, className, container) {

        var el = document.createElement(tagName);
        el.className = className || '';

        if (container) {
            container.appendChild(el);
        }

        return el;
    },

    remove: function remove(el) {

        var parent = el.parentNode;
        if (parent) {
            parent.removeChild(el);
        }
    },

    setPosition: function setPosition(el, point) {

        el.position = point;

        el.style.left = point.x + 'px';
        el.style.top = point.y + 'px';
    },

    setOpacity: function setOpacity(el, value) {

        if ('opacity' in el.style) {
            el.style.opacity = value;
        } else if ('filter' in el.style) {
            CLOUD.DomUtilEx._setOpacityIE(el, value);
        }
    },

    _setOpacityIE: function _setOpacityIE(el, value) {
        var filter = false,
            filterName = 'DXImageTransform.Microsoft.Alpha';

        // filters collection throws an error if we try to retrieve a filter that doesn't exist
        try {
            filter = el.filters.item(filterName);
        } catch (e) {
            // don't set opacity to 1 if we haven't already set an opacity,
            // it isn't needed and breaks transparent pngs.
            if (value === 1) {
                return;
            }
        }

        value = Math.round(value * 100);

        if (filter) {
            filter.Enabled = value !== 100;
            filter.Opacity = value;
        } else {
            el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
        }
    }

};

CLOUD.MarkerUtil = {

    viewer: undefined,

    setOptions: function setOptions(obj, options) {

        if (!obj.hasOwnProperty('options')) {
            obj.options = {};
        }
        for (var i in options) {
            obj.options[i] = options[i];
        }

        return obj.options;
    },

    transformPosition: function transformPosition(position) {

        if (CLOUD.MarkerUtil.viewer === undefined) {
            throw new Error('please set the viewer for transformPosition.');
        } else {
            var bounds = CLOUD.DomUtil.getContainerOffsetToClient(document.getElementById('viewport'));
            var scene = CLOUD.MarkerUtil.viewer.getScene();
            var camera = CLOUD.MarkerUtil.viewer.cameraControl.camera;
            var sceneMatrix = scene.getMatrixGlobal();

            var result = new THREE.Vector3(position.x, position.y, position.z);
            result.applyMatrix4(sceneMatrix);
            result.project(camera);

            result.x = Math.round(0.5 * (result.x + 1) * bounds.width);
            result.y = Math.round(-0.5 * (result.y - 1) * bounds.height);

            return { x: result.x, y: result.y };
        }
    },

    panes: {},

    createPane: function createPane(name, container) {
        var className = name ? ' ' + name.replace('Pane', '') + '-pane' : '';
        var pane = CLOUD.DomUtilEx.create('div', className, container || document.getElementById('viewport'));

        if (name) {
            CLOUD.MarkerUtil.panes[name] = pane;
        }
        return pane;
    },

    getPane: function getPane(name, container) {
        if (name === undefined) {
            name = 'markerPane';
        }
        if (!CLOUD.MarkerUtil.panes.hasOwnProperty(name)) {
            return CLOUD.MarkerUtil.createPane(name, container);
        } else {
            return CLOUD.MarkerUtil.panes[name];
        }
    }
    //emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='

};
CLOUD.MiniMap = function (viewer) {

    this.viewer = viewer;
    this.visible = true;
    this.width = 0;
    this.height = 0;
    this.domContainer = null;
    this.autoClear = true;
    this.mouseButtons = { LEFT: THREE.MOUSE.LEFT, RIGHT: THREE.MOUSE.RIGHT };
    this.callbackCameraChanged = null;
    this.callbackMapClick = null;
    this.mapClickMode = "default";
    this.callbackClickOnAxisGrid = null;
    this.initialized = false;
    this.axisGirds = null;

    var scope = this;
    var _mapContainer;
    var normalizedMouse = new THREE.Vector2();

    var _clearColor = new THREE.Color(),
        _clearAlpha = 1;
    var _defaultClearColor = 0x333333; //0xffffff; // 0xadadad; // 缺省背景色
    var _materialColor = 0x999999;

    // 轴网材质
    var _materialGrid = new THREE.LineBasicMaterial({
        color: _materialColor,
        linewidth: 0.5
    });

    var _xmlns = "http://www.w3.org/2000/svg";
    //var _svg = document.createElementNS(_xmlns, 'svg');
    //var _svgGroupForAxisGrid = document.createElementNS(_xmlns, "g");
    var _svg, _svgGroupForAxisGrid;
    var _svgPathPool = [],
        _svgLinePool = [],
        _svgTextPool = [],
        _svgImagePool = [],
        _svgCirclePool = [],
        _pathCount = 0,
        _lineCount = 0,
        _textCount = 0,
        _imageCount = 0,
        _circleCount = 0,
        _quality = 1;
    var _svgNode, _svgWidth, _svgHeight, _svgHalfWidth, _svgHalfHeight;

    var _clipBox2D = new THREE.Box2(),
        _elemBox2D = new THREE.Box2(),
        _axisGridBox2D = new THREE.Box2();

    var _axisGridElements = [],
        _axisGridIntersectionPoints = [],
        _axisGridLevels = [];
    var _axisGridNumberCircleRadius = 10,
        _axisGridNumberFontSize = 8,
        _axisGridNumberInterval = 3; // 轴号间隔
    var _isShowAxisGrid = false,
        _isLoadedAxisGrid = false,
        _isLoadedFloorPlane = false;

    var _enableFlyByClick = true; // 是否允许click飞到指定位置

    var _tipNode, _circleNode, _highlightHorizLineNode, _highlightVerticalLineNode, _cameraNode, _cameraArrowNode, _cameraCircleNode;
    var _highlightColor = '#258ae3',
        _tipNodeColor = "#000",
        _tipNodeBackgroundColor = "#fff";
    var _highlightLineWidth = 1,
        _circleNodeRadius = 3;
    var _hasHighlightInterPoint = false;

    var _floorPlaneMinZ = 0; // 平面图最小高度
    var _cameraProjectedPosZ = 0; // 相机投影点位置高度
    var _floorPlaneBox, _floorPlaneUrl;

    var _enableShowCamera = true;
    var _lastCameraWorldPosition;
    var _epsilon = 0.00001;

    var _isNormalizeMousePoint = false;
    var _isChangeView = false;
    var _axisGridExpandSize = 100; // 100mm

    // ------------- 这些算法可以独立成单独文件 S ------------- //

    function cross(p1, p2, p3, p4) {
        return (p2.x - p1.x) * (p4.y - p3.y) - (p2.y - p1.y) * (p4.x - p3.x);
    }

    // 获得三角形面积(S = |AB * AC|)
    function getArea(p1, p2, p3) {
        return cross(p1, p2, p1, p3);
    }

    // 获得三角形面积
    function getAbsArea(p1, p2, p3) {
        return Math.abs(getArea(p1, p2, p3));
    }

    // 计算交点
    function getInterPoint(p1, p2, p3, p4) {

        var s1 = getAbsArea(p1, p2, p3);
        var s2 = getAbsArea(p1, p2, p4);
        var interPoint = new THREE.Vector2((p4.x * s1 + p3.x * s2) / (s1 + s2), (p4.y * s1 + p3.y * s2) / (s1 + s2));

        return interPoint;
    }

    //判断两向量角度是否大于180°，大于180°返回真，否则返回假
    function isAngleGreaterThanPi(start, end, up) {

        // 根据混合积来判断角度
        var dir = new THREE.Vector3();
        dir.crossVectors(start, end);

        var volume = dir.dot(up);

        //dir 与 up 同向 - 小于 180°
        if (volume >= 0) {
            return false;
        }

        return true;
    }

    // ------------- 这些算法可以独立成单独文件 E ------------- //

    // 正规化坐标转屏幕坐标
    function normalizedPointToScreen(point) {

        point.x = point.x * _svgHalfWidth;
        point.y = -point.y * _svgHalfHeight;
    }

    // 屏幕坐标转正规化坐标
    function screenToNormalizedPoint(point) {

        point.x = point.x / _svgHalfWidth;
        point.y = -point.y / _svgHalfHeight;
    }

    // 正规化屏幕坐标转世界坐标
    function normalizedPointToWorld(point) {

        var boxSize = _axisGridBox2D.getSize();

        point.x = 0.5 * (point.x + 1) * boxSize.x + _axisGridBox2D.min.x;
        point.y = 0.5 * (point.y + 1) * boxSize.y + _axisGridBox2D.min.y;
    }

    // 世界坐标转正规化屏幕坐标 [-1, 1]
    function worldToNormalizedPoint(point) {

        var boxSize = _axisGridBox2D.getSize();

        point.x = (point.x - _axisGridBox2D.min.x) / boxSize.x * 2 - 1;
        point.y = (point.y - _axisGridBox2D.min.y) / boxSize.y * 2 - 1;
    }

    function loadStyleString(css) {

        var style = document.createElement("style");
        style.type = "text/css";

        try {
            style.appendChild(document.createTextNode(css));
        } catch (ex) {
            style.styleSheet.cssText = css;
        }

        var head = document.getElementsByTagName('head')[0];
        head.appendChild(style);
    }

    function getImageNode(id) {

        if (_svgImagePool[id] == null) {
            _svgImagePool[id] = document.createElementNS(_xmlns, 'image');
            return _svgImagePool[id];
        }

        return _svgImagePool[id];
    }

    function getLineNode(id) {

        if (_svgLinePool[id] == null) {
            _svgLinePool[id] = document.createElementNS(_xmlns, 'line');

            if (_quality == 0) {
                _svgLinePool[id].setAttribute('shape-rendering', 'crispEdges'); //optimizeSpeed
            }

            return _svgLinePool[id];
        }

        return _svgLinePool[id];
    }

    function getCircleNode(id) {

        if (_svgCirclePool[id] == null) {
            _svgCirclePool[id] = document.createElementNS(_xmlns, 'circle');

            if (_quality == 0) {
                _svgCirclePool[id].setAttribute('shape-rendering', 'crispEdges'); //optimizeSpeed
            }

            return _svgCirclePool[id];
        }

        return _svgCirclePool[id];
    }

    function getTextNode(id) {

        if (_svgTextPool[id] == null) {
            _svgTextPool[id] = document.createElementNS(_xmlns, 'text');

            if (_quality == 0) {
                _svgTextPool[id].setAttribute('shape-rendering', 'crispEdges'); //optimizeSpeed
            }

            return _svgTextPool[id];
        }

        return _svgTextPool[id];
    }

    // 绘制线条
    function renderLine(v1, v2, material) {

        _svgNode = getLineNode(_lineCount++);
        _svgNode.setAttribute('x1', v1.x);
        _svgNode.setAttribute('y1', v1.y);
        _svgNode.setAttribute('x2', v2.x);
        _svgNode.setAttribute('y2', v2.y);

        if (material instanceof THREE.LineBasicMaterial) {
            _svgNode.setAttribute('style', 'fill: none; stroke: ' + material.color.getStyle() + '; stroke-width: ' + material.linewidth + '; stroke-opacity: ' + material.opacity + '; stroke-linecap: ' + material.linecap + '; stroke-linejoin: ' + material.linejoin);
            _svgGroupForAxisGrid.appendChild(_svgNode);
        }
    }

    // 绘制圆
    function renderCircle(cx, cy, material) {

        _svgNode = getCircleNode(_circleCount++);
        _svgNode.setAttribute('r', _axisGridNumberCircleRadius + '');
        _svgNode.setAttribute('transform', 'translate(' + cx + ',' + cy + ')');

        if (material instanceof THREE.LineBasicMaterial) {
            _svgNode.setAttribute('style', 'fill: none; stroke: ' + material.color.getStyle() + '; stroke-width: 1');
            _svgGroupForAxisGrid.appendChild(_svgNode);
        }
    }

    // 绘制文本
    function renderText(cx, cy, literal, material) {

        _svgNode = getTextNode(_textCount++);

        if (material instanceof THREE.LineBasicMaterial) {
            _svgNode.setAttribute('style', 'font-size:' + _axisGridNumberFontSize + 'px; fill: none; stroke: ' + material.color.getStyle() + '; stroke-width: 1');
            _svgGroupForAxisGrid.appendChild(_svgNode);
        }

        _svgNode.innerHTML = literal;

        // 注意: 必须已加到document中才能求到getBoundingClientRect
        var box = _svgNode.getBoundingClientRect();
        var offsetX = cx - 0.5 * box.width;
        var offsetY = cy + 0.25 * box.height;

        _svgNode.setAttribute('transform', 'translate(' + offsetX + ',' + offsetY + ')');
    }

    // 绘制平面图
    function renderFloorPlan() {

        if (_isLoadedFloorPlane) {
            _svgNode = getImageNode(0);
            _svg.appendChild(_svgNode);
        }
    }

    // 绘制高亮提示
    function renderHighlightNode() {

        _svg.appendChild(_highlightHorizLineNode);
        _svg.appendChild(_highlightVerticalLineNode);
        _svg.appendChild(_circleNode);
    }

    // 绘制轴网
    function renderAxisGrid() {

        _svg.appendChild(_svgGroupForAxisGrid);

        for (var i = 0, len = _axisGridElements.length; i < len; i++) {
            var lineElements = _axisGridElements[i];

            for (var j = 0, len2 = lineElements.length; j < len2; j++) {
                var element = lineElements[j];
                var v1 = element.v1.clone();
                var v2 = element.v2.clone();
                var material = element.material;

                _elemBox2D.makeEmpty();
                _elemBox2D.setFromPoints([v1, v2]);

                if (_clipBox2D.isIntersectionBox(_elemBox2D) === true) {
                    renderLine(v1, v2, material);

                    // 绘制轴号
                    if (j % _axisGridNumberInterval == 0) {
                        var dir = new THREE.Vector2();
                        dir.subVectors(v2, v1).normalize().multiplyScalar(_axisGridNumberCircleRadius);

                        var newV1 = v1.clone().sub(dir);
                        var newV2 = v2.clone().add(dir);

                        renderCircle(newV1.x, newV1.y, material);
                        renderCircle(newV2.x, newV2.y, material);

                        renderText(newV1.x, newV1.y, element.name, material);
                        renderText(newV2.x, newV2.y, element.name, material);
                    }
                }
            }
        }
    }

    // 设置容器元素style
    function setContainerElementStyle(container, styleOptions) {

        var defaultStyle = {
            position: "absolute",
            display: "block",
            left: "20px",
            bottom: "20px",
            outline: "#0000FF dotted thin"
            //opacity: ".6",
            //border: "red solid thin",
            //webkitTransition: "opacity .2s ease",
            //mozTransition: "opacity .2s ease",
            //msTransform: "opacity .2s ease",
            //oTransform: "opacity .2s ease",
            //transition: "opacity .2s ease"
        };

        styleOptions = styleOptions || defaultStyle;

        for (var attr in styleOptions) {
            //console.log(attr);
            container.style[attr] = styleOptions[attr];
        }

        //container.style.position = style.position;
        //container.style.display = style.display;
        //container.style.outline = style.outline;
        //container.style.left = style.left;
        //container.style.bottom = style.bottom;
    }

    function transformWorldPoint(point) {
        var sceneMatrix = scope.getMainSceneMatrix();
        point.applyMatrix4(sceneMatrix);
    }

    // 调整轴网
    function adjustAxisGrid(grids, mapMaxBox) {

        var newBox2D = new THREE.Box2();
        var newGrids = [];
        var specifiedMaxBox = new THREE.Box2(new THREE.Vector2(mapMaxBox[0], mapMaxBox[1]), new THREE.Vector2(mapMaxBox[2], mapMaxBox[3]));

        var horizLineElements = []; // 水平线集合
        var verticalLineElements = []; // 垂直线集

        var i = 0,
            j = 0,
            len = grids.length;

        // 计算轴网包围盒
        for (i = 0; i < len; i++) {

            var grid = grids[i];
            var startPt = grid.start || grid.Start;
            var endPt = grid.end || grid.End;
            var start = new THREE.Vector2(startPt.X, startPt.Y);
            var end = new THREE.Vector2(endPt.X, endPt.Y);
            var dir = end.clone().sub(start).normalize();

            if (Math.abs(dir.x) >= Math.abs(dir.y)) {
                // 水平方向线条
                horizLineElements.push({ v1: start, v2: end });
            } else {
                // 垂直方向线条
                verticalLineElements.push({ v1: start, v2: end });
            }
        }

        // 计算交点
        var horizLineElementsLen = horizLineElements.length;
        var verticalLineElementsLen = verticalLineElements.length;
        var horizLine, verticalLine;
        var p1, p2, p3, p4;

        for (i = 0; i < horizLineElementsLen; i++) {
            horizLine = horizLineElements[i];
            p1 = horizLine.v1.clone();
            p2 = horizLine.v2.clone();

            for (j = 0; j < verticalLineElementsLen; j++) {
                verticalLine = verticalLineElements[j];
                p3 = verticalLine.v1.clone();
                p4 = verticalLine.v2.clone();

                // 获得交点
                var interPoint = getInterPoint(p1, p2, p3, p4);

                newBox2D.expandByPoint(interPoint);
            }
        }

        newBox2D.union(specifiedMaxBox);
        // 扩展大小
        newBox2D.expandByScalar(_axisGridExpandSize);

        // 计算轴网包围盒
        for (i = 0; i < len; i++) {

            var grid = grids[i];
            var name = grid.name || grid.Name;
            var startPt = grid.start || grid.Start;
            var endPt = grid.end || grid.End;

            var start = new THREE.Vector2(startPt.X, startPt.Y);
            var end = new THREE.Vector2(endPt.X, endPt.Y);

            var dir = end.clone().sub(start).normalize();

            if (Math.abs(dir.x) >= Math.abs(dir.y)) {
                // 水平方向线条
                start.x = newBox2D.max.x;
                end.x = newBox2D.min.x;
                newGrids.push({ name: name, start: { X: start.x, Y: start.y }, end: { X: end.x, Y: end.y } });
            } else {
                // 垂直方向线条
                start.y = newBox2D.min.y;
                end.y = newBox2D.max.y;
                newGrids.push({ name: name, start: { X: start.x, Y: start.y }, end: { X: end.x, Y: end.y } });
            }
        }

        return newGrids;
    }

    // 计算轴网包围盒
    function calculateAxisGridBox(grids) {

        _axisGridBox2D.makeEmpty();

        // 计算轴网包围盒
        for (var i = 0, len = grids.length; i < len; i++) {

            var grid = grids[i];
            var startPt = grid.start || grid.Start;
            var endPt = grid.end || grid.End;

            var start = new THREE.Vector2(startPt.X, startPt.Y);
            var end = new THREE.Vector2(endPt.X, endPt.Y);

            _axisGridBox2D.expandByPoint(start);
            _axisGridBox2D.expandByPoint(end);
        }

        var center = _axisGridBox2D.getCenter();
        var oldSize = _axisGridBox2D.getSize();
        var newSize = new THREE.Vector2();
        var offset = 4;

        //
        //if (_isShowAxisGrid) {
        //
        //    //var center = _axisGridBox2D.getCenter();
        //    //var oldSize = _axisGridBox2D.getSize();
        //    //var newSize = new THREE.Vector2();
        //    newSize.x = oldSize.x * _svgWidth / (_svgWidth - 4.0 * (_axisGridNumberCircleRadius + offset));
        //    newSize.y = oldSize.y * _svgHeight / (_svgHeight - 4.0 * (_axisGridNumberCircleRadius + offset));
        //
        //    _axisGridBox2D.setFromCenterAndSize(center, newSize);
        //}

        // 扩展边框盒
        var svgAspect = _svgWidth / _svgHeight;
        var boxAspect = oldSize.x / oldSize.y;

        var newWidth = oldSize.x;
        var newHeight = oldSize.y;

        // 横向边较长 - 上下扩展
        if (boxAspect > svgAspect) {

            // 显示轴号，则先扩展横向边长，再求纵向边长
            if (_isShowAxisGrid) {
                newWidth = oldSize.x * _svgWidth / (_svgWidth - 4.0 * (_axisGridNumberCircleRadius + offset));
            }

            newHeight = newWidth / svgAspect;
        } else if (boxAspect < svgAspect) {
            // 左右扩展

            // 显示轴号，则先扩展纵向边长，再求横向边长
            if (_isShowAxisGrid) {
                newHeight = oldSize.y * _svgHeight / (_svgHeight - 4.0 * (_axisGridNumberCircleRadius + offset));
            }

            newWidth = newHeight * svgAspect;
        }

        newSize.set(newWidth, newHeight);

        _axisGridBox2D.setFromCenterAndSize(center, newSize);
    }

    // 计算轴网交叉点
    function calculateAxisGridIntersection(grids, material) {

        if (_axisGridElements.length > 0) {
            //_axisGridElements.splice(0,_axisGridElements.length);
            _axisGridElements = [];
        }

        if (_axisGridIntersectionPoints.length > 0) {
            _axisGridIntersectionPoints = [];
        }

        var horizLineElements = []; // 水平线集合
        var verticalLineElements = []; // 垂直线集

        var i = 0,
            j = 0,
            len = grids.length;

        for (i = 0; i < len; i++) {

            var grid = grids[i];

            var name = grid.name || grid.Name;
            var startPt = grid.start || grid.Start;
            var endPt = grid.end || grid.End;

            var start = new THREE.Vector2(startPt.X, startPt.Y);
            var end = new THREE.Vector2(endPt.X, endPt.Y);

            worldToNormalizedPoint(start);
            normalizedPointToScreen(start);

            worldToNormalizedPoint(end);
            normalizedPointToScreen(end);

            var dir = end.clone().sub(start).normalize();

            if (Math.abs(dir.x) >= Math.abs(dir.y)) {
                // 水平方向线条
                horizLineElements.push({ name: name, v1: start, v2: end, material: material });
            } else {
                // 垂直方向线条
                verticalLineElements.push({ name: name, v1: start, v2: end, material: material });
            }
        }

        _axisGridElements.push(horizLineElements);
        _axisGridElements.push(verticalLineElements);

        // 计算交点
        var horizLineElementsLen = horizLineElements.length;
        var verticalLineElementsLen = verticalLineElements.length;
        var horizLine, verticalLine, numeralName, abcName;
        var p1, p2, p3, p4;

        for (i = 0; i < horizLineElementsLen; i++) {
            horizLine = horizLineElements[i];
            abcName = horizLine.name;
            p1 = horizLine.v1.clone();
            p2 = horizLine.v2.clone();

            for (j = 0; j < verticalLineElementsLen; j++) {
                verticalLine = verticalLineElements[j];
                numeralName = verticalLine.name;
                p3 = verticalLine.v1.clone();
                p4 = verticalLine.v2.clone();

                // 获得交点
                var interPoint = getInterPoint(p1, p2, p3, p4);
                _axisGridIntersectionPoints.push({
                    intersectionPoint: interPoint,
                    horizLine: [p1.clone(), p2.clone()],
                    verticalLine: [p3.clone(), p4.clone()],
                    abcName: abcName,
                    numeralName: numeralName
                });
            }
        }
    }

    this.enableMouseEvent = function (enable) {

        _enableFlyByClick = enable;
        //this.render();
    };

    this.isEnableMouseEvent = function () {
        return _enableFlyByClick;
    };

    this.isMouseOverCanvas = function (mouse) {

        var domElement = _mapContainer;

        _isNormalizeMousePoint = false;

        if (domElement) {
            var dim = CLOUD.DomUtil.getContainerOffsetToClient(domElement);
            var canvasMouse = new THREE.Vector2();

            // 计算鼠标点相对于所在视口的位置
            canvasMouse.x = mouse.x - dim.left;
            canvasMouse.y = mouse.y - dim.top;

            if (dim.width === 0 || dim.height === 0) {
                return false;
            }

            // 规范化坐标系[-1, 1]
            if (canvasMouse.x > 0 && canvasMouse.x < this.width && canvasMouse.y > 0 && canvasMouse.y < this.height) {
                normalizedMouse.x = canvasMouse.x / this.width * 2 - 1;
                normalizedMouse.y = -canvasMouse.y / this.height * 2 + 1;

                _isNormalizeMousePoint = true;

                return true;
            }
        }

        return false;
    };

    // 主场景面板鼠标运动状态
    // 主场景面板的mouse move 和 mouse up 注册在 window 上，
    // 当鼠标从主场景移动到其他元素上时，不响应其他元素的事件
    this.isMouseMoving = function () {

        return this.viewer.editorManager.isMouseMoving();
    };

    this.onMouseDown = function (event) {

        if (this.isMouseMoving()) {
            return;
        }

        this.isMouseDown = true;
    };

    this.onMouseMove = function (event) {

        if (this.isMouseMoving()) {
            return;
        }

        if (!_enableFlyByClick) return;

        var mouse = new THREE.Vector2(event.clientX, event.clientY);
        var isOverCanvas = this.isMouseOverCanvas(mouse);

        this.highlightedNode(isOverCanvas, _isShowAxisGrid, false);
    };

    this.onMouseUp = function (event) {

        if (!this.isMouseDown) {

            return;
        }

        this.isMouseDown = false;

        var mouse = new THREE.Vector2(event.clientX, event.clientY);
        var isOverCanvas = this.isMouseOverCanvas(mouse);
        var isExistData = _isLoadedAxisGrid || _isLoadedFloorPlane;

        if (!_enableFlyByClick) {

            this.highlightedNode(isOverCanvas, _isShowAxisGrid, true);

            return;
        }

        if (isOverCanvas && isExistData) {

            // 计算选中点的坐标
            var clickPoint = new THREE.Vector3();
            var clickPoint2D = normalizedMouse.clone();
            normalizedPointToWorld(clickPoint2D);

            // 如果靠近交点，使用交点会更好，不然感觉靠近交点高亮时，点击的位置不一致。
            var screenPosition = normalizedMouse.clone();
            normalizedPointToScreen(screenPosition);

            // 获得最近的交点
            var intersection = this.getIntersectionToMinDistance(screenPosition);

            if (intersection) {
                // 计算轴信息
                var interPoint = new THREE.Vector2(intersection.intersectionPoint.x, intersection.intersectionPoint.y);
                var offset = screenPosition.sub(interPoint);

                if (offset.lengthSq() < _circleNodeRadius * _circleNodeRadius) {
                    var interScreenPoint = interPoint.clone();
                    screenToNormalizedPoint(interScreenPoint);
                    normalizedPointToWorld(interScreenPoint);
                    clickPoint.set(interScreenPoint.x, interScreenPoint.y, _cameraProjectedPosZ);
                } else {
                    clickPoint.set(clickPoint2D.x, clickPoint2D.y, _cameraProjectedPosZ);
                }
            } else {
                clickPoint.set(clickPoint2D.x, clickPoint2D.y, _cameraProjectedPosZ);
            }

            //    transformWorldPoint(clickPoint);

            var newPoint = clickPoint.clone();
            if (this.mapClickMode == "default") {
                this.callbackMapClick && this.callbackMapClick(newPoint);
                transformWorldPoint(clickPoint);
                this.flyToPointWithParallelEye(clickPoint);
            } else if (this.mapClickMode == "static") {
                this.callbackMapClick && this.callbackMapClick(newPoint);
            }
        }
    };

    /**
     * 位置转换
     * wangbing
     * @param location
     * @returns {*|Vector3}
     */
    this.imageCoord2WordCoord = function (location) {
        if (location.x > 0 && location.x < this.width && location.y > 0 && location.y < this.height) {
            normalizedMouse.x = location.x / this.width * 2 - 1;
            normalizedMouse.y = -location.y / this.height * 2 + 1;
        }
        _isNormalizeMousePoint = true;
        // 计算选中点的坐标
        var clickPoint = new THREE.Vector3();
        var clickPoint2D = normalizedMouse.clone();
        normalizedPointToWorld(clickPoint2D);

        // 如果靠近交点，使用交点会更好，不然感觉靠近交点高亮时，点击的位置不一致。
        var screenPosition = normalizedMouse.clone();
        normalizedPointToScreen(screenPosition);

        // 获得最近的交点
        var intersection = this.getIntersectionToMinDistance(screenPosition);

        if (intersection) {
            // 计算轴信息
            var interPoint = new THREE.Vector2(intersection.intersectionPoint.x, intersection.intersectionPoint.y);
            var offset = screenPosition.sub(interPoint);

            if (offset.lengthSq() < _circleNodeRadius * _circleNodeRadius) {
                var interScreenPoint = interPoint.clone();
                screenToNormalizedPoint(interScreenPoint);
                normalizedPointToWorld(interScreenPoint);
                clickPoint.set(interScreenPoint.x, interScreenPoint.y, _cameraProjectedPosZ);
            } else {
                clickPoint.set(clickPoint2D.x, clickPoint2D.y, _cameraProjectedPosZ);
            }
        } else {
            clickPoint.set(clickPoint2D.x, clickPoint2D.y, _cameraProjectedPosZ);
        }

        return clickPoint;
    };

    /**
     * 小地图定位到模型
     * @Author   WangBing
     * @DateTime 2017-10-24
     * @param    {[type]}   point    [description]
     * @param    {Function} callback [description]
     * @returns  {[type]}            [description]
     */
    this.toLocation = function (point, callback) {
        var isOverCanvas = false;
        if (point.x > 0 && point.x < this.width && point.y > 0 && point.y < this.height) {
            normalizedMouse.x = point.x / this.width * 2 - 1;
            normalizedMouse.y = -point.y / this.height * 2 + 1;
            _isNormalizeMousePoint = true;
            isOverCanvas = true;
        }

        var isExistData = _isLoadedAxisGrid || _isLoadedFloorPlane;

        if (!_enableFlyByClick) {

            this.highlightedNode(isOverCanvas, _isShowAxisGrid, true);

            return;
        }

        if (isOverCanvas && isExistData) {

            var clickPoint = this.imageCoord2WordCoord(point);

            var newPoint = clickPoint.clone();
            if (this.mapClickMode == "default") {
                if (callback) {
                    callback(newPoint);
                } else {
                    this.callbackMapClick(newPoint);
                    transformWorldPoint(clickPoint);
                    this.flyToPointWithParallelEye(clickPoint);
                }
            } else if (this.mapClickMode == "static") {
                if (callback) {
                    callback(newPoint);
                } else {
                    this.callbackMapClick(newPoint);
                }
            }

            this.flyToPointWithParallelEye(clickPoint);
        }
    };

    this.onContextMenu = function (event) {

        event.preventDefault();
    };

    this.onMouseDownBinded = this.onMouseDown.bind(this);
    this.onMouseMoveBinded = this.onMouseMove.bind(this);
    this.onMouseUpBinded = this.onMouseUp.bind(this);
    this.onContextMenuBinded = this.onContextMenu.bind(this);

    this.addDomEventListeners = function () {

        if (_mapContainer) {

            _mapContainer.addEventListener('contextmenu', this.onContextMenuBinded, false);
            _mapContainer.addEventListener('mousedown', this.onMouseDownBinded, false);
            _mapContainer.addEventListener('mousemove', this.onMouseMoveBinded, false);
            _mapContainer.addEventListener('mouseup', this.onMouseUpBinded, false);
        }
    };

    this.removeDomEventListeners = function () {

        if (_mapContainer) {

            _mapContainer.removeEventListener('contextmenu', this.onContextMenuBinded, false);
            _mapContainer.removeEventListener('mousedown', this.onMouseDownBinded, false);
            _mapContainer.removeEventListener('mousemove', this.onMouseMoveBinded, false);
            _mapContainer.removeEventListener('mouseup', this.onMouseUpBinded, false);
        }
    };

    this.init = function (domContainer, width, height, styleOptions, alpha) {

        width = width || 320;
        height = height || 240;
        alpha = alpha || 0;

        if (!_svg) {
            _svg = document.createElementNS(_xmlns, 'svg');
            _svgGroupForAxisGrid = document.createElementNS(_xmlns, "g");
        }

        // 初始化绘图面板
        this.initCanvasContainer(domContainer, styleOptions);
        // 初始化提示节点
        this.initTipNode();
        this.initCameraNode();
        // 设置绘图面板大小
        this.setSize(width, height);
        // 设置绘图面板背景色
        this.setClearColor(_defaultClearColor, alpha);
        this.clear();
        this.addDomEventListeners();

        _hasHighlightInterPoint = false;

        if (this.callbackClickOnAxisGrid) {

            var gridInfo = {
                position: '',
                abcName: '',
                numeralName: '',
                offsetX: '',
                offsetY: ''
            };
            this.callbackClickOnAxisGrid(gridInfo);
        }

        this.initialized = true;
    };

    this.uninit = function () {

        if (this.initialized) {

            this.initialized = false;

            this.removeDomEventListeners();

            this.clear();

            if (_svg.parentNode) {

                _svg.parentNode.removeChild(_svg);
            }

            this.remove();

            _mapContainer = null;
            _svg = null;
            _svgGroupForAxisGrid = null;

            this.domContainer = null;
            this.callbackCameraChanged = null;
            this.callbackClickOnAxisGrid = null;
            this.axisGirds = null;
        }
    };

    // 设置绘图面板大小
    this.setSize = function (width, height) {

        if (_mapContainer) {
            this.width = width;
            this.height = height;

            _mapContainer.style.width = width + "px";
            _mapContainer.style.height = height + "px";

            _svgWidth = width;
            _svgHeight = height;
            _svgHalfWidth = _svgWidth / 2;
            _svgHalfHeight = _svgHeight / 2;

            _svg.setAttribute('viewBox', -_svgHalfWidth + ' ' + -_svgHalfHeight + ' ' + _svgWidth + ' ' + _svgHeight);
            _svg.setAttribute('width', _svgWidth);
            _svg.setAttribute('height', _svgHeight);

            _clipBox2D.min.set(-_svgHalfWidth, -_svgHalfHeight);
            _clipBox2D.max.set(_svgHalfWidth, _svgHalfHeight);

            //this.resizeClientAxisGrid();
            //
            //_svgGroupForAxisGrid.style.display = "";
            //
            //if (_hasHighlightInterPoint) {
            //    this.showTip();
            //}
            //
            //this.render();
        }
    };

    // 设置绘图面板背景色
    this.setClearColor = function (color, alpha) {

        _clearColor.set(color);
        _clearAlpha = alpha !== undefined ? alpha : 1;
    };

    this.clear = function () {

        _pathCount = 0;
        _lineCount = 0;
        _textCount = 0;
        _imageCount = 0;
        _circleCount = 0;

        while (_svg.childNodes.length > 0) {

            while (_svg.childNodes[0] > 0) {
                _svg.childNodes[0].removeChild(_svg.childNodes[0].childNodes[0]);
            }

            _svg.removeChild(_svg.childNodes[0]);
        }

        _svg.style.backgroundColor = 'rgba(' + (_clearColor.r * 255 | 0) + ',' + (_clearColor.g * 255 | 0) + ',' + (_clearColor.b * 255 | 0) + ',' + _clearAlpha + ')';
    };

    this.render = function () {

        if (!_isLoadedAxisGrid) return;

        if (this.autoClear) this.clear();

        if (!this.visible) return;

        renderFloorPlan();

        if (_isShowAxisGrid) {
            renderAxisGrid();
            renderHighlightNode();
        }

        this.calculateCameraPosition();

        if (_enableShowCamera) {
            _svg.appendChild(_cameraNode);
        }
    };

    // 初始化绘图面板
    this.initCanvasContainer = function (domContainer, styleOptions) {

        this.domContainer = domContainer;

        if (!_mapContainer) {
            _mapContainer = document.createElement("div");
            setContainerElementStyle(_mapContainer, styleOptions);
            domContainer.appendChild(_mapContainer);
            _mapContainer.appendChild(_svg);
        }
    };

    // 初始化相机图形节点
    this.initCameraNode = function () {

        if (!_cameraNode) {

            _cameraNode = document.createElementNS(_xmlns, 'g');
            _cameraNode.setAttribute('fill', '#1b8cef');
            _cameraNode.setAttribute('stroke', '#cbd7e1');
            _cameraNode.setAttribute('stroke-width', '1');
            _cameraNode.setAttribute('stroke-linejoin', 'round');
            //_cameraNode.setAttribute('opacity', '0.0');

            // 尺寸大小 直径 12px
            var circle = document.createElementNS(_xmlns, 'circle');
            circle.setAttribute('r', '6');
            _cameraCircleNode = circle;

            var path = document.createElementNS(_xmlns, 'path');
            path.setAttribute('d', 'M 7 6 Q 10 0, 7 -6 L 19 0 Z');
            _cameraArrowNode = path;

            _cameraNode.appendChild(circle);
            _cameraNode.appendChild(path);
        }

        _cameraNode.setAttribute('opacity', '0.0');
    };

    // 初始化提示节点
    this.initTipNode = function () {

        if (!_tipNode) {

            // 指示箭头样式
            var css = ".cloud-tip:after { " + "box-sizing: border-box;" + "display: inline;" + "font-size: 10px;" + "width: 100%;" + "line-height: 1;" + "color: " + _tipNodeBackgroundColor + ";" + "content: '\\25BC';" + "position: absolute;" + "text-align: center;" + "margin: -4px 0 0 0;" + "top: 100%;" + "left: 0;" + "}";

            loadStyleString(css);

            _tipNode = document.createElement('div');
            _tipNode.className = "";
            //_tipNode.className = "cloud-tip";
            _tipNode.style.position = "absolute";
            _tipNode.style.display = "block";
            _tipNode.style.background = _tipNodeBackgroundColor;
            _tipNode.style.color = _tipNodeColor;
            _tipNode.style.padding = "0 8px 0 8px";
            _tipNode.style.borderRadius = "2px";
            _tipNode.style.fontSize = "8px";
            //_tipNode.style.opacity = 0;

            _mapContainer.appendChild(_tipNode);
        }

        _tipNode.style.opacity = 0;

        if (!_circleNode) {
            _circleNode = document.createElementNS(_xmlns, 'circle');
            _circleNode.setAttribute('r', _circleNodeRadius + '');
            _circleNode.setAttribute('fill', _highlightColor);
            //_circleNode.style.opacity = 0;
        }

        _circleNode.style.opacity = 0;

        if (!_highlightHorizLineNode) {
            _highlightHorizLineNode = document.createElementNS(_xmlns, 'line');
            _highlightHorizLineNode.setAttribute('style', 'stroke:' + _highlightColor + ';stroke-width:' + _highlightLineWidth + '');
            //_highlightHorizLineNode.style.opacity = 0;
        }

        _highlightHorizLineNode.style.opacity = 0;

        if (!_highlightVerticalLineNode) {
            _highlightVerticalLineNode = document.createElementNS(_xmlns, 'line');
            _highlightVerticalLineNode.setAttribute('style', 'stroke:' + _highlightColor + ';stroke-width:' + _highlightLineWidth + '');
            //_highlightVerticalLineNode.style.opacity = 0;
        }

        _highlightVerticalLineNode.style.opacity = 0;
    };

    // 构造轴网
    this.generateAxisGrid = function (recalculate) {

        if (recalculate == undefined) {

            recalculate = true;
        }

        var jsonObj = CLOUD.MiniMap.axisGridData;

        if (!jsonObj) return;

        var len = jsonObj.Grids.length;

        if (len < 1) {

            console.error("axis grid data error!!!");
            return;
        }

        _isLoadedAxisGrid = true;

        var grids;
        var mapMaxBox = jsonObj.mapMaxBox;

        if (recalculate && mapMaxBox) {

            grids = adjustAxisGrid(jsonObj.Grids, mapMaxBox);
        } else {

            grids = jsonObj.Grids;
        }

        this.axisGirds = grids;

        this.initAxisGird(grids);

        // 如果先初始化平面图，后初始化轴网，因为轴网确定范围，则需要重新初始化平面图
        if (_isLoadedFloorPlane) {

            console.log("re-initialize floor plane!!!");

            this.initFloorPlane();

            if (_isChangeView) {
                this.fly();
            } else {
                this.render();
            }
        } else {
            this.render();
        }
    };

    // 初始化轴网
    this.initAxisGird = function (grids) {

        // 计算轴网包围盒
        calculateAxisGridBox(grids);

        // 计算轴网交叉点
        calculateAxisGridIntersection(grids, _materialGrid);
    };

    //this.initAxisGirdLevels = function (levels) {
    //    var len = levels.length;
    //
    //    if (len < 1) {
    //        return;
    //    }
    //
    //    for (var i = 0; i < len; i++) {
    //        _axisGridLevels.push(levels[i]);
    //    }
    //};

    // 构造平面图
    this.generateFloorPlane = function (changeView) {

        if (changeView === undefined) {
            changeView = false;
        }

        _isChangeView = changeView;

        var jsonObj = CLOUD.MiniMap.floorPlaneData;

        if (!jsonObj) return;

        var url = jsonObj["Path"] || jsonObj["path"];
        var boundingBox = jsonObj["BoundingBox"] || jsonObj["boundingBox"];
        var elevation = jsonObj["Elevation"] || jsonObj["elevation"];

        if (!url || !boundingBox) {
            console.warn('floor-plan data is error!');
            return;
        }

        _floorPlaneUrl = url;
        _floorPlaneBox = new THREE.Box3(new THREE.Vector3(boundingBox.Min.X, boundingBox.Min.Y, boundingBox.Min.Z), new THREE.Vector3(boundingBox.Max.X, boundingBox.Max.Y, boundingBox.Max.Z));

        // 设置相机投影点位置高度在平面图包围盒中心
        _cameraProjectedPosZ = 0.5 * (_floorPlaneBox.min.z + _floorPlaneBox.max.z);
        _floorPlaneMinZ = elevation || _floorPlaneBox.min.z;

        _isLoadedFloorPlane = true;

        if (!_isLoadedAxisGrid) {
            console.warn('axis-grid is not initialized!');

            return;
        }

        this.initFloorPlane();

        // render
        if (_isChangeView) {
            this.fly();
        } else {
            this.render();
        }
    };

    // 初始化平面图
    this.initFloorPlane = function () {

        var url = _floorPlaneUrl;
        // 平面图不需要使用Z坐标
        var bBox2D = new THREE.Box2(new THREE.Vector2(_floorPlaneBox.min.x, _floorPlaneBox.min.y), new THREE.Vector2(_floorPlaneBox.max.x, _floorPlaneBox.max.y));
        // 计算位置
        var axisGridBoxSize = _axisGridBox2D.getSize();
        var axisGridCenter = _axisGridBox2D.getCenter();
        var boxSize = bBox2D.getSize();
        var boxCenter = bBox2D.getCenter();
        //var scaleX = _svgWidth / axisGridBoxSize.x;
        //var scaleY = _svgHeight / axisGridBoxSize.y;
        ////var scale = Math.min(scaleX, scaleY);
        //var scale = Math.max(scaleX, scaleY);
        // 保持比例
        var scale = _svgWidth / axisGridBoxSize.x;
        var width = boxSize.x * scale;
        var height = boxSize.y * scale;
        var offset = boxCenter.clone().sub(axisGridCenter);

        offset.x *= scale;
        offset.y *= -scale;

        if (!_axisGridBox2D.containsBox(bBox2D)) {
            console.warn('the bounding-box of axis-grid is not contains the bounding-box of floor-plane!');
        }

        _svgNode = getImageNode(0);
        _svgNode.href.baseVal = url;
        _svgNode.setAttribute("id", "Floor-" + _imageCount);
        _svgNode.setAttribute("preserveAspectRatio", "none");
        _svgNode.setAttribute("width", width + "");
        _svgNode.setAttribute("height", height + "");
        _svgNode.setAttribute("x", -0.5 * width + "");
        _svgNode.setAttribute("y", -0.5 * height + "");
        _svgNode.setAttribute("transform", 'translate(' + offset.x + ',' + offset.y + ')');
    };

    // 重设轴网大小
    this.resizeClientAxisGrid = function () {

        var grids = this.axisGirds || CLOUD.MiniMap.axisGridData.Grids;

        this.initAxisGird(grids);

        if (_isLoadedFloorPlane) {
            this.initFloorPlane();
        }
    };

    // 显示轴网
    this.showAxisGird = function () {

        if (_isLoadedAxisGrid) {

            _isShowAxisGrid = true;

            this.resizeClientAxisGrid();

            //_svgGroupForAxisGrid.style.opacity = 1;
            _svgGroupForAxisGrid.style.display = "";

            if (_hasHighlightInterPoint) {
                this.showTip();
            }

            this.render();
        }
    };

    // 隐藏轴网
    this.hideAxisGird = function () {

        if (_isLoadedAxisGrid) {

            _isShowAxisGrid = false;

            this.resizeClientAxisGrid();

            //_svgGroupForAxisGrid.style.opacity = 0;
            _svgGroupForAxisGrid.style.display = "none";

            this.hideTip();

            this.render();
        }
    };

    // 显示提示节点
    this.showTip = function () {

        if (_tipNode) {
            _tipNode.className = "cloud-tip";
            _tipNode.style.opacity = 1;
        }

        if (_circleNode) {
            _circleNode.style.opacity = 1;
        }

        if (_highlightHorizLineNode) {
            _highlightHorizLineNode.style.opacity = 1;
        }

        if (_highlightVerticalLineNode) {
            _highlightVerticalLineNode.style.opacity = 1;
        }
    };

    // 隐藏提示节点
    this.hideTip = function () {

        if (_tipNode) {
            _tipNode.className = "";
            _tipNode.style.opacity = 0;
        }

        if (_circleNode) {
            _circleNode.style.opacity = 0;
        }

        if (_highlightHorizLineNode) {
            _highlightHorizLineNode.style.opacity = 0;
        }

        if (_highlightVerticalLineNode) {
            _highlightVerticalLineNode.style.opacity = 0;
        }
    };

    // 通过轴网号高亮
    this.highlightNodeByAxisGridNumber = function (abcName, numeralName) {

        var intersection = this.getIntersectionByAxisGridNumber(abcName, numeralName);

        if (intersection) {

            this.setHighlightNode(intersection);
            this.showTip();
        } else {

            this.hideTip();
        }

        this.render();
    };

    // 高亮节点
    this.highlightedNode = function (isOverCanvas, isShowAxisGrid, allowNear) {

        _hasHighlightInterPoint = false;

        if (isOverCanvas && isShowAxisGrid) {

            var intersection;

            // 允许获得离选中的点最近的交点
            if (allowNear) {

                var screenPosition = normalizedMouse.clone();
                normalizedPointToScreen(screenPosition);
                // 获得最近的轴网交点
                intersection = this.getIntersectionToMinDistance(screenPosition);
            } else {

                intersection = this.getIntersectionByNormalizedPoint(normalizedMouse);
            }

            if (intersection) {

                _hasHighlightInterPoint = true;

                this.setHighlightNode(intersection);
                this.showTip();
            } else {

                this.hideTip();
            }

            this.render();

            if (this.callbackClickOnAxisGrid) {

                var gridInfo = this.getAxisGridInfoByNormalizedPoint(normalizedMouse);
                this.callbackClickOnAxisGrid(gridInfo);
            }
        } else {

            this.hideTip();
            this.render();
        }
    };

    // 设置节点高亮状态
    this.setHighlightNode = function (highlightNode) {

        // 高亮点的变换位置
        _circleNode.setAttribute('transform', 'translate(' + highlightNode.intersectionPoint.x + ',' + highlightNode.intersectionPoint.y + ')');

        // 提示文本
        _tipNode.innerHTML = highlightNode.numeralName + "-" + highlightNode.abcName;

        // 位置
        var box = _tipNode.getBoundingClientRect();

        _tipNode.style.left = _svgHalfWidth + highlightNode.intersectionPoint.x - 0.5 * box.width + "px";
        _tipNode.style.top = _svgHalfHeight + highlightNode.intersectionPoint.y - box.height - 12 + "px"; // 12 = fontsize(10px) + 2 * linewidth(1px)

        // 水平线条
        _highlightHorizLineNode.setAttribute('x1', highlightNode.horizLine[0].x);
        _highlightHorizLineNode.setAttribute('y1', highlightNode.horizLine[0].y);
        _highlightHorizLineNode.setAttribute('x2', highlightNode.horizLine[1].x);
        _highlightHorizLineNode.setAttribute('y2', highlightNode.horizLine[1].y);

        // 垂直线条
        _highlightVerticalLineNode.setAttribute('x1', highlightNode.verticalLine[0].x);
        _highlightVerticalLineNode.setAttribute('y1', highlightNode.verticalLine[0].y);
        _highlightVerticalLineNode.setAttribute('x2', highlightNode.verticalLine[1].x);
        _highlightVerticalLineNode.setAttribute('y2', highlightNode.verticalLine[1].y);
    };

    // 获得主场景变换矩阵
    this.getMainSceneMatrix = function () {
        return this.viewer.getScene().getMatrixGlobal();
    };

    // 判断点是否在场景包围盒中
    this.containsPointInMainScene = function (point) {

        var boundingBox = this.viewer.getScene().getBoundingBoxWorld();

        if (boundingBox) {
            return boundingBox.containsPoint(point);
        }

        return false;
    };

    // 根据指定位置点获得轴网信息
    this.getAxisGridInfoByPoint = function (point) {

        //if (_isLoadedFloorPlane) {

        var sceneMatrix = this.getMainSceneMatrix();
        var inverseMatrix = new THREE.Matrix4();
        inverseMatrix.getInverse(sceneMatrix);

        // 点对应的世界坐标
        var pointWorldPosition = point.clone();
        pointWorldPosition.applyMatrix4(inverseMatrix);

        // 屏幕坐标
        var screenPosition = pointWorldPosition.clone();
        worldToNormalizedPoint(screenPosition);
        normalizedPointToScreen(screenPosition);

        // 获得最近的轴网交点
        var intersection = this.getIntersectionToMinDistance(screenPosition);

        if (intersection) {
            // 计算轴信息
            var interPoint = new THREE.Vector2(intersection.intersectionPoint.x, intersection.intersectionPoint.y);
            screenToNormalizedPoint(interPoint);
            normalizedPointToWorld(interPoint);

            var offsetX = Math.round(pointWorldPosition.x - interPoint.x);
            var offsetY = Math.round(pointWorldPosition.y - interPoint.y);

            return {
                position: pointWorldPosition,
                abcName: intersection.abcName,
                numeralName: intersection.numeralName,
                offsetX: offsetX,
                offsetY: offsetY
            };
        }
        //}

        return {
            position: new THREE.Vector3(),
            abcName: '',
            numeralName: '',
            offsetX: '',
            offsetY: ''
        };
    };

    // 根据规范化坐标点获得轴网信息
    this.getAxisGridInfoByNormalizedPoint = function (normalizedPoint) {

        //if (_isLoadedFloorPlane) {

        // 世界坐标
        var pointWorldPosition = normalizedPoint.clone();
        normalizedPointToWorld(pointWorldPosition);

        // 屏幕坐标
        var screenPosition = normalizedPoint.clone();
        normalizedPointToScreen(screenPosition);

        // 获得最近的轴网交点
        var intersection = this.getIntersectionToMinDistance(screenPosition);

        if (intersection) {
            // 计算轴信息
            var interPoint = new THREE.Vector2(intersection.intersectionPoint.x, intersection.intersectionPoint.y);
            screenToNormalizedPoint(interPoint);
            normalizedPointToWorld(interPoint);

            var offsetX = Math.round(pointWorldPosition.x - interPoint.x);
            var offsetY = Math.round(pointWorldPosition.y - interPoint.y);

            return {
                position: pointWorldPosition,
                abcName: intersection.abcName,
                numeralName: intersection.numeralName,
                offsetX: offsetX,
                offsetY: offsetY
            };
        }
        //}

        return {
            position: new THREE.Vector3(),
            abcName: '',
            numeralName: '',
            offsetX: '',
            offsetY: ''
        };
    };

    // 根据正规化坐标获得轴网交叉点
    this.getIntersectionByNormalizedPoint = function (normalizedPoint) {

        var intersection = null;
        var _circleRadiusToSquared = _circleNodeRadius * _circleNodeRadius;

        for (var i = 0, len = _axisGridIntersectionPoints.length; i < len; i++) {
            var interPoint = _axisGridIntersectionPoints[i].intersectionPoint;
            var point = new THREE.Vector2(normalizedPoint.x, normalizedPoint.y);
            normalizedPointToScreen(point);

            var distanceSquared = interPoint.distanceToSquared(point);

            if (distanceSquared < _circleRadiusToSquared) {
                intersection = _axisGridIntersectionPoints[i];
                break;
            }
        }

        return intersection;
    };

    // 根据轴网号获得轴网交叉点
    this.getIntersectionByAxisGridNumber = function (abcName, numeralName) {

        var intersection = null;

        for (var i = 0, len = _axisGridIntersectionPoints.length; i < len; i++) {
            var abcNameTmp = _axisGridIntersectionPoints[i].abcName.toLowerCase();
            var numeralNameTmp = _axisGridIntersectionPoints[i].numeralName;

            if (abcNameTmp === abcName.toLowerCase() && numeralNameTmp === numeralName) {
                intersection = _axisGridIntersectionPoints[i];
                break;
            }
        }

        return intersection;
    };

    // 获得离指定位置最近的交叉点
    this.getIntersectionToMinDistance = function (screenPosition) {

        if (_axisGridIntersectionPoints.length < 1) return null;

        var minDistanceSquared = 0;
        var idx = 0;

        for (var i = 0, len = _axisGridIntersectionPoints.length; i < len; i++) {
            var interObj = _axisGridIntersectionPoints[i];
            var interPoint = new THREE.Vector2(interObj.intersectionPoint.x, interObj.intersectionPoint.y);
            var distanceSquared = interPoint.distanceToSquared(screenPosition);

            if (i == 0) {
                minDistanceSquared = distanceSquared;
            } else {
                if (minDistanceSquared > distanceSquared) {
                    minDistanceSquared = distanceSquared;
                    idx = i;
                }
            }
        }

        return _axisGridIntersectionPoints[idx];
    };

    // 检查平面图包围盒，如果没有平面图，则使用场景包围盒
    this.checkFloorPlaneBox = function () {

        if (!_floorPlaneBox) {
            // 没有平面图的话，将平面图包围设置为场景包围盒
            _floorPlaneBox = this.viewer.getBoundingBoxWorld();
            // 设置相机投影点位置高度在平面图包围盒中心
            _cameraProjectedPosZ = 0.5 * (_floorPlaneBox.min.z + _floorPlaneBox.max.z);
            _floorPlaneMinZ = _floorPlaneBox.min.z;
        }
    };

    // 计算相机在小地图上的位置
    this.calculateCameraPosition = function () {

        // if (!_isLoadedFloorPlane) return;

        this.checkFloorPlaneBox();

        var camera = this.viewer.camera;
        var cameraControl = this.viewer.cameraControl;

        if (!camera || !cameraControl) return;

        var cameraPosition = camera.position;
        var cameraTargetPosition = camera.target;
        var sceneMatrix = this.getMainSceneMatrix();
        var inverseMatrix = new THREE.Matrix4();
        inverseMatrix.getInverse(sceneMatrix);

        var bBoxCenter = _floorPlaneBox.getCenter();
        var pointA = new THREE.Vector3(_floorPlaneBox.min.x, _floorPlaneBox.min.y, bBoxCenter.z).applyMatrix4(sceneMatrix);
        var pointB = new THREE.Vector3(_floorPlaneBox.min.x, _floorPlaneBox.max.y, bBoxCenter.z).applyMatrix4(sceneMatrix);
        var pointC = new THREE.Vector3(_floorPlaneBox.max.x, _floorPlaneBox.min.y, bBoxCenter.z).applyMatrix4(sceneMatrix);

        var plane = new THREE.Plane();
        plane.setFromCoplanarPoints(pointA, pointB, pointC);

        // 计算相机投影
        var projectedCameraPosition = plane.projectPoint(cameraPosition);
        // 相机投影点世界坐标
        projectedCameraPosition.applyMatrix4(inverseMatrix);

        // 计算相机LookAt投影
        var projectedTargetPosition = plane.projectPoint(cameraTargetPosition);
        // 相机LookAt投影点世界坐标
        projectedTargetPosition.applyMatrix4(inverseMatrix);

        // 计算相机投影后的方向
        var projectedEye = projectedTargetPosition.clone().sub(projectedCameraPosition);
        projectedEye.z = 0;
        projectedEye.normalize();

        // 计算相机世界位置
        var cameraWorldPosition = cameraPosition.clone();
        cameraWorldPosition.applyMatrix4(inverseMatrix);

        // 相机屏幕坐标
        var cameraScreenPosition = cameraWorldPosition.clone();
        worldToNormalizedPoint(cameraScreenPosition);
        normalizedPointToScreen(cameraScreenPosition);

        _cameraNode.setAttribute('opacity', '1.0');

        if (projectedEye.length() < _epsilon) {

            // 隐藏箭头方向
            _cameraArrowNode.setAttribute('opacity', '0.0');
            _cameraNode.setAttribute("transform", "translate(" + cameraScreenPosition.x + "," + cameraScreenPosition.y + ")");
        } else {

            // 计算角度
            var up = new THREE.Vector3(0, 0, 1);
            var axisX = new THREE.Vector3(1, 0, 0);
            var isGreaterThanPi = isAngleGreaterThanPi(axisX, projectedEye, up);

            // [0, PI]
            var angle = THREE.Math.radToDeg(axisX.angleTo(projectedEye));

            // 注意：svg顺时针时针为正
            if (!isGreaterThanPi) {
                angle *= -1;
            }

            // 计算边缘交点
            var newProjectedCameraPosition = this.calculateEdgePositionCameraOutBounds(_axisGridBox2D, projectedCameraPosition, projectedEye);

            if (newProjectedCameraPosition) {

                var newCameraScreenPosition = new THREE.Vector2(newProjectedCameraPosition.x, newProjectedCameraPosition.y);
                worldToNormalizedPoint(newCameraScreenPosition);
                normalizedPointToScreen(newCameraScreenPosition);

                _cameraArrowNode.setAttribute('opacity', '1.0');
                _cameraCircleNode.setAttribute('opacity', '0.0');
                _cameraNode.setAttribute("transform", "translate(" + newCameraScreenPosition.x + "," + newCameraScreenPosition.y + ") rotate(" + angle + ")");
            } else {
                _cameraArrowNode.setAttribute('opacity', '1.0');
                _cameraCircleNode.setAttribute('opacity', '1.0');
                _cameraNode.setAttribute("transform", "translate(" + cameraScreenPosition.x + "," + cameraScreenPosition.y + ") rotate(" + angle + ")");
            }
        }

        // 设置回调相机信息
        this.setCallbackCameraInfo(cameraWorldPosition, cameraScreenPosition);

        _lastCameraWorldPosition = cameraWorldPosition.clone();

        var cameraProjectedWorldPosition = new THREE.Vector3(projectedCameraPosition.x, projectedCameraPosition.y, _cameraProjectedPosZ);

        return {
            worldPosition: cameraWorldPosition,
            projectedWorldPosition: cameraProjectedWorldPosition,
            screenPosition: cameraScreenPosition
        };
    };

    // 计算相机在边界上的位置
    this.calculateEdgePositionCameraOutBounds = function (bBox, worldPosition, direction) {

        // 先计算射线与Y轴平行的两个面的交点，再计算射线与X轴平行的两个面的交点

        var isExistedPoint = function isExistedPoint(points, p) {

            var existEqual = false;

            for (var i = 0, len = points.length; i < len; i++) {

                if (CLOUD.Extensions.Utils.Geometric.isEqualBetweenPoints(p, points[i], _epsilon)) {
                    existEqual = true;
                    break;
                }
            }

            return existEqual;
        };

        // 将包围盒上下左右拉大0.5，预防浮点精度问题
        var extendBox = bBox.clone();
        extendBox.min.x -= 0.5;
        extendBox.min.y -= 0.5;
        extendBox.max.x += 0.5;
        extendBox.max.y += 0.5;

        // 判断点是否在包围盒中，不在则计算与边缘的交点
        if (!extendBox.containsPoint(worldPosition)) {

            var intersects = [];

            var origin = new THREE.Vector3(worldPosition.x, worldPosition.y, 0);
            var ray = new THREE.Ray(origin, direction);

            // 与Y轴平行的面
            var point = new THREE.Vector3(bBox.min.x, bBox.min.y, 0);
            var normal = new THREE.Vector3(-1, 0, 0);
            var plane = new THREE.Plane();
            plane.setFromNormalAndCoplanarPoint(normal, point);

            var intersect = ray.intersectPlane(plane);

            if (intersect && extendBox.containsPoint(intersect)) {
                intersects.push(intersect);
            }

            // 与Y轴平行的面
            point.set(bBox.max.x, bBox.max.y, 0);
            normal.set(-1, 0, 0);
            plane.setFromNormalAndCoplanarPoint(normal, point);
            intersect = ray.intersectPlane(plane);

            if (intersect && extendBox.containsPoint(intersect)) {
                intersects.push(intersect);
            }

            // 与X轴平行的面
            point.set(bBox.min.x, bBox.min.y, 0);
            normal.set(0, 1, 0);
            plane.setFromNormalAndCoplanarPoint(normal, point);
            intersect = ray.intersectPlane(plane);

            if (intersect && extendBox.containsPoint(intersect)) {

                // 判断是否存在同一个点（四个角的位置可能出现同点）
                if (!isExistedPoint(intersect, intersects)) {
                    intersects.push(intersect);
                }
            }

            // 与X轴平行的面
            point.set(bBox.max.x, bBox.max.y, 0);
            normal.set(0, 1, 0);
            plane.setFromNormalAndCoplanarPoint(normal, point);
            intersect = ray.intersectPlane(plane);

            if (intersect && extendBox.containsPoint(intersect)) {

                // 判断是否存在同一个点（四个角的位置可能出现同点）
                if (!isExistedPoint(intersect, intersects)) {
                    intersects.push(intersect);
                }
            }

            if (intersects.length != 2) {

                return null;
            }

            // 存在两个交点则射线与包围盒相交
            var inter1 = intersects[0];
            var inter2 = intersects[1];

            var dir = inter2.clone().sub(inter1).normalize();

            if (CLOUD.Extensions.Utils.Geometric.isEqualBetweenPoints(dir, direction, _epsilon)) {

                return intersects[0];
            } else {

                return intersects[1];
            }
        }

        return null;
    };

    // 定位
    this.fly = function () {

        var cameraPosition = this.calculateCameraPosition();
        var cameraProjectedWorldPosition = cameraPosition.projectedWorldPosition.clone();

        // 变换到缩放后的场景区域
        transformWorldPoint(cameraProjectedWorldPosition);
        this.flyToPointWithParallelEye(cameraProjectedWorldPosition);
    };

    // 根据给定世界系中的点以平行视线方向定位
    this.flyToPointWithParallelEye = function (wPoint) {

        this.viewer.cameraControl.flyToPointWithParallelEye(wPoint);
    };

    // 根据轴号定位
    this.flyByAxisGridNumber = function (abcName, numeralName) {

        // 获得最近的交点
        var intersection = this.getIntersectionByAxisGridNumber(abcName, numeralName);

        if (intersection) {

            this.checkFloorPlaneBox();

            var interPoint = new THREE.Vector3(intersection.intersectionPoint.x, intersection.intersectionPoint.y, _cameraProjectedPosZ);

            screenToNormalizedPoint(interPoint);
            normalizedPointToWorld(interPoint);
            transformWorldPoint(interPoint);
            this.viewer.cameraControl.flyToPointWithParallelEye(interPoint);

            return true;
        }

        return false;
    };

    // 返回相机信息
    this.setCallbackCameraInfo = function (worldPosition, screenPosition) {

        var posChanged = true;

        if (_lastCameraWorldPosition) {
            posChanged = worldPosition.distanceToSquared(_lastCameraWorldPosition) !== 0;
        }

        if (this.callbackCameraChanged && posChanged) {

            var cameraWorldPos = worldPosition.clone();

            // 获得离相机最近的交点
            var intersection = this.getIntersectionToMinDistance(screenPosition);

            if (intersection) {
                // 计算轴信息
                var interPoint = new THREE.Vector2(intersection.intersectionPoint.x, intersection.intersectionPoint.y);
                screenToNormalizedPoint(interPoint);
                normalizedPointToWorld(interPoint);

                var offsetX = Math.round(worldPosition.x - interPoint.x);
                var offsetY = Math.round(worldPosition.y - interPoint.y);
                var offsetZ = Math.round(worldPosition.z - _floorPlaneMinZ);
                var axisInfoX = "X(" + intersection.numeralName + "," + offsetX + ")";
                var axisInfoY = "Y(" + intersection.abcName + "," + offsetY + ")";
                var isInScene = true;

                var projectedWorldPosition = worldPosition.clone();
                projectedWorldPosition.setZ(_cameraProjectedPosZ);

                // 判断是否在场景包围盒里面
                if (!this.containsPointInMainScene(projectedWorldPosition)) {
                    isInScene = false;
                    axisInfoX = "";
                    axisInfoY = "";
                }

                var jsonObj = {
                    position: cameraWorldPos,
                    isInScene: isInScene,
                    axis: {
                        abcName: intersection.abcName,
                        numeralName: intersection.numeralName,
                        offsetX: offsetX,
                        offsetY: offsetY,
                        offsetZ: offsetZ,
                        infoX: axisInfoX,
                        infoY: axisInfoY
                    }
                };

                this.callbackCameraChanged(jsonObj);
            } else {

                var jsonObj = {
                    position: cameraWorldPos,
                    isInScene: false,
                    axis: {
                        abcName: '',
                        numeralName: '',
                        offsetX: '',
                        offsetY: '',
                        offsetZ: '',
                        infoX: '',
                        infoY: ''
                    }
                };

                this.callbackCameraChanged(jsonObj);
            }
        }
    };

    // 启用或禁用相机图标
    this.enableCameraNode = function (enable) {

        _enableShowCamera = enable;
        //this.render();
    };

    // 从主容器中移除小地图
    this.remove = function () {

        if (_mapContainer && _mapContainer.parentNode) {

            _mapContainer.parentNode.removeChild(_mapContainer);
        }
    };

    // 增加小地图到主容器
    this.append = function () {

        if (_mapContainer && !_mapContainer.parentNode) {

            this.domContainer.appendChild(_mapContainer);

            this.render();
        }
    };

    // 相机变化回调
    this.setCameraChangedCallback = function (callback) {

        this.callbackCameraChanged = callback;
    };

    //Viewer小地图点击回调事件
    this.setMapClickCallback = function (callback) {

        this.callbackMapClick = callback;
    };

    //设置小地图点击模式
    this.setMapClickMode = function (mode) {
        this.mapClickMode = mode;
    };

    // 轴网上点击回调
    this.setClickOnAxisGridCallback = function (callback) {

        this.callbackClickOnAxisGrid = callback;
    };

    this.resize = function (width, height) {

        if (_mapContainer && _isLoadedAxisGrid) {
            // 设置绘图面板大小
            this.setSize(width, height);
            this.resizeClientAxisGrid();

            if (_isShowAxisGrid) {
                _svgGroupForAxisGrid.style.display = "";
            } else {
                _svgGroupForAxisGrid.style.display = "none";
            }

            this.hideTip();
            this.render();
        }
    };
};

CLOUD.MiniMap.axisGridData = null;
CLOUD.MiniMap.floorPlaneData = null;

CLOUD.MiniMap.setAxisGridData = function (jsonObj) {
    CLOUD.MiniMap.axisGridData = jsonObj;
};
CLOUD.MiniMap.setFloorPlaneData = function (jsonObj) {
    CLOUD.MiniMap.floorPlaneData = jsonObj;
};

CLOUD.Extensions.Annotation = function (editor, id) {

    this.editor = editor;
    this.id = id;
    this.shapeType = 0;

    this.position = { x: 0, y: 0, z: 0 };
    this.size = { width: 0, height: 0 };
    this.rotation = 0;

    this.style = editor.annotationStyle ? CLOUD.DomUtil.cloneStyle(editor.annotationStyle) : this.getDefaultStyle();
    this.shape = null;
    this.selected = false;
    this.highlighted = false;
    this.highlightColor = '#FAFF3C';
    this.isDisableInteractions = false;
    this.disableResizeWidth = false;
    this.disableResizeHeight = false;
    this.disableRotation = false;

    this.onMouseDownBinded = this.onMouseDown.bind(this);
    this.onMouseOutBinded = this.onMouseOut.bind(this);
    this.onMouseOverBinded = this.onMouseOver.bind(this);
};

CLOUD.Extensions.Annotation.prototype = {
    constructor: CLOUD.Extensions.Annotation,

    addDomEventListeners: function addDomEventListeners() {},

    removeDomEventListeners: function removeDomEventListeners() {},

    onMouseDown: function onMouseDown(event) {

        if (this.isDisableInteractions) {
            return;
        }

        this.select();

        if (this.editor.annotationFrame) {
            this.editor.annotationFrame.dragBegin(event);
        }
    },

    onMouseOut: function onMouseOut() {
        this.highlight(false);
    },

    onMouseOver: function onMouseOver() {
        this.highlight(true);
    },

    created: function created() {},

    destroy: function destroy() {

        this.removeDomEventListeners();
        this.deselect();
        this.setParent(null);
    },

    set: function set(position, size, rotation) {

        this.position.x = position.x;
        this.position.y = position.y;
        this.position.z = position.z;
        this.size.width = size.width;
        this.size.height = size.height;
        this.rotation = rotation || 0;

        this.update();
    },

    // 设置旋转角（弧度）
    resetRotation: function resetRotation(angle) {

        this.rotation = angle;
        this.update();
    },

    // 获得旋转角（弧度）
    getRotation: function getRotation() {

        return this.rotation;
    },

    // 设置位置
    resetPosition: function resetPosition(position) {

        this.position.x = position.x;
        this.position.y = position.y;
        this.position.z = position.z;
        this.update();
    },

    getClientPosition: function getClientPosition() {

        return this.editor.getAnnotationClientPosition(this.position);
    },

    resetSize: function resetSize(size, position) {

        this.size.width = size.width;
        this.size.height = size.height;
        this.position.x = position.x;
        this.position.y = position.y;
        this.position.z = position.z;
        this.update();
    },

    getClientSize: function getClientSize() {

        return this.editor.getAnnotationClientSize(this.size, this.position);
    },

    setParent: function setParent(parent) {

        var shapeEl = this.shape;

        if (shapeEl.parentNode) {
            shapeEl.parentNode.removeChild(shapeEl);
        }

        if (parent) {
            parent.appendChild(shapeEl);
        }
    },

    setStyle: function setStyle(style) {

        this.style = CLOUD.DomUtil.cloneStyle(style);
        // 文本批注需要传入一个强制更新的参数
        this.update(true);
    },

    getStyle: function getStyle() {

        return CLOUD.DomUtil.cloneStyle(this.style);
    },

    updateStyle: function updateStyle(style) {

        this.style = CLOUD.DomUtil.cloneStyle(style);
        // 文本批注需要传入一个强制更新的参数
        this.update(true);
    },

    update: function update() {},

    select: function select() {

        if (this.selected) {
            return;
        }

        this.selected = true;
        this.highlighted = false;
        this.update();

        this.editor.selectAnnotation(this);
    },

    deselect: function deselect() {

        this.selected = false;
    },

    highlight: function highlight(isHighlight) {

        if (this.isDisableInteractions) {
            return;
        }

        this.highlighted = isHighlight;
        this.update();
    },

    disableInteractions: function disableInteractions(disable) {

        this.isDisableInteractions = disable;
    },

    delete: function _delete() {

        this.editor.deleteAnnotation(this);
    },

    getDefaultStyle: function getDefaultStyle() {

        var style = {};

        style['stroke-width'] = 3;
        style['stroke-color'] = '#ff0000';
        style['stroke-opacity'] = 1.0;
        style['fill-color'] = '#ff0000';
        style['fill-opacity'] = 0.0;
        style['font-family'] = 'Arial';
        style['font-size'] = 16;
        style['font-style'] = ''; // 'italic'
        style['font-weight'] = ''; // 'bold'

        return style;
    }
};

CLOUD.Extensions.Annotation.shapeTypes = { ARROW: 0, RECTANGLE: 1, CIRCLE: 2, CROSS: 3, CLOUD: 4, TEXT: 5 };
CLOUD.Extensions.AnnotationArrow = function (editor, id) {

    CLOUD.Extensions.Annotation.call(this, editor, id);

    this.shapeType = CLOUD.Extensions.Annotation.shapeTypes.ARROW;
    this.head = new THREE.Vector2();
    this.tail = new THREE.Vector2();
    this.disableResizeHeight = true;
    this.size.height = this.style['stroke-width'] * 4; // 箭头固定高度

    this.createShape();
    this.addDomEventListeners();
};

CLOUD.Extensions.AnnotationArrow.prototype = Object.create(CLOUD.Extensions.Annotation.prototype);
CLOUD.Extensions.AnnotationArrow.prototype.constructor = CLOUD.Extensions.AnnotationArrow;

CLOUD.Extensions.AnnotationArrow.prototype.addDomEventListeners = function () {

    this.shape.addEventListener("mousedown", this.onMouseDownBinded, true);
    this.shape.addEventListener("mouseout", this.onMouseOutBinded);
    this.shape.addEventListener("mouseover", this.onMouseOverBinded);
};

CLOUD.Extensions.AnnotationArrow.prototype.removeDomEventListeners = function () {

    this.shape.removeEventListener("mousedown", this.onMouseDownBinded, true);
    this.shape.removeEventListener("mouseout", this.onMouseOutBinded);
    this.shape.removeEventListener("mouseover", this.onMouseOverBinded);
};

CLOUD.Extensions.AnnotationArrow.prototype.createShape = function () {
    this.shape = CLOUD.Extensions.Utils.Shape2D.createSvgElement('polygon');
};

CLOUD.Extensions.AnnotationArrow.prototype.setByTailHead = function (tail, head) {

    var v0 = new THREE.Vector2(tail.x, tail.y);
    var v1 = new THREE.Vector2(head.x, head.y);
    var dir = v1.clone().sub(v0).normalize();

    // 计算尺寸
    this.size.width = v0.distanceTo(v1);

    // 计算旋转角度
    this.rotation = Math.acos(dir.dot(new THREE.Vector2(1, 0)));
    this.rotation = head.y > tail.y ? Math.PI * 2 - this.rotation : this.rotation;

    this.tail.set(tail.x, tail.y);
    this.head.set(head.x, head.y);

    var depth = tail.z;

    this.position.x = 0.5 * (this.head.x + this.tail.x);
    this.position.y = 0.5 * (this.head.y + this.tail.y);
    this.position.z = depth;

    this.update();
};

CLOUD.Extensions.AnnotationArrow.prototype.getClientSize = function () {

    var size = this.editor.getAnnotationClientSize(this.size, this.position);
    size.height = this.style['stroke-width'] * 4;

    return size;
};

CLOUD.Extensions.AnnotationArrow.prototype.resetSize = function (size, position) {

    var dir = new THREE.Vector2(Math.cos(this.rotation), Math.sin(this.rotation));
    dir.multiplyScalar(size.width * 0.5);

    var center = new THREE.Vector2(position.x, position.y);
    var tail = center.clone().sub(dir);
    var head = center.clone().add(dir);

    this.tail.set(tail.x, tail.y);
    this.head.set(head.x, head.y);

    this.position.x = position.x;
    this.position.y = position.y;
    this.position.z = position.z;

    this.size.width = size.width;

    this.update();
};

CLOUD.Extensions.AnnotationArrow.prototype.resetPosition = function (position) {

    var dx = this.head.x - this.tail.x;
    var dy = this.head.y - this.tail.y;

    this.tail.x = position.x - dx * 0.5;
    this.tail.y = position.y - dy * 0.5;
    this.head.x = this.tail.x + dx;
    this.head.y = this.tail.y + dy;

    this.position.x = position.x;
    this.position.y = position.y;
    this.position.z = position.z;

    this.update();
};

CLOUD.Extensions.AnnotationArrow.prototype.update = function () {

    var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];
    var strokeOpacity = this.style['stroke-opacity'];

    var shapePoints = this.getShapePoints();
    var mappedPoints = shapePoints.map(function (point) {
        return point[0] + ',' + point[1];
    });
    var pointsStr = mappedPoints.join(' ');
    var position = this.getClientPosition();
    var size = this.getClientSize();
    var offsetX = 0.5 * size.width;
    var offsetY = 0.5 * size.height;

    this.transformShape = ['translate(', position.x, ',', position.y, ') ', 'rotate(', THREE.Math.radToDeg(this.rotation), ') ', 'translate(', -offsetX, ',', -offsetY, ') '].join('');

    this.shape.setAttribute('points', pointsStr);
    this.shape.setAttribute("transform", this.transformShape);
    this.shape.setAttribute('fill', strokeColor);
    this.shape.setAttribute('opacity', strokeOpacity);
};

CLOUD.Extensions.AnnotationArrow.prototype.getShapePoints = function () {

    var strokeWidth = this.style['stroke-width'] * 2;
    var size = this.getClientSize();
    var halfLen = size.width * 0.5;
    var thickness = strokeWidth;
    var halfThickness = strokeWidth * 0.5;
    var headLen = halfLen - 2.0 * thickness;

    var p1 = [-halfLen, -halfThickness];
    var p2 = [headLen, -halfThickness];
    var p3 = [headLen, -thickness];
    var p4 = [halfLen, 0];
    var p5 = [headLen, thickness];
    var p6 = [headLen, halfThickness];
    var p7 = [-halfLen, halfThickness];

    var points = [p1, p2, p3, p4, p5, p6, p7];

    points.forEach(function (point) {
        point[0] += halfLen;
        point[1] += thickness;
    });

    return points;
};

CLOUD.Extensions.AnnotationArrow.prototype.renderToCanvas = function (ctx) {

    var strokeWidth = this.style['stroke-width'] * 2;
    var strokeColor = this.style['stroke-color'];
    var strokeOpacity = this.style['stroke-opacity'];

    var position = this.getClientPosition();
    var size = this.getClientSize();
    var offsetX = size.width * 0.5;
    var offsetY = strokeWidth;

    var m1 = new THREE.Matrix4().makeTranslation(-offsetX, -offsetY, 0);
    var m2 = new THREE.Matrix4().makeRotationZ(this.rotation);
    var m3 = new THREE.Matrix4().makeTranslation(position.x, position.y, 0);
    var transform = m3.multiply(m2).multiply(m1);

    var points = this.getShapePoints();

    ctx.fillStyle = CLOUD.Extensions.Utils.Shape2D.getRGBAString(strokeColor, strokeOpacity);
    ctx.beginPath();

    points.forEach(function (point) {

        var client = new THREE.Vector3(point[0], point[1], 0);
        client.applyMatrix4(transform);
        ctx.lineTo(client.x, client.y);
    });

    ctx.fill();
};

CLOUD.Extensions.AnnotationRectangle = function (editor, id) {

    CLOUD.Extensions.Annotation.call(this, editor, id);

    this.shapeType = CLOUD.Extensions.Annotation.shapeTypes.RECTANGLE;

    this.createShape();
    this.addDomEventListeners();
};

CLOUD.Extensions.AnnotationRectangle.prototype = Object.create(CLOUD.Extensions.Annotation.prototype);
CLOUD.Extensions.AnnotationRectangle.prototype.constructor = CLOUD.Extensions.AnnotationRectangle;

CLOUD.Extensions.AnnotationRectangle.prototype.addDomEventListeners = function () {

    this.shape.addEventListener("mousedown", this.onMouseDownBinded, true);
    this.shape.addEventListener("mouseout", this.onMouseOutBinded);
    this.shape.addEventListener("mouseover", this.onMouseOverBinded);
};

CLOUD.Extensions.AnnotationRectangle.prototype.removeDomEventListeners = function () {

    this.shape.removeEventListener("mousedown", this.onMouseDownBinded, true);
    this.shape.removeEventListener("mouseout", this.onMouseOutBinded);
    this.shape.removeEventListener("mouseover", this.onMouseOverBinded);
};

CLOUD.Extensions.AnnotationRectangle.prototype.createShape = function () {
    this.shape = CLOUD.Extensions.Utils.Shape2D.createSvgElement('rect');
};

CLOUD.Extensions.AnnotationRectangle.prototype.update = function () {

    var strokeWidth = this.style['stroke-width'];
    var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];
    var strokeOpacity = this.style['stroke-opacity'];
    var fillColor = this.style['fill-color'];
    var fillOpacity = this.style['fill-opacity'];

    var position = this.getClientPosition();
    var size = this.getClientSize();
    var width = Math.max(size.width - strokeWidth, 0);
    var height = Math.max(size.height - strokeWidth, 0);
    var offsetX = 0.5 * width;
    var offsetY = 0.5 * height;

    this.transformShape = ['translate(', position.x, ',', position.y, ') ', 'rotate(', THREE.Math.radToDeg(this.rotation), ') ', 'translate(', -offsetX, ',', -offsetY, ') '].join('');

    this.shape.setAttribute('transform', this.transformShape);
    this.shape.setAttribute('stroke-width', strokeWidth);
    this.shape.setAttribute("stroke", CLOUD.Extensions.Utils.Shape2D.getRGBAString(strokeColor, strokeOpacity));
    this.shape.setAttribute('fill', CLOUD.Extensions.Utils.Shape2D.getRGBAString(fillColor, fillOpacity));
    this.shape.setAttribute('width', width + '');
    this.shape.setAttribute('height', height + '');
};

CLOUD.Extensions.AnnotationRectangle.prototype.renderToCanvas = function (ctx) {

    var strokeWidth = this.style['stroke-width'];
    var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];
    var strokeOpacity = this.style['stroke-opacity'];
    var fillColor = this.style['fill-color'];
    var fillOpacity = this.style['fill-opacity'];

    var size = this.getClientSize();
    var position = this.getClientPosition();
    var width = Math.max(size.width - strokeWidth, 0);
    var height = Math.max(size.height - strokeWidth, 0);

    ctx.strokeStyle = CLOUD.Extensions.Utils.Shape2D.getRGBAString(strokeColor, strokeOpacity);
    ctx.fillStyle = CLOUD.Extensions.Utils.Shape2D.getRGBAString(fillColor, fillOpacity);
    ctx.lineWidth = strokeWidth;
    ctx.translate(position.x, position.y);
    ctx.rotate(this.rotation);

    ctx.beginPath();

    if (fillOpacity !== 0) {
        ctx.fillRect(width / -2, height / -2, width, height);
    }

    ctx.strokeRect(width / -2, height / -2, width, height);
};

CLOUD.Extensions.AnnotationCircle = function (editor, id) {

    CLOUD.Extensions.Annotation.call(this, editor, id);

    this.shapeType = CLOUD.Extensions.Annotation.shapeTypes.CIRCLE;

    this.createShape();
    this.addDomEventListeners();
};

CLOUD.Extensions.AnnotationCircle.prototype = Object.create(CLOUD.Extensions.Annotation.prototype);
CLOUD.Extensions.AnnotationCircle.prototype.constructor = CLOUD.Extensions.AnnotationCircle;

CLOUD.Extensions.AnnotationCircle.prototype.addDomEventListeners = function () {

    this.shape.addEventListener("mousedown", this.onMouseDownBinded, true);
    this.shape.addEventListener("mouseout", this.onMouseOutBinded);
    this.shape.addEventListener("mouseover", this.onMouseOverBinded);
};

CLOUD.Extensions.AnnotationCircle.prototype.removeDomEventListeners = function () {

    this.shape.removeEventListener("mousedown", this.onMouseDownBinded, true);
    this.shape.removeEventListener("mouseout", this.onMouseOutBinded);
    this.shape.removeEventListener("mouseover", this.onMouseOverBinded);
};

CLOUD.Extensions.AnnotationCircle.prototype.createShape = function () {
    this.shape = CLOUD.Extensions.Utils.Shape2D.createSvgElement('ellipse');
};

CLOUD.Extensions.AnnotationCircle.prototype.update = function () {

    var strokeWidth = this.style['stroke-width'];
    var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];
    var strokeOpacity = this.style['stroke-opacity'];
    var fillColor = this.style['fill-color'];
    var fillOpacity = this.style['fill-opacity'];

    var position = this.getClientPosition();
    var size = this.getClientSize();
    var offsetX = Math.max(size.width - strokeWidth, 0) * 0.5;
    var offsetY = Math.max(size.height - strokeWidth, 0) * 0.5;

    this.transformShape = ['translate(', position.x, ',', position.y, ') ', 'rotate(', THREE.Math.radToDeg(this.rotation), ') ', 'translate(', -offsetX, ',', -offsetY, ') '].join('');

    this.shape.setAttribute("transform", this.transformShape);
    this.shape.setAttribute("stroke-width", strokeWidth);
    this.shape.setAttribute("stroke", CLOUD.Extensions.Utils.Shape2D.getRGBAString(strokeColor, strokeOpacity));
    this.shape.setAttribute('fill', CLOUD.Extensions.Utils.Shape2D.getRGBAString(fillColor, fillOpacity));
    this.shape.setAttribute('cx', offsetX);
    this.shape.setAttribute('cy', offsetY);
    this.shape.setAttribute('rx', offsetX);
    this.shape.setAttribute('ry', offsetY);
};

CLOUD.Extensions.AnnotationCircle.prototype.renderToCanvas = function (ctx) {

    function ellipse(ctx, cx, cy, w, h) {

        ctx.beginPath();

        var lx = cx - w / 2,
            rx = cx + w / 2,
            ty = cy - h / 2,
            by = cy + h / 2;

        var magic = 0.551784;
        var xmagic = magic * w / 2;
        var ymagic = magic * h / 2;

        ctx.moveTo(cx, ty);
        ctx.bezierCurveTo(cx + xmagic, ty, rx, cy - ymagic, rx, cy);
        ctx.bezierCurveTo(rx, cy + ymagic, cx + xmagic, by, cx, by);
        ctx.bezierCurveTo(cx - xmagic, by, lx, cy + ymagic, lx, cy);
        ctx.bezierCurveTo(lx, cy - ymagic, cx - xmagic, ty, cx, ty);
        ctx.stroke();
    }

    var strokeWidth = this.style['stroke-width'];
    var strokeColor = this.style['stroke-color'];
    var strokeOpacity = this.style['stroke-opacity'];
    var fillColor = this.style['fill-color'];
    var fillOpacity = this.style['fill-opacity'];

    var position = this.getClientPosition();
    var size = this.getClientSize();
    var width = Math.max(size.width - strokeWidth, 0);
    var height = Math.max(size.height - strokeWidth, 0);

    ctx.strokeStyle = CLOUD.Extensions.Utils.Shape2D.getRGBAString(strokeColor, strokeOpacity);
    ctx.fillStyle = CLOUD.Extensions.Utils.Shape2D.getRGBAString(fillColor, fillOpacity);
    ctx.lineWidth = strokeWidth;
    ctx.translate(position.x, position.y);
    ctx.rotate(this.rotation);

    //ctx.beginPath();

    ellipse(ctx, 0, 0, width, height);

    if (fillOpacity !== 0) {
        ctx.fill();
    }

    //ctx.stroke();
};
CLOUD.Extensions.AnnotationCloud = function (editor, id) {

    CLOUD.Extensions.Annotation.call(this, editor, id);

    this.shapeType = CLOUD.Extensions.Annotation.shapeTypes.CLOUD;
    this.shapePoints = [];
    this.trackingPoint = { x: 0, y: 0 };
    this.isSeal = false; // 是否封口
    this.isTracking = false;
    this.isEnableTrack = false;
    this.originSize = { width: 1, height: 1 };
    this.viewBox = { width: 1000, height: 1000 };

    this.createShape();
    this.addDomEventListeners();
};

CLOUD.Extensions.AnnotationCloud.prototype = Object.create(CLOUD.Extensions.Annotation.prototype);
CLOUD.Extensions.AnnotationCloud.prototype.constructor = CLOUD.Extensions.AnnotationCloud;

CLOUD.Extensions.AnnotationCloud.prototype.addDomEventListeners = function () {

    this.shape.addEventListener("mousedown", this.onMouseDownBinded, true);
    this.shape.addEventListener("mouseout", this.onMouseOutBinded);
    this.shape.addEventListener("mouseover", this.onMouseOverBinded);
};

CLOUD.Extensions.AnnotationCloud.prototype.removeDomEventListeners = function () {

    this.shape.removeEventListener("mousedown", this.onMouseDownBinded, true);
    this.shape.removeEventListener("mouseout", this.onMouseOutBinded);
    this.shape.removeEventListener("mouseover", this.onMouseOverBinded);
};

CLOUD.Extensions.AnnotationCloud.prototype.createShape = function () {
    this.shape = CLOUD.Extensions.Utils.Shape2D.createSvgElement('path');
};

CLOUD.Extensions.AnnotationCloud.prototype.setByPositions = function (positions, isSeal) {

    this.positions = positions.concat();

    this.isSeal = isSeal || false;

    // 计算位置及大小
    this.calculatePosition(true);

    this.originSize.width = this.size.width === 0 ? 1 : this.size.width;
    this.originSize.height = this.size.height === 0 ? 1 : this.size.height;

    this.update();
};

CLOUD.Extensions.AnnotationCloud.prototype.set = function (position, size, rotation, shapePointsStr, originSize) {

    this.position.x = position.x;
    this.position.y = position.y;
    this.position.z = position.z;
    this.size.width = size.width;
    this.size.height = size.height;
    this.rotation = rotation || 0;

    if (originSize) {

        this.originSize.width = originSize.width === 0 ? 1 : originSize.width;
        this.originSize.height = originSize.height === 0 ? 1 : originSize.height;
    } else {

        this.originSize.width = this.size.width === 0 ? 1 : this.size.width;
        this.originSize.height = this.size.height === 0 ? 1 : this.size.height;
    }

    this.setShapePoints(shapePointsStr);

    this.update();
};

CLOUD.Extensions.AnnotationCloud.prototype.setTrackingPoint = function (point) {

    this.trackingPoint.x = point.x;
    this.trackingPoint.y = point.y;

    this.calculatePosition(false);

    this.update();
};

CLOUD.Extensions.AnnotationCloud.prototype.update = function () {

    if (this.shapePoints.length < 1) return;

    var shapePathStr = this.getPathString();
    var strokeWidth = this.style['stroke-width'];
    var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];
    var strokeOpacity = this.style['stroke-opacity'];
    var fillColor = this.style['fill-color'];
    var fillOpacity = this.style['fill-opacity'];

    this.shape.setAttribute("stroke-width", strokeWidth);
    this.shape.setAttribute("stroke", CLOUD.Extensions.Utils.Shape2D.getRGBAString(strokeColor, strokeOpacity));
    this.shape.setAttribute('fill', CLOUD.Extensions.Utils.Shape2D.getRGBAString(fillColor, fillOpacity));
    this.shape.setAttribute('d', shapePathStr);
};

CLOUD.Extensions.AnnotationCloud.prototype.worldToViewBox = function (wPoint) {

    var originWidth = this.originSize.width;
    var originHeight = this.originSize.height;
    var viewBoxWidth = this.viewBox.width;
    var viewBoxHeight = this.viewBox.height;
    var x = Math.floor(wPoint.x / originWidth * viewBoxWidth + 0.5);
    var y = Math.floor(wPoint.y / originHeight * viewBoxHeight + 0.5);

    return { x: x, y: y };
};

CLOUD.Extensions.AnnotationCloud.prototype.viewBoxToWorld = function (vPoint) {

    var originWidth = this.originSize.width;
    var originHeight = this.originSize.height;
    var viewBoxWidth = this.viewBox.width;
    var viewBoxHeight = this.viewBox.height;
    var x = vPoint.x / viewBoxWidth * originWidth;
    var y = vPoint.y / viewBoxHeight * originHeight;

    return { x: x, y: y };
};

CLOUD.Extensions.AnnotationCloud.prototype.getPathString = function () {

    //var path = this.shapePoints.map(function(point, i){
    //    if (i === 0) {
    //        return ['M'].concat([point.x, point.y]).join(' ');
    //    } else {
    //        return ['Q'].concat([point.cx, point.cy, point.x, point.y ]).join(' ');
    //    }
    //}).join(' ');
    //
    //if (this.isSeal) {

    //    path += 'Z';
    //}
    //
    //return path;

    var scaleX = this.size.width / this.originSize.width;
    var scaleY = this.size.height / this.originSize.height;

    var m0 = new THREE.Matrix4().makeScale(scaleX, scaleY, 1);
    var m1 = new THREE.Matrix4().makeRotationZ(-this.rotation);
    var m2 = new THREE.Matrix4().makeTranslation(this.position.x, this.position.y, this.position.z);
    var transform = m2.multiply(m1).multiply(m0);

    var scope = this;
    var pos = new THREE.Vector3();
    var x, y, cx, cy;

    var path = this.shapePoints.map(function (point, i) {

        if (i === 0) {

            pos.x = point.x;
            pos.y = point.y;
            pos.z = 0;
            pos.applyMatrix4(transform);
            pos = scope.editor.worldToClient(pos);
            x = pos.x;
            y = pos.y;

            return ['M'].concat([x, y]).join(' ');
        } else {

            pos.x = point.cx;
            pos.y = point.cy;
            pos.z = 0;
            pos.applyMatrix4(transform);
            pos = scope.editor.worldToClient(pos);
            cx = pos.x;
            cy = pos.y;

            pos.x = point.x;
            pos.y = point.y;
            pos.z = 0;
            pos.applyMatrix4(transform);
            pos = scope.editor.worldToClient(pos);
            x = pos.x;
            y = pos.y;

            return ['Q'].concat([cx, cy, x, y]).join(' ');
        }
    }).join(' ');

    if (this.isSeal) {
        path += 'Z';
    }

    return path;
};

// 计算控制点
CLOUD.Extensions.AnnotationCloud.prototype.getControlPoint = function (startPoint, endPoint) {

    var start = new THREE.Vector2(startPoint.x, startPoint.y);
    var end = new THREE.Vector2(endPoint.x, endPoint.y);
    var direction = end.clone().sub(start);
    var halfLen = 0.5 * direction.length();
    var centerX = 0.5 * (start.x + end.x);
    var centerY = 0.5 * (start.y + end.y);
    var center = new THREE.Vector2(centerX, centerY);

    if (halfLen == 0) {
        return null;
    }
    direction.normalize();
    direction.rotateAround(new THREE.Vector2(0, 0), 0.5 * Math.PI);
    direction.multiplyScalar(halfLen);
    center.add(direction);

    return {
        x: center.x,
        y: center.y
    };
};

CLOUD.Extensions.AnnotationCloud.prototype.getBoundingBox = function () {

    var box = new THREE.Box2();
    var point = new THREE.Vector2();

    for (var i = 0, len = this.shapePoints.length; i < len; i++) {

        if (i === 0) {

            point.set(this.shapePoints[i].x, this.shapePoints[i].y);
            box.expandByPoint(point);
        } else {

            point.set(this.shapePoints[i].cx, this.shapePoints[i].cy);
            box.expandByPoint(point);

            point.set(this.shapePoints[i].x, this.shapePoints[i].y);
            box.expandByPoint(point);
        }
    }

    return box;
};

CLOUD.Extensions.AnnotationCloud.prototype.calculateShapePath = function () {

    var originShapePoint = {};
    var currentShapePoint = {};
    var lastShapePoint = {};
    var controlPoint;

    var len = this.positions.length;
    this.shapePoints = [];

    if (len < 1) {
        return;
    }

    // 保存深度
    this.depth = this.positions[0].z || 0;

    if (len === 1) {

        currentShapePoint.x = this.positions[0].x;
        currentShapePoint.y = this.positions[0].y;

        this.shapePoints.push({ x: this.positions[0].x, y: this.positions[0].y });

        if (this.isTracking) {

            // 计算控制点
            controlPoint = this.getControlPoint(currentShapePoint, this.trackingPoint);

            if (controlPoint) {
                this.shapePoints.push({ cx: controlPoint.x, cy: controlPoint.y, x: this.trackingPoint.x, y: this.trackingPoint.y });
            }
        }
    } else {

        for (var i = 0; i < len; i++) {

            currentShapePoint.x = this.positions[i].x;
            currentShapePoint.y = this.positions[i].y;

            if (i === 0) {

                this.shapePoints.push({ x: this.positions[i].x, y: this.positions[i].y });

                lastShapePoint.x = this.positions[i].x;
                lastShapePoint.y = this.positions[i].y;

                originShapePoint.x = this.positions[i].x;
                originShapePoint.y = this.positions[i].y;
            } else {

                // 计算控制点
                controlPoint = this.getControlPoint(lastShapePoint, currentShapePoint);

                if (controlPoint) {
                    this.shapePoints.push({ cx: controlPoint.x, cy: controlPoint.y, x: currentShapePoint.x, y: currentShapePoint.y });
                }

                lastShapePoint.x = currentShapePoint.x;
                lastShapePoint.y = currentShapePoint.y;

                // 最后一个点, 处理封口
                if (i === len - 1) {

                    if (this.isTracking) {

                        // 计算控制点
                        controlPoint = this.getControlPoint(lastShapePoint, this.trackingPoint);

                        if (controlPoint) {
                            this.shapePoints.push({ cx: controlPoint.x, cy: controlPoint.y, x: this.trackingPoint.x, y: this.trackingPoint.y });
                        }
                    } else if (this.isSeal) {
                        // 计算控制点
                        controlPoint = this.getControlPoint(lastShapePoint, originShapePoint);

                        if (controlPoint) {
                            this.shapePoints.push({ cx: controlPoint.x, cy: controlPoint.y, x: originShapePoint.x, y: originShapePoint.y });
                        }
                    }
                }
            }
        }
    }
};

CLOUD.Extensions.AnnotationCloud.prototype.calculateRelativePosition = function (center) {

    // 计算相对位置
    for (var i = 0, len = this.shapePoints.length; i < len; i++) {

        if (i === 0) {

            this.shapePoints[i].x -= center.x;
            this.shapePoints[i].y -= center.y;
        } else {

            this.shapePoints[i].x -= center.x;
            this.shapePoints[i].y -= center.y;
            this.shapePoints[i].cx -= center.x;
            this.shapePoints[i].cy -= center.y;
        }
    }
};

CLOUD.Extensions.AnnotationCloud.prototype.calculatePosition = function (force) {

    force = force || false;

    // 计算控制点
    this.calculateShapePath();

    if (force) {

        var box = this.getBoundingBox();
        var center = box.getCenter();

        this.center = { x: center.x, y: center.y };

        // 计算中心点
        this.position.x = center.x;
        this.position.y = center.y;
        this.position.z = this.depth || 0;

        // 计算相对位置
        this.calculateRelativePosition(center);

        // 重计算包围盒
        box = this.getBoundingBox();

        var size = box.getSize();

        this.size.width = size.x || 16;
        this.size.height = size.y || 16;
    } else {

        if (this.center) {

            // 计算相对位置
            this.calculateRelativePosition(this.center);
        }
    }
};

CLOUD.Extensions.AnnotationCloud.prototype.startTrack = function () {
    this.isTracking = true;
};

CLOUD.Extensions.AnnotationCloud.prototype.finishTrack = function () {
    this.isTracking = false;
};

CLOUD.Extensions.AnnotationCloud.prototype.enableTrack = function () {
    this.isEnableTrack = true;
};

CLOUD.Extensions.AnnotationCloud.prototype.disableTrack = function () {
    this.isEnableTrack = false;
};

CLOUD.Extensions.AnnotationCloud.prototype.getTrackState = function () {
    return this.isEnableTrack;
};

CLOUD.Extensions.AnnotationCloud.prototype.setSeal = function (isSeal) {

    this.isSeal = isSeal;

    this.calculatePosition(false);
    this.update();
};

// 设置形状点集
CLOUD.Extensions.AnnotationCloud.prototype.setShapePoints = function (shapeStr) {

    var x, y, cx, cy, retPoint;
    var shapePoints = shapeStr.split(',');

    var x0 = parseInt(shapePoints[0]);
    var y0 = parseInt(shapePoints[1]);
    retPoint = this.viewBoxToWorld({ x: x0, y: y0 });
    x0 = retPoint.x;
    y0 = retPoint.y;

    this.shapePoints = [];
    this.shapePoints.push({ x: x0, y: y0 });

    for (var i = 2, len = shapePoints.length; i < len; i += 4) {

        cx = parseInt(shapePoints[i]);
        cy = parseInt(shapePoints[i + 1]);
        retPoint = this.viewBoxToWorld({ x: cx, y: cy });
        cx = retPoint.x;
        cy = retPoint.y;

        x = parseInt(shapePoints[i + 2]);
        y = parseInt(shapePoints[i + 3]);
        retPoint = this.viewBoxToWorld({ x: x, y: y });
        x = retPoint.x;
        y = retPoint.y;

        this.shapePoints.push({ cx: cx, cy: cy, x: x, y: y });
    }
};

// 获得形状点集字符串（用“，”分割）
CLOUD.Extensions.AnnotationCloud.prototype.getShapePoints = function () {

    var points = [];

    // 转成整型存储以减少存储空间
    var x, y, cx, cy, retPoint;

    for (var i = 0, len = this.shapePoints.length; i < len; i++) {

        if (i === 0) {

            x = this.shapePoints[i].x;
            y = this.shapePoints[i].y;
            retPoint = this.worldToViewBox({ x: x, y: y });
            x = retPoint.x;
            y = retPoint.y;
            points.push(x);
            points.push(y);
        } else {

            cx = this.shapePoints[i].cx;
            cy = this.shapePoints[i].cy;
            retPoint = this.worldToViewBox({ x: cx, y: cy });
            cx = retPoint.x;
            cy = retPoint.y;
            points.push(cx);
            points.push(cy);

            x = this.shapePoints[i].x;
            y = this.shapePoints[i].y;
            retPoint = this.worldToViewBox({ x: x, y: y });
            x = retPoint.x;
            y = retPoint.y;
            points.push(x);
            points.push(y);
        }
    }

    return points.join(',');
};

CLOUD.Extensions.AnnotationCloud.prototype.renderToCanvas = function (ctx) {

    // 小于两个点，不处理
    if (this.shapePoints.length < 2) return;

    var strokeWidth = this.style['stroke-width'];
    var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];
    var strokeOpacity = this.style['stroke-opacity'];
    var fillColor = this.style['fill-color'];
    var fillOpacity = this.style['fill-opacity'];

    ctx.strokeStyle = CLOUD.Extensions.Utils.Shape2D.getRGBAString(strokeColor, strokeOpacity);
    ctx.fillStyle = CLOUD.Extensions.Utils.Shape2D.getRGBAString(fillColor, fillOpacity);
    ctx.lineWidth = strokeWidth;

    var scaleX = this.size.width / this.originSize.width;
    var scaleY = this.size.height / this.originSize.height;

    var m0 = new THREE.Matrix4().makeScale(scaleX, scaleY, 1);
    var m1 = new THREE.Matrix4().makeRotationZ(-this.rotation);
    var m2 = new THREE.Matrix4().makeTranslation(this.position.x, this.position.y, this.position.z);
    var transform = m2.multiply(m1).multiply(m0);

    var scope = this;

    ctx.beginPath();

    var pos = new THREE.Vector3();
    var x, y, cx, cy;

    this.shapePoints.forEach(function (point, i) {

        if (i === 0) {

            pos.x = point.x;
            pos.y = point.y;
            pos.z = 0;
            pos.applyMatrix4(transform);
            pos = scope.editor.worldToClient(pos);
            x = pos.x;
            y = pos.y;

            ctx.moveTo(x, y);
        } else {

            pos.x = point.cx;
            pos.y = point.cy;
            pos.z = 0;
            pos.applyMatrix4(transform);
            pos = scope.editor.worldToClient(pos);
            cx = pos.x;
            cy = pos.y;

            pos.x = point.x;
            pos.y = point.y;
            pos.z = 0;
            pos.applyMatrix4(transform);
            pos = scope.editor.worldToClient(pos);
            x = pos.x;
            y = pos.y;

            ctx.quadraticCurveTo(cx, cy, x, y);
        }
    });

    ctx.stroke();

    if (fillOpacity !== 0) {
        ctx.fill();
    }

    ctx.stroke();
};

CLOUD.Extensions.AnnotationCross = function (editor, id) {

    CLOUD.Extensions.Annotation.call(this, editor, id);

    this.shapeType = CLOUD.Extensions.Annotation.shapeTypes.CROSS;

    this.createShape();
    this.addDomEventListeners();
};

CLOUD.Extensions.AnnotationCross.prototype = Object.create(CLOUD.Extensions.Annotation.prototype);
CLOUD.Extensions.AnnotationCross.prototype.constructor = CLOUD.Extensions.AnnotationCross;

CLOUD.Extensions.AnnotationCross.prototype.addDomEventListeners = function () {

    this.shape.addEventListener("mousedown", this.onMouseDownBinded, true);
    this.shape.addEventListener("mouseout", this.onMouseOutBinded);
    this.shape.addEventListener("mouseover", this.onMouseOverBinded);
};

CLOUD.Extensions.AnnotationCross.prototype.removeDomEventListeners = function () {

    this.shape.removeEventListener("mousedown", this.onMouseDownBinded, true);
    this.shape.removeEventListener("mouseout", this.onMouseOutBinded);
    this.shape.removeEventListener("mouseover", this.onMouseOverBinded);
};

CLOUD.Extensions.AnnotationCross.prototype.createShape = function () {
    this.shape = CLOUD.Extensions.Utils.Shape2D.createSvgElement('path');
};

CLOUD.Extensions.AnnotationCross.prototype.update = function () {

    var strokeWidth = this.style['stroke-width'];
    var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];
    var strokeOpacity = this.style['stroke-opacity'];
    var fillColor = this.style['fill-color'];
    var fillOpacity = this.style['fill-opacity'];

    var position = this.getClientPosition();
    var size = this.getClientSize();
    var offsetX = Math.max(size.width - strokeWidth, 0) * 0.5;
    var offsetY = Math.max(size.height - strokeWidth, 0) * 0.5;

    this.transformShape = ['translate(', position.x, ',', position.y, ') ', 'rotate(', THREE.Math.radToDeg(this.rotation), ') ', 'translate(', -offsetX, ',', -offsetY, ') '].join('');

    this.shape.setAttribute('transform', this.transformShape);
    this.shape.setAttribute('stroke-width', strokeWidth);
    //this.shape.setAttribute('stroke',strokeColor);
    //this.shape.setAttribute('stroke-opacity',strokeOpacity);
    //this.shape.setAttribute('fill', fillColor);
    //this.shape.setAttribute('fill-opacity', fillOpacity);
    this.shape.setAttribute("stroke", CLOUD.Extensions.Utils.Shape2D.getRGBAString(strokeColor, strokeOpacity));
    this.shape.setAttribute('fill', CLOUD.Extensions.Utils.Shape2D.getRGBAString(fillColor, fillOpacity));
    this.shape.setAttribute('d', this.getPath().join(' '));
};

CLOUD.Extensions.AnnotationCross.prototype.getPath = function () {

    var size = this.getClientSize();
    var l = 0;
    var t = 0;
    var r = size.width;
    var b = size.height;

    var path = [];

    path.push('M');
    path.push(l);
    path.push(t);
    path.push('L');
    path.push(r);
    path.push(b);
    path.push('z');

    path.push('M');
    path.push(l);
    path.push(b);
    path.push('L');
    path.push(r);
    path.push(t);
    path.push('z');

    return path;
};

CLOUD.Extensions.AnnotationCross.prototype.renderToCanvas = function (ctx) {

    var strokeWidth = this.style['stroke-width'];
    var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];
    var strokeOpacity = this.style['stroke-opacity'];
    var fillColor = this.style['fill-color'];
    var fillOpacity = this.style['fill-opacity'];

    var position = this.getClientPosition();
    var size = this.getClientSize();
    var width = Math.max(size.width - strokeWidth, 0);
    var height = Math.max(size.height - strokeWidth, 0);

    ctx.strokeStyle = CLOUD.Extensions.Utils.Shape2D.getRGBAString(strokeColor, strokeOpacity);
    ctx.fillStyle = CLOUD.Extensions.Utils.Shape2D.getRGBAString(fillColor, fillOpacity);
    ctx.lineWidth = strokeWidth;

    ctx.translate(position.x, position.y);
    ctx.rotate(this.rotation);
    ctx.translate(-0.5 * width, -0.5 * height);

    ctx.beginPath();

    ctx.moveTo(0, 0);
    ctx.lineTo(width, height);

    ctx.moveTo(0, height);
    ctx.lineTo(width, 0);

    ctx.stroke();

    if (fillOpacity !== 0) {
        ctx.fill();
    }

    ctx.stroke();
};

CLOUD.Extensions.AnnotationText = function (editor, id) {

    CLOUD.Extensions.Annotation.call(this, editor, id);

    this.shapeType = CLOUD.Extensions.Annotation.shapeTypes.TEXT;
    this.currText = "";
    this.currTextLines = [""];
    this.textDirty = true;
    this.lineHeight = 100; // 单位 %

    // this.textArea = document.createElement('textarea');
    // this.textArea.setAttribute('maxlength', '260');
    //
    // this.textAreaStyle = {};
    // this.textAreaStyle['position'] = 'absolute';
    // this.textAreaStyle['overflow-y'] = 'hidden';
    //
    // this.measurePanel = document.createElement('div');

    // this.isActive = false;

    this.createShape();
    this.addDomEventListeners();
};

CLOUD.Extensions.AnnotationText.prototype = Object.create(CLOUD.Extensions.Annotation.prototype);
CLOUD.Extensions.AnnotationText.prototype.constructor = CLOUD.Extensions.AnnotationText;

CLOUD.Extensions.AnnotationText.prototype.addDomEventListeners = function () {

    this.shape.addEventListener("mousedown", this.onMouseDownBinded, true);
    this.shape.addEventListener("mouseout", this.onMouseOutBinded);
    this.shape.addEventListener("mouseover", this.onMouseOverBinded);
};

CLOUD.Extensions.AnnotationText.prototype.removeDomEventListeners = function () {

    this.shape.removeEventListener("mousedown", this.onMouseDownBinded, true);
    this.shape.removeEventListener("mouseout", this.onMouseOutBinded);
    this.shape.removeEventListener("mouseover", this.onMouseOverBinded);
};

CLOUD.Extensions.AnnotationText.prototype.createShape = function () {

    this.clipPath = CLOUD.Extensions.Utils.Shape2D.createSvgElement('clipPath');
    this.clipPathId = 'clip_' + this.id;
    this.clipPath.setAttribute('id', this.clipPathId);
    this.clipPath.removeAttribute('pointer-events');

    this.clipRect = CLOUD.Extensions.Utils.Shape2D.createSvgElement('rect');
    this.clipRect.removeAttribute('pointer-events');
    this.clipPath.appendChild(this.clipRect);

    this.shape = CLOUD.Extensions.Utils.Shape2D.createSvgElement('text');
    this.backgroundRect = CLOUD.Extensions.Utils.Shape2D.createSvgElement('rect');
};

CLOUD.Extensions.AnnotationText.prototype.set = function (position, size, rotation, textString) {

    this.position.x = position.x;
    this.position.y = position.y;
    this.position.z = position.z;

    this.size.width = size.width;
    this.size.height = size.height;

    this.rotation = rotation;

    this.setText(textString);
};

CLOUD.Extensions.AnnotationText.prototype.resetSize = function (size, position) {

    var clientSize = this.getClientSize();
    var isCalcLines = Math.floor(clientSize.width) !== size.width;

    this.position.x = position.x;
    this.position.y = position.y;
    this.position.z = position.z;

    this.size.width = size.width;
    this.size.height = size.height;

    if (isCalcLines) {

        var newLines = this.calcTextLines();

        if (!this.linesEqual(newLines)) {

            this.currTextLines = newLines;
            this.textDirty = true;
            this.forceRedraw();
        }
    }

    this.update();
};

CLOUD.Extensions.AnnotationText.prototype.setText = function (text) {

    this.currText = text;
    this.currTextLines = this.calcTextLines();
    this.textDirty = true;
    this.show();
    this.update();
};

CLOUD.Extensions.AnnotationText.prototype.getText = function () {

    return this.currText;
};

CLOUD.Extensions.AnnotationText.prototype.setParent = function (parent) {

    var currParent = this.clipPath.parentNode;

    if (currParent) {
        currParent.removeChild(this.clipPath);
    }

    if (parent) {
        parent.appendChild(this.clipPath);
    }

    currParent = this.backgroundRect.parentNode;

    if (currParent) {
        currParent.removeChild(this.backgroundRect);
    }

    if (parent) {
        parent.appendChild(this.backgroundRect);
    }

    currParent = this.shape.parentNode;

    if (currParent) {
        currParent.removeChild(this.shape);
    }

    if (parent) {
        parent.appendChild(this.shape);
    }
};

CLOUD.Extensions.AnnotationText.prototype.update = function (forceDirty) {

    var fontSize = this.style['font-size'];
    var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];
    var strokeOpacity = this.style['stroke-opacity'];
    var fillColor = this.style['fill-color'];
    var fillOpacity = this.style['fill-opacity'];

    var position = this.getClientPosition();
    var size = this.getClientSize();
    var offsetX = size.width * 0.5;
    var offsetY = size.height * 0.5;

    this.transformShape = ['translate(', position.x, ',', position.y, ') ', 'rotate(', THREE.Math.radToDeg(this.rotation), ') ', 'translate(', -offsetX, ',', -offsetY, ') '].join('');

    this.shape.setAttribute("font-family", this.style['font-family']);
    this.shape.setAttribute("font-size", fontSize);
    this.shape.setAttribute('font-weight', this.style['font-weight']);
    this.shape.setAttribute("font-style", this.style['font-style']);
    this.shape.setAttribute("fill", CLOUD.Extensions.Utils.Shape2D.getRGBAString(strokeColor, strokeOpacity));

    //var bBox = this.shape.getBBox();
    var verticalTransform = ['translate(0, ', fontSize, ')'].join('');
    this.shape.setAttribute("transform", this.transformShape + verticalTransform);
    //this.shape.setAttribute('clip-path', 'url(#' + this.clipPathId + ')');

    if (this.textDirty || forceDirty) {

        if (forceDirty) {
            this.currTextLines = this.calcTextLines();
        }

        this.rebuildTextSvg();
        this.textDirty = false;
    }

    //var bBox = this.shape.getBBox();
    var bBox = { x: 0, y: 0, left: 0, right: 0 };

    this.shapeBox = bBox;

    this.clipRect.setAttribute('x', "0");
    this.clipRect.setAttribute('y', bBox.y + '');
    this.clipRect.setAttribute('width', size.width);
    this.clipRect.setAttribute('height', size.height);

    verticalTransform = ['translate(0, ', size.height, ')'].join('');
    // this.backgroundRect.setAttribute("transform", this.transformShape + verticalTransform);
    this.backgroundRect.setAttribute("transform", this.transformShape);
    this.backgroundRect.setAttribute('width', size.width);
    this.backgroundRect.setAttribute('height', size.height);
    this.backgroundRect.setAttribute("stroke-width", '0');
    this.backgroundRect.setAttribute('fill', CLOUD.Extensions.Utils.Shape2D.getRGBAString(fillColor, fillOpacity));
};

CLOUD.Extensions.AnnotationText.prototype.show = function () {

    if (this.shape.style.display !== "") {
        this.shape.style.display = "";
    }
};

CLOUD.Extensions.AnnotationText.prototype.hide = function () {

    if (this.shape.style.display !== "none") {
        this.shape.style.display = "none";
    }
};

CLOUD.Extensions.AnnotationText.prototype.forceRedraw = function () {

    window.requestAnimationFrame(function () {

        this.highlighted = !this.highlighted;
        this.update();

        this.highlighted = !this.highlighted;
        this.update();
    }.bind(this));
};

CLOUD.Extensions.AnnotationText.prototype.rebuildTextSvg = function () {

    while (this.shape.childNodes.length > 0) {
        this.shape.removeChild(this.shape.childNodes[0]);
    }

    var dx = 0;
    var dy = 0;
    var yOffset = this.getLineHeight();

    this.currTextLines.forEach(function (line) {

        var tspan = CLOUD.Extensions.Utils.Shape2D.createSvgElement('tspan');
        tspan.setAttribute('x', dx);
        tspan.setAttribute('y', dy);
        tspan.textContent = line;
        this.shape.appendChild(tspan);
        dy += yOffset;
    }.bind(this));
};

CLOUD.Extensions.AnnotationText.prototype.getLineHeight = function () {
    return this.style['font-size'] * (this.lineHeight * 0.01);
};

// CLOUD.Extensions.AnnotationText.prototype.calcTextLines = function () {
//
//     var textValues = this.editor.annotationTextArea.getTextValuesByAnnotation(this);
//     return textValues.lines;
// };

CLOUD.Extensions.AnnotationText.prototype.calcTextLines = function () {

    var textArea = this.editor.getTextArea();
    var textValues = textArea.getTextValuesByAnnotation(this);

    return textValues.lines;
};

CLOUD.Extensions.AnnotationText.prototype.getTextLines = function () {

    return this.currTextLines.concat();
};

CLOUD.Extensions.AnnotationText.prototype.linesEqual = function (lines) {

    var curr = this.currTextLines;

    if (lines.length !== curr.length) return false;

    var len = curr.length;

    for (var i = 0; i < len; ++i) {
        if (lines[i] !== curr[i]) return false;
    }

    return true;
};

CLOUD.Extensions.AnnotationText.prototype.renderToCanvas = function (ctx) {

    function renderTextLines(ctx, lines, lineHeight, maxHeight) {

        var y = 0;

        lines.forEach(function (line) {

            if (y + lineHeight > maxHeight) {
                return;
            }

            ctx.fillText(line, 0, y);
            y += lineHeight;
        });
    }

    var fillColor = this.style['fill-color'];
    var fillOpacity = this.style['fill-opacity'];
    var strokeColor = this.style['stroke-color'];
    var fontOpacity = this.style['stroke-opacity'];
    var fontFamily = this.style['font-family'];
    var fontStyle = this.style['font-style'];
    var fontWeight = this.style['font-weight'];
    var fontSize = this.style['font-size'];

    var lineHeight = fontSize * (this.lineHeight * 0.01);
    var position = this.getClientPosition();
    var size = this.getClientSize();

    // 对应超出文本区域的文字的处理：使用包围盒
    //var bBox = this.shape.getBBox();
    var sizeBox = { width: this.shapeBox.width, height: this.shapeBox.height };

    ctx.save();
    ctx.fillStyle = CLOUD.Extensions.Utils.Shape2D.getRGBAString(fillColor, fillOpacity);
    ctx.translate(position.x, position.y);

    if (fillOpacity !== 0) {
        ctx.fillRect(-0.5 * sizeBox.width, -0.5 * sizeBox.height, sizeBox.width, sizeBox.height);
    }

    ctx.restore();

    // Text
    ctx.fillStyle = strokeColor;
    ctx.strokeStyle = strokeColor;
    ctx.textBaseline = 'top';
    ctx.translate(position.x, position.y);
    ctx.rotate(this.rotation);
    ctx.translate(-0.5 * size.width, -0.5 * size.height);

    ctx.font = fontStyle + " " + fontWeight + " " + fontSize + "px " + fontFamily;
    ctx.globalAlpha = fontOpacity;
    renderTextLines(ctx, this.currTextLines, lineHeight, sizeBox.height);
};

CLOUD.Extensions.AnnotationTextArea = function (editor, container) {

    this.editor = editor;
    this.container = container;

    this.textArea = document.createElement('textarea');
    this.textArea.setAttribute('maxlength', '260');

    this.textAreaStyle = {};
    this.textAreaStyle['position'] = 'absolute';
    this.textAreaStyle['overflow-y'] = 'hidden';

    this.measurePanel = document.createElement('div');

    this.textAnnotation = null;
    this.onKeyDownBinded = this.onKeyDown.bind(this);
    this.onResizeBinded = this.onResize.bind(this);

    this.addDomEventListeners();
};

CLOUD.Extensions.AnnotationTextArea.prototype.addDomEventListeners = function () {

    this.textArea.addEventListener('keydown', this.onKeyDownBinded, false);
};

CLOUD.Extensions.AnnotationTextArea.prototype.removeDomEventListeners = function () {

    this.textArea.removeEventListener('keydown', this.onKeyDownBinded, false);
};

CLOUD.Extensions.AnnotationTextArea.prototype.onKeyDown = function () {

    var keyCode = event.keyCode;
    var shiftDown = event.shiftKey;

    // 回车键
    if (!shiftDown && keyCode === 13) {
        event.preventDefault();
        this.accept();
        this.editor.resetCurrentAnnotationText();
    }
};

CLOUD.Extensions.AnnotationTextArea.prototype.onResize = function () {

    window.requestAnimationFrame(function () {

        if (this.textAnnotation) {

            var text = this.textArea.value;
            this.style = null;
            this.init();
            this.textArea.value = text;
        }
    }.bind(this));
};

CLOUD.Extensions.AnnotationTextArea.prototype.destroy = function () {

    this.removeDomEventListeners();
    this.inactive();
};

CLOUD.Extensions.AnnotationTextArea.prototype.init = function () {

    var position = this.textAnnotation.getClientPosition();
    var size = this.textAnnotation.getClientSize();
    var left = Math.floor(position.x - size.width * 0.5 + 0.5);
    var top = Math.floor(position.y - size.height * 0.5 + 0.5);

    var lineHeightPercentage = this.textAnnotation.lineHeight + "%";
    this.textAreaStyle['line-height'] = lineHeightPercentage;

    this.setBound(left, top, size.width, size.height);
    this.setStyle(this.textAnnotation.getStyle());
    this.textArea.value = this.textAnnotation.getText();
};

CLOUD.Extensions.AnnotationTextArea.prototype.setBound = function (left, top, width, height) {

    if (left + width >= this.container.clientWidth) {
        left = this.container.clientWidth - (width + 10);
    }

    if (top + height >= this.container.clientHeight) {
        top = this.container.clientHeight - (height + 10);
    }

    this.textAreaStyle['left'] = left + 'px';
    this.textAreaStyle['top'] = top + 'px';
    this.textAreaStyle['width'] = width + 'px';
    this.textAreaStyle['height'] = height + 'px';
};

CLOUD.Extensions.AnnotationTextArea.prototype.setStyle = function (style) {

    if (this.style) {

        var width = parseFloat(this.textArea.style.width);
        var height = parseFloat(this.textArea.style.height);
        var left = parseFloat(this.textArea.style.left);
        var top = parseFloat(this.textArea.style.top);

        var position = {
            x: left + width * 0.5,
            y: top + height * 0.5
        };

        this.setBound(position.x - width * 0.5, position.y - height * 0.5, width, height);
    }

    this.textAreaStyle['font-family'] = style['font-family'];
    this.textAreaStyle['font-size'] = style['font-size'] + 'px';
    this.textAreaStyle['font-weight'] = style['font-weight'];
    this.textAreaStyle['font-style'] = style['font-style'];
    this.textAreaStyle['color'] = style['stroke-color'];

    var styleStr = CLOUD.DomUtil.getStyleString(this.textAreaStyle);
    this.textArea.setAttribute('style', styleStr);

    this.style = CLOUD.DomUtil.cloneStyle(style);
};

CLOUD.Extensions.AnnotationTextArea.prototype.isActive = function () {

    return !!this.textAnnotation;
};

CLOUD.Extensions.AnnotationTextArea.prototype.active = function (annotation, firstEdit) {

    if (this.textAnnotation === annotation) {
        return;
    }

    this.inactive();

    this.container.appendChild(this.textArea);
    this.textAnnotation = annotation;
    this.firstEdit = firstEdit || false;

    this.init();

    window.addEventListener('resize', this.onResizeBinded);

    var textArea = this.textArea;

    window.requestAnimationFrame(function () {
        textArea.focus();
    });
};

CLOUD.Extensions.AnnotationTextArea.prototype.inactive = function () {

    window.removeEventListener('resize', this.onResizeBinded);

    if (this.textAnnotation) {

        this.textAnnotation = null;
        this.container.removeChild(this.textArea);
    }

    this.style = null;
};

CLOUD.Extensions.AnnotationTextArea.prototype.accept = function () {

    var left = parseFloat(this.textArea.style.left);
    var top = parseFloat(this.textArea.style.top);
    var width = parseFloat(this.textArea.style.width);
    var height = parseFloat(this.textArea.style.height);
    var textValues = this.getTextValues();
    var position = {
        x: left + width * 0.5,
        y: top + height * 0.5
    };
    var data = {
        annotation: this.textAnnotation,
        firstEdit: this.firstEdit,
        style: this.style,
        position: position,
        width: width,
        height: height,
        text: textValues.text,
        lines: textValues.lines
    };

    this.editor.handleTextChange(data);
    this.inactive();
};

CLOUD.Extensions.AnnotationTextArea.prototype.getTextValuesByAnnotation = function (annotation) {

    this.active(annotation, false);

    var textValues = this.getTextValues();

    this.inactive();

    return textValues;
};

CLOUD.Extensions.AnnotationTextArea.prototype.getTextValues = function () {

    var text = this.textArea.value;

    return {
        text: text,
        lines: this.calcTextLines()
    };
};

CLOUD.Extensions.AnnotationTextArea.prototype.calcTextLines = function () {

    var text = this.textArea.value;
    var linesBreaks = text.split(/\r*\n/);

    var measureStyle = CLOUD.DomUtil.cloneStyle(this.textAreaStyle);
    CLOUD.DomUtil.removeStyleAttribute(measureStyle, ['top', 'left', 'width', 'height', 'overflow-y']);
    measureStyle['position'] = 'absolute';
    measureStyle['white-space'] = 'nowrap';
    measureStyle['float'] = 'left';
    measureStyle['visibility'] = 'hidden';

    this.measurePanel.setAttribute('style', CLOUD.DomUtil.getStyleString(measureStyle));
    this.container.appendChild(this.measurePanel);

    var maxLineLength = parseFloat(this.textArea.style.width);
    var lines = [];

    for (var i = 0, len = linesBreaks.length; i < len; ++i) {

        var line = CLOUD.DomUtil.trimRight(linesBreaks[i]);
        this.splitLine(line, maxLineLength, lines);
    }

    this.container.removeChild(this.measurePanel);

    return lines;
};

CLOUD.Extensions.AnnotationTextArea.prototype.getShorterLine = function (line) {

    var iLastSpace = line.lastIndexOf(' ');

    if (iLastSpace === -1) {
        return [line];
    }

    while (line.charAt(iLastSpace - 1) === ' ') {
        iLastSpace--;
    }

    var trailingWord = line.substr(iLastSpace);
    var shorterLine = line.substr(0, iLastSpace);

    return [shorterLine, trailingWord];
};

CLOUD.Extensions.AnnotationTextArea.prototype.splitWord = function (word, remaining, maxLength, output) {

    var lenSoFar = 1;
    var fits = true;

    while (fits) {

        var part = word.substr(0, lenSoFar);
        this.measurePanel.innerHTML = part;
        var lineLen = this.measurePanel.clientWidth;

        if (lineLen > maxLength) {

            if (lenSoFar === 1) {

                output.push(part);
                this.splitWord(word.substr(1), remaining, maxLength, output);

                return;
            }

            var okayWord = word.substr(0, lenSoFar - 1);
            output.push(okayWord);

            var extraWord = word.substr(lenSoFar - 1);

            this.splitLine(extraWord + remaining, maxLength, output);

            return;
        }

        lenSoFar++;

        if (lenSoFar > word.length) {

            output.push(word);

            return;
        }
    }
};

CLOUD.Extensions.AnnotationTextArea.prototype.splitLine = function (text, maxLength, output) {

    if (text === '') {
        return;
    }

    var remaining = '';
    var done = false;

    while (!done) {

        this.measurePanel.innerHTML = text;
        var lineLen = this.measurePanel.clientWidth;

        if (lineLen <= maxLength) {

            output.push(text);
            this.splitLine(CLOUD.DomUtil.trimLeft(remaining), maxLength, output);
            done = true;
        } else {

            var parts = this.getShorterLine(text);

            if (parts.length === 1) {

                this.splitWord(text, remaining, maxLength, output);
                done = true;
            } else {

                text = parts[0];
                remaining = parts[1] + remaining;
            }
        }
    }
};

CLOUD.Extensions.AnnotationPopupTextArea = function (editor, container, popupCallback) {

    this.editor = editor;
    this.container = container;
    this.measurePanel = document.createElement('div');
    this.textAnnotation = null;
    this.popupCallback = popupCallback;
    this.initialText = "";
    this._resetTextAreaStyle();
};

CLOUD.Extensions.AnnotationPopupTextArea.prototype._setStyle = function (style) {

    var position = this.textAnnotation.getClientPosition();
    var size = this.textAnnotation.getClientSize();
    var left = Math.floor(position.x - size.width * 0.5 + 0.5);
    var top = Math.floor(position.y - size.height * 0.5 + 0.5);
    var width = size.width;
    var height = size.height;
    var fontSize = style['font-size']; // lineHeight = fontSize

    if (left + width >= this.container.clientWidth) {
        width = this.container.clientWidth - left + fontSize;
    }

    if (top + height >= this.container.clientHeight) {
        height = this.container.clientHeight - top + fontSize;
    }

    this.textAreaStyle['left'] = left + 'px';
    this.textAreaStyle['top'] = top + 'px';
    this.textAreaStyle['width'] = width + 'px';
    this.textAreaStyle['height'] = height + 'px';
    this.textAreaStyle['font-family'] = style['font-family'];
    this.textAreaStyle['font-size'] = style['font-size'] + 'px';
    this.textAreaStyle['font-weight'] = style['font-weight'];
    this.textAreaStyle['font-style'] = style['font-style'];
    this.textAreaStyle['color'] = style['stroke-color'];
};

CLOUD.Extensions.AnnotationPopupTextArea.prototype._getTextValues = function () {

    var text = this.textAnnotation.getText();

    return {
        text: text,
        lines: this._calcTextLines(text)
    };
};

CLOUD.Extensions.AnnotationPopupTextArea.prototype._calcTextLines = function (text) {

    var linesBreaks = text.split(/\r*\n/);
    var container = this.container;
    var measureStyle = CLOUD.DomUtil.cloneStyle(this.textAreaStyle);

    CLOUD.DomUtil.removeStyleAttribute(measureStyle, ['top', 'left', 'width', 'height', 'overflow-y']);
    measureStyle['position'] = 'absolute';
    measureStyle['white-space'] = 'nowrap';
    measureStyle['float'] = 'left';
    measureStyle['visibility'] = 'hidden';

    this.measurePanel.setAttribute('style', CLOUD.DomUtil.getStyleString(measureStyle));
    container.appendChild(this.measurePanel);

    var maxLineLength = parseFloat(this.textAreaStyle.width);
    var lines = [];

    for (var i = 0, len = linesBreaks.length; i < len; ++i) {

        var line = CLOUD.DomUtil.trimRight(linesBreaks[i]);
        this._splitTextLine(line, maxLineLength, lines);
    }

    container.removeChild(this.measurePanel);

    return lines;
};

CLOUD.Extensions.AnnotationPopupTextArea.prototype._getShorterTextLine = function (line) {

    var iLastSpace = line.lastIndexOf(' ');

    if (iLastSpace === -1) {
        return [line];
    }

    while (line.charAt(iLastSpace - 1) === ' ') {
        iLastSpace--;
    }

    var trailingWord = line.substr(iLastSpace);
    var shorterLine = line.substr(0, iLastSpace);

    return [shorterLine, trailingWord];
};

CLOUD.Extensions.AnnotationPopupTextArea.prototype._splitWord = function (word, remaining, maxLength, output) {

    var lenSoFar = 1;
    var fits = true;

    while (fits) {

        var part = word.substr(0, lenSoFar);
        this.measurePanel.innerHTML = part;
        var lineLen = this.measurePanel.clientWidth;

        if (lineLen > maxLength) {

            if (lenSoFar === 1) {

                output.push(part);
                this._splitWord(word.substr(1), remaining, maxLength, output);

                return;
            }

            var okayWord = word.substr(0, lenSoFar - 1);
            output.push(okayWord);

            var extraWord = word.substr(lenSoFar - 1);

            this._splitTextLine(extraWord + remaining, maxLength, output);

            return;
        }

        lenSoFar++;

        if (lenSoFar > word.length) {

            output.push(word);

            return;
        }
    }
};

CLOUD.Extensions.AnnotationPopupTextArea.prototype._splitTextLine = function (text, maxLength, output) {

    if (text === '') {
        return;
    }

    var remaining = '';
    var done = false;

    var measurePanel = this.measurePanel;

    while (!done) {

        measurePanel.innerHTML = text;
        var lineLen = measurePanel.clientWidth;

        if (lineLen <= maxLength) {

            output.push(text);
            this._splitTextLine(CLOUD.DomUtil.trimLeft(remaining), maxLength, output);
            done = true;
        } else {

            var parts = this._getShorterTextLine(text);

            if (parts.length === 1) {

                this._splitWord(text, remaining, maxLength, output);
                done = true;
            } else {

                text = parts[0];
                remaining = parts[1] + remaining;
            }
        }
    }
};

CLOUD.Extensions.AnnotationPopupTextArea.prototype._resetTextAreaStyle = function () {

    this.textAreaStyle = {};
    this.textAreaStyle['position'] = 'absolute';
    this.textAreaStyle['overflow-y'] = 'hidden';
};

CLOUD.Extensions.AnnotationPopupTextArea.prototype.destroy = function () {

    this.inactive();

    this.editor = null;
    this.container = null;
    this.measurePanel = null;
    this.popupCallback = null;
};

CLOUD.Extensions.AnnotationPopupTextArea.prototype.isActive = function () {

    return !!this.textAnnotation;
};

CLOUD.Extensions.AnnotationPopupTextArea.prototype.active = function (annotation, popup) {

    this.inactive();
    this.textAnnotation = annotation;

    if (popup && this.popupCallback) {

        this._setStyle(this.textAnnotation.getStyle());
        this.initialText = this.textAnnotation.getText();
        var text = this.initialText;
        this.popupCallback(text);
    }
};

CLOUD.Extensions.AnnotationPopupTextArea.prototype.inactive = function () {

    if (this.textAnnotation) {

        this.textAnnotation = null;
    }

    // this._resetTextAreaStyle();
};

CLOUD.Extensions.AnnotationPopupTextArea.prototype.accept = function (text) {

    var textAreaStyle = this.textAreaStyle;
    var left = parseFloat(textAreaStyle.left);
    var top = parseFloat(textAreaStyle.top);
    var width = parseFloat(textAreaStyle.width);
    var height = parseFloat(textAreaStyle.height);

    var textLines = this._calcTextLines(text);
    var position = {
        x: left + width * 0.5,
        y: top + height * 0.5
    };
    var data = {
        annotation: this.textAnnotation,
        position: position,
        width: width,
        height: height,
        text: text,
        lines: textLines
    };

    this.editor.handleTextChange(data);
    this.inactive();
    this._resetTextAreaStyle();
};

CLOUD.Extensions.AnnotationPopupTextArea.prototype.unaccept = function () {

    var text = this.initialText;
    this.accept(text);
};

CLOUD.Extensions.AnnotationPopupTextArea.prototype.getTextValuesByAnnotation = function (annotation) {

    this.active(annotation, false);

    var textValues = this._getTextValues();

    this.inactive();

    return textValues;
};

CLOUD.Extensions.AnnotationFrame = function (editor, container) {

    this.editor = editor;
    this.container = container;
    this.selection = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        rotation: 0,
        element: null,
        active: false,
        dragging: false,
        resizing: false,
        handle: {}
    };

    this.annotation = null;

    this.onResizeDownBinded = this.onResizeDown.bind(this);
    this.onDoubleClickBinded = this.onDoubleClick.bind(this);
    this.onRepositionDownBinded = this.onRepositionDown.bind(this);
    this.onRotationDownBinded = this.onRotationDown.bind(this);

    this.createFramePanel();
    this.addDomEventListeners();
};

CLOUD.Extensions.AnnotationFrame.prototype.addDomEventListeners = function () {

    this.framePanel.addEventListener('mousedown', this.onResizeDownBinded);
    this.framePanel.addEventListener('dblclick', this.onDoubleClickBinded);
    this.selection.element.addEventListener('mousedown', this.onRepositionDownBinded);
    this.selection.element.addEventListener('mousedown', this.onRotationDownBinded);
};

CLOUD.Extensions.AnnotationFrame.prototype.removeDomEventListeners = function () {

    this.framePanel.removeEventListener('mousedown', this.onResizeDownBinded);
    this.framePanel.removeEventListener('dblclick', this.onDoubleClickBinded);
    this.selection.element.removeEventListener('mousedown', this.onRepositionDownBinded);
    this.selection.element.removeEventListener('mousedown', this.onRotationDownBinded);
};

CLOUD.Extensions.AnnotationFrame.prototype.onMouseMove = function (event) {};

CLOUD.Extensions.AnnotationFrame.prototype.onMouseUp = function (event) {};

CLOUD.Extensions.AnnotationFrame.prototype.onRepositionDown = function (event) {

    if (!this.annotation) return;

    if (this.isDragPoint(event.target) || this.isRotatePoint(event.target)) return;

    this.selection.dragging = true;
    this.originMouse = this.editor.getPointOnDomContainer(event.clientX, event.clientY);
    this.originPosition = this.annotation.getClientPosition();

    this.onMouseMove = this.onRepositionMove.bind(this);
    this.onMouseUp = this.onRepositionUp.bind(this);

    this.editor.dragAnnotationFrameBegin();
};

CLOUD.Extensions.AnnotationFrame.prototype.onRepositionMove = function (event) {

    if (!this.annotation) return;

    if (!this.selection.dragging) return;

    var mouse = this.editor.getPointOnDomContainer(event.clientX, event.clientY);

    var movement = {
        x: mouse.x - this.originMouse.x,
        y: mouse.y - this.originMouse.y
    };

    var x = this.originPosition.x + movement.x;
    var y = this.originPosition.y + movement.y;

    this.updatePosition(x, y, this.selection.rotation);
    var position = this.editor.getAnnotationWorldPosition({ x: x, y: y });
    this.annotation.resetPosition(position);
};

CLOUD.Extensions.AnnotationFrame.prototype.onRepositionUp = function () {

    this.onMouseMove = function () {};

    this.onMouseUp = function () {};

    if (!this.selection.dragging) {
        return;
    }

    this.selection.dragging = false;
    this.editor.dragAnnotationFrameEnd();
};

CLOUD.Extensions.AnnotationFrame.prototype.onResizeDown = function (event) {

    if (!this.annotation) return;

    var target = event.target;

    if (this.isDragPoint(target)) {

        this.selection.resizing = true;
        this.selection.handle.resizingPanel = target;

        var direction = this.selection.handle.resizingPanel.getAttribute('data-drag-point');
        this.container.style.cursor = direction + '-resize';

        var mouse = this.editor.getPointOnDomContainer(event.clientX, event.clientY);
        var position = this.annotation.getClientPosition();
        var size = this.annotation.getClientSize();

        this.origin = {
            x: position.x,
            y: position.y,
            width: size.width,
            height: size.height,
            mouseX: mouse.x,
            mouseY: mouse.y
        };

        this.onMouseMove = this.onResizeMove.bind(this);
        this.onMouseUp = this.onResizeUp.bind(this);

        this.editor.dragAnnotationFrameBegin();
    }
};

CLOUD.Extensions.AnnotationFrame.prototype.onResizeMove = function (event) {

    if (!this.annotation) return;

    if (!this.selection.resizing) return;

    var mouse = this.editor.getPointOnDomContainer(event.clientX, event.clientY);
    var origin = this.origin;

    var movement = {
        x: mouse.x - origin.mouseX,
        y: mouse.y - origin.mouseY
    };

    var vMovement = new THREE.Vector3(movement.x, movement.y, 0);
    var matRotation = new THREE.Matrix4().makeRotationZ(-this.selection.rotation);
    movement = vMovement.applyMatrix4(matRotation);

    var x = origin.x,
        y = origin.y,
        width = origin.width,
        height = origin.height;

    var translationDelta = new THREE.Vector3();
    var direction = this.selection.handle.resizingPanel.getAttribute('data-drag-point');

    var translations = {
        n: function n() {
            height -= movement.y;
            translationDelta.y = movement.y;
        },
        s: function s() {
            height += movement.y;
            translationDelta.y = movement.y;
        },
        w: function w() {
            width -= movement.x;
            translationDelta.x = movement.x;
        },
        e: function e() {
            width += movement.x;
            translationDelta.x = movement.x;
        },
        nw: function nw() {
            this.n();
            this.w();
        },
        ne: function ne() {
            this.n();
            this.e();
        },
        sw: function sw() {
            this.s();
            this.w();
        },
        se: function se() {
            this.s();
            this.e();
        }
    };

    translations[direction]();

    var matRedoRotation = new THREE.Matrix4().makeRotationZ(this.selection.rotation);
    var actualDelta = translationDelta.applyMatrix4(matRedoRotation);
    var clientPosition = { x: x + actualDelta.x * 0.5, y: y + actualDelta.y * 0.5 };
    var clientSize = { width: width, height: height };
    var newPosition = this.editor.getAnnotationWorldPosition(clientPosition);
    var size = this.editor.getAnnotationWorldSize(clientSize, clientPosition);

    this.annotation.resetSize(size, newPosition);
};

CLOUD.Extensions.AnnotationFrame.prototype.onResizeUp = function (event) {

    this.onMouseMove = function () {};

    this.onMouseUp = function () {};

    this.selection.resizing = false;
    this.selection.handle.resizingPanel = null;
    this.container.style.cursor = '';
    this.editor.dragAnnotationFrameEnd();
};

CLOUD.Extensions.AnnotationFrame.prototype.onRotationDown = function (event) {

    if (!this.annotation) return;

    if (!this.isRotatePoint(event.target)) return;

    this.selection.rotating = true;

    this.originPosition = this.editor.getPointOnDomContainer(event.clientX, event.clientY);
    this.originRotation = this.selection.rotation || 0;

    this.onMouseMove = this.onRotationMove.bind(this);
    this.onMouseUp = this.onRotationUp.bind(this);

    this.editor.dragAnnotationFrameBegin();
};

CLOUD.Extensions.AnnotationFrame.prototype.onRotationMove = function (event) {

    if (!this.annotation) return;

    if (!this.selection.rotating) return;

    var mouse = this.editor.getPointOnDomContainer(event.clientX, event.clientY);
    var position = this.annotation.getClientPosition();
    var angle1 = CLOUD.Extensions.Utils.Geometric.getAngleBetweenPoints(position, mouse);
    var angle2 = CLOUD.Extensions.Utils.Geometric.getAngleBetweenPoints(position, this.originPosition);
    var rotation = angle1 - angle2 + this.originRotation;

    this.updatePosition(this.selection.x, this.selection.y, rotation);

    this.annotation.resetRotation(rotation);
};

CLOUD.Extensions.AnnotationFrame.prototype.onRotationUp = function (event) {

    this.onMouseMove = function () {};

    this.onMouseUp = function () {};

    this.selection.rotating = false;
    this.originRotation = null;
    this.originPosition = null;
    this.editor.dragAnnotationFrameEnd();
};

CLOUD.Extensions.AnnotationFrame.prototype.onDoubleClick = function (event) {

    this.selection.dragging = false;

    if (this.annotation) {
        this.editor.onMouseDoubleClick(event, this.annotation);
    }
};

CLOUD.Extensions.AnnotationFrame.prototype.destroy = function () {

    this.removeDomEventListeners();
};

CLOUD.Extensions.AnnotationFrame.prototype.createFramePanel = function () {

    var scope = this;

    var createBoxWrapperPanel = function createBoxWrapperPanel() {

        var panel = document.createElement('div');
        panel.style.position = 'absolute';
        panel.style.top = 0;
        panel.style.bottom = 0;
        panel.style.left = 0;
        panel.style.right = 0;
        panel.style.overflow = 'hidden';
        panel.style.visibility = 'hidden';
        panel.style.pointerEvents = 'none';

        return panel;
    };

    var createRotatePointPanel = function createRotatePointPanel(diameter) {

        var borderWidth = 2;
        var borderRadius = diameter / 2 + borderWidth;

        var panel = document.createElement('div');
        panel.style.position = 'absolute';
        panel.style.backgroundColor = 'aqua';
        panel.style.border = borderWidth + 'px solid rgb(95, 98, 100)';
        panel.style.height = diameter + 'px';
        panel.style.width = diameter + 'px';
        panel.style.borderRadius = borderRadius + 'px';
        panel.style.boxSizing = 'border-box';
        panel.classList.add('select-rotate-point');
        panel.style.top = '-25px';
        panel.style.left = '50%';
        panel.style.transform = 'translate3d(-50%, 0px, 0px)';

        return panel;
    };

    var createDragBoxPanel = function createDragBoxPanel() {

        var borderWidth = 1;
        var borderColor = 'rgb(0, 0, 255)';

        var panel = document.createElement('div');
        panel.style.position = 'absolute';
        panel.style.border = borderWidth + 'px solid ' + borderColor;
        panel.style.zIndex = 1;
        panel.style.cursor = 'move';
        panel.style.boxSizing = 'border-box';
        panel.style.pointerEvents = 'auto';
        panel.classList.add('drag-box');

        return panel;
    };

    var createDragPointPanel = function createDragPointPanel(diameter, position) {

        var borderWidth = 2;
        var placementOffset = -1 * ((diameter + borderWidth) / 2);
        var wrapperPanel;

        var dragPointPanel = document.createElement('div');
        dragPointPanel.style.position = 'absolute';
        dragPointPanel.style.backgroundColor = 'rgba(151, 151, 151, 1)';
        dragPointPanel.style.border = borderWidth + 'px solid rgb(95, 98, 100)';
        dragPointPanel.style.height = diameter + 'px';
        dragPointPanel.style.width = diameter + 'px';
        dragPointPanel.style.borderRadius = diameter / 2 + borderWidth + 'px';
        dragPointPanel.style.boxSizing = 'border-box';
        CLOUD.DomUtil.setCursorStyle(dragPointPanel, position);
        dragPointPanel.className = 'select-drag-point drag-point-' + position;
        dragPointPanel.setAttribute('data-drag-point', position);

        switch (position) {
            case 'n':
                wrapperPanel = document.createElement('div');
                wrapperPanel.style.position = 'absolute';
                wrapperPanel.style.width = '100%';
                wrapperPanel.style.height = diameter + 'px';
                wrapperPanel.style.top = placementOffset + 'px';

                dragPointPanel.style.margin = '0 auto';
                dragPointPanel.style.position = '';
                wrapperPanel.appendChild(dragPointPanel);
                dragPointPanel = wrapperPanel;
                break;
            case 's':
                wrapperPanel = document.createElement('div');
                wrapperPanel.style.position = 'absolute';
                wrapperPanel.style.width = '100%';
                wrapperPanel.style.height = diameter + 'px';
                wrapperPanel.style.bottom = placementOffset + 'px';

                dragPointPanel.style.margin = '0 auto';
                dragPointPanel.style.position = '';
                wrapperPanel.appendChild(dragPointPanel);
                dragPointPanel = wrapperPanel;
                break;
            case 'w':
                dragPointPanel.style.left = placementOffset + 'px';
                dragPointPanel.style.top = '50%';
                dragPointPanel.style.transform = 'translate3d(0, -50%, 0)';
                break;
            case 'e':
                dragPointPanel.style.right = placementOffset + 'px';
                dragPointPanel.style.top = '50%';
                dragPointPanel.style.transform = 'translate3d(0, -50%, 0)';
                break;
            case 'nw':
                dragPointPanel.style.top = placementOffset + 'px';
                dragPointPanel.style.left = placementOffset + 'px';
                break;
            case 'ne':
                dragPointPanel.style.top = placementOffset + 'px';
                dragPointPanel.style.right = placementOffset + 'px';
                break;
            case 'sw':
                dragPointPanel.style.bottom = placementOffset + 'px';
                dragPointPanel.style.left = placementOffset + 'px';
                break;
            case 'se':
                dragPointPanel.style.bottom = placementOffset + 'px';
                dragPointPanel.style.right = placementOffset + 'px';
                break;
        }

        return dragPointPanel;
    };

    var createDragPointPanels = function createDragPointPanels(selector) {

        var diameter = 12;
        var directions = ['n', 's', 'w', 'e', 'nw', 'ne', 'sw', 'se'];

        directions.forEach(function (direction) {

            scope.selection.handle[direction] = createDragPointPanel(diameter, direction);
            selector.appendChild(scope.selection.handle[direction]);
        });
    };

    this.framePanel = createBoxWrapperPanel();
    this.container.appendChild(this.framePanel);

    var dragBoxPanel = createDragBoxPanel();
    createDragPointPanels(dragBoxPanel);

    this.selection.element = dragBoxPanel;
    this.framePanel.appendChild(this.selection.element);

    this.selection.rotationPanel = createRotatePointPanel(12);
    dragBoxPanel.appendChild(this.selection.rotationPanel);

    this.updateState(false);
};

CLOUD.Extensions.AnnotationFrame.prototype.setSelection = function (x, y, width, height, rotation) {

    this.updateDimensions(width, height);
    this.updatePosition(x, y, rotation);
    this.updateState(true);
    this.framePanel.style.visibility = 'visible';
};

CLOUD.Extensions.AnnotationFrame.prototype.setAnnotation = function (annotation) {

    if (!annotation) {

        if (this.annotation) {

            this.annotation = null;
            this.updateState(false);
        }

        return;
    }

    var size = annotation.getClientSize();
    var position = annotation.getClientPosition();
    var rotation = annotation.rotation;

    this.annotation = annotation;

    this.setSelection(position.x - size.width / 2, position.y - size.height / 2, size.width, size.height, rotation);

    this.enableResize();
    this.enableRotation();
};

CLOUD.Extensions.AnnotationFrame.prototype.isActive = function () {
    return this.isDragging() || this.isResizing() || this.isRotating();
};

CLOUD.Extensions.AnnotationFrame.prototype.dragBegin = function (event) {

    this.onRepositionDown(event);
};

CLOUD.Extensions.AnnotationFrame.prototype.isDragging = function () {

    return this.selection.dragging;
};

CLOUD.Extensions.AnnotationFrame.prototype.isResizing = function () {

    return this.selection.resizing;
};

CLOUD.Extensions.AnnotationFrame.prototype.isRotating = function () {

    return this.selection.rotating;
};

CLOUD.Extensions.AnnotationFrame.prototype.enableResize = function () {

    var handle, direction;

    if (this.annotation.disableResizeHeight || this.annotation.disableResizeWidth) {

        for (direction in this.selection.handle) {

            handle = this.selection.handle[direction];
            if (handle) handle.style.display = 'none';
        }

        if (this.annotation.disableResizeHeight) {

            this.selection.handle['w'].style.display = 'block';
            this.selection.handle['e'].style.display = 'block';
        }

        if (this.annotation.disableResizeWidth) {

            this.selection.handle['n'].style.display = 'block';
            this.selection.handle['s'].style.display = 'block';
        }
    } else {

        for (direction in this.selection.handle) {

            handle = this.selection.handle[direction];

            if (handle) {
                handle.style.display = 'block';
            }
        }
    }
};

CLOUD.Extensions.AnnotationFrame.prototype.enableRotation = function () {

    var display = this.annotation.disableRotation ? 'none' : 'block';
    this.selection.rotationPanel.style.display = display;
};

CLOUD.Extensions.AnnotationFrame.prototype.updateDimensions = function (width, height) {

    this.selection.width = width;
    this.selection.height = height;
    this.selection.element.style.width = width + 'px';
    this.selection.element.style.height = height + 'px';
};

CLOUD.Extensions.AnnotationFrame.prototype.updatePosition = function (x, y, rotation) {

    var size = this.annotation.getClientSize();

    this.selection.x = x;
    this.selection.y = y;
    this.selection.rotation = rotation;

    this.selection.element.style.msTransform = CLOUD.DomUtil.toTranslate3d(x, y) + ' rotate(' + rotation + 'rad)';
    this.selection.element.style.msTransformOrigin = size.width / 2 + 'px ' + size.height / 2 + 'px';

    this.selection.element.style.webkitTransform = CLOUD.DomUtil.toTranslate3d(x, y) + ' rotate(' + rotation + 'rad)';
    this.selection.element.style.webkitTransformOrigin = size.width / 2 + 'px ' + size.height / 2 + 'px';

    this.selection.element.style.transform = CLOUD.DomUtil.toTranslate3d(x, y) + ' rotate(' + rotation + 'rad)';
    this.selection.element.style.transformOrigin = size.width / 2 + 'px ' + size.height / 2 + 'px';
};

CLOUD.Extensions.AnnotationFrame.prototype.updateState = function (active) {

    this.selection.active = active;
    this.selection.element.style.display = active ? 'block' : 'none';
};

CLOUD.Extensions.AnnotationFrame.prototype.isDragPoint = function (element) {

    return CLOUD.DomUtil.matchesSelector(element, '.select-drag-point');
};

CLOUD.Extensions.AnnotationFrame.prototype.isRotatePoint = function (element) {

    return CLOUD.DomUtil.matchesSelector(element, '.select-rotate-point');
};

CLOUD.Extensions = CLOUD.Extensions || {};

CLOUD.Extensions.AnnotationEditor = function (domElement, options) {
    "use strict";

    this.domElement = domElement;
    this.annotations = [];
    this.selectedAnnotation = null;
    this.bounds = { x: 0, y: 0, width: 0, height: 0 };
    this.keys = {
        BACKSPACE: 8,
        ALT: 18,
        ESC: 27,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        BOTTOM: 40,
        DELETE: 46,
        ZERO: 48,
        A: 65,
        D: 68,
        E: 69,
        Q: 81,
        S: 83,
        W: 87,
        PLUS: 187,
        SUB: 189
    };
    this.isEditing = false;
    this.originX = 0;
    this.originY = 0;
    this.isCreating = false;
    this.beginEditCallback = null;
    this.endEditCallback = null;
    this.changeEditorModeCallback = null;
    this.annotationType = CLOUD.Extensions.Annotation.shapeTypes.ARROW;
    this.nextAnnotationId = 0;
    this.annotationMinLen = 16;
    this.initialized = false;
    this.epsilon = 0.0001;
    this.annotationStyle = null;
    this.isDblClickCloseCloud = true;
    this.mouseButtons = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

    this.onContextMenuBinded = this.onContextMenu.bind(this);
    this.onMouseDownBinded = this.onMouseDown.bind(this);
    this.onMouseDoubleClickBinded = this.onMouseDoubleClick.bind(this);
    this.onMouseMoveBinded = this.onMouseMove.bind(this);
    this.onMouseUpBinded = this.onMouseUp.bind(this);
    this.onKeyDownBinded = this.onKeyDown.bind(this);
    this.onKeyUpBinded = this.onKeyUp.bind(this);

    this.onTouchStartBinded = this.onTouchStart.bind(this);
    this.onTouchMoveBinded = this.onTouchMove.bind(this);
    this.onTouchEndBinded = this.onTouchEnd.bind(this);

    options = options || {};
    this.popupCallback = options.popupCallback;
    this.annotationTextArea = null;
    this.annotationPopupTextArea = null;
};

CLOUD.Extensions.AnnotationEditor.prototype.addDomEventListeners = function () {

    if (this.svg) {

        this.svg.addEventListener('mousedown', this.onMouseDownBinded, false);
        this.svg.addEventListener('touchstart', this.onTouchStartBinded, false);
        this.svg.addEventListener('dblclick', this.onMouseDoubleClickBinded, false);
        this.svg.addEventListener('contextmenu', this.onContextMenuBinded, false);

        window.addEventListener('mousemove', this.onMouseMoveBinded, false);
        window.addEventListener('mouseup', this.onMouseUpBinded, false);
        window.addEventListener('touchmove', this.onTouchMoveBinded, false);
        window.addEventListener('touchend', this.onTouchEndBinded, false);
        window.addEventListener('keydown', this.onKeyDownBinded, false);
        window.addEventListener('keyup', this.onKeyUpBinded, false);

        this.onFocus();
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.removeDomEventListeners = function () {

    if (this.svg) {

        this.svg.removeEventListener('mousedown', this.onMouseDownBinded, false);
        this.svg.removeEventListener('touchstart', this.onTouchStartBinded, false);
        this.svg.removeEventListener('dblclick', this.onMouseDoubleClickBinded, false);
        this.svg.removeEventListener('contextmenu', this.onContextMenuBinded, false);

        window.removeEventListener('mousemove', this.onMouseMoveBinded, false);
        window.removeEventListener('mouseup', this.onMouseUpBinded, false);
        window.removeEventListener('touchmove', this.onTouchMoveBinded, false);
        window.removeEventListener('touchend', this.onTouchEndBinded, false);
        window.removeEventListener('keydown', this.onKeyDownBinded, false);
        window.removeEventListener('keyup', this.onKeyUpBinded, false);
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.onFocus = function () {

    if (this.svg) {

        this.svg.focus();
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.onContextMenu = function (event) {

    event.preventDefault();
};

CLOUD.Extensions.AnnotationEditor.prototype.onMouseDown = function (event) {

    event.preventDefault();
    event.stopPropagation();

    if (event.button === this.mouseButtons.LEFT) {

        if (this.annotationFrame.isActive()) {

            this.annotationFrame.setAnnotation(this.selectedAnnotation);

            return;
        }

        this.handleEvent(event, "down");

        if (!this.isCreating && event.target === this.svg) {

            this.selectAnnotation(null);
        }
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.onMouseMove = function (event) {

    // mark: 对应注册到window上的事件，如果调用会取消事件的默认动作，导致document上其他元素（例如textarea)的行为出现问题（例如，鼠标移动无法选择文本）
    //event.preventDefault();
    event.stopPropagation();

    if (event.button === this.mouseButtons.LEFT) {

        if (this.annotationFrame.isActive()) {

            this.annotationFrame.onMouseMove(event);
            this.annotationFrame.setAnnotation(this.selectedAnnotation);

            return;
        }

        this.handleEvent(event, "move");
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.onMouseUp = function (event) {

    // mark: 对应注册到window上的事件，如果调用会取消事件的默认动作，导致document上其他元素（例如textarea)的行为出现问题（例如，鼠标移动无法选择文本）
    //event.preventDefault();
    event.stopPropagation();

    // 批注编辑结束
    if (this.annotationFrame.isActive()) {

        this.annotationFrame.onMouseUp(event);

        return;
    }

    if (this.selectedAnnotation && this.isCreating) {

        this.handleEvent(event, "up");
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.onTouchStart = function (event) {

    event.preventDefault();
    event.stopPropagation();

    if (event.touches.length == 1) {

        if (this.annotationFrame.isActive()) {

            this.annotationFrame.setAnnotation(this.selectedAnnotation);

            return;
        }

        this.handleEvent(event, "start");

        if (!this.isCreating && event.target === this.svg) {

            this.selectAnnotation(null);
        }
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.onTouchMove = function (event) {

    // mark: 对应注册到window上的事件，如果调用会取消事件的默认动作，导致document上其他元素（例如textarea)的行为出现问题（例如，鼠标移动无法选择文本）
    //event.preventDefault();
    event.stopPropagation();

    if (event.touches.length == 1) {

        if (this.annotationFrame.isActive()) {

            this.annotationFrame.onTouchMove(event);
            this.annotationFrame.setAnnotation(this.selectedAnnotation);

            return;
        }

        this.handleEvent(event, "touchmove");
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.onTouchEnd = function (event) {

    // mark: 对应注册到window上的事件，如果调用会取消事件的默认动作，导致document上其他元素（例如textarea)的行为出现问题（例如，鼠标移动无法选择文本）
    //event.preventDefault();
    event.stopPropagation();

    // 批注编辑结束
    if (this.annotationFrame.isActive()) {

        this.annotationFrame.onTouchEnd(event);

        return;
    }

    if (this.selectedAnnotation && this.isCreating) {

        this.handleEvent(event, "end");
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.onMouseDoubleClick = function (event, annotation) {

    event.preventDefault();
    event.stopPropagation();

    if (!this.isEditing) {
        return;
    }

    if (this.isDblClickCloseCloud) {
        this.mouseDoubleClickForCloud(event);
    }

    this.mouseDoubleClickForText(event, annotation);
};

CLOUD.Extensions.AnnotationEditor.prototype.onKeyDown = function (event) {};

CLOUD.Extensions.AnnotationEditor.prototype.onKeyUp = function (event) {

    if (!this.isEditing) {
        return;
    }

    switch (event.keyCode) {
        case this.keys.DELETE:
            if (this.selectedAnnotation) {
                this.selectedAnnotation.delete();
                this.selectedAnnotation = null;
                this.deselectAnnotation();
            }
            break;
        case this.keys.ESC:

            // 结束云图绘制
            if (this.annotationType === CLOUD.Extensions.Annotation.shapeTypes.CLOUD) {

                // 结束云图绘制，不封闭云图
                this.selectedAnnotation.finishTrack();
                this.selectedAnnotation.setSeal(false);
                this.createAnnotationEnd();
                this.deselectAnnotation();
            }

            this.forceAnnotationTextComplete();

            break;
        default:
            break;
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.onResize = function () {

    var bounds = this.getDomContainerBounds();

    this.bounds.x = 0;
    this.bounds.y = 0;
    this.bounds.width = bounds.width;
    this.bounds.height = bounds.height;

    this.svg.setAttribute('width', this.bounds.width + '');
    this.svg.setAttribute('height', this.bounds.height + '');

    this.updateAnnotations();
};

CLOUD.Extensions.AnnotationEditor.prototype.handleEvent = function (event, type) {

    var mode = this.annotationType;

    // 对文本批注的处理
    if ((type === "down" || type === "start") && this.forceAnnotationTextComplete()) {
        return;
    }

    switch (mode) {

        case CLOUD.Extensions.Annotation.shapeTypes.RECTANGLE:
            if (type === "down") {
                if (this.startRectangle(event.clientX, event.clientY)) {
                    this.createAnnotationBegin();
                }
            } else if (type === "start") {
                if (this.startRectangle(event.touches[0].clientX, event.touches[0].clientY)) {
                    this.createAnnotationBegin();
                }
            } else if (type === "move") {
                this.moveRectangle(event.clientX, event.clientY);
            } else if (type === "touchmove") {
                this.moveRectangle(event.touches[0].clientX, event.touches[0].clientY);
            } else if (type === "up" || type === "end") {
                this.createAnnotationEnd();
                this.deselectAnnotation();
            }
            break;
        case CLOUD.Extensions.Annotation.shapeTypes.CIRCLE:
            if (type === "down") {
                if (this.startCircle(event.clientX, event.clientY)) {
                    this.createAnnotationBegin();
                }
            } else if (type === "start") {
                if (this.startCircle(event.touches[0].clientX, event.touches[0].clientY)) {
                    this.createAnnotationBegin();
                }
            } else if (type === "move") {
                this.moveCircle(event.clientX, event.clientY);
            } else if (type === "touchmove") {
                this.moveCircle(event.touches[0].clientX, event.touches[0].clientY);
            } else if (type === "up" || type === "end") {
                //this.created()
                this.createAnnotationEnd();
                this.deselectAnnotation();
            }
            break;
        case CLOUD.Extensions.Annotation.shapeTypes.CROSS:
            if (type === "down") {
                if (this.startCross(event.clientX, event.clientY)) {
                    this.createAnnotationBegin();
                }
            } else if (type === "start") {
                if (this.startCross(event.touches[0].clientX, event.touches[0].clientY)) {
                    this.createAnnotationBegin();
                }
            } else if (type === "move") {
                this.moveCross(event.clientX, event.clientY);
            } else if (type === "touchmove") {
                this.moveCross(event.touches[0].clientX, event.touches[0].clientY);
            } else if (type === "up" || type === "end") {
                this.createAnnotationEnd();
                this.deselectAnnotation();
            }
            break;
        case CLOUD.Extensions.Annotation.shapeTypes.CLOUD:
            if (type === "down") {
                if (this.startCloud(event.clientX, event.clientY)) {
                    this.createAnnotationBegin();
                }
            } else if (type === "start") {
                if (this.startCloud(event.touches[0].clientX, event.touches[0].clientY)) {
                    this.createAnnotationBegin();
                }
            } else if (type === "move") {
                this.moveCloud(event.clientX, event.clientY);
            } else if (type === "touchmove") {
                this.moveCloud(event.touches[0].clientX, event.touches[0].clientY);
            } else if (type === "up" || type === "end") {
                this.endCloud(event, type);
            }
            break;
        case CLOUD.Extensions.Annotation.shapeTypes.TEXT:
            if (type === "down") {
                this.startText(event.clientX, event.clientY);
            } else if (type === "start") {
                this.startText(event.touches[0].clientX, event.touches[0].clientY);
            }
            break;
        case CLOUD.Extensions.Annotation.shapeTypes.ARROW:
        default:
            if (type === "down") {
                if (this.startArrow(event.clientX, event.clientY)) {
                    this.createAnnotationBegin();
                }
            } else if (type === "start") {
                if (this.startArrow(event.touches[0].clientX, event.touches[0].clientY)) {
                    this.createAnnotationBegin();
                }
            } else if (type === "move") {
                this.moveArrow(event.clientX, event.clientY);
            } else if (type === "touchmove") {
                this.moveArrow(event.touches[0].clientX, event.touches[0].clientY);
            } else if (type === "up" || type === "end") {
                this.createAnnotationEnd();
                this.deselectAnnotation();
            }
            break;
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.startArrow = function (x, y) {

    if (this.selectedAnnotation) return false;

    var start = this.getPointOnDomContainer(x, y);

    this.originX = start.x;
    this.originY = start.y;

    var width = this.annotationMinLen;
    var tail = { x: this.originX, y: this.originY };
    var head = {
        x: Math.round(tail.x + Math.cos(Math.PI * 0.25) * width),
        y: Math.round(tail.y + Math.sin(-Math.PI * 0.25) * width)
    };

    var constrain = function constrain(tail, head, width, bounds) {

        if (CLOUD.Extensions.Utils.Geometric.isInsideBounds(head.x, head.y, bounds)) {
            return;
        }

        head.y = Math.round(tail.y + Math.sin(Math.PI * 0.25) * width);

        if (CLOUD.Extensions.Utils.Geometric.isInsideBounds(head.x, head.y, bounds)) {
            return;
        }

        head.x = Math.round(tail.y + Math.cos(-Math.PI * 0.25) * width);

        if (CLOUD.Extensions.Utils.Geometric.isInsideBounds(head.x, head.y, bounds)) {
            return;
        }

        head.y = Math.round(tail.y + Math.sin(-Math.PI * 0.25) * width);
    };

    constrain(tail, head, width, this.getBounds());

    head = this.getAnnotationWorldPosition(head);
    tail = this.getAnnotationWorldPosition(tail);

    var arrowId = this.generateAnnotationId();
    var arrow = new CLOUD.Extensions.AnnotationArrow(this, arrowId);
    arrow.setByTailHead(tail, head);
    this.addAnnotation(arrow);
    arrow.created();

    this.selectedAnnotation = arrow;

    return true;
};

CLOUD.Extensions.AnnotationEditor.prototype.moveArrow = function (x, y) {

    if (!this.selectedAnnotation || !this.isCreating) {
        return;
    }

    var arrow = this.selectedAnnotation;
    var end = this.getPointOnDomContainer(x, y);
    var bounds = this.getBounds();

    var startX = this.originX;
    var startY = this.originY;

    var deltaX = end.x - startX;

    if (Math.abs(deltaX) < this.annotationMinLen) {

        if (deltaX > 0) {
            end.x = startX + this.annotationMinLen;
        } else {
            end.x = startX - this.annotationMinLen;
        }
    }

    var endX = Math.min(Math.max(bounds.x, end.x), bounds.x + bounds.width);
    var endY = Math.min(Math.max(bounds.y, end.y), bounds.y + bounds.height);

    if (endX === startX && endY === startY) {
        endX++;
        endY++;
    }

    var tail = { x: startX, y: startY };
    var head = { x: endX, y: endY };

    tail = this.getAnnotationWorldPosition(tail);
    head = this.getAnnotationWorldPosition(head);

    if (Math.abs(arrow.head.x - head.x) >= this.epsilon || Math.abs(arrow.head.y - head.y) >= this.epsilon || Math.abs(arrow.tail.x - tail.x) >= this.epsilon || Math.abs(arrow.tail.y - tail.y) >= this.epsilon) {

        arrow.setByTailHead(tail, head);
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.startRectangle = function (x, y) {

    if (this.selectedAnnotation) return false;

    var start = this.getPointOnDomContainer(x, y);
    var minLen = this.annotationMinLen;

    this.originX = start.x;
    this.originY = start.y;

    var clientPosition = { x: start.x, y: start.y };
    var clientSize = { width: minLen, height: minLen };
    var position = this.getAnnotationWorldPosition(clientPosition);
    var size = this.getAnnotationWorldSize(clientSize, clientPosition);

    var id = this.generateAnnotationId();
    var rectangle = new CLOUD.Extensions.AnnotationRectangle(this, id);
    rectangle.set(position, size, 0);
    this.addAnnotation(rectangle);
    rectangle.created();

    this.selectedAnnotation = rectangle;

    return true;
};

CLOUD.Extensions.AnnotationEditor.prototype.moveRectangle = function (x, y) {

    if (!this.selectedAnnotation || !this.isCreating) {
        return;
    }

    var rectangle = this.selectedAnnotation;
    var end = this.getPointOnDomContainer(x, y);
    var bounds = this.getBounds();

    var startX = this.originX;
    var startY = this.originY;
    var endX = Math.min(Math.max(bounds.x, end.x), bounds.x + bounds.width);
    var endY = Math.min(Math.max(bounds.y, end.y), bounds.y + bounds.height);

    if (endX === startX && endY === startY) {
        endX++;
        endY++;
    }

    var clientPosition = { x: (startX + endX) / 2, y: (startY + endY) / 2 };
    var clientSize = { width: Math.abs(endX - startX), height: Math.abs(endY - startY) };
    var position = this.getAnnotationWorldPosition(clientPosition);
    var size = this.getAnnotationWorldSize(clientSize, clientPosition);

    if (Math.abs(rectangle.position.x - position.x) > this.epsilon || Math.abs(rectangle.size.y - size.y) > this.epsilon || Math.abs(rectangle.position.y - position.y) > this.epsilon || Math.abs(rectangle.size.y - size.y) > this.epsilon) {

        rectangle.set(position, size);
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.startCircle = function (x, y) {

    if (this.selectedAnnotation) return false;

    var start = this.getPointOnDomContainer(x, y);

    this.originX = start.x;
    this.originY = start.y;

    var minLen = this.annotationMinLen;
    var clientPosition = { x: start.x, y: start.y };
    var clientSize = { width: minLen, height: minLen };
    var position = this.getAnnotationWorldPosition(clientPosition);
    var size = this.getAnnotationWorldSize(clientSize, clientPosition);

    var id = this.generateAnnotationId();
    var circle = new CLOUD.Extensions.AnnotationCircle(this, id);
    circle.set(position, size, 0);
    this.addAnnotation(circle);
    circle.created();

    this.selectedAnnotation = circle;

    return true;
};

CLOUD.Extensions.AnnotationEditor.prototype.moveCircle = function (x, y) {

    if (!this.selectedAnnotation || !this.isCreating) {
        return;
    }

    var circle = this.selectedAnnotation;
    var end = this.getPointOnDomContainer(x, y);
    var bounds = this.getBounds();
    var startX = this.originX;
    var startY = this.originY;
    var endX = Math.min(Math.max(bounds.x, end.x), bounds.x + bounds.width);
    var endY = Math.min(Math.max(bounds.y, end.y), bounds.y + bounds.height);

    if (endX === startX && endY === startY) {
        endX++;
        endY++;
    }

    var clientPosition = { x: (startX + endX) / 2, y: (startY + endY) / 2 };
    var clientSize = { width: Math.abs(endX - startX), height: Math.abs(endY - startY) };
    var position = this.getAnnotationWorldPosition(clientPosition);
    var size = this.getAnnotationWorldSize(clientSize, clientPosition);

    if (Math.abs(circle.position.x - position.x) > this.epsilon || Math.abs(circle.size.y - size.y) > this.epsilon || Math.abs(circle.position.y - position.y) > this.epsilon || Math.abs(circle.size.y - size.y) > this.epsilon) {

        circle.set(position, size);
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.startCross = function (x, y) {

    if (this.selectedAnnotation) return false;

    var start = this.getPointOnDomContainer(x, y);

    this.originX = start.x;
    this.originY = start.y;

    var minLen = this.annotationMinLen;
    var clientPosition = { x: start.x, y: start.y };
    var clientSize = { width: minLen, height: minLen };
    var position = this.getAnnotationWorldPosition(clientPosition);
    var size = this.getAnnotationWorldSize(clientSize, clientPosition);

    var id = this.generateAnnotationId();
    var cross = new CLOUD.Extensions.AnnotationCross(this, id);
    cross.set(position, size, 0);
    this.addAnnotation(cross);
    cross.created();

    this.selectedAnnotation = cross;

    return true;
};

CLOUD.Extensions.AnnotationEditor.prototype.moveCross = function (x, y) {

    if (!this.selectedAnnotation || !this.isCreating) {
        return;
    }

    var cross = this.selectedAnnotation;
    var end = this.getPointOnDomContainer(x, y);
    var bounds = this.getBounds();

    var startX = this.originX;
    var startY = this.originY;
    var endX = Math.min(Math.max(bounds.x, end.x), bounds.x + bounds.width);
    var endY = Math.min(Math.max(bounds.y, end.y), bounds.y + bounds.height);

    if (endX === startX && endY === startY) {
        endX++;
        endY++;
    }

    var clientPosition = { x: (startX + endX) / 2, y: (startY + endY) / 2 };
    var clientSize = { width: Math.abs(endX - startX), height: Math.abs(endY - startY) };
    var position = this.getAnnotationWorldPosition(clientPosition);
    var size = this.getAnnotationWorldSize(clientSize, clientPosition);

    if (Math.abs(cross.position.x - position.x) > this.epsilon || Math.abs(cross.size.y - size.y) > this.epsilon || Math.abs(cross.position.y - position.y) > this.epsilon || Math.abs(cross.size.y - size.y) > this.epsilon) {

        cross.set(position, size);
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.startCloud = function (x, y) {

    if (this.selectedAnnotation) return false;

    var start = this.getPointOnDomContainer(x, y);
    this.originX = start.x;
    this.originY = start.y;

    var position = this.getAnnotationWorldPosition({ x: start.x, y: start.y });
    this.cloudPoints = [position];

    var id = this.generateAnnotationId();
    var cloud = new CLOUD.Extensions.AnnotationCloud(this, id);
    cloud.setByPositions(this.cloudPoints);
    cloud.created();
    cloud.enableTrack();

    this.addAnnotation(cloud);
    this.selectedAnnotation = cloud;

    return true;
};

CLOUD.Extensions.AnnotationEditor.prototype.moveCloud = function (x, y) {

    if (!this.selectedAnnotation || !this.isCreating) {
        return;
    }

    var cloud = this.selectedAnnotation;

    if (cloud.getTrackState()) {

        var mouse = this.getPointOnDomContainer(x, y);
        var position = this.getAnnotationWorldPosition(mouse);
        cloud.startTrack();
        cloud.setTrackingPoint(position);
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.endCloud = function (event, type) {

    if (event.button === this.mouseButtons.LEFT || event.touches && event.touches.length === 0) {

        // 采用计时器来判断是否单击和双击
        var handleEnd = function handleEnd() {

            cloud.finishTrack();
            cloud.setByPositions(positions);
            cloud.enableTrack();
        };

        if (!this.selectedAnnotation || !this.isCreating) {
            return;
        }

        var end = type === "up" ? this.getPointOnDomContainer(event.clientX, event.clientY) : this.getPointOnDomContainer(event.touches[0].clientX, event.touches[0].clientY);
        var origin = { x: this.originX, y: this.originY };
        var threshold = 2; // 相差2个像素

        // 判断是否同一个点, 同一个点不加入集合
        if (CLOUD.Extensions.Utils.Geometric.isEqualBetweenPoints(origin, end, threshold)) return;

        var point = this.getAnnotationWorldPosition({ x: end.x, y: end.y });
        this.cloudPoints.push(point);

        var cloud = this.selectedAnnotation;

        // 先禁止跟踪，在真正响应事件时启用
        cloud.disableTrack();

        var positions = this.cloudPoints;

        if (this.isDblClickCloseCloud) {

            if (this.timerId) {
                clearTimeout(this.timerId);
            }

            // 延迟300ms以判断是否单击
            this.timerId = setTimeout(handleEnd, 300);
        } else {

            handleEnd();
        }
    } else if (event.button === this.mouseButtons.RIGHT) {

        this.mouseDoubleClickForCloud(event);
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.mouseDoubleClickForCloud = function (event) {

    if (this.isCreating && this.selectedAnnotation) {

        if (this.selectedAnnotation.shapeType === CLOUD.Extensions.Annotation.shapeTypes.CLOUD) {

            if (this.isDblClickCloseCloud) {

                // 清除定时器
                if (this.timerId) {
                    clearTimeout(this.timerId);
                }
            }

            var position = this.getPointOnDomContainer(event.clientX, event.clientY);
            var point = this.getAnnotationWorldPosition(position);

            this.cloudPoints.push(point);
            this.selectedAnnotation.finishTrack();
            // 结束云图绘制，并封闭云图
            this.selectedAnnotation.setByPositions(this.cloudPoints, true);
            this.createAnnotationEnd();
            this.deselectAnnotation();
        }
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.startText = function (x, y) {

    //if (this.forceAnnotationTextComplete() ) {
    //    return;
    //}

    if (this.selectedAnnotation) {
        return;
    }

    var start = this.getPointOnDomContainer(x, y);
    var clientFontSize = 16;
    var originWidth = clientFontSize * 20;
    var originHeight = clientFontSize * 4;

    var clientPosition = { x: start.x + 0.5 * originWidth, y: start.y + 0.5 * originHeight };
    var clientSize = { width: originWidth, height: originHeight };
    var position = this.getAnnotationWorldPosition(clientPosition);
    var size = this.getAnnotationWorldSize(clientSize, clientPosition);

    var id = this.generateAnnotationId();
    //var text = new CLOUD.Extensions.AnnotationText(this, id);
    var text = this.currentAnnotationText = new CLOUD.Extensions.AnnotationText(this, id);
    text.set(position, size, 0, '');
    this.addAnnotation(text);
    text.created();
    text.forceRedraw();

    this.selectedAnnotation = text;

    var textArea = this.getTextArea();
    textArea.active(this.selectedAnnotation, true);

    return true;
};

CLOUD.Extensions.AnnotationEditor.prototype.mouseDoubleClickForText = function (event, annotation) {

    if (annotation) {

        if (this.selectedAnnotation && this.selectedAnnotation.shapeType === CLOUD.Extensions.Annotation.shapeTypes.TEXT) {

            this.currentAnnotationText = annotation;
            this.selectedAnnotation.hide();
            this.deselectAnnotation();

            var textArea = this.getTextArea();
            textArea.active(annotation, true);
        }
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.init = function (callbacks) {

    if (callbacks) {

        this.beginEditCallback = callbacks.beginEditCallback;
        this.endEditCallback = callbacks.endEditCallback;
        this.changeEditorModeCallback = callbacks.changeEditorModeCallback;
    }

    if (!this.svg) {

        var rect = this.getDomContainerBounds();
        this.bounds.width = rect.width;
        this.bounds.height = rect.height;

        this.svg = CLOUD.Extensions.Utils.Shape2D.createSvgElement('svg');
        this.svg.style.position = "absolute";
        this.svg.style.display = "block";
        this.svg.style.left = "0";
        this.svg.style.top = "0";
        this.svg.setAttribute('width', rect.width + '');
        this.svg.setAttribute('height', rect.height + '');

        this.domElement.appendChild(this.svg);

        this.enableSVGPaint(false);

        this.annotationFrame = new CLOUD.Extensions.AnnotationFrame(this, this.domElement);

        if (this.popupCallback) {
            this.annotationPopupTextArea = new CLOUD.Extensions.AnnotationPopupTextArea(this, this.domElement, this.popupCallback);
        } else {
            this.annotationTextArea = new CLOUD.Extensions.AnnotationTextArea(this, this.domElement);
        }
    }

    this.initialized = true;
};

CLOUD.Extensions.AnnotationEditor.prototype.uninit = function () {

    this.initialized = false;

    if (!this.svg) return;

    // 如果仍然处在编辑中，强行结束
    if (this.isEditing) {
        this.editEnd();
    }

    // 卸载数据
    this.unloadAnnotations();

    if (this.svg.parentNode) {
        this.svg.parentNode.removeChild(this.svg);
    }

    this.svgGroup = null;
    this.svg = null;

    this.beginEditCallback = null;
    this.endEditCallback = null;
    this.changeEditorModeCallback = null;

    //this.destroy();
};

CLOUD.Extensions.AnnotationEditor.prototype.isInitialized = function () {

    return this.initialized;
};

CLOUD.Extensions.AnnotationEditor.prototype.destroy = function () {

    this.forceAnnotationTextComplete();
    this.deselectAnnotation();

    if (this.annotationFrame) {

        this.annotationFrame.destroy();
        this.annotationFrame = null;
    }

    if (this.currentAnnotationText) {
        this.currentAnnotationText = null;
    }

    if (this.popupCallback) {
        this.popupCallback = null;
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.generateAnnotationId = function () {

    ++this.nextAnnotationId;

    return this.nextAnnotationId.toString(10);

    //return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    //    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
    //    return v.toString(16);
    //});
};

CLOUD.Extensions.AnnotationEditor.prototype.onExistEditor = function () {

    this.uninit();
};

CLOUD.Extensions.AnnotationEditor.prototype.editBegin = function () {

    if (this.isEditing) {
        return true;
    }

    if (!this.svgGroup) {
        this.svgGroup = CLOUD.Extensions.Utils.Shape2D.createSvgElement('g');
    }

    if (!this.svgGroup.parentNode) {
        this.svg.insertBefore(this.svgGroup, this.svg.firstChild);
    }

    this.handleCallbacks("beginEdit");

    // 注册事件
    this.addDomEventListeners();
    // 允许在SVG上绘图
    this.enableSVGPaint(true);
    // 清除数据
    this.clear();

    this.isEditing = true;
};

CLOUD.Extensions.AnnotationEditor.prototype.editEnd = function () {

    this.isEditing = false;

    this.forceAnnotationTextComplete();

    if (this.svgGroup && this.svgGroup.parentNode) {
        //this.svg.removeChild(this.svgGroup);
        this.svgGroup.parentNode.removeChild(this.svgGroup);
    }

    this.removeDomEventListeners();

    this.handleCallbacks("endEdit");

    // 不允许穿透
    this.enableSVGPaint(false);
    this.deselectAnnotation();
};

CLOUD.Extensions.AnnotationEditor.prototype.createAnnotationBegin = function () {

    if (!this.isCreating) {

        this.isCreating = true;
        this.disableAnnotationInteractions(true);
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.createAnnotationEnd = function () {

    if (this.isCreating) {

        this.isCreating = false;
        this.disableAnnotationInteractions(false);
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.dragAnnotationFrameBegin = function () {

    this.disableAnnotationInteractions(true);
};

CLOUD.Extensions.AnnotationEditor.prototype.dragAnnotationFrameEnd = function () {

    this.disableAnnotationInteractions(false);
};

CLOUD.Extensions.AnnotationEditor.prototype.clear = function () {

    var annotations = this.annotations;

    while (annotations.length) {
        var annotation = annotations[0];
        this.removeAnnotation(annotation);
        annotation.destroy();
    }

    var group = this.svgGroup;
    if (group && group.childNodes.length > 0) {
        while (group.childNodes.length) {
            group.removeChild(group.childNodes[0]);
        }
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.setAnnotationType = function (type) {

    this.forceAnnotationTextComplete();

    this.annotationType = type;

    // 强行完成
    this.createAnnotationEnd();
    this.deselectAnnotation();

    this.onFocus();
};

CLOUD.Extensions.AnnotationEditor.prototype.addAnnotation = function (annotation) {

    annotation.setParent(this.svgGroup);

    this.annotations.push(annotation);
};

CLOUD.Extensions.AnnotationEditor.prototype.deleteAnnotation = function (annotation) {

    if (annotation) {
        this.removeAnnotation(annotation);
        annotation.destroy();
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.removeAnnotation = function (annotation) {

    var idx = this.annotations.indexOf(annotation);

    if (idx !== -1) {
        this.annotations.splice(idx, 1);
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.setAnnotationSelection = function (annotation) {

    if (this.selectedAnnotation !== annotation) {

        this.deselectAnnotation();
    }

    this.selectedAnnotation = annotation;

    // 放在最前面

    if (!this.isCreating) {
        this.annotationFrame.setAnnotation(annotation);
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.selectAnnotation = function (annotation) {

    if (annotation) {

        var shapeType = annotation.shapeType;

        if (this.annotationType === shapeType) {

            this.setAnnotationSelection(annotation);
        } else {

            this.setAnnotationSelection(null);
            //this.setAnnotationType(shapeType);
            this.setAnnotationSelection(annotation);
        }

        if (shapeType === CLOUD.Extensions.Annotation.shapeTypes.TEXT) {
            this.currentAnnotationText = annotation;
        } else {
            this.currentAnnotationText = null;
        }
    } else {
        this.setAnnotationSelection(null);
        this.currentAnnotationText = null;
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.deselectAnnotation = function () {

    if (this.selectedAnnotation) {
        this.selectedAnnotation.deselect();
        this.selectedAnnotation = null;
    }

    this.annotationFrame.setAnnotation(null);
};

CLOUD.Extensions.AnnotationEditor.prototype.worldToClient = function (wPoint) {

    // var rect = this.getDomContainerBounds();
    var result = new THREE.Vector3(wPoint.x, wPoint.y, wPoint.z);

    // // 变换到相机空间
    // result.applyMatrix4(camera.matrixWorld);
    // result.sub(camera.position);
    // result.project(camera);
    //
    // // 变换到屏幕空间
    // result.x = Math.floor(0.5 * (result.x + 1) * rect.width + 0.5);
    // result.y = Math.floor(-0.5 * (result.y - 1) * rect.height + 0.5);
    // result.z = 0;

    return result;
};

CLOUD.Extensions.AnnotationEditor.prototype.clientToWorld = function (cPoint) {

    // var rect = this.getDomContainerBounds();
    var result = new THREE.Vector3(cPoint.x, cPoint.y, 0);
    //
    // result.x = cPoint.x / rect.width * 2 - 1;
    // result.y = -cPoint.y / rect.height * 2 + 1;
    // result.z = 0;
    //
    // result.unproject(camera);
    // result.add(camera.position).applyMatrix4(camera.matrixWorldInverse);
    // //result.z = 0;

    return result;
};

CLOUD.Extensions.AnnotationEditor.prototype.getAnnotationWorldPosition = function (cPos) {

    return this.clientToWorld(cPos);
};

CLOUD.Extensions.AnnotationEditor.prototype.getAnnotationClientPosition = function (wPos) {

    return this.worldToClient(wPos);
};

CLOUD.Extensions.AnnotationEditor.prototype.getAnnotationWorldSize = function (cSize, cPos) {

    var lt = this.clientToWorld({ x: cPos.x - 0.5 * cSize.width, y: cPos.y - 0.5 * cSize.height });
    var rb = this.clientToWorld({ x: cPos.x + 0.5 * cSize.width, y: cPos.y + 0.5 * cSize.height });

    return { width: Math.abs(rb.x - lt.x), height: Math.abs(rb.y - lt.y) };
};

CLOUD.Extensions.AnnotationEditor.prototype.getAnnotationClientSize = function (wSize, wPos) {

    var lt = this.worldToClient({ x: wPos.x - 0.5 * wSize.width, y: wPos.y - 0.5 * wSize.height, z: wPos.z });
    var rb = this.worldToClient({ x: wPos.x + 0.5 * wSize.width, y: wPos.y + 0.5 * wSize.height, z: wPos.z });

    return { width: Math.abs(rb.x - lt.x), height: Math.abs(rb.y - lt.y) };
};

CLOUD.Extensions.AnnotationEditor.prototype.getBounds = function () {
    return this.bounds;
};

CLOUD.Extensions.AnnotationEditor.prototype.getPointOnDomContainer = function (clientX, clientY) {
    var rect = this.getDomContainerBounds();
    return new THREE.Vector2(clientX - rect.left, clientY - rect.top);
};

CLOUD.Extensions.AnnotationEditor.prototype.getDomContainerBounds = function () {
    return CLOUD.DomUtil.getContainerOffsetToClient(this.domElement);
};

CLOUD.Extensions.AnnotationEditor.prototype.getViewBox = function (clientWidth, clientHeight) {
    var lt = this.clientToWorld({ x: 0, y: 0 });
    var rb = this.clientToWorld({ x: clientWidth, y: clientHeight });
    var left = Math.min(lt.x, rb.x);
    var top = Math.min(lt.y, rb.y);
    var right = Math.max(lt.x, rb.x);
    var bottom = Math.max(lt.y, rb.y);

    return [left, top, right - left, bottom - top].join(' ');
};

CLOUD.Extensions.AnnotationEditor.prototype.handleTextChange = function (data) {

    var textAnnotation = data.annotation;

    if (data.text === '') {
        this.selectAnnotation(null);
        data.annotation.delete();
        return;
    }

    var clientPosition = { x: data.position.x, y: data.position.y };
    var clientSize = { width: data.width, height: data.height };
    var position = this.getAnnotationWorldPosition(clientPosition);
    var size = this.getAnnotationWorldSize(clientSize, clientPosition);

    textAnnotation.resetSize(size, position);
    textAnnotation.setText(data.text);

    this.createAnnotationEnd();
    this.deselectAnnotation();
};

CLOUD.Extensions.AnnotationEditor.prototype.disableAnnotationInteractions = function (disable) {

    this.annotations.forEach(function (annotation) {
        annotation.disableInteractions(disable);
    });
};

CLOUD.Extensions.AnnotationEditor.prototype.handleCallbacks = function (name) {

    switch (name) {

        case "beginEdit":
            if (this.beginEditCallback) {
                this.beginEditCallback(this.domElement);
            }
            break;
        case "endEdit":
            if (this.endEditCallback) {
                this.endEditCallback(this.domElement);
            }
            break;
        case "changeEditor":
            if (this.changeEditorModeCallback) {

                this.changeEditorModeCallback(this.domElement);
            }
            break;
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.renderToCanvas = function (ctx) {

    this.annotations.forEach(function (annotation) {
        ctx.save();
        annotation.renderToCanvas(ctx);
        ctx.restore();
    });
};

// 是否允许在SVG上绘图
CLOUD.Extensions.AnnotationEditor.prototype.enableSVGPaint = function (enable) {

    if (enable) {
        this.svg && this.svg.setAttribute("pointer-events", "painted");
    } else {
        this.svg && this.svg.setAttribute("pointer-events", "none");
    }
};

// 强制结束文本批注的编辑
CLOUD.Extensions.AnnotationEditor.prototype.forceAnnotationTextComplete = function () {

    //if (this.annotationType === CLOUD.Extensions.Annotation.shapeTypes.TEXT) {

    if (this.annotationTextArea && this.annotationTextArea.isActive()) {

        this.annotationTextArea.accept();

        if (this.currentAnnotationText) {
            this.currentAnnotationText = null;
        }

        return true;
    }
    //}

    return false;
};

// 强制结束文本批注的编辑
CLOUD.Extensions.AnnotationEditor.prototype.resetCurrentAnnotationText = function () {

    if (this.currentAnnotationText) {
        this.currentAnnotationText = null;
    }
};

// ---------------------------- 外部 API BEGIN ---------------------------- //

// 屏幕快照
CLOUD.Extensions.AnnotationEditor.prototype.getScreenSnapshot = function (snapshot, callback) {

    var canvas = document.createElement("canvas");

    var bounds = this.getDomContainerBounds();
    canvas.width = bounds.width;
    canvas.height = bounds.height;

    var ctx = canvas.getContext('2d');
    var startColor = this.gradientStartColor;
    var stopColor = this.gradientStopColor;

    var scope = this;

    // 绘制背景
    if (startColor) {

        if (stopColor) {
            var gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, startColor);
            gradient.addColorStop(1, stopColor);
            ctx.fillStyle = gradient;
        } else {
            ctx.fillStyle = startColor;
        }

        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // fixed bug: 在chrome 版本 57.0.2987.133 (64-bit)上截不到图，估计是图片异步加载的问题, 采用回调函数处理。

    if (callback && snapshot) {

        var preSnapshot = new Image();
        preSnapshot.onload = function () {

            ctx.drawImage(preSnapshot, 0, 0);
            scope.renderToCanvas(ctx); // 绘制批注

            var data = canvas.toDataURL("image/png");
            canvas = ctx = null;
            callback(data);
        };
        preSnapshot.src = snapshot;

        return null;
    }

    // 先绘制之前的图像
    if (snapshot) {
        var preSnapshot = new Image();
        preSnapshot.src = snapshot;
        ctx.drawImage(preSnapshot, 0, 0);
    }

    this.renderToCanvas(ctx); // 绘制批注

    var data = canvas.toDataURL("image/png");
    canvas = ctx = null;

    return data;
};

// 设置导出背景色
CLOUD.Extensions.AnnotationEditor.prototype.setBackgroundColor = function (startColor, stopColor) {

    this.gradientStartColor = startColor;
    this.gradientStopColor = stopColor;
};

// 获得批注列表
CLOUD.Extensions.AnnotationEditor.prototype.getAnnotationInfoList = function () {

    // 强行完成
    this.forceAnnotationTextComplete();
    this.createAnnotationEnd();
    this.deselectAnnotation();

    var annotationInfoList = [];

    for (var i = 0, len = this.annotations.length; i < len; i++) {
        var annotation = this.annotations[i];

        var text = "";
        if (annotation.shapeType === CLOUD.Extensions.Annotation.shapeTypes.TEXT) {
            text = encodeURIComponent(annotation.currText); // 编码中文
            //text = annotation.currText; // 编码中文
        }

        var shapePoints = "";
        var originSize = null;
        if (annotation.shapeType === CLOUD.Extensions.Annotation.shapeTypes.CLOUD) {
            shapePoints = annotation.getShapePoints();
            originSize = annotation.originSize;
        }

        var info = {
            id: annotation.id,
            shapeType: annotation.shapeType,
            position: annotation.position,
            size: annotation.size,
            rotation: annotation.rotation,
            shapePoints: shapePoints,
            originSize: originSize,
            style: annotation.style, //
            text: text
        };

        annotationInfoList.push(info);
    }

    return annotationInfoList;
};

// 加载批注
CLOUD.Extensions.AnnotationEditor.prototype.loadAnnotations = function (annotationInfoList) {

    if (!this.svgGroup) {
        this.svgGroup = CLOUD.Extensions.Utils.Shape2D.createSvgElement('g');
    }

    // 清除数据
    this.clear();

    if (!this.svgGroup.parentNode) {
        this.svg.insertBefore(this.svgGroup, this.svg.firstChild);
    }

    for (var i = 0, len = annotationInfoList.length; i < len; i++) {

        var info = annotationInfoList[i];
        var id = info.id;
        var shapeType = info.shapeType;
        var position = info.position;
        var size = info.size;
        var rotation = info.rotation;
        var shapePointsStr = info.shapePoints;
        var originSize = info.originSize;
        //var text = info.text; // 解码中文
        var text = decodeURIComponent(info.text); // 解码中文
        var style = info.style ? info.style : this.annotationStyle;

        switch (shapeType) {

            case CLOUD.Extensions.Annotation.shapeTypes.ARROW:
                var arrow = new CLOUD.Extensions.AnnotationArrow(this, id);
                arrow.set(position, size, rotation);
                arrow.setStyle(style);
                this.addAnnotation(arrow);
                arrow.created();
                break;
            case CLOUD.Extensions.Annotation.shapeTypes.RECTANGLE:
                var rectangle = new CLOUD.Extensions.AnnotationRectangle(this, id);
                rectangle.set(position, size, rotation);
                rectangle.setStyle(style);
                this.addAnnotation(rectangle);
                rectangle.created();
                break;
            case CLOUD.Extensions.Annotation.shapeTypes.CIRCLE:
                var circle = new CLOUD.Extensions.AnnotationCircle(this, id);
                circle.set(position, size, rotation);
                circle.setStyle(style);
                this.addAnnotation(circle);
                circle.created();
                break;
            case CLOUD.Extensions.Annotation.shapeTypes.CROSS:
                var cross = new CLOUD.Extensions.AnnotationCross(this, id);
                cross.set(position, size, rotation);
                cross.setStyle(style);
                this.addAnnotation(cross);
                cross.created();
                break;
            case CLOUD.Extensions.Annotation.shapeTypes.CLOUD:
                var cloud = new CLOUD.Extensions.AnnotationCloud(this, id);
                cloud.set(position, size, rotation, shapePointsStr, originSize);
                cloud.setStyle(style);
                this.addAnnotation(cloud);
                cloud.created();
                break;
            case CLOUD.Extensions.Annotation.shapeTypes.TEXT:
                var textAnnotation = new CLOUD.Extensions.AnnotationText(this, id);
                textAnnotation.set(position, size, rotation, text);
                textAnnotation.setStyle(style);
                this.addAnnotation(textAnnotation);
                textAnnotation.created();
                textAnnotation.forceRedraw();
                break;
            default:
                break;
        }
    }
};

// 卸载批注
CLOUD.Extensions.AnnotationEditor.prototype.unloadAnnotations = function () {

    // 清除数据
    this.clear();

    if (this.svgGroup && this.svgGroup.parentNode) {
        this.svgGroup.parentNode.removeChild(this.svgGroup);
    }
};

// 显示批注
CLOUD.Extensions.AnnotationEditor.prototype.showAnnotations = function () {

    if (this.svgGroup) {
        this.svgGroup.setAttribute("visibility", "visible");
    }
};

// 隐藏批注
CLOUD.Extensions.AnnotationEditor.prototype.hideAnnotations = function () {

    if (this.svgGroup) {
        this.svgGroup.setAttribute("visibility", "hidden");
    }
};

// 设置批注风格（边框色，填充色，字体大小等等）
CLOUD.Extensions.AnnotationEditor.prototype.setAnnotationStyle = function (style, updateText) {

    this.annotationStyle = CLOUD.DomUtil.cloneStyle(style);

    if (updateText) {

        //if (this.annotationType === CLOUD.Extensions.Annotation.shapeTypes.TEXT) {

        // 对文本特殊处理
        if (this.currentAnnotationText) {
            this.currentAnnotationText.updateStyle(style);

            if (this.annotationTextArea) {
                this.annotationTextArea.setStyle(style);
            }
        }
        // }
    }
};

// 更新所有批注
CLOUD.Extensions.AnnotationEditor.prototype.updateAnnotations = function () {

    for (var i = 0, len = this.annotations.length; i < len; i++) {
        var annotation = this.annotations[i];
        annotation.update();
    }

    if (this.annotationFrame && this.selectedAnnotation) {
        this.annotationFrame.setAnnotation(this.selectedAnnotation);
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.onCameraChange = function () {};

CLOUD.Extensions.AnnotationEditor.prototype.enableDblClickCloseCloud = function (enable) {
    this.isDblClickCloseCloud = enable;
};

CLOUD.Extensions.AnnotationEditor.prototype.getTextArea = function () {

    var textArea;

    if (this.popupCallback) {
        textArea = this.annotationPopupTextArea;
    } else {
        textArea = this.annotationTextArea;
    }

    return textArea;
};

CLOUD.Extensions.AnnotationEditor.prototype.setTextFromPopupBox = function (text) {

    if (this.popupCallback) {
        this.annotationPopupTextArea.accept(text);
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.unsetTextFromPopupBox = function () {

    if (this.popupCallback) {
        this.annotationPopupTextArea.unaccept();
    }
};

CLOUD.Extensions.AnnotationEditor.prototype.clearAnnotations = function () {

    if (!this.svg) return;

    this.deselectAnnotation();

    // 清除数据
    var annotations = this.annotations;
    for (var i = 0, len = annotations.length; i < len; ++i) {
        var annotation = annotations[i];
        annotation.destroy();
    }

    this.annotations = [];
};

// ---------------------------- 外部 API END ---------------------------- //


CLOUD.Extensions = CLOUD.Extensions || {};

CLOUD.Extensions.AnnotationEditor2D = function (domElement, options) {
    "use strict";

    CLOUD.Extensions.AnnotationEditor.call(this, domElement, options);

    this.absoluteBasePoint = null;
    this.screenBasePoint = null;
    this.zoomFactor = { x: 1.0, y: 1.0 };
};

CLOUD.Extensions.AnnotationEditor2D.prototype = Object.create(CLOUD.Extensions.AnnotationEditor.prototype);
CLOUD.Extensions.AnnotationEditor2D.prototype.constructor = CLOUD.Extensions.AnnotationEditor2D;

CLOUD.Extensions.AnnotationEditor2D.prototype.setDomContainer = function (domElement) {

    if (domElement) {

        this.domElement = domElement;
    }
};

// 设置绝对基点
CLOUD.Extensions.AnnotationEditor2D.prototype.setAbsoluteBasePoint = function (point) {

    if (point) {

        if (!this.absoluteBasePoint) {
            this.absoluteBasePoint = {};
        }

        this.absoluteBasePoint.x = point.x;
        this.absoluteBasePoint.y = point.y;
    }
};

// 设置屏幕基点
CLOUD.Extensions.AnnotationEditor2D.prototype.setScreenBasePoint = function (point) {

    if (point) {

        if (!this.screenBasePoint) {
            this.screenBasePoint = {};
        }

        this.screenBasePoint.x = point.x;
        this.screenBasePoint.y = point.y;
    }
};

// 设置缩放因子
CLOUD.Extensions.AnnotationEditor2D.prototype.setZoomFactor = function (factorX, factorY) {

    factorX = factorX || 1.0;
    factorY = factorY || 1.0;
    this.zoomFactor.x = factorX;
    this.zoomFactor.y = factorY;
};

CLOUD.Extensions.AnnotationEditor2D.prototype.worldToClient = function (wPoint) {

    // (Wp - Wc) * zoomFactor = Sp - Sc ===> Sp = (Wp - Wc) * zoomFactor + Sc

    var rect = this.getDomContainerBounds();
    var result = new THREE.Vector3();
    var absBasePoint = this.absoluteBasePoint;
    var screenBasePoint = this.screenBasePoint;

    if (!this.absoluteBasePoint) {

        absBasePoint = { x: 0.0, y: 0.0 };
    }

    if (!this.screenBasePoint) {

        screenBasePoint = { x: rect.width * 0.5, y: rect.height * 0.5 };
    }

    // 变换到屏幕空间
    result.x = (wPoint.x - absBasePoint.x) * this.zoomFactor.x + screenBasePoint.x;
    result.y = (-wPoint.y - absBasePoint.y) * this.zoomFactor.y + screenBasePoint.y;
    result.z = 0;

    return result;
};

CLOUD.Extensions.AnnotationEditor2D.prototype.clientToWorld = function (cPoint) {

    // Wp - Wc = Sp - Sc ===> Wp = Sp - Sc + Wc
    // (Wp - Wc) * zoomFactor = Sp - Sc ===> Wp = (Sp - Sc) / zoomFactor + Wc

    var rect = this.getDomContainerBounds();
    var result = new THREE.Vector3();
    var invFactorX = 1 / this.zoomFactor.x;
    var invFactorY = 1 / this.zoomFactor.y;
    var absBasePoint = this.absoluteBasePoint;
    var screenBasePoint = this.screenBasePoint;

    if (!this.absoluteBasePoint) {

        absBasePoint = { x: 0.0, y: 0.0 };
    }

    if (!this.screenBasePoint) {

        screenBasePoint = { x: rect.width * 0.5, y: rect.height * 0.5 };
    }

    result.x = (cPoint.x - screenBasePoint.x) * invFactorX + absBasePoint.x;
    result.y = -((cPoint.y - screenBasePoint.y) * invFactorY + absBasePoint.y); // 翻转,因为绘制图形参照坐标和屏幕的坐标系不同
    result.z = 0;

    return result;
};

CLOUD.Extensions.AnnotationEditor2D.prototype.onCameraChange = function () {

    this.handleCallbacks("changeEditor");
};

CLOUD.Extensions.AnnotationEditor2D.prototype.setSvgZIndex = function (zIndex) {

    zIndex = zIndex || 18;

    if (this.svg) {
        this.svg.style.zIndex = zIndex;
    }
};

CLOUD.Extensions = CLOUD.Extensions || {};

CLOUD.Extensions.AnnotationEditor3D = function (domElement, camera, options) {
    "use strict";

    CLOUD.Extensions.AnnotationEditor.call(this, domElement, options);

    this.camera = camera;
};

CLOUD.Extensions.AnnotationEditor3D.prototype = Object.create(CLOUD.Extensions.AnnotationEditor.prototype);
CLOUD.Extensions.AnnotationEditor3D.prototype.constructor = CLOUD.Extensions.AnnotationEditor3D;

CLOUD.Extensions.AnnotationEditor3D.prototype.setDomContainer = function (domElement) {

    if (domElement) {
        this.domElement = domElement;
    }
};

CLOUD.Extensions.AnnotationEditor3D.prototype.worldToClient = function (wPoint) {

    var bounds = this.getDomContainerBounds();
    var camera = this.camera;
    var result = new THREE.Vector3(wPoint.x, wPoint.y, wPoint.z);

    // 变换到相机空间
    result.applyMatrix4(camera.matrixWorld);
    result.sub(camera.position);
    result.project(camera);

    // 变换到屏幕空间
    result.x = Math.floor(0.5 * (result.x + 1) * bounds.width + 0.5);
    result.y = Math.floor(-0.5 * (result.y - 1) * bounds.height + 0.5);
    result.z = 0;

    return result;
};

CLOUD.Extensions.AnnotationEditor3D.prototype.clientToWorld = function (cPoint) {

    var bounds = this.getDomContainerBounds();
    var camera = this.camera;
    var result = new THREE.Vector3();

    result.x = cPoint.x / bounds.width * 2 - 1;
    result.y = -cPoint.y / bounds.height * 2 + 1;
    result.z = 0;

    result.unproject(camera);
    result.add(camera.position).applyMatrix4(camera.matrixWorldInverse);
    //result.z = 0;

    return result;
};

CLOUD.Extensions.AnnotationEditor3D.prototype.onCameraChange = function () {

    if (this.camera.dirty) {
        this.handleCallbacks("changeEditor");
    }
};
CLOUD.Extensions.Marker = function (id, editor) {

    this.id = id;
    this.editor = editor;
    this.position = new THREE.Vector3();
    this.boundingBox = new THREE.Box3();
    this.shape = null;
    this.style = CLOUD.Extensions.Marker.getDefaultStyle();

    this.selected = false;
    this.highlighted = false;
    this.highlightColor = '#000088';
    this.isDisableInteractions = false;

    this.keys = {
        BACKSPACE: 8,
        ALT: 18,
        ESC: 27,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        BOTTOM: 40,
        DELETE: 46,
        ZERO: 48,
        A: 65,
        D: 68,
        E: 69,
        Q: 81,
        S: 83,
        W: 87,
        PLUS: 187,
        SUB: 189
    };

    this.onMouseDownBinded = this.onMouseDown.bind(this);
    this.onKeyUpBinded = this.onKeyUp.bind(this);
};

CLOUD.Extensions.Marker.prototype = {
    constructor: CLOUD.Extensions.Marker,

    addDomEventListeners: function addDomEventListeners() {
        this.shape.addEventListener("mousedown", this.onMouseDownBinded, true);
        this.shape.addEventListener("touchstart", this.onMouseDownBinded, true);
        window.addEventListener("keyup", this.onKeyUpBinded);
    },

    removeDomEventListeners: function removeDomEventListeners() {
        this.shape.removeEventListener("mousedown", this.onMouseDownBinded, true);
        this.shape.removeEventListener("touchstart", this.onMouseDownBinded, true);
        window.removeEventListener("keyup", this.onKeyUpBinded);
    },

    onMouseDown: function onMouseDown(event) {

        event.preventDefault();
        event.stopPropagation();

        this.select();
    },

    onKeyUp: function onKeyUp(event) {

        switch (event.keyCode) {
            case this.keys.DELETE:
                this.editor.deselectMarker();
                this.delete();
                break;
            default:
                break;
        }
    },

    createShape: function createShape() {},

    destroy: function destroy() {
        this.removeDomEventListeners();
        this.deselect();
        this.setParent(null);
    },

    set: function set(userId, position, boundingBox, style) {

        this.userId = userId;
        this.position.set(position.x, position.y, position.z);
        this.boundingBox = boundingBox.clone();

        if (style) {
            this.style = CLOUD.DomUtil.cloneStyle(style);
        }

        this.update();
    },

    setParent: function setParent(parent) {

        var shapeEl = this.shape;

        if (shapeEl) {

            if (shapeEl.parentNode) {
                shapeEl.parentNode.removeChild(shapeEl);
            }

            if (parent) {
                parent.appendChild(shapeEl);
            }
        }
    },

    setStyle: function setStyle(style) {
        this.style = CLOUD.DomUtil.cloneStyle(style);
        this.update();
    },

    select: function select() {

        //if (this.selected) {
        //    return;
        //}
        //
        //this.selected = true;
        //this.highlighted = false;
        //this.update();
        //this.editor.selectMarker(this);


        if (!this.selected) {

            this.selected = true;
            this.highlight(true);
        }

        this.editor.selectMarker(this);
    },

    deselect: function deselect() {

        this.highlight(false);
        this.selected = false;
    },

    highlight: function highlight(isHighlight) {

        if (this.isDisableInteractions) {
            return;
        }

        this.highlighted = isHighlight;
        this.update();
    },

    disableInteractions: function disableInteractions(disable) {

        this.isDisableInteractions = disable;
    },

    delete: function _delete() {

        this.editor.deleteMarker(this);
    },

    getClientPosition: function getClientPosition() {

        return this.editor.worldToClient(this.position);
    },

    getBoundingBox: function getBoundingBox() {
        return this.boundingBox;
    },

    toNewObject: function toNewObject() {

        return {
            id: this.id,
            userId: this.userId,
            shapeType: this.shapeType,
            cx: this.cx,
            cy: this.cy,
            position: this.position ? this.position.clone() : null,
            boundingBox: this.boundingBox ? this.boundingBox.clone() : null
        };
    },

    update: function update() {

        var strokeWidth = this.style['stroke-width'];
        var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];
        var strokeOpacity = this.style['stroke-opacity'];
        var fillColor = this.style['fill-color'];
        var fillOpacity = this.style['fill-opacity'];

        var position = this.getClientPosition();

        if (!position) {

            this.shape.style.display = "none";
            return;
        }

        var offsetX = position.x;
        var offsetY = position.y;

        if (this.shapeType == 2) {
            var transformShape = ['translate(', offsetX - this.pictureSize * 0.5, ',', offsetY - this.pictureSize * 0.5, ') '].join('');
        } else {
            var transformShape = ['translate(', offsetX, ',', offsetY, ') '].join('');
        }

        this.cx = offsetX;
        this.cy = offsetY;

        this.shape.setAttribute("transform", transformShape);
        this.shape.setAttribute("stroke-width", strokeWidth);
        this.shape.setAttribute("stroke", strokeColor);
        this.shape.setAttribute("stroke-opacity", strokeOpacity);
        this.shape.setAttribute('fill', fillColor);
        this.shape.setAttribute('fill-opacity', fillOpacity);
    }
};

CLOUD.Extensions.Marker.shapeTypes = { BUBBLE: 0, FLAG: 1, COMMON: 2 };

CLOUD.Extensions.Marker.getDefaultStyle = function () {
    var style = {};

    style['stroke-width'] = 2;
    style['stroke-color'] = '#fffaff';
    style['stroke-opacity'] = 1.0;
    style['fill-color'] = '#ff2129';
    style['fill-opacity'] = 1.0;

    return style;
};
CLOUD.Extensions.MarkerBubble = function (id, editor) {

    CLOUD.Extensions.Marker.call(this, id, editor);

    this.shapeType = CLOUD.Extensions.Marker.shapeTypes.BUBBLE;

    this.createShape();
    this.addDomEventListeners();
};

CLOUD.Extensions.MarkerBubble.prototype = Object.create(CLOUD.Extensions.Marker.prototype);
CLOUD.Extensions.MarkerBubble.prototype.constructor = CLOUD.Extensions.MarkerBubble;

CLOUD.Extensions.MarkerBubble.prototype.createShape = function () {

    this.shape = CLOUD.Extensions.Utils.Shape2D.makeBubble();
};

CLOUD.Extensions.MarkerFlag = function (id, editor) {

    CLOUD.Extensions.Marker.call(this, id, editor);

    this.shapeType = CLOUD.Extensions.Marker.shapeTypes.FLAG;

    this.createShape();
    this.addDomEventListeners();
};

CLOUD.Extensions.MarkerFlag.prototype = Object.create(CLOUD.Extensions.Marker.prototype);
CLOUD.Extensions.MarkerFlag.prototype.constructor = CLOUD.Extensions.MarkerFlag;

CLOUD.Extensions.MarkerFlag.prototype.createShape = function () {

    this.shape = CLOUD.Extensions.Utils.Shape2D.makeFlag();
};

CLOUD.Extensions.MarkerCommon = function (id, editor, url) {

    CLOUD.Extensions.Marker.call(this, id, editor);

    this.shapeType = CLOUD.Extensions.Marker.shapeTypes.COMMON;

    this.pictureSize = 50;

    this.createShape(url);
    this.addDomEventListeners();
};

CLOUD.Extensions.MarkerCommon.prototype = Object.create(CLOUD.Extensions.Marker.prototype);
CLOUD.Extensions.MarkerCommon.prototype.constructor = CLOUD.Extensions.MarkerCommon;

CLOUD.Extensions.MarkerCommon.prototype.createShape = function (url) {

    this.shape = CLOUD.Extensions.Utils.Shape2D.makeCommon(url, this.pictureSize);
};

CLOUD.Extensions.MarkerEditor = function (viewer) {
    "use strict";

    this.cameraControl = viewer.cameraControl;
    this.scene = viewer.getScene();
    this.domElement = viewer.domElement;

    this.markers = [];
    this.selectedMarker = null;

    // 隐患待整改：红色
    // 隐患已整改：黄色
    // 隐患已关闭：绿色
    // size: 15 * 20
    this.flagColors = { red: "#ff2129", green: "#85af03", yellow: "#fe9829" };

    // 有隐患：红色
    // 无隐患：绿色
    // 过程验收点、开业验收点的未检出：灰色 --> 橙色
    // size: 14 * 20
    this.bubbleColors = { red: "#f92a24", green: "#86b507", gray: "#ff9326" };

    this.nextMarkerId = 0;
    this.initialized = false;
    this.markerClickCallback = null;
};

CLOUD.Extensions.MarkerEditor.prototype.onResize = function () {

    if (!this.svg) return;

    var bounds = this.getDomContainerBounds();

    this.svg.setAttribute('width', bounds.width + '');
    this.svg.setAttribute('height', bounds.height + '');

    this.updateMarkers();
};

CLOUD.Extensions.MarkerEditor.prototype.init = function () {

    if (!this.svg) {

        var bounds = this.getDomContainerBounds();
        var svgWidth = bounds.width;
        var svgHeight = bounds.height;

        this.svg = CLOUD.Extensions.Utils.Shape2D.createSvgElement('svg');
        this.svg.style.position = "absolute";
        this.svg.style.display = "block";
        this.svg.style.position = "absolute";
        this.svg.style.display = "block";
        this.svg.style.left = "0";
        this.svg.style.top = "0";
        this.svg.setAttribute('width', svgWidth + '');
        this.svg.setAttribute('height', svgHeight + '');

        this.domElement.appendChild(this.svg);
        //this.enableSVGPaint(false);

        this.svgGroup = CLOUD.Extensions.Utils.Shape2D.createSvgElement('g');
        this.svg.insertBefore(this.svgGroup, this.svg.firstChild);
    }

    this.initialized = true;
};

CLOUD.Extensions.MarkerEditor.prototype.uninit = function () {

    this.initialized = false;

    if (!this.svg) return;

    // 卸载数据
    this.unloadMarkers();

    if (this.svgGroup && this.svgGroup.parentNode) {
        this.svgGroup.parentNode.removeChild(this.svgGroup);
    }

    if (this.svg.parentNode) {
        this.svg.parentNode.removeChild(this.svg);
    }

    this.svgGroup = null;
    this.svg = null;
    this.markerClickCallback = null;
};

CLOUD.Extensions.MarkerEditor.prototype.isInitialized = function () {

    return this.initialized;
};

// 生成标识ID
CLOUD.Extensions.MarkerEditor.prototype.generateMarkerId = function () {

    ++this.nextMarkerId;

    var id = this.nextMarkerId.toString(10);

    //var id = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    //    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
    //    return v.toString(16);
    //});

    return id;
};

// 清除数据
CLOUD.Extensions.MarkerEditor.prototype.clear = function () {

    var markers = this.markers;

    while (markers.length) {
        var marker = markers[0];
        this.deleteMarker(marker);
    }

    var group = this.svgGroup;
    if (group && group.childNodes.length > 0) {
        while (group.childNodes.length) {
            group.removeChild(group.childNodes[0]);
        }
    }
};

// 增加
CLOUD.Extensions.MarkerEditor.prototype.addMarker = function (marker) {

    marker.setParent(this.svgGroup);

    this.markers.push(marker);
};

// 删除
CLOUD.Extensions.MarkerEditor.prototype.deleteMarker = function (marker) {

    if (marker) {

        var idx = this.markers.indexOf(marker);

        if (idx !== -1) {
            this.markers.splice(idx, 1);
        }

        marker.destroy();
    }
};

// 选中
CLOUD.Extensions.MarkerEditor.prototype.selectMarker = function (marker) {

    if (this.selectedMarker !== marker) {

        this.deselectMarker();
        this.selectedMarker = marker;
    } else {

        // 取消选择
        this.deselectMarker();
    }

    // click 回调
    if (this.markerClickCallback) {

        if (this.selectedMarker) {
            this.markerClickCallback(this.selectedMarker.toNewObject());
        } else {

            this.markerClickCallback(null);
        }
    }
};

// 取消选中
CLOUD.Extensions.MarkerEditor.prototype.deselectMarker = function () {

    if (this.selectedMarker) {

        this.selectedMarker.deselect();
        this.selectedMarker = null;
    }
};

// 获得主场景构件根节点变换矩阵
CLOUD.Extensions.MarkerEditor.prototype.getSceneMatrix = function () {
    return this.scene.getMatrixGlobal();
};

// 获得主场景构件根节点变换矩阵的逆
CLOUD.Extensions.MarkerEditor.prototype.getInverseSceneMatrix = function () {

    var sceneMatrix = this.getSceneMatrix();
    var inverseMatrix = new THREE.Matrix4();

    inverseMatrix.getInverse(sceneMatrix);

    return inverseMatrix;
};

// 世界坐标转屏幕坐标
CLOUD.Extensions.MarkerEditor.prototype.worldToClient = function (wPoint) {

    var bounds = this.getDomContainerBounds();
    var camera = this.cameraControl.camera;
    var sceneMatrix = this.getSceneMatrix();
    var result = new THREE.Vector3(wPoint.x, wPoint.y, wPoint.z);

    result.applyMatrix4(sceneMatrix);
    result.project(camera);

    // 裁剪不在相机范围的值
    if (Math.abs(result.z) > 1) {
        return null;
    }

    result.x = Math.round(0.5 * (result.x + 1) * bounds.width);
    result.y = Math.round(-0.5 * (result.y - 1) * bounds.height);
    result.z = 0;

    return result;
};

// 屏幕坐标转世界坐标
CLOUD.Extensions.MarkerEditor.prototype.clientToWorld = function (cPoint) {

    var bounds = this.getDomContainerBounds();
    var camera = this.cameraControl.camera;
    var result = new THREE.Vector3();

    result.x = cPoint.x / bounds.width * 2 - 1;
    result.y = -cPoint.y / bounds.height * 2 + 1;
    result.z = 0;

    result.unproject(camera);

    var inverseMatrix = this.getInverseSceneMatrix();

    result.applyMatrix4(inverseMatrix);

    return result;
};

// 屏幕坐标转规范化坐标
CLOUD.Extensions.MarkerEditor.prototype.clientToViewport = function (cPoint) {

    var bounds = this.getDomContainerBounds();
    var result = new THREE.Vector3();

    result.x = cPoint.x / bounds.width * 2 - 1;
    result.y = -cPoint.y / bounds.height * 2 + 1;
    result.z = 0;

    return result;
};

// 是否允许在SVG上绘图
CLOUD.Extensions.MarkerEditor.prototype.enableSVGPaint = function (enable) {

    if (enable) {

        this.svg && this.svg.setAttribute("pointer-events", "painted");
    } else {

        this.svg && this.svg.setAttribute("pointer-events", "none");
    }
};

// 获得容器边框
CLOUD.Extensions.MarkerEditor.prototype.getDomContainerBounds = function () {

    return CLOUD.DomUtil.getContainerOffsetToClient(this.domElement);
};

// 根据形状和状态获得颜色
CLOUD.Extensions.MarkerEditor.prototype.getMarkerColor = function (shape, state) {

    var markerColor = this.bubbleColors.red;

    if (shape < 0 && shape > 1) {
        shape = 0;
    }

    // 兼容以前的模式（0 - 5）
    if (state > 2) {
        state -= 3;
    }

    if (state < 0 && state > 2) {
        state = 0;
    }

    switch (state) {
        case 0:
            if (shape === 0) {
                markerColor = this.bubbleColors.red;
            } else {
                markerColor = this.flagColors.red;
            }

            break;
        case 1:

            if (shape === 0) {
                markerColor = this.bubbleColors.green;
            } else {
                markerColor = this.flagColors.green;
            }
            break;
        case 2:

            if (shape === 0) {
                markerColor = this.bubbleColors.gray;
            } else {
                markerColor = this.flagColors.yellow;
            }
            break;
    }

    return markerColor;
};

// 根据Pick对象信息创建标记
CLOUD.Extensions.MarkerEditor.prototype.createMarkerByIntersect = function (intersect, shapeType, state) {

    var id = this.generateMarkerId(); //intersect.userId;
    var userId = intersect.userId;
    var position = intersect.worldPosition || intersect.object.point;
    var boundingBox = intersect.worldBoundingBox || intersect.object.boundingBox;

    var markerInfo = {
        id: id,
        userId: userId,
        position: position,
        boundingBox: boundingBox,
        shapeType: shapeType,
        state: state
    };

    this.createMarker(markerInfo);
};

// 创建标记
CLOUD.Extensions.MarkerEditor.prototype.createMarker = function (markerInfo) {

    if (!markerInfo) return;

    var style = CLOUD.Extensions.Marker.getDefaultStyle();
    style['fill-color'] = this.getMarkerColor(markerInfo.shapeType, markerInfo.state);

    var markerId = markerInfo.id; //this.generateMarkerId();
    var marker;

    var shapeTypes = CLOUD.Extensions.Marker.shapeTypes;

    switch (markerInfo.shapeType) {

        case shapeTypes.BUBBLE:
            marker = new CLOUD.Extensions.MarkerBubble(markerId, this);
            break;
        case shapeTypes.COMMON:
            marker = new CLOUD.Extensions.MarkerCommon(markerId, this, markerInfo.state);
            break;
        case shapeTypes.FLAG:
            marker = new CLOUD.Extensions.MarkerFlag(markerId, this);
            break;
        default:
            marker = new CLOUD.Extensions.MarkerFlag(markerId, this);
            break;
    }

    marker.set(markerInfo.userId, markerInfo.position, markerInfo.boundingBox, style);

    this.addMarker(marker);
};

// ---------------------------- 外部 API BEGIN ---------------------------- //

// 获得所有marker的包围盒
CLOUD.Extensions.MarkerEditor.prototype.getMarkersBoundingBox = function () {

    if (this.markers.length < 1) return null;

    var bBox = new THREE.Box3();

    for (var i = 0, len = this.markers.length; i < len; i++) {
        var marker = this.markers[i];
        bBox.union(marker.getBoundingBox());
    }

    return bBox;
};

// 获得marker列表
CLOUD.Extensions.MarkerEditor.prototype.getMarkerInfoList = function () {

    var markerInfoList = [];

    for (var i = 0, len = this.markers.length; i < len; i++) {

        var marker = this.markers[i];
        var tmpId = marker.userId + "_" + i;
        var info = {
            id: marker.id || tmpId,
            userId: marker.userId,
            shapeType: marker.shapeType,
            position: marker.position,
            boundingBox: marker.boundingBox,
            state: marker.state
        };

        markerInfoList.push(info);
    }

    return markerInfoList;
};

// 加载
CLOUD.Extensions.MarkerEditor.prototype.loadMarkers = function (markers) {

    // 清除数据
    this.clear();

    for (var i = 0, len = markers.length; i < len; i++) {

        var info = markers[i];
        var tmpId = info.userId + "_" + i;
        var id = info.id || tmpId;
        var userId = info.userId;
        var shapeType = info.shapeType;
        var state = info.state;
        var position = info.position;

        var boundingBox = new THREE.Box3();
        boundingBox.max.x = info.boundingBox.max.x;
        boundingBox.max.y = info.boundingBox.max.y;
        boundingBox.max.z = info.boundingBox.max.z;
        boundingBox.min.x = info.boundingBox.min.x;
        boundingBox.min.y = info.boundingBox.min.y;
        boundingBox.min.z = info.boundingBox.min.z;

        var markerInfo = {
            id: id,
            userId: userId,
            position: position,
            boundingBox: boundingBox,
            shapeType: shapeType,
            state: state
        };

        this.createMarker(markerInfo);
    }
};

// 根据Pick对象信息加载
CLOUD.Extensions.MarkerEditor.prototype.loadMarkersFromIntersect = function (intersect, shapeType, state) {

    // 清除数据
    this.clear();
    this.createMarkerByIntersect(intersect, shapeType, state);
};

// 卸载
CLOUD.Extensions.MarkerEditor.prototype.unloadMarkers = function () {

    // 清除数据
    this.clear();
};

// 更新所有
CLOUD.Extensions.MarkerEditor.prototype.updateMarkers = function () {

    for (var i = 0, len = this.markers.length; i < len; i++) {
        var marker = this.markers[i];
        marker.update();
    }
};

//// 显示
//CLOUD.Extensions.MarkerEditor.prototype.showMarkers = function () {
//
//    if (this.svgGroup) {
//        this.svgGroup.setAttribute("visibility", "visible");
//    }
//};
//
//// 隐藏
//CLOUD.Extensions.MarkerEditor.prototype.hideMarkers = function () {
//
//    if (this.svgGroup) {
//        this.svgGroup.setAttribute("visibility", "hidden");
//    }
//};

// 根据ID获得marker
CLOUD.Extensions.MarkerEditor.prototype.getMarker = function (id) {

    var markers = this.markers;
    var count = markers.length;

    for (var i = 0; i < count; ++i) {
        if (markers[i].id == id) {
            return markers[i];
        }
    }

    return null;
};

CLOUD.Extensions.MarkerEditor.prototype.getMarkerByUserId = function (userId) {

    var markers = this.markers;
    var count = markers.length;

    for (var i = 0; i < count; ++i) {
        if (markers[i].userId == userId) {
            return markers[i];
        }
    }

    return null;
};

// 设置marker选中回调
CLOUD.Extensions.MarkerEditor.prototype.setMarkerClickCallback = function (callback) {

    this.markerClickCallback = callback;
};

// ---------------------------- 外部 API END ---------------------------- //


CLOUD.Extensions.Icon = function (iconUrl, iconSize, iconAnchor, shadowUrl, shadowSize, shadowAnchor) {

    this.options = {
        iconUrl: iconUrl,
        iconSize: iconSize ? iconSize : [40, 40],
        iconAnchor: iconAnchor ? iconAnchor : [20, 20],
        shadowUrl: shadowUrl,
        shadowSize: shadowSize ? shadowSize : [41, 41],
        shadowAnchor: shadowAnchor ? shadowAnchor : [20, 20]
    };
};

CLOUD.Extensions.Icon.prototype = {

    constructor: CLOUD.Extensions.Icon,

    initialize: function initialize(options) {
        CLOUD.MarkerUtil.setOptions(this, options);
    },

    createIcon: function createIcon(oldIcon) {
        return this._createIcon('icon', oldIcon);
    },

    createShadow: function createShadow(oldIcon) {
        return this._createIcon('shadow', oldIcon);
    },

    _createIcon: function _createIcon(name, oldIcon) {
        var src = this._getIconUrl(name);

        if (!src) {
            if (name === 'icon') {
                throw new Error('iconUrl not set in Icon options, please set the iconUrl.');
            }
            return null;
        }

        var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
        this._setIconStyles(img, name);

        return img;
    },

    _setIconStyles: function _setIconStyles(img, name) {
        var options = this.options;
        var sizeOption = options[name + 'Size'];

        if (typeof sizeOption === 'number') {
            sizeOption = [sizeOption, sizeOption];
        }

        var size = sizeOption;
        var anchor = name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && [size[0] / 2, size[1] / 2];

        img.style.position = 'absolute';

        if (anchor) {
            img.style.marginLeft = -anchor[0] + 'px';
            img.style.marginTop = -anchor[1] + 'px';
        }

        if (size) {
            img.style.width = size[0] + 'px';
            img.style.height = size[1] + 'px';
        }
    },

    _createImg: function _createImg(src, el) {
        el = el || document.createElement('img');
        el.src = src;
        return el;
    },

    _getIconUrl: function _getIconUrl(name) {
        return this.options[name + 'Url'];
    }

};
CLOUD.Extensions.MarkerEx = function (icon) {

    this.options = {
        icon: icon,
        title: '',
        zIndexOffset: 0,
        opacity: 1,

        riseOnHover: true,

        riseOffset: 250,

        pane: 'markerPane'
    };

    this.position = {};
    this.uuid = '';

    this.clickCallback = null;

    this.mouseDownFun = this.onMouseDown.bind(this);
    this.mouseUpFun = this.onMouseUp.bind(this);
    this.mouseOverFun = this.onMouseOver.bind(this);
    this.mouseOutFun = this.onMouseOut.bind(this);

    this.touchEndFun = this.onTouchEnd.bind(this);
};

CLOUD.Extensions.MarkerEx.prototype = {

    constructor: CLOUD.Extensions.MarkerEx,

    initialize: function initialize(position, options) {

        CLOUD.MarkerUtil.setOptions(this, options);
        this.position.x = position.x;
        this.position.y = position.y;
        this.position.z = position.z;
    },

    onAdd: function onAdd() {

        this._initIcon();
        this.update();
    },

    onRemove: function onRemove() {

        this._removeIcon();
        this._removeShadow();
    },

    setZIndexOffset: function setZIndexOffset(offset) {

        this.options.zIndexOffset = offset;
        return this.update();
    },

    setIcon: function setIcon(icon) {

        this.options.icon = icon;

        this._initIcon();
        this.update();

        return this;
    },

    getElement: function getElement() {
        return this._icon;
    },

    getPos: function getPos() {
        return this._pos;
    },

    update: function update() {

        if (this._icon) {
            var pos = CLOUD.MarkerUtil.transformPosition(this.position);
            this._setPos(pos);
        }

        return this;
    },

    display: function display(isHide) {
        if (this._icon) {
            this._icon.style.display = isHide ? 'none' : '';
        }
    },

    onMouseDown: function onMouseDown(event) {

        event.preventDefault();
        event.stopPropagation();

        this.event = event;
    },

    onMouseUp: function onMouseUp(event) {

        event.preventDefault();
        event.stopPropagation();

        if (this.event.clientX == event.clientX && this.event.clientY == event.clientY) {

            if (this.clickCallback != null) {
                this.clickCallback(event, this);
            }
        }
    },

    onTouchEnd: function onTouchEnd(event) {

        event.preventDefault();
        event.stopPropagation();

        if (this.event.pageX == event.pageX && this.event.pageY == event.pageY) {

            if (this.clickCallback != null) {
                this.clickCallback(this.event, this);
            }
        }
    },

    onMouseOver: function onMouseOver(event) {
        this._bringToFront();
        this.setOpacity(this.options.opacity * 0.5);
    },

    onMouseOut: function onMouseOut(event) {
        this._resetZIndex();
        this.setOpacity(this.options.opacity * 2.0);
    },

    setClickCallback: function setClickCallback(callback) {
        if (this._icon) {
            this.clickCallback = callback;
        }
    },

    _initIcon: function _initIcon() {
        var options = this.options;

        var icon = options.icon.createIcon(this._icon);
        var addIcon = false;

        // if we're not reusing the icon, remove the old one and init new one
        if (icon !== this._icon) {
            if (this._icon) {
                this._removeIcon();
            }
            addIcon = true;
        }

        this._icon = icon;

        if (options.riseOnHover) {
            this._icon.addEventListener('mouseover', this.mouseOverFun);
            this._icon.addEventListener('mouseout', this.mouseOutFun);
        }

        var newShadow = options.icon.createShadow(this._shadow);
        var addShadow = false;

        if (newShadow !== this._shadow) {
            this._removeShadow();
            addShadow = true;
        }

        this._shadow = newShadow;

        if (options.opacity < 1) {
            this._updateOpacity();
        }

        if (addIcon) {
            CLOUD.MarkerUtil.getPane(this.options.pane).appendChild(this._icon);
        }
        if (newShadow && addShadow) {
            CLOUD.MarkerUtil.getPane('shadowPane').appendChild(this._shadow);
        }

        this._icon.addEventListener('mousedown', this.mouseDownFun, false);
        this._icon.addEventListener('mouseup', this.mouseUpFun, false);

        this._icon.addEventListener('touchstart', this.mouseDownFun, false);
        this._icon.addEventListener('touchend', this.touchEndFun, false);
    },

    _removeIcon: function _removeIcon() {

        if (this._icon) {
            if (this.options.riseOnHover) {
                this._icon.removeEventListener('mouseover', this.mouseOverFun);
                this._icon.removeEventListener('mouseout', this.mouseOutFun);
            }

            this._icon.removeEventListener('mousedown', this.mouseDownFun, false);
            this._icon.removeEventListener('mouseup', this.mouseUpFun, false);

            this._icon.removeEventListener('touchstart', this.mouseDownFun, false);
            this._icon.removeEventListener('touchend', this.touchEndFun, false);

            CLOUD.DomUtilEx.remove(this._icon);

            this._icon = null;
        }
    },

    _removeShadow: function _removeShadow() {
        if (this._shadow) {
            CLOUD.DomUtilEx.remove(this._shadow);
        }
        this._shadow = null;
    },

    _setPos: function _setPos(pos) {

        this._pos = pos;

        CLOUD.DomUtilEx.setPosition(this._icon, pos);

        if (this._shadow) {
            CLOUD.DomUtilEx.setPosition(this._shadow, pos);
        }

        this._zIndex = pos.y + this.options.zIndexOffset;

        this._resetZIndex();
    },

    _updateZIndex: function _updateZIndex(offset) {
        this._icon.style.zIndex = this._zIndex + offset;
    },

    setOpacity: function setOpacity(opacity) {
        this.options.opacity = opacity;
        if (this._icon) {
            this._updateOpacity();
        }

        return this;
    },

    _updateOpacity: function _updateOpacity() {

        var opacity = this.options.opacity;

        CLOUD.DomUtilEx.setOpacity(this._icon, opacity);

        if (this._shadow) {
            CLOUD.DomUtilEx.setOpacity(this._shadow, opacity);
        }
    },

    _bringToFront: function _bringToFront() {

        this._updateZIndex(this.options.riseOffset);
    },

    _resetZIndex: function _resetZIndex() {

        this._updateZIndex(0);
    }

};
CLOUD.Extensions.Layer = function () {

    CLOUD.Extensions.MarkerEx.call(this);

    this.markerList = [];
};

CLOUD.Extensions.Layer.prototype = Object.create(CLOUD.Extensions.MarkerEx.prototype);
CLOUD.Extensions.Layer.prototype.constructor = CLOUD.Extensions.Layer;

CLOUD.Extensions.Layer.prototype.addMarker = function (marker) {

    this.markerList.push(marker);
    if (this.markerList.length != 1) {
        this.addPosition(marker.position);
        this.update();
    } else {
        var marker = this.markerList[0];
        this.initialize(marker.position, marker.options);
        this.onAdd();
    }

    this._icon.title = this.markerList.length.toString();
};

CLOUD.Extensions.Layer.prototype.addLayer = function (layer) {

    this.markerList = this.markerList.concat(layer.markerList);
    if (this.markerList.length != layer.markerList.length) {
        this.addPosition(layer.position);
        this.update();
    } else {
        this.initialize(layer.position, layer.options);
        this.onAdd();
    }

    this._icon.title = this.markerList.length.toString();
};

CLOUD.Extensions.Layer.prototype.addPosition = function (position) {

    this.position.x += position.x;
    this.position.y += position.y;
    this.position.z += position.z;

    this.position.x *= 0.5;
    this.position.y *= 0.5;
    this.position.z *= 0.5;
};

CLOUD.Extensions.Layer.prototype.getPos = function () {

    this._pos = CLOUD.MarkerUtil.transformPosition(this.position);
    return this._pos;
};

CLOUD.Extensions.MarkerManager = function (viewer) {

    this.viewer = viewer;
    CLOUD.MarkerUtil.viewer = viewer;

    this.markerList = {};
    this.markerResultList = {};

    this.iconList = {};
    this.layerIcon = {};

    this.viewer.addRenderCallback(this.update.bind(this));

    this.markerClusterDistance = 25;
    this.zoomFactor = 10;

    this.zoomToLayerFun = this.zoomToLayer.bind(this);

    this.markerClickCallback = null;
    this.layerClickCallback = null;
};

CLOUD.Extensions.MarkerManager.prototype = {

    constructor: CLOUD.Extensions.MarkerManager,

    createIcon: function createIcon(iconName, iconUrl, iconSize, iconAnchor, shadowUrl, shadowSize, shadowAnchor) {

        var icon = new CLOUD.Extensions.Icon(iconUrl, iconSize, iconAnchor, shadowUrl, shadowSize, shadowAnchor);
        icon.name = iconName;
        this.iconList[iconName] = icon;
    },

    setLayerIcon: function setLayerIcon(iconName, groupName) {

        if (groupName === undefined) {
            groupName = 'Default';
        }

        this.layerIcon[groupName] = this.iconList[iconName];
    },

    addMarker: function addMarker(iconName, position, uuid, groupName) {

        var marker = new CLOUD.Extensions.MarkerEx(this.iconList[iconName]);
        if (groupName === undefined) {
            groupName = 'Default';
        }

        if (!this.markerList.hasOwnProperty(groupName)) {
            this.markerList[groupName] = [];
        }

        this.markerList[groupName].push(marker);

        marker.uuid = uuid;
        marker.initialize(position);
        marker.onAdd();

        if (this.markerClickCallback != null) {
            marker.setClickCallback(this.markerClickCallback);
        }
    },

    removeMarker: function removeMarker(uuid) {

        for (var name in this.markerList) {

            var markerGroup = this.markerList[name];
            var length = markerGroup.length;
            for (var i = 0; i < length; ++i) {

                if (uuid === markerGroup[i].uuid) {
                    this.markerList[name].splice(i, 1);
                    this.update();
                    return true;
                }
            }
        }

        return false;
    },

    getMarkerByUserId: function getMarkerByUserId(uuid) {

        for (var name in this.markerList) {

            var markerGroup = this.markerList[name];
            var length = markerGroup.length;
            for (var i = 0; i < length; ++i) {

                if (uuid === markerGroup[i].uuid) {
                    return markerGroup[i];
                }
            }
        }

        return null;
    },

    getMarkerInfoList: function getMarkerInfoList() {

        var iconListInfo = {};
        for (var name in this.iconList) {

            iconListInfo[name] = this.iconList[name].options;
        }

        var layerIconInfo = {};
        for (var name in this.layerIcon) {

            layerIconInfo[name] = this.layerIcon[name].name;
        }

        var markerInfoList = {};
        for (var name in this.markerList) {

            markerInfoList[name] = [];
            var markerGroup = this.markerList[name];
            var length = markerGroup.length;
            for (var i = 0; i < length; ++i) {

                var marker = markerGroup[i];
                markerInfoList[name][i] = {
                    iconName: marker.options.icon.name,
                    uuid: marker.uuid,
                    position: marker.position
                };
            }
        }

        return JSON.stringify({ icons: iconListInfo, layers: layerIconInfo, markers: markerInfoList });
    },

    loadMarkers: function loadMarkers(infoListStr) {

        this.clearAll();

        var infoList = JSON.parse(infoListStr);

        var iconListInfo = infoList.icons;
        for (var name in iconListInfo) {

            var icon = new CLOUD.Extensions.Icon();
            icon.initialize(iconListInfo[name]);

            this.iconList[name] = icon;
        }

        var layerIconInfo = infoList.layers;
        for (var name in layerIconInfo) {

            this.setLayerIcon(layerIconInfo[name], name);
        }

        var markersInfo = infoList.markers;
        for (var name in markersInfo) {

            var markerGroup = markersInfo[name];
            var length = markerGroup.length;
            for (var i = 0; i < length; ++i) {

                var markerInfo = markerGroup[i];
                this.addMarker(markerInfo.iconName, markerInfo.position, markerInfo.uuid, name);
            }
        }

        this.update();
    },

    setMarkerClickCallback: function setMarkerClickCallback(callback) {

        this.markerClickCallback = callback;
    },

    setLayerClickCallback: function setLayerClickCallback(callback) {

        this.layerClickCallback = callback;
    },

    clearMarkers: function clearMarkers() {

        for (var name in this.markerList) {

            var markerGroup = this.markerList[name];
            var length = markerGroup.length;
            for (var i = 0; i < length; ++i) {

                markerGroup[i].onRemove();
            }

            this.markerList[name] = [];
        }

        this.update();
    },

    clearAll: function clearAll() {

        this.clearMarkers();

        this.layerIcon = {};
        this.iconList = {};
    },

    update: function update() {

        for (var name in this.markerList) {

            this.updateMarkerCluster(name);
        }

        this.updateLayerCluster();

        for (var name in this.markerResultList) {

            var markerResult = this.markerResultList[name];
            var length = markerResult.length;
            for (var i = 0; i < length; ++i) {

                var layer = markerResult[i];
                if (layer.markerList.length == 1) {

                    layer.onRemove();
                    layer.markerList[0].display(false);
                } else {

                    if (this.layerIcon.hasOwnProperty(name)) {
                        layer.setIcon(this.layerIcon[name]);
                    } else {
                        layer.onAdd();
                    }
                    layer.setClickCallback(this.zoomToLayerFun);
                }
            }
        }
    },

    updateMarkerCluster: function updateMarkerCluster(groupName) {

        if (groupName === undefined) {
            groupName = 'Default';
        }

        if (!this.markerList.hasOwnProperty(groupName)) {
            return;
        }

        this.clearMarkerResult(groupName);

        var markerGroup = this.markerList[groupName];
        var markerResult = this.markerResultList[groupName];

        var length = markerGroup.length;
        for (var i = 0; i < length; ++i) {

            var marker = markerGroup[i];
            marker.update();

            var layer = this.findNearbyCluster(marker, groupName);
            if (layer == null) {
                layer = new CLOUD.Extensions.Layer();
                markerResult.push(layer);
            }

            layer.addMarker(marker);
            marker.display(true);
        }
    },

    updateLayerCluster: function updateLayerCluster() {

        for (var name in this.markerResultList) {

            var markerResult = this.markerResultList[name];
            this.markerResultList[name] = [];

            for (var i = 0; i < markerResult.length; ++i) {

                var marker = markerResult[i];

                var layer = this.findNearbyCluster(marker, name);
                if (layer == null) {
                    layer = new CLOUD.Extensions.Layer();
                    this.markerResultList[name].push(layer);
                }

                layer.addLayer(marker);
                marker.onRemove();
            }
        }
    },

    findNearbyCluster: function findNearbyCluster(marker, groupName) {

        var pos = marker.getPos();

        var markerResult = this.markerResultList[groupName];
        var length = markerResult.length;
        for (var i = 0; i < length; ++i) {

            var layer = markerResult[i];
            var layerPos = layer.getPos();
            var delta = { x: layerPos.x - pos.x, y: layerPos.y - pos.y };
            if (Math.sqrt(delta.x * delta.x + delta.y * delta.y) < this.markerClusterDistance) {
                return layer;
            }
        }

        return null;
    },

    clearMarkerResult: function clearMarkerResult(groupName) {

        if (groupName === undefined) {
            groupName = 'Default';
        }

        if (!this.markerResultList.hasOwnProperty(groupName)) {

            this.markerResultList[groupName] = [];
            return;
        }

        var markerResult = this.markerResultList[groupName];
        var length = markerResult.length;
        for (var i = 0; i < length; ++i) {

            markerResult[i].onRemove();
        }

        this.markerResultList[groupName] = [];
    },

    zoomToLayer: function zoomToLayer(event, layer) {

        var viewer = this.viewer;

        var length = layer.markerList.length;
        var bbox = new THREE.Box3();
        for (var i = 0; i < length; ++i) {

            bbox.expandByPoint(layer.markerList[i].position);
        }

        var center = bbox.getCenter();
        center.applyMatrix4(viewer.getScene().getMatrixGlobal());

        var camera = viewer.camera;
        var cameraPosition = viewer.camera.position.clone();

        var direction = new THREE.Vector3();
        direction.subVectors(center, cameraPosition);
        direction.multiplyScalar(1.0 / this.zoomFactor);

        for (var i = 0; i < this.zoomFactor; ++i) {
            camera.position.addVectors(camera.position, direction);
            camera.target.addVectors(camera.target, direction);
            camera.updateMVP();

            layer.markerList[0].update();
            var pos1 = layer.markerList[0].getPos();

            layer.markerList[1].update();
            var pos2 = layer.markerList[1].getPos();

            var delta = { x: pos1.x - pos2.x, y: pos1.y - pos2.y };
            if (Math.sqrt(delta.x * delta.x + delta.y * delta.y) > this.markerClusterDistance) {
                viewer.render();
                break;
            }
        }

        if (this.layerClickCallback != null) {
            this.layerClickCallback(event, layer);
        }
    }

};
CLOUD.Extensions.MeasureMark = function (id, editor, enableEvent) {

    "use strict";

    this.id = id;
    this.editor = editor;
    this.enableEvent = enableEvent === undefined ? true : enableEvent;
    this.shape = null;
    this.shapeType = 0;
    this.style = CLOUD.Extensions.MeasureMark.getDefaultStyle();

    this.selected = false;
    this.highlighted = false;
    this.highlightColor = '#000088';
    this.isDisableInteractions = false;

    this.onMouseDownBinded = this.onMouseDown.bind(this);
    this.onMouseMoveBinded = this.onMouseMove.bind(this);
    this.onMouseUpBinded = this.onMouseUp.bind(this);

    this.createShape();
    this.addDomEventListeners();
};

CLOUD.Extensions.MeasureMark.prototype = {

    constructor: CLOUD.Extensions.MeasureMark,

    destroy: function destroy() {

        this.removeDomEventListeners();
        this.onMouseDownBinded = null;
        this.onMouseMoveBinded = null;
        this.onMouseUpBinded = null;

        this.deselect();
        this.setParent(null);

        this.editor = null;
        this.position = null;
        this.shape = null;
        this.style = null;
    },

    addDomEventListeners: function addDomEventListeners() {

        if (!this.enableEvent) {
            return;
        }

        this.shape.addEventListener("mousedown", this.onMouseDownBinded, false);
        this.shape.addEventListener("mousemove", this.onMouseMoveBinded, false);
        //this.shape.addEventListener("mouseup", this.onMouseUpBinded, false);
        window.addEventListener("mouseup", this.onMouseUpBinded, false);
    },

    removeDomEventListeners: function removeDomEventListeners() {

        if (!this.enableEvent) {
            return;
        }

        this.shape.removeEventListener("mousedown", this.onMouseDownBinded, false);
        this.shape.removeEventListener("mousemove", this.onMouseMoveBinded, false);
        //this.shape.removeEventListener("mouseup", this.onMouseUpBinded, false);
        window.removeEventListener("mouseup", this.onMouseUpBinded, false);
    },

    onMouseDown: function onMouseDown(event) {

        event.preventDefault();
        event.stopPropagation();

        this.select();
    },

    onMouseMove: function onMouseMove(event) {},

    onMouseUp: function onMouseUp(event) {},

    createShape: function createShape() {},

    set: function set() {},

    clear: function clear() {},

    getClientPosition: function getClientPosition(wPoint) {

        return this.editor.worldToClient(wPoint);
    },

    setParent: function setParent(parent) {

        var shapeEl = this.shape;

        if (shapeEl) {

            if (shapeEl.parentNode) {
                shapeEl.parentNode.removeChild(shapeEl);
            }

            if (parent) {
                parent.appendChild(shapeEl);
            }
        }
    },

    setStyle: function setStyle(style, refresh) {

        this.style = CLOUD.DomUtil.cloneStyle(style);

        if (refresh) {
            this.update();
        }
    },

    isSelected: function isSelected() {

        return this.selected;
    },

    select: function select() {

        if (!this.selected) {

            this.selected = true;
            this.highlight(true);
        }
    },

    deselect: function deselect() {

        this.highlight(false);
        this.selected = false;
    },

    highlight: function highlight(isHighlight) {

        if (this.isDisableInteractions) {
            return;
        }

        this.highlighted = isHighlight;
        this.update();
    },

    disableInteractions: function disableInteractions(disable) {

        this.isDisableInteractions = disable;
    },

    update: function update() {},

    hide: function hide() {

        //this.shape.style.display = "none";

        // if (this.shape.getAttribute("visibility") === 'visible') {
        //     this.shape.setAttribute("visibility", "hidden");
        // }

        if (this.shape.style.display === '') {
            this.shape.style.display = 'none';
        }
    },

    show: function show() {

        //this.shape.style.display = "";

        // if (this.shape.getAttribute("visibility") === 'hidden') {
        //     this.shape.setAttribute("visibility", "visible");
        // }

        if (this.shape.style.display === 'none') {
            this.shape.style.display = '';
        }
    }
};

CLOUD.Extensions.MeasureMark.shapeTypes = { ANCHOR: 0, LINE: 1, LABEL: 2 };

CLOUD.Extensions.MeasureMark.getDefaultStyle = function () {
    var style = {};

    style['stroke-width'] = 2;
    style['stroke-color'] = '#fffaff';
    style['stroke-opacity'] = 1.0;
    style['fill-color'] = '#ff2129';
    style['fill-opacity'] = 1.0;
    style['font-family'] = 'Arial';
    style['font-size'] = 16;
    style['font-style'] = ''; // 'italic'
    style['font-weight'] = ''; // 'bold'

    return style;
};

CLOUD.Extensions.MeasureAnchor = function (id, editor, enableEvent) {

    "use strict";

    CLOUD.Extensions.MeasureMark.call(this, id, editor, enableEvent);

    this.shapeType = CLOUD.Extensions.MeasureMark.shapeTypes.ANCHOR;
    this.position = null;
    this.mouseKey = this.editor.mouseKey;
};

CLOUD.Extensions.MeasureAnchor.prototype = Object.create(CLOUD.Extensions.MeasureMark.prototype);
CLOUD.Extensions.MeasureAnchor.prototype.constructor = CLOUD.Extensions.MeasureAnchor;

CLOUD.Extensions.MeasureAnchor.prototype.onMouseDown = function (event) {

    event.preventDefault();
    // event.stopPropagation();

    if (event.button === this.mouseKey.LEFT) {
        this.select();
    }
};

CLOUD.Extensions.MeasureAnchor.prototype.onMouseUp = function (event) {

    event.preventDefault();
    event.stopPropagation();

    if (event.button === this.mouseKey.LEFT) {
        this.deselect();
    }
};

CLOUD.Extensions.MeasureAnchor.prototype.createShape = function () {

    var radius = this.enableEvent ? '15' : '10';
    this.shape = CLOUD.Extensions.Utils.Shape2D.createSvgElement('circle');
    this.shape.setAttribute('r', radius);
};

CLOUD.Extensions.MeasureAnchor.prototype.set = function (position, style, refresh) {

    if (!this.position) {
        this.position = { x: 0, y: 0, z: 0 };
    }

    this.position.x = position.x;
    this.position.y = position.y;
    this.position.z = position.z;

    if (style) {
        this.style = CLOUD.DomUtil.cloneStyle(style);
    }

    if (refresh) {
        this.update();
    }
};

CLOUD.Extensions.MeasureAnchor.prototype.update = function () {

    if (!this.position) {
        this.hide();
        return;
    }

    var strokeWidth = this.style['stroke-width'];
    var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];
    var strokeOpacity = this.style['stroke-opacity'];
    var fillColor = this.style['fill-color'];
    var fillOpacity = this.style['fill-opacity'];

    var position = this.getClientPosition(this.position);

    var offsetX = position.x;
    var offsetY = position.y;

    var transformShape = ['translate(', offsetX, ',', offsetY, ') '].join('');

    this.shape.setAttribute("transform", transformShape);
    this.shape.setAttribute("stroke-width", strokeWidth);
    this.shape.setAttribute("stroke", strokeColor);
    this.shape.setAttribute("stroke-opacity", strokeOpacity);
    this.shape.setAttribute('fill', fillColor);
    this.shape.setAttribute('fill-opacity', fillOpacity);

    this.show();

    // if (this.shape.getAttribute("visibility") === 'hidden') {
    //     this.shape.setAttribute("visibility", "visible");
    // }
};

CLOUD.Extensions.MeasureAnchor.prototype.clear = function () {

    this.position = null;
};

CLOUD.Extensions.MeasureLine = function (id, editor, enableEvent) {

    "use strict";

    CLOUD.Extensions.MeasureMark.call(this, id, editor, enableEvent);

    this.shapeType = CLOUD.Extensions.MeasureMark.shapeTypes.LINE;
    this.start = { x: 0, y: 0, z: 0 };
    this.end = { x: 0, y: 0, z: 0 };
};

CLOUD.Extensions.MeasureLine.prototype = Object.create(CLOUD.Extensions.MeasureMark.prototype);
CLOUD.Extensions.MeasureLine.prototype.constructor = CLOUD.Extensions.MeasureLine;

CLOUD.Extensions.MeasureLine.prototype.createShape = function () {
    this.shape = CLOUD.Extensions.Utils.Shape2D.createSvgElement('polyline');
};

CLOUD.Extensions.MeasureLine.prototype.set = function (start, end, style, refresh) {

    if (!this.start) {

        this.start = { x: 0, y: 0, z: 0 };
        this.end = { x: 0, y: 0, z: 0 };
    }

    this.start.x = start.x;
    this.start.y = start.y;
    this.start.z = start.z;

    this.end.x = end.x;
    this.end.y = end.y;
    this.end.z = end.z;

    if (style) {
        this.style = CLOUD.DomUtil.cloneStyle(style);
    }

    if (refresh) {
        this.update();
    }
};

CLOUD.Extensions.MeasureLine.prototype.update = function () {

    if (!this.start) {
        // this.shape.style.display = 'none';
        this.hide();
        return;
    }

    var strokeWidth = this.style['stroke-width'];
    var strokeColor = this.style['fill-color']; //this.style['stroke-color'];
    var strokeOpacity = this.style['stroke-opacity'];
    // var fillColor = this.style['fill-color'];
    // var fillOpacity = this.style['fill-opacity'];

    var start = this.getClientPosition(this.start);
    var end = this.getClientPosition(this.end);

    var pointsStr = start.x + ',' + start.y + ' ' + end.x + ',' + end.y;

    this.shape.setAttribute('points', pointsStr);
    this.shape.setAttribute("stroke-width", strokeWidth);
    this.shape.setAttribute("stroke", strokeColor);
    this.shape.setAttribute("stroke-opacity", strokeOpacity);
    // this.shape.setAttribute('fill', fillColor);
    // this.shape.setAttribute('fill-opacity', fillOpacity);

    this.show();

    // if (this.shape.getAttribute("visibility") === 'hidden') {
    //     this.shape.setAttribute("visibility", "visible");
    // }
};

CLOUD.Extensions.MeasureLine.prototype.clear = function () {

    this.start = null;
    this.end = null;
};

CLOUD.Extensions.MeasureLabel = function (id, editor, enableEvent) {

    "use strict";

    CLOUD.Extensions.MeasureMark.call(this, id, editor, enableEvent);

    this.shapeType = CLOUD.Extensions.MeasureMark.shapeTypes.LABEL;
    this.position = null;
};

CLOUD.Extensions.MeasureLabel.prototype = Object.create(CLOUD.Extensions.MeasureMark.prototype);
CLOUD.Extensions.MeasureLabel.prototype.constructor = CLOUD.Extensions.MeasureLabel;

CLOUD.Extensions.MeasureLabel.prototype.createShape = function () {

    this.shape = CLOUD.Extensions.Utils.Shape2D.createSvgElement('text');
};

CLOUD.Extensions.MeasureLabel.prototype.set = function (position, text, style, refresh) {

    if (!this.position) {
        this.position = { x: 0, y: 0, z: 0 };
    }

    this.position.x = position.x;
    this.position.y = position.y;
    this.position.z = position.z;

    this.text = text;

    if (style) {
        this.style = CLOUD.DomUtil.cloneStyle(style);
    }

    if (refresh) {
        this.update();
    }
};

CLOUD.Extensions.MeasureLabel.prototype.update = function () {

    if (!this.position) {
        this.hide();
        return;
    }

    var fontSize = this.style['font-size'];
    // var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];
    // var strokeOpacity = this.style['stroke-opacity'];
    var fillColor = this.style['fill-color'];
    var fillOpacity = this.style['fill-opacity'];

    var position = this.getClientPosition(this.position);

    var offsetX = position.x + 20;
    var offsetY = position.y + 0.5 * fontSize;

    var transformShape = ['translate(', offsetX, ',', offsetY, ') '].join('');

    this.shape.setAttribute("transform", transformShape);
    this.shape.setAttribute("font-family", this.style['font-family']);
    this.shape.setAttribute("font-size", fontSize);
    this.shape.setAttribute('font-weight', this.style['font-weight']);
    this.shape.setAttribute("font-style", this.style['font-style']);
    this.shape.setAttribute("fill", CLOUD.Extensions.Utils.Shape2D.getRGBAString(fillColor, fillOpacity));

    this.show();

    // if (this.shape.getAttribute("visibility") === 'hidden') {
    //     this.shape.setAttribute("visibility", "visible");
    // }

    if (!this.textPan) {
        this.textPan = CLOUD.Extensions.Utils.Shape2D.createSvgElement('tspan');
        this.shape.appendChild(this.textPan);
    }

    this.textPan.textContent = this.text;
};

CLOUD.Extensions.MeasureLabel.prototype.clear = function () {

    this.position = null;
};
CLOUD.Extensions.MeasureEditor = function (viewer, options) {

    "use strict";

    this.viewer = viewer;
    this.options = options;
    this.cameraControl = viewer.cameraControl;
    this.scene = viewer.getScene();
    this.domElement = viewer.domElement;
    this.nextId = 0;

    this.lastMouse = { x: 0, y: 0 };
    this.mouseKey = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

    this._onMouseDownBinded = this._onMouseDown.bind(this);
    this._onMouseMoveBinded = this._onMouseMove.bind(this);
    this._onMouseUpBinded = this._onMouseUp.bind(this);

    this._init();
};

// 获得容器边框
CLOUD.Extensions.MeasureEditor.prototype._addDomEventListeners = function () {

    this.svg.addEventListener('mousedown', this._onMouseDownBinded, false);
    this.svg.addEventListener('mousemove', this._onMouseMoveBinded, false);
    this.svg.addEventListener('mouseup', this._onMouseUpBinded, false);
};

CLOUD.Extensions.MarkerEditor.prototype._removeDomEventListeners = function () {

    this.svg.removeEventListener('mousedown', this._onMouseDownBinded, false);
    this.svg.removeEventListener('mousemove', this._onMouseMoveBinded, false);
    this.svg.removeEventListener('mouseup', this._onMouseUpBinded, false);
};

CLOUD.Extensions.MeasureEditor.prototype._onMouseDown = function (event) {

    if (event.button === this.mouseKey.LEFT) {

        this.lastMouse.x = event.clientX;
        this.lastMouse.y = event.clientY;
    }
};

CLOUD.Extensions.MeasureEditor.prototype._onMouseMove = function (event) {

    if (!this.anchorHolder.isSelected()) {
        return;
    }

    // var deltaX = Math.abs(this.lastMouse.x - event.clientX);
    // var deltaY = Math.abs(this.lastMouse.y - event.clientY);
    //
    // if (deltaX > 2 || deltaY > 2) {
    //
    //     this._pick(event);
    //
    // }

    event.preventDefault();
    event.stopPropagation();

    if (this.lastMouse.x !== event.clientX || this.lastMouse.y !== event.clientY) {
        this._pick(event);
    }

    this.lastMouse.x = event.clientX;
    this.lastMouse.y = event.clientY;
};

CLOUD.Extensions.MeasureEditor.prototype._onMouseUp = function (event) {

    if (this.anchorHolder.isSelected()) {
        this.anchorHolder.deselect();
    }

    if (event.button === this.mouseKey.LEFT) {

        var deltaX = Math.abs(this.lastMouse.x - event.clientX);
        var deltaY = Math.abs(this.lastMouse.y - event.clientY);

        if (deltaX < 2 && deltaY < 2) {
            this._pick(event);
        }

        this.lastMouse.x = event.clientX;
        this.lastMouse.y = event.clientY;
    }
};

// 生成标识ID
CLOUD.Extensions.MeasureEditor.prototype._generateId = function () {

    ++this.nextId;
    var id = this.nextId.toString(10);

    return id;
};

// CLOUD.Extensions.MeasureEditor.prototype._pick = function (event) {
//
//     var scene = this.scene;
//
//     if (!scene) {
//         console.log("WebViewer.js is not imported!");
//         return;
//     }
//
//     var cameraControl = this.cameraControl;
//     // var camera = cameraControl.camera;
//
//     if (cameraControl.enabled === false)
//         return false;
//
//     var scope = this;
//
// 	var clientPos = new THREE.Vector2(event.clientX, event.clientY);
// 	var pickContext = cameraControl.getIntersectContext(clientPos);
//     var screenX = event.clientX;
//     var screenY = event.clientY;
//
//     cameraControl.intersector.pick(pickContext, function (intersect) {
//
//         if (!intersect) {
//             return;
//         }
//
//         // 将位置和包围转换到世界系
//         scene.intersectToWorld(intersect);
//
//         intersect.cx = screenX;
//         intersect.cy = screenY;
//
//         var meshNode = intersect.object;
//
//         // var sceneMatrix = scene.getMatrixGlobal();
//         var origin = intersect.point.clone();
//         var geometry = meshNode.geometry;
//         var position = geometry.attributes.position;
//
//         var vA = new THREE.Vector3();
//         var vB = new THREE.Vector3();
//         var vC = new THREE.Vector3();
//
//         vA.fromBufferAttribute( position, intersect.face.a );
//         vB.fromBufferAttribute( position, intersect.face.b );
//         vC.fromBufferAttribute( position, intersect.face.c );
//
//         // vA.applyMatrix4(sceneMatrix);
//         // vB.applyMatrix4(sceneMatrix);
//         // vC.applyMatrix4(sceneMatrix);
//
//         var matrixWorld = meshNode.matrixWorld;
//         vA.applyMatrix4(matrixWorld);
//         vB.applyMatrix4(matrixWorld);
//         vC.applyMatrix4(matrixWorld);
//
//         var edge1 = new THREE.Vector3();
//         var edge2 = new THREE.Vector3();
//         var normal = new THREE.Vector3();
//
//         edge1.subVectors( vB, vA );
//         edge2.subVectors( vC, vA );
//         normal.crossVectors( edge1, edge2 ).normalize();
//
//         // console.log("normal", normal);
//
//         // var direction = intersect.face.normal.clone();
//         // direction.applyMatrix4(sceneMatrix);
//         var direction = normal;
//         // direction.transformDirection(camera.matrixWorld);
//
//         var posStart, posEnd;
//
//         var intersectEnd = cameraControl.intersector.getIntersectByRay(
// 									pickContext, {origin: origin, direction: direction});
//
//         if (intersectEnd) {
//             // 将位置和包围转换到世界系
//             scene.intersectToWorld(intersectEnd);
//             posEnd = intersectEnd.worldPosition;
//         } else {
//             posEnd = intersect.worldPosition;
//         }
//
//         posStart = intersect.worldPosition;
//
//         scope._set(posStart, posEnd);
//     });
// };


CLOUD.Extensions.MeasureEditor.prototype._pick = function (event) {

    var scene = this.scene;

    if (!scene) {
        console.log("WebViewer.js is not imported!");
        return;
    }

    var cameraControl = this.cameraControl;

    if (cameraControl.enabled === false) return false;

    var scope = this;

    var clientPos = new THREE.Vector2(event.clientX, event.clientY);
    var pickContext = cameraControl.getIntersectContext(clientPos);
    var screenX = event.clientX;
    var screenY = event.clientY;

    cameraControl.intersector.pick(pickContext, function (intersect) {

        if (!intersect) {
            return;
        }

        // 将位置和包围转换到世界系
        scene.intersectToWorld(intersect);

        intersect.cx = screenX;
        intersect.cy = screenY;

        var posStart, posEnd;

        var intersectIds = [];
        intersectIds.push(intersect.userId);

        posStart = intersect.worldPosition;

        // 计算第二个构件
        var sceneMatrix = scene.getMatrixGlobal();
        var direction = intersect.face.normal.clone();
        var origin = intersect.worldPosition.clone();
        var ray = new THREE.Ray(origin, direction);

        ray.applyMatrix4(sceneMatrix);

        var intersectEnd = cameraControl.intersector.getIntersectByRay(pickContext, ray);

        if (intersectEnd) {
            // 将位置和包围转换到世界系
            scene.intersectToWorld(intersectEnd);
            posEnd = intersectEnd.worldPosition;
            intersectIds.push(intersectEnd.userId);
        } else {
            posEnd = intersect.worldPosition;
        }

        scope._set(posStart, posEnd);

        if (scope.options && scope.options.pickedCallback) {
            scope.options.pickedCallback(intersectIds);
        }
    });
};

CLOUD.Extensions.MeasureEditor.prototype._init = function () {

    this.anchorHolder = new CLOUD.Extensions.MeasureAnchor(this._generateId(), this, true);
    this.anchor = new CLOUD.Extensions.MeasureAnchor(this._generateId(), this, false);
    this.line = new CLOUD.Extensions.MeasureLine(this._generateId(), this, false);
    this.label = new CLOUD.Extensions.MeasureLabel(this._generateId(), this, false);

    var bounds = this._getDomContainerBounds();
    var svgWidth = bounds.width;
    var svgHeight = bounds.height;

    this.svg = CLOUD.Extensions.Utils.Shape2D.createSvgElement('svg');
    this.svg.style.position = "absolute";
    this.svg.style.display = "block";
    this.svg.style.position = "absolute";
    this.svg.style.display = "block";
    this.svg.style.left = "0";
    this.svg.style.top = "0";
    this.svg.setAttribute('width', svgWidth + '');
    this.svg.setAttribute('height', svgHeight + '');

    this.domElement.appendChild(this.svg);

    this.svgGroup = CLOUD.Extensions.Utils.Shape2D.createSvgElement('g');
    this.svg.appendChild(this.svgGroup);

    this.anchorHolder.setParent(this.svgGroup);
    this.anchor.setParent(this.svgGroup);
    this.line.setParent(this.svgGroup);
    this.label.setParent(this.svgGroup);

    this._addDomEventListeners();

    this.reset();
};

CLOUD.Extensions.MeasureEditor.prototype._appendSvgNode = function () {

    if (!this.svg.parentNode) {
        this.domElement.appendChild(this.svg);
    }
};

CLOUD.Extensions.MeasureEditor.prototype._removeSvgNode = function () {

    if (this.svg.parentNode) {
        this.svg.parentNode.removeChild(this.svg);
    }
};

CLOUD.Extensions.MeasureEditor.prototype._set = function (start, end) {

    var half = { x: 0.5 * (start.x + end.x), y: 0.5 * (start.y + end.y), z: 0.5 * (start.z + end.z) };

    var text = Math.abs(start.x - end.x);
    text += Math.abs(start.y - end.y);
    text += Math.abs(start.z - end.z);
    text = Math.round(text);
    text += ' mm';

    this.anchorHolder.set(start);
    this.anchor.set(end);
    this.line.set(start, end);
    this.label.set(half, text);
    this.update();
};

// 获得容器边框
CLOUD.Extensions.MeasureEditor.prototype._getDomContainerBounds = function () {

    return CLOUD.DomUtil.getContainerOffsetToClient(this.domElement);
};

CLOUD.Extensions.MeasureEditor.prototype.destroy = function () {

    this.anchorHolder.destroy();
    this.anchorHolder = null;

    this.anchor.destroy();
    this.anchor = null;

    this.line.destroy();
    this.line = null;

    this.label.destroy();
    this.label = null;

    this._removeDomEventListeners();
    this._onMouseDownBinded = null;
    this._onMouseMoveBinded = null;
    this._onMouseUpBinded = null;

    if (this.svgGroup && this.svgGroup.parentNode) {
        this.svgGroup.parentNode.removeChild(this.svgGroup);
    }

    if (this.svg.parentNode) {
        this.svg.parentNode.removeChild(this.svg);
    }

    this.svgGroup = null;
    this.svg = null;

    this.cameraControl = null;
    this.scene = null;
    this.domElement = null;
    this.viewer = null;
};

CLOUD.Extensions.MeasureEditor.prototype.resize = function () {

    if (!this.domElement) return;

    var bounds = this._getDomContainerBounds();

    this.svg.setAttribute('width', bounds.width + '');
    this.svg.setAttribute('height', bounds.height + '');

    this.update();
};

CLOUD.Extensions.MeasureEditor.prototype.reset = function () {

    if (this.anchorHolder.isSelected()) {
        this.anchorHolder.deselect();
    }

    this.anchorHolder.clear();
    this.anchor.clear();
    this.line.clear();
    this.label.clear();

    this.update();
};

CLOUD.Extensions.MeasureEditor.prototype.setStyle = function (style) {

    this.anchorHolder.setStyle(style);
    this.anchor.setStyle(style);
    this.line.setStyle(style);
    this.label.setStyle(style);
    this.update();
};

CLOUD.Extensions.MeasureEditor.prototype.setStyles = function (styles) {

    this.anchorHolder.setStyle(styles.anchorHolder);
    this.anchor.setStyle(styles.anchor);
    this.line.setStyle(styles.line);
    this.label.setStyle(styles.label);
    this.update();
};

CLOUD.Extensions.MeasureEditor.prototype.update = function () {

    if (this.domElement) {

        var anchorPosition = this.anchor.position;

        if (anchorPosition) {

            // 是否在相机视锥内
            if (this.worldToClient(anchorPosition)) {

                this.anchor.update();
                this.anchorHolder.update();
                this.line.update();
                this.label.update();
            } else {

                this.anchor.hide();
                this.anchorHolder.update();
                this.line.hide();
                this.label.hide();
            }

            this.showGroup();
        } else {

            // this.anchor.hide();
            // this.anchorHolder.hide();
            // this.line.hide();
            // this.label.hide();

            this.hideGroup();
        }
    }
};

CLOUD.Extensions.MeasureEditor.prototype.worldToClient = function (wPoint) {

    // var scene = this.scene;
    // var cameraControl = this.cameraControl;
    // var sceneMatrix = scene.getMatrixGlobal();
    // var bounds = this._getDomContainerBounds();
    //
    // var tmp = new THREE.Vector3(wPoint.x, wPoint.y, wPoint.z);
    // tmp.applyMatrix4(sceneMatrix);
    //
    // var result = cameraControl.worldToLocal(tmp, bounds.width, bounds.height);
    //
    // return result;

    return this.viewer.worldToCanvas(wPoint);
};

CLOUD.Extensions.MeasureEditor.prototype.activate = function () {
    this._appendSvgNode();
};

CLOUD.Extensions.MeasureEditor.prototype.deactivate = function () {
    this.reset();
    this._removeSvgNode();
};

CLOUD.Extensions.MeasureEditor.prototype.hideGroup = function () {

    // if (this.svgGroup && this.svgGroup.getAttribute("visibility") === 'visible') {
    //     this.svgGroup.setAttribute("visibility", "hidden");
    // }

    if (this.svgGroup && this.svgGroup.style.display === '') {
        this.svgGroup.style.display = 'none';
    }
};

CLOUD.Extensions.MeasureEditor.prototype.showGroup = function () {

    // if (this.svgGroup && this.svgGroup.getAttribute("visibility") === 'hidden') {
    //     this.svgGroup.setAttribute("visibility", "visible");
    // }

    if (this.svgGroup && this.svgGroup.style.display === 'none') {
        this.svgGroup.style.display = '';
    }
};

/**
 * 测量辅助类
 * @class  CLOUD.Extensions.MeasureHelper
 * @param {Object} viewer - 模型浏览类对象
 * @param {Object} [options] - 特定的操作对象
 * @param {Object} [options.pickedCallback(array)] - 构件选中回调函数
 */
CLOUD.Extensions.MeasureHelper = function (viewer, options) {

    "use strict";

    this.viewer = viewer;

    if (options) {
        this.options = options;
    } else {
        this.options = {};
    }
};

/**
 * @lends CLOUD.Extensions.MeasureHelper.prototype
 *
 */
CLOUD.Extensions.MeasureHelper.prototype = {

    constructor: CLOUD.Extensions.MeasureHelper,

    /**
     * 释放资源
     *
     */
    destroy: function destroy() {

        if (this.editor) {
            this.editor.destroy();
        }

        this.editor = null;
        this.viewer = null;

        if (this.options) {
            this.options = null;
        }
    },

    /**
     * 启用
     *
     */
    activate: function activate() {

        if (!this.editor) {
            this.editor = new CLOUD.Extensions.MeasureEditor(this.viewer, this.options);
        }

        this.editor.activate();
    },

    /**
     * 停用
     *
     */
    deactivate: function deactivate() {

        if (this.editor) {
            this.editor.deactivate();
        }
    },

    /**
     * 更新
     *
     */
    update: function update() {

        if (this.editor) {
            this.editor.update();
        }
    },

    /**
     * 重置大小
     *
     */
    resize: function resize() {

        if (this.editor) {
            this.editor.resize();
        }
    },

    /**
     * 重置状态
     *
     */
    reset: function reset() {

        if (this.editor) {
            this.editor.reset();
        }
    },

    /**
     * 设置测量标签元素统一样式风格
     * @param {Object} style - 标签元素的风格
     *      {
     *      'stroke-width': 2,
     *      'stroke-color': '#fffaff',
     *      'stroke-opacity': 1.0,
     *      'fill-color': '#ff2129',
     *      'fill-opacity': 1.0,
     *      'font-family': 'Arial',
     *      'font-size': 16,
     *      'font-style': '',
     *      'font-weight': ''
     *      }
     */
    setStyle: function setStyle(style) {

        if (this.editor) {
            this.editor.setStyle(style);
        }
    },

    /**
     * 设置测量标签元素各自的样式风格
     *
     * @param {Object} styles - 多个标签元素的风格 {anchorHolder: xxx, anchor: xxx, line: xxx, label: xxx}
     */
    setStyles: function setStyles(styles) {

        if (this.editor) {
            this.editor.setStyles(styles);
        }
    }
};
/**
 * 小地图批注辅助类
 * @class  CLOUD.Extensions.MiniMapHelper
 * @param {Object} viewer- 模型浏览类对象
 */
CLOUD.Extensions.MiniMapHelper = function (viewer) {

    "use strict";

    this.viewer = viewer;
    this.miniMaps = {};
    this.defaultMiniMap = null;
};

/**
 * @lends CLOUD.Extensions.MiniMapHelper.prototype
 *
 */
CLOUD.Extensions.MiniMapHelper.prototype = {

    constructor: CLOUD.Extensions.MiniMapHelper,

    /**
     * 释放资源
     *
     */
    destroy: function destroy() {

        // TODO: clear other resources.

        this.destroyAllMiniMap();
        this.viewer = null;
        this.miniMaps = {};
        this.defaultMiniMap = null;
    },

    // ------------------ 小地图API -- S ------------------ //
    /**
     * 创建小地图
     *
     * @param {String} name - 小地图名
     * @param {HTMLElement} domElement - 父容器
     * @param {Number} width - 小地图宽度
     * @param {Number} height - 小地图高度
     * @param {Object} styleOptions - 小地图显示风格
     * @param {function(Object)} callbackCameraChanged - 相机变化回调
     *                                                      ({
     *                                                      position: position,
     *                                                      isInScene : isInScene,
     *                                                      axis: {
     *                                                          abcName: abcName,
     *                                                          numeralName: numeralName,
     *                                                          offsetX: offsetX,
     *                                                          offsetY: offsetY,
     *                                                          offsetZ: offsetZ,
     *                                                          infoX: axisInfoX,
     *                                                          infoY: axisInfoY
     *                                                          }
     *                                                      })
     * @param {function(Object)} callbackClickOnAxisGrid - click 回调
     *                                                      ({
     *                                                          position: position,
     *                                                          abcName: abcName,
     *                                                          numeralName: numeralName,
     *                                                          offsetX: offsetX,
     *                                                          offsetY: offsetY
     *                                                       })
     */
    createMiniMap: function createMiniMap(name, domElement, width, height, styleOptions, callbackCameraChanged, callbackClickOnAxisGrid) {

        var miniMap = this.miniMaps[name];

        if (!miniMap) {
            miniMap = this.miniMaps[name] = new CLOUD.MiniMap(this.viewer);
            miniMap.setCameraChangedCallback(callbackCameraChanged);
            miniMap.setClickOnAxisGridCallback(callbackClickOnAxisGrid);
        }

        domElement = domElement || this.viewer.domElement;

        if (domElement) {
            // 初始化小地图
            miniMap.init(domElement, width, height, styleOptions);
        }

        if (!this.defaultMiniMap) {
            this.defaultMiniMap = this.miniMaps[name];
        }

        //return this.miniMaps[name];
    },

    /**
     *  销毁小地图
     *
     * @param {String} name - 小地图名
     */
    destroyMiniMap: function destroyMiniMap(name) {

        var miniMap = this.miniMaps[name];

        if (miniMap) {

            miniMap.uninit();

            if (this.defaultMiniMap === miniMap) {
                this.defaultMiniMap = null;
            }

            delete this.miniMaps[name];
        }
    },

    /**
     * 销毁所有小地图资源
     *
     */
    destroyAllMiniMap: function destroyAllMiniMap() {

        for (var name in this.miniMaps) {

            this.destroyMiniMap(name);
        }
    },

    /**
     * 将小地图容器从主容器中移除
     *
     * @param {String} name - 小地图名
     */
    removeMiniMap: function removeMiniMap(name) {

        var miniMap = this.miniMaps[name];

        if (miniMap) {
            miniMap.remove();

            //delete this.miniMaps[name];
        }
    },

    /**
     * 将小地图容器附加到主容器中
     *
     * @param {String} name - 小地图名
     */
    appendMiniMap: function appendMiniMap(name) {

        var miniMap = this.miniMaps[name];

        if (miniMap) {
            miniMap.append();
        }
    },

    /**
     * 获得所有的小地图对象
     *
     */
    getMiniMaps: function getMiniMaps() {
        return this.miniMaps;
    },

    /**
     * 获得小地图对象
     *
     * @param {String} name - 小地图名
     */
    getMiniMap: function getMiniMap(name) {

        return this.miniMaps[name];
    },

    /**
     * 绘制小地图
     *
     */
    renderMiniMap: function renderMiniMap() {

        for (var name in this.miniMaps) {
            var miniMap = this.miniMaps[name];

            if (miniMap) {
                miniMap.render();
            }
        }
    },

    /**
     * 设置平面图
     *
     * @param {Object} jsonObj - 平面图数据对象
     */
    setFloorPlaneData: function setFloorPlaneData(jsonObj) {

        CLOUD.MiniMap.setFloorPlaneData(jsonObj);
    },

    /**
     * 构造平面图
     *
     * @param {String} name - 小地图名
     * @param {Boolean} [changeView] - 是否改变视角
     */
    generateFloorPlane: function generateFloorPlane(name, changeView) {
        var miniMap = this.miniMaps[name];

        if (miniMap) {
            miniMap.generateFloorPlane(changeView);
        }
    },

    /**
     * 设置轴网数据
     *
     * @param {Object} jsonObj - 轴网数据对象
     * @param {Number} [level] - 未使用
     */
    setAxisGridData: function setAxisGridData(jsonObj, level) {

        CLOUD.MiniMap.setAxisGridData(jsonObj);
    },

    /**
     * 构造轴网
     *
     * @param {String} name - 小地图名
     */
    generateAxisGrid: function generateAxisGrid(name) {
        var miniMap = this.miniMaps[name];

        if (miniMap) {
            miniMap.generateAxisGrid();
        }
    },

    /**
     * 是否显示隐藏轴网
     *
     * @param {String} name - 小地图名
     * @param {Boolean} enable - 是否显示隐藏， true: 显示， false：隐藏
     */
    showAxisGrid: function showAxisGrid(name, show) {

        var miniMap = this.miniMaps[name];

        if (miniMap) {
            if (show) {
                miniMap.showAxisGird();
            } else {
                miniMap.hideAxisGird();
            }
        }
    },

    /**
     * 是否允许触发轴网事件
     *
     * @param {String} name - 小地图名
     * @param {Boolean} enable - 是否允许
     */
    enableAxisGridEvent: function enableAxisGridEvent(name, enable) {

        var miniMap = this.miniMaps[name];

        if (miniMap) {
            miniMap.enableMouseEvent(enable);
        }
    },

    /**
     * 是否允许显示相机光标
     *
     * @param {String} name - 小地图名
     * @param {Boolean} enable - 是否允许显示
     */
    enableMiniMapCameraNode: function enableMiniMapCameraNode(name, enable) {

        var miniMap = this.miniMaps[name];

        if (miniMap) {
            miniMap.enableCameraNode(enable);
        }
    },

    /**
     * 根据轴号定位
     *
     * @param {String} name - 小地图名
     * @param {String} abcName - 字母轴号
     * @param {String} numeralName - 数字轴号
     */
    flyBypAxisGridNumber: function flyBypAxisGridNumber(name, abcName, numeralName) {

        console.warn('CLOUD.Extensions.MiniMapHelper.flyBypAxisGridNumber() has been deprecated. Use CLOUD.Extensions.MiniMapHelper.flyByAxisGridNumber() instead.');
        return this.flyByAxisGridNumber(name, abcName, numeralName);
    },

    /**
     * 根据轴号定位
     *
     * @param {String} name - 小地图名
     * @param {String} abcName - 字母轴号
     * @param {String} numeralName - 数字轴号
     */
    flyByAxisGridNumber: function flyByAxisGridNumber(name, abcName, numeralName) {

        var miniMap = this.miniMaps[name];

        if (miniMap) {
            return miniMap.flyByAxisGridNumber(abcName, numeralName);
        }

        return false;
    },

    /**
     * 根据指定点获得轴网信息(变换后的点, 一般来着pick点)
     *
     * @param {THREE.Vector3} point - 指定构件包围盒
     */
    getAxisGridInfoByPoint: function getAxisGridInfoByPoint(point) {

        var defaultMiniMap = this.defaultMiniMap;
        var axisGridInfo = null;

        if (defaultMiniMap) {
            axisGridInfo = defaultMiniMap.getAxisGridInfoByPoint(point);
        }

        return axisGridInfo;
    },

    /**
     * 根据相交信息获得轴网信息
     *
     * @param {Object} intersect - 相交信息对象, 来源pick
     */
    getAxisGridInfoByIntersect: function getAxisGridInfoByIntersect(intersect) {

        var defaultMiniMap = this.defaultMiniMap;

        if (defaultMiniMap) {
            intersect.axisGridInfo = defaultMiniMap.getAxisGridInfoByPoint(intersect.point);
        }
    },

    /**
     * 重置小地图大小
     *
     * @param {string} name - 小地图标识名
     * @param {number} width - 宽度
     * @param {number} height - 高度
     */
    resize: function resize(name, width, height) {

        var miniMap = this.miniMaps[name];

        if (miniMap) {
            miniMap.resize(width, height);
        }
    }

    // ------------------ 小地图API -- E ------------------ //
};

/**
 * 标注辅助类
 * @class  CLOUD.Extensions.MarkerHelper
 * @param {Object} viewer - 模型浏览类对象
 */
CLOUD.Extensions.MarkerHelper = function (viewer) {

    "use strict";

    this.viewer = viewer;
    this.markerClickCallback = null;
};

/**
 * @lends CLOUD.Extensions.MarkerHelper.prototype
 *
 */
CLOUD.Extensions.MarkerHelper.prototype = {

    constructor: CLOUD.Extensions.MarkerHelper,

    /**
     * 释放资源
     *
     */
    destroy: function destroy() {

        this.uninitMarkerEditor();
        this.markerEditor = null;
        this.markerClickCallback = null;
        this.viewer = null;
    },

    /**
     * 初始化Marker
     *
     */
    initMarkerEditor: function initMarkerEditor() {

        var viewer = this.viewer;

        if (!this.markerEditor) {

            this.markerEditor = new CLOUD.Extensions.MarkerEditor(viewer);
        }

        if (!this.markerEditor.isInitialized()) {

            this.markerEditor.init();
        }

        if (this.markerClickCallback) {
            this.markerEditor.setMarkerClickCallback(this.markerClickCallback);
        }
    },

    /**
     * 卸载Marker
     *
     */
    uninitMarkerEditor: function uninitMarkerEditor() {

        if (this.markerEditor && this.markerEditor.isInitialized()) {

            this.markerEditor.uninit();
        }
    },

    /**
     * zoom 到  markers 包围盒大小
     *
     */
    zoomToSelectedMarkers: function zoomToSelectedMarkers() {

        if (this.markerEditor) {

            var bBox = this.markerEditor.getMarkersBoundingBox();

            if (bBox) {
                this.viewer.zoomToBBox(bBox, 0.05);
            }

            this.markerEditor.updateMarkers();
        }
    },

    /**
     * 加载标记
     *
     * @param {Array} markerInfoList - marker 列表
     */
    loadMarkers: function loadMarkers(markerInfoList) {

        if (markerInfoList) {

            this.initMarkerEditor();
            this.markerEditor.loadMarkers(markerInfoList);
        } else {

            this.uninitMarkerEditor();
        }
    },

    /**
     * 从picker中添加一个标记
     *
     * @param {Object} intersect - pick 选点
     * @param {Number} shapeType - 形状类型 ({BUBBLE: 0, FLAG: 1, COMMON:2})
     * @param {Number} state - 颜色状态
     */
    loadMarkerFromIntersect: function loadMarkerFromIntersect(intersect, shapeType, state) {

        if (intersect) {

            this.initMarkerEditor();
            this.markerEditor.createMarkerByIntersect(intersect, shapeType, state);
        }
    },

    loadMarkerFromPosition: function loadMarkerFromPosition(position, userId, box3Min, box3Max, shapeType, state) {

        if (position && userId) {

            var intersect = {
                worldPosition: position,
                userId: userId,
                worldBoundingBox: new THREE.Box3(box3Min, box3Max)
            };

            this.initMarkerEditor();
            this.markerEditor.createMarkerByIntersect(intersect, shapeType, state);
        }
    },

    /**
     * 从picker中加载标记
     *
     * @param {Object} intersect - pick 选点
     * @param {Number} shapeType - 形状类型 ({BUBBLE: 0, FLAG: 1, COMMON:2})
     * @param {Number} state - 颜色状态
     */
    loadMarkersFromIntersect: function loadMarkersFromIntersect(intersect, shapeType, state) {

        if (intersect) {

            this.initMarkerEditor();
            this.markerEditor.loadMarkersFromIntersect(intersect, shapeType, state);
        } else {

            this.uninitMarkerEditor();
        }
    },

    /**
     * 获得标记列表
     *
     */
    getMarkerInfoList: function getMarkerInfoList() {

        if (this.markerEditor) {

            return this.markerEditor.getMarkerInfoList();
        }

        return null;
    },

    /**
     * resize
     *
     */
    resizeMarkers: function resizeMarkers() {

        if (this.markerEditor) {

            return this.markerEditor.onResize();
        }
    },

    /**
     * 绘制 markers
     *
     */
    renderMarkers: function renderMarkers() {

        if (this.markerEditor) {

            return this.markerEditor.updateMarkers();
        }
    },

    /**
     * 获得所有 marker 的包围盒
     *
     */
    getMarkersBoundingBox: function getMarkersBoundingBox() {

        if (this.markerEditor) {

            return this.markerEditor.getMarkersBoundingBox();
        }
    },

    hideMarkerByUserId: function hideMarkerByUserId(userId) {
        if (this.markerEditor) {
            var marker = this.markerEditor.getMarkerByUserId(userId);
            marker.shape["style"].display = "none";
        }
    },

    hideAllMarker: function hideAllMarker() {
        if (this.markerEditor) {
            this.markerEditor.svg["style"].display = "none";
        }
    },

    showMarkerByUserId: function showMarkerByUserId(userId) {
        if (this.markerEditor) {
            var marker = this.markerEditor.getMarkerByUserId(userId);
            marker.shape["style"].display = "";
        }
    },

    showAllMarker: function showAllMarker() {
        if (this.markerEditor) {
            this.markerEditor.svg["style"].display = "";
        }
    },

    selectMarkerByUserId: function selectMarkerByUserId(userIdid) {

        if (this.markerEditor) {
            var marker = this.markerEditor.getMarkerByUserId(userIdid);
            marker.highlight(true);
            this.markerEditor.selectMarker(marker);
        }
    },

    deleteMarkerByUserId: function deleteMarkerByUserId(userIdid) {

        if (this.markerEditor) {
            var marker = this.markerEditor.getMarkerByUserId(userIdid);
            this.markerEditor.deleteMarker(marker);
        }
    },

    deleteSelectMarker: function deleteSelectMarker() {

        if (this.markerEditor && this.markerEditor.selectedMarker) {
            this.markerEditor.deleteMarker(this.markerEditor.selectedMarker);
        }
    },

    /**
     * 设置marker click 回调
     *
     * @param {function(Object)} callback - 回调函数
     * @param {Object} callback(Object) - 回调函数参数 ({id: id, userId: userId, shapeType: shapeType, position: position, boundingBox: boundingBox})
     */
    setMarkerClickCallback: function setMarkerClickCallback(callback) {

        this.markerClickCallback = callback;
    }

};
/**
 * DWG批注辅助类
 * @class  CLOUD.Extensions.DwgHelper
 * @param {Object} options - 特定的操作对象, 例如指定回调函数 options.popupCallback
 */
CLOUD.Extensions.DwgHelper = function (options) {

    "use strict";

    this.dwgContainer = null;
    this.annotationContainer = null;
    this.defaultStyle = {
        'stroke-width': 3,
        'stroke-color': '#ff0000',
        'stroke-opacity': 1.0,
        'fill-color': '#ff0000',
        'fill-opacity': 0.0,
        'font-family': 'Arial',
        'font-size': 16,
        'font-style': '',
        'font-weight': ''
    };
    this.isDblClickCloseCloud = true;
    this.options = options;
};

/**
 * @lends CLOUD.Extensions.DwgHelper.prototype
 *
 */
CLOUD.Extensions.DwgHelper.prototype = {

    constructor: CLOUD.Extensions.DwgHelper,

    /**
     * 释放资源
     *
     */
    destroy: function destroy() {

        this.uninitAnnotation();
        this.editor = null;
        this.dwgContainer = null;
        this.annotationContainer = null;
        this.options = null;
    },

    /**
     * 设置DWG批注容器, 在使用批注功能前，需要先设置dom容器
     *
     * @param {HTMLElement} dwgContainer - dwg 图纸容器
     * @param {HTMLElement} domContainer - 绘制批注的主容器
     */
    setDomContainer: function setDomContainer(dwgContainer, annotationContainer) {

        this.dwgContainer = dwgContainer;

        if (annotationContainer) {
            this.annotationContainer = annotationContainer;
        } else {
            this.annotationContainer = dwgContainer;
        }
    },

    /**
     * 初始化DWG批注
     *
     * @param {function(domElement)} [beginEditCallback] - 开始编辑时回调函数
     * @param {function(domElement)} [endEditCallback] - 结束编辑时回调函数
     */
    initAnnotation: function initAnnotation(beginEditCallback, endEditCallback) {

        var scope = this;
        var domElement = this.annotationContainer;
        var options = this.options;

        if (!this.editor) {

            this.editor = new CLOUD.Extensions.AnnotationEditor2D(domElement, options);
        } else {

            // 设置父容器
            this.editor.setDomContainer(domElement);
        }

        this.editor.enableDblClickCloseCloud(this.isDblClickCloseCloud);

        if (!this.editor.isInitialized()) {

            var callbacks = {
                beginEditCallback: beginEditCallback,
                endEditCallback: endEditCallback,
                changeEditorModeCallback: function changeEditorModeCallback() {
                    scope.uninitAnnotation();
                }
            };

            this.editor.init(callbacks);
            this.editor.setSvgZIndex();

            callbacks = null;
        }
    },

    /**
     * 卸载DWG批注资源
     *
     */
    uninitAnnotation: function uninitAnnotation() {

        if (this.editor && this.editor.isInitialized()) {

            this.editor.uninit();
        }
    },

    /**
     * 设置背景色，支持过渡色
     *
     * @param {Color} [startColor] - 过渡色1（16进制颜色值）
     * @param {Color} [stopColor] - 过渡色2 （16进制颜色值）
     */
    setAnnotationBackgroundColor: function setAnnotationBackgroundColor(startColor, stopColor) {

        if (this.editor) {

            this.editor.setBackgroundColor(startColor, stopColor);
        }
    },

    /**
     * 开始编辑DWG批注
     *
     * @param {Object} [pointToCenter] - 绝对基准点 {x: x, y: y}, 相对于某个可参考的绝对位置点(根据情况选定)。如果 absBasePoint 未定义，则默认为 {x: 0, y: 0}
     * @param {function(domElement)} [beginEditCallback] - 开始编辑时回调函数
     * @param {function(domElement)} [endEditCallback] - 结束编辑时回调函数
     */
    editAnnotationBegin: function editAnnotationBegin(pointToCenter, beginEditCallback, endEditCallback) {

        // 如果没有设置批注模式，则自动进入批注模式
        this.initAnnotation(beginEditCallback, endEditCallback);

        if (pointToCenter) {
            this.editor.setAbsoluteBasePoint(pointToCenter);
        }

        this.editor.editBegin();
    },

    /**
     * 完成编辑
     *
     */
    editAnnotationEnd: function editAnnotationEnd() {

        if (this.editor) {

            this.editor.editEnd();
        }
    },

    /**
     * 设置批注类型
     *
     * @param {Int} type - 批注类型（{ARROW: 0, RECTANGLE: 1, CIRCLE: 2, CROSS: 3, CLOUD: 4, TEXT: 5}）
     */
    setAnnotationType: function setAnnotationType(type) {

        if (this.editor) {

            this.editor.setAnnotationType(type);
        }
    },

    /**
     * 设置批注风格
     *
     * @param {Object} style - 批注风格 （{'stroke-width': 3,'stroke-color': '#ff0000','stroke-opacity': 1.0,'fill-color': '#ff0000', 'font-size': 16}）
     * @param {Object} [updateText] - 是否刷新文本风格
     */
    setAnnotationStyle: function setAnnotationStyle(style, updateText) {

        if (this.editor) {

            for (var attr in style) {

                if (attr in this.defaultStyle) {
                    this.defaultStyle[attr] = style[attr];
                }
            }

            this.editor.setAnnotationStyle(this.defaultStyle, updateText);
        }
    },

    /**
     * 加载批注
     *
     * @param {Array} [annotations] - 批注列表
     *                          ({  id: id,
     *                              shapeType: shapeType,
     *                              position: position,
     *                              size: size,
     *                              rotation: rotation,
     *                              shapePoints: shapePoints,
     *                              originSize: originSize,
     *                              style: style,
     *                              text: text
     *                          })
     * @param {Object} [absBasePoint] - 绝对基准点 {x: x, y: y}, 相对于某个可参考的绝对位置点(根据情况选定)。如果 absBasePoint 未定义，则默认为 {x: 0, y: 0}
     * @param {function(domElement)} [beginEditCallback] - 开始编辑时回调函数
     * @param {function(domElement)} [endEditCallback] - 结束编辑时回调函数
     */
    loadAnnotations: function loadAnnotations(annotations, absBasePoint, beginEditCallback, endEditCallback) {

        if (annotations) {

            this.initAnnotation(beginEditCallback, endEditCallback);

            if (absBasePoint) {
                this.editor.setAbsoluteBasePoint(absBasePoint);
            }

            this.editor.loadAnnotations(annotations);
        } else {
            this.uninitAnnotation();
        }
    },

    /**
     * 获得批注对象列表
     *
     * @return {Array} 批注对象列表
     */
    getAnnotationInfoList: function getAnnotationInfoList() {

        if (this.editor) {

            return this.editor.getAnnotationInfoList();
        }

        return null;
    },

    /**
     * resize
     *
     */
    resizeAnnotations: function resizeAnnotations() {

        if (this.editor && this.editor.isInitialized()) {

            this.editor.onResize();
        }
    },

    /**
     * 状态变化 - 清除批注
     *
     */
    clearAnnotations: function clearAnnotations() {

        if (this.editor && this.editor.isInitialized()) {

            this.editor.onCameraChange();
        }
    },

    /**
     * 特殊处理 - 是否允许双击关闭云图批注
     *
     * @param {Boolean} enable - 是否允许双击封闭云图, true:允许
     */
    enableDblClickCloseCloud: function enableDblClickCloseCloud(enable) {

        this.isDblClickCloseCloud = enable;
    },

    /**
     * 截屏 base64 格式png图片
     *
     * @param {function(data)} snapshotCallback - 回调
     */
    captureAnnotationsScreenSnapshot: function captureAnnotationsScreenSnapshot(snapshotCallback) {

        var scope = this;
        var isInitialized = this.editor && this.editor.isInitialized();
        var dwgDom = this.dwgContainer;

        if (!dwgDom || !isInitialized) {

            snapshotCallback(null);

            return;
        }

        html2canvas(dwgDom, {
            logging: true,
            onrendered: function onrendered(canvas) {

                var dataUrl = canvas.toDataURL("image/png");

                // fixed bug: 在chrome 版本 57.0.2987.133 (64-bit)上截不到图，采用回调函数处理。
                // dataUrl = scope.editor.getScreenSnapshot(dataUrl);
                // snapshotCallback(dataUrl);
                scope.editor.getScreenSnapshot(dataUrl, snapshotCallback);
            }
        });
    },

    /**
     * 截屏 base64 格式png图片
     *
     * @param {function(data)} snapshotCallback - 回调
     */
    canvas2image: function canvas2image(snapshotCallback) {

        // DWG不能直接返回截屏图片，故这种方式处理不了DWG，回调函数解决
        //var snapshotCallback = function(dataUrl) {
        //
        //    var win = window.open();
        //    var img = new Image();
        //    img.onload = function () {
        //        img.onload = null;
        //        win.document.body.appendChild(img);
        //    };
        //    img.onerror = function () {
        //        img.onerror = null;
        //        if (console.log) {
        //            console.log("Not loaded image from canvas.toDataURL");
        //        } else {
        //            alert("Not loaded image from canvas.toDataURL");
        //        }
        //    };
        //
        //    img.src = dataUrl;
        //};

        this.captureAnnotationsScreenSnapshot(snapshotCallback);
    },

    /**
     * 设置绝对基准点
     *
     * @param {Object} point - 相对某一个绝对位置点的坐标
     */
    setAbsoluteBasePoint: function setAbsoluteBasePoint(point) {

        // 如果初始化，则自动初始化
        this.initAnnotation();

        if (point) {

            this.editor.setAbsoluteBasePoint(point);
        }
    },

    /**
     * 设置屏幕基准点
     *
     * @param {Object} point - 相对 SVG 容器的坐标
     */
    setScreenBasePoint: function setScreenBasePoint(point) {

        // 如果初始化，则自动初始化
        this.initAnnotation();

        if (point) {

            this.editor.setScreenBasePoint(point);
        }
    },

    /**
     * 设置缩放比例
     *
     * @param {Float} factorX - x 方向缩放因子
     * @param {Float} factorY - y 方向缩放因子
     */
    setZoomFactor: function setZoomFactor(factorX, factorY) {

        factorY = factorY || factorX;

        // 如果初始化，则自动初始化
        this.initAnnotation();

        this.editor.setZoomFactor(factorX, factorY);
    },

    /**
     * 设置文字批注文本内容
     *
     * @param {string} text - 弹窗文本
     */
    setTextFromPopupBox: function setTextFromPopupBox(text) {

        if (this.editor) {
            this.editor.setTextFromPopupBox(text);
        }
    },

    /**
     * 取消文字批注文本内容设置
     *
     */
    unsetTextFromPopupBox: function unsetTextFromPopupBox() {

        if (this.editor) {
            this.editor.unsetTextFromPopupBox();
        }
    }

};

/**
 * 2D批注辅助类
 * @class  CLOUD.Extensions.AnnotationHelper2D
 * @param {Object} options - 特定的操作对象, 例如指定回调函数 options.popupCallback
 */
CLOUD.Extensions.AnnotationHelper2D = function (options) {

    "use strict";

    this.domContainer = null;
    this.defaultStyle = {
        'stroke-width': 3,
        'stroke-color': '#ff0000',
        'stroke-opacity': 1.0,
        'fill-color': '#ff0000',
        'fill-opacity': 0.0,
        'font-family': 'Arial',
        'font-size': 16,
        'font-style': '',
        'font-weight': ''
    };
    this.isDblClickCloseCloud = false;
    this.options = options;
};

/**
 * @lends CLOUD.Extensions.AnnotationHelper2D.prototype
 *
 */
CLOUD.Extensions.AnnotationHelper2D.prototype = {

    constructor: CLOUD.Extensions.AnnotationHelper2D,

    /**
     * 释放资源
     *
     */
    destroy: function destroy() {
        this.uninitAnnotation();
        this.editor = null;
        this.domContainer = null;
        this.beginEditCallback = null;
        this.endEditCallback = null;
        this.stateChangeCallback = null;
        this.defaultStyle = null;
        this.options = null;
    },

    /**
     * 设置批注容器, 在使用批注功能前，需要先设置dom容器
     *
     * @param {HTMLElement} domContainer - 绘制批注的主容器
     */
    setDomContainer: function setDomContainer(domContainer) {
        this.domContainer = domContainer;
    },

    /**
     * 设置回调, 如果需要设置，在初始化之前设置
     *
     * @param {function(domElement)} [beginEditCallback] - 开始编辑时回调函数
     * @param {function(domElement)} [endEditCallback] - 结束编辑时回调函数
     * @param {function(domElement)} [stateChangeCallback] - 状态变化时（平移，旋转等操作）回调函数
     */
    setEditCallback: function setEditCallback(beginEditCallback, endEditCallback, stateChangeCallback) {
        this.beginEditCallback = beginEditCallback;
        this.endEditCallback = endEditCallback;
        this.stateChangeCallback = stateChangeCallback;
    },

    /**
     * 初始化, 不用显示调用
     *
     */
    initAnnotation: function initAnnotation() {

        var scope = this;
        var domElement = this.domContainer;
        var options = this.options;

        if (!this.editor) {
            this.editor = new CLOUD.Extensions.AnnotationEditor2D(domElement, options);
        } else {
            // 设置父容器
            this.editor.setDomContainer(domElement);
        }

        this.editor.enableDblClickCloseCloud(this.isDblClickCloseCloud);

        if (!this.editor.isInitialized()) {

            var callbacks = {
                beginEditCallback: scope.beginEditCallback,
                endEditCallback: scope.endEditCallback,
                changeEditorModeCallback: scope.stateChangeCallback
            };

            this.editor.init(callbacks);

            callbacks = null;
        }
    },

    /**
     * 卸载
     *
     */
    uninitAnnotation: function uninitAnnotation() {
        if (this.editor && this.editor.isInitialized()) {
            this.editor.uninit();
        }
    },

    /**
     * 设置背景色，支持过渡色
     *
     * @param {Color} [startColor] - 过渡色1（16进制颜色值）
     * @param {Color} [stopColor] - 过渡色2 （16进制颜色值）
     */
    setAnnotationBackgroundColor: function setAnnotationBackgroundColor(startColor, stopColor) {
        // 如果没有初始化，则自动初始化
        this.initAnnotation();
        this.editor.setBackgroundColor(startColor, stopColor);
    },

    /**
     * 开始编辑
     *
     * @param {Object} [absBasePoint] - 绝对基准点 {x: x, y: y}, 相对于某个可参考的绝对位置点(根据情况选定)。如果 absBasePoint 未定义，则默认为 {x: 0, y: 0}
     * @param {Object} [screenBasePoint] - 屏幕基准点 {x: x, y: y}, 相对于svg容器。 如果 screenBasePoint 未定义，则默认为svg容器的中心点
     * @param {Object} [zoomFactor] - 缩放比例 {x: x, y: y}
     * @remark absBasePoint 和 screenBasePoint 是同一个点在不同参照系下的表达
     */
    editAnnotationBegin: function editAnnotationBegin(absBasePoint, screenBasePoint, zoomFactor) {
        // 如果没有初始化，则自动初始化
        this.initAnnotation();

        if (absBasePoint) {
            this.editor.setAbsoluteBasePoint(absBasePoint);
        }

        if (screenBasePoint) {
            this.editor.setScreenBasePoint(screenBasePoint);
        }

        if (zoomFactor) {
            this.editor.setZoomFactor(zoomFactor.x, zoomFactor.y);
        }

        this.editor.editBegin();
    },

    /**
     * 完成编辑
     *
     */
    editAnnotationEnd: function editAnnotationEnd() {
        if (this.editor) {
            this.editor.editEnd();
        }
    },

    /**
     * 设置批注类型
     *
     * @param {Int} type - 批注类型（{ARROW: 0, RECTANGLE: 1, CIRCLE: 2, CROSS: 3, CLOUD: 4, TEXT: 5}）
     */
    setAnnotationType: function setAnnotationType(type) {
        // 如果没有初始化，则自动初始化
        this.initAnnotation();
        this.editor.setAnnotationType(type);
    },

    /**
     * 设置批注风格
     *
     * @param {Object} style - 批注风格 （{'stroke-width': 3,'stroke-color': '#ff0000','stroke-opacity': 1.0,'fill-color': '#ff0000', 'font-size': 16}）
     * @param {Object} [updateText] - 是否刷新文本风格
     */
    setAnnotationStyle: function setAnnotationStyle(style, updateText) {
        // 如果没有初始化，则自动初始化
        this.initAnnotation();

        for (var attr in style) {

            if (attr in this.defaultStyle) {
                this.defaultStyle[attr] = style[attr];
            }
        }

        this.editor.setAnnotationStyle(this.defaultStyle, updateText);
    },

    /**
     * 加载批注
     *
     * @param {Array} [annotations] - 批注列表
     *                          ({  id: id,
     *                              shapeType: shapeType,
     *                              position: position,
     *                              size: size,
     *                              rotation: rotation,
     *                              shapePoints: shapePoints,
     *                              originSize: originSize,
     *                              style: style,
     *                              text: text
     *                          })
     * @param {Object} [absBasePoint] - 绝对基准点 {x: x, y: y}, 相对于某个可参考的绝对位置点(根据情况选定)。如果 absBasePoint 未定义，则默认为 {x: 0, y: 0}
     * @param {Object} [screenBasePoint] - 屏幕基准点 {x: x, y: y}, 相对于svg容器。 如果 screenBasePoint 未定义，则默认为svg容器的中心点
     * @param {Object} [zoomFactor] - 缩放比例 {x: x, y: y}
     * @remark absBasePoint 和 screenBasePoint 是同一个点在不同参照系下的表达
     */
    loadAnnotations: function loadAnnotations(annotations, absBasePoint, screenBasePoint, zoomFactor) {

        if (annotations) {
            // 如果没有初始化，则自动初始化
            this.initAnnotation();

            if (absBasePoint) {
                this.editor.setAbsoluteBasePoint(absBasePoint);
            }

            if (screenBasePoint) {
                this.editor.setScreenBasePoint(screenBasePoint);
            }

            if (zoomFactor) {
                this.editor.setZoomFactor(zoomFactor.x, zoomFactor.y);
            }

            this.editor.loadAnnotations(annotations);
        } else {
            this.uninitAnnotation();
        }
    },

    /**
     * 获得批注对象列表
     *
     * @return {Array} 批注对象列表
     */
    getAnnotationInfoList: function getAnnotationInfoList() {

        if (this.editor) {
            return this.editor.getAnnotationInfoList();
        }

        return null;
    },

    /**
     * 获得批注信息(带有包围盒信息)
     *
     * @return {Object} 批注信息 {boundingBox: boundingBox, annotations: annotations}
     */
    getAnnotationInfoListWithBox: function getAnnotationInfoListWithBox() {

        if (this.editor) {
            var annotationInfoList = this.editor.getAnnotationInfoList();

            if (annotationInfoList.length === 0) {

                return null;
            }

            var boundingBox = new THREE.Box2();

            // 计算包围盒
            for (var i = 0, len = annotationInfoList.length; i < len; i++) {
                var info = annotationInfoList[i];
                var shapeType = info.shapeType;
                var position = info.position;
                var size = info.size;
                var rotation = info.rotation || 0;

                if (shapeType === CLOUD.Extensions.Annotation.shapeTypes.ARROW) {
                    var dir = new THREE.Vector2(Math.cos(rotation), Math.sin(rotation));
                    dir.multiplyScalar(size.width * 0.5);
                    var center = new THREE.Vector2(position.x, position.y);
                    var tail = center.clone().sub(dir);
                    var head = center.clone().add(dir);

                    tail.y = -tail.y; // 注意: y值要取反，原因是坐标变换时取过反
                    head.y = -head.y;

                    boundingBox.expandByPoint(tail);
                    boundingBox.expandByPoint(head);
                } else {

                    var lt = new THREE.Vector2(position.x - 0.5 * size.width, -position.y - 0.5 * size.height); // 注意: y值要取反，原因是坐标变换时取过反
                    var rb = new THREE.Vector2(position.x + 0.5 * size.width, -position.y + 0.5 * size.height); // 注意: y值要取反，原因是坐标变换时取过反
                    boundingBox.expandByPoint(lt);
                    boundingBox.expandByPoint(rb);
                }
            }

            return { boundingBox: boundingBox, annotations: annotationInfoList };
        }

        return null;
    },

    /**
     * resize
     *
     */
    resizeAnnotations: function resizeAnnotations() {
        if (this.editor && this.editor.isInitialized()) {
            this.editor.onResize();
        }
    },

    /**
     * 状态变化
     *
     */
    renderAnnotations: function renderAnnotations() {
        if (this.editor && this.editor.isInitialized()) {
            this.editor.onCameraChange();
        }
    },

    /**
     * 特殊处理 - 是否允许双击关闭云图批注
     *
     * @param {Boolean} enable - 是否允许双击封闭云图, true:允许
     */
    enableDblClickCloseCloud: function enableDblClickCloseCloud(enable) {
        this.isDblClickCloseCloud = enable;
    },

    /**
     * 截屏 base64 格式png图片
     * 在chrome 版本 57.0.2987.133 (64-bit)上截不到图，估计是图片异步加载的问题, 采用回调函数处理。
     *
     * @param {base64} dataUrl - base64 背景图
     * @param {function(data)} callback - 回调
     * @return 如果定义了callback，则直接返回null，截屏数据作为 callback 函数参数传入，所有需要获得截屏数据之后进行的操作，在callback中处理；
     *          如果没有定义callback, 则直接返回 base64位图片(可能截不到图)
     */
    captureAnnotationsScreenSnapshot: function captureAnnotationsScreenSnapshot(dataUrl, callback) {
        return this.editor.getScreenSnapshot(dataUrl, callback);
    },

    /**
     * 设置绝对基准点
     *
     * @param {Object} point - 相对某一个绝对位置点的坐标
     */
    setAbsoluteBasePoint: function setAbsoluteBasePoint(point) {
        // 如果初始化，则自动初始化
        this.initAnnotation();

        if (point) {
            this.editor.setAbsoluteBasePoint(point);
        }
    },

    /**
     * 设置屏幕基准点
     *
     * @param {Object} point - 相对 SVG 容器的坐标
     */
    setScreenBasePoint: function setScreenBasePoint(point) {
        // 如果初始化，则自动初始化
        this.initAnnotation();

        if (point) {
            this.editor.setScreenBasePoint(point);
        }
    },

    /**
     * 设置缩放比例
     *
     * @param {Float} factorX - x 方向缩放因子
     * @param {Float} factorY - y 方向缩放因子
     */
    setZoomFactor: function setZoomFactor(factorX, factorY) {
        factorY = factorY || factorX;
        // 如果初始化，则自动初始化
        this.initAnnotation();
        this.editor.setZoomFactor(factorX, factorY);
    },

    /**
     * 设置文字批注文本内容
     *
     * @param {string} text - 弹窗文本
     */
    setTextFromPopupBox: function setTextFromPopupBox(text) {

        if (this.editor) {
            this.editor.setTextFromPopupBox(text);
        }
    },

    /**
     * 取消文字批注文本内容设置
     *
     */
    unsetTextFromPopupBox: function unsetTextFromPopupBox() {

        if (this.editor) {
            this.editor.unsetTextFromPopupBox();
        }
    },

    /**
     * 清除批注
     *
     */
    clearAnnotations: function clearAnnotations() {
        if (this.editor) {
            this.editor.clearAnnotations();
        }
    }

};

/**
 * 3D批注辅助类
 * @class  CLOUD.Extensions.AnnotationHelper3D
 * @param {Object} viewer - 模型浏览类对象
 * @param {Object} options - 特定的操作对象, 例如指定回调函数 options.popupCallback
 */
CLOUD.Extensions.AnnotationHelper3D = function (viewer, options) {

    "use strict";

    this.viewer = viewer;
    this.defaultStyle = {
        'stroke-width': 3,
        'stroke-color': '#ff0000',
        'stroke-opacity': 1.0,
        'fill-color': '#ff0000',
        'fill-opacity': 0.0,
        'font-family': 'Arial',
        'font-size': 16,
        'font-style': '',
        'font-weight': ''
    };
    this.isDblClickCloseCloud = true;
    this.resizeBind = this.resizeAnnotations.bind(this);
    this.renderBind = this.renderAnnotations.bind(this);
    this.options = options;
};

/**
 * @lends CLOUD.Extensions.AnnotationHelper3D.prototype
 *
 */
CLOUD.Extensions.AnnotationHelper3D.prototype = {

    constructor: CLOUD.Extensions.AnnotationHelper3D,

    /**
     * 释放资源
     *
     */
    destroy: function destroy() {
        this.uninitAnnotation();
        this.editor = null;
        this.viewer = null;
        this.resizeBind = null;
        this.renderBind = null;
        this.options = null;
    },

    /**
     * 是否存在批注
     *
     */
    hasAnnotations: function hasAnnotations() {
        return this.editor && this.editor.isInitialized();
    },

    /**
     * 初始化, 不用显示调用
     *
     */
    initAnnotation: function initAnnotation() {
        var viewer = this.viewer;
        var scope = this;
        var options = this.options;

        if (!this.editor) {
            this.editor = new CLOUD.Extensions.AnnotationEditor3D(viewer.domElement, viewer.camera, options);
        }

        this.editor.enableDblClickCloseCloud(this.isDblClickCloseCloud);

        if (!this.editor.isInitialized()) {

            var callbacks = {
                beginEditCallback: function beginEditCallback(domElement) {
                    viewer.editorManager.unregisterDomEventListeners(domElement);
                },
                endEditCallback: function endEditCallback(domElement) {
                    viewer.editorManager.registerDomEventListeners(domElement);
                },
                changeEditorModeCallback: function changeEditorModeCallback() {
                    scope.uninitAnnotation();
                }
            };

            this.viewer.addCallbacks("resize", this.resizeBind);
            this.viewer.addCallbacks("render", this.renderBind);
            this.editor.init(callbacks);
            callbacks = null;
        }
    },

    /**
     * 卸载批注资源
     *
     */
    uninitAnnotation: function uninitAnnotation() {
        if (this.editor && this.editor.isInitialized()) {
            this.viewer.removeCallbacks("resize", this.resizeBind);
            this.viewer.removeCallbacks("render", this.renderBind);
            this.editor.uninit();
        }
    },

    /**
     * 设置背景色，支持过渡色
     *
     * @param {Color} [startColor] - 过渡色1（16进制颜色值）
     * @param {Color} [stopColor] - 过渡色2 （16进制颜色值）
     */
    setAnnotationBackgroundColor: function setAnnotationBackgroundColor(startColor, stopColor) {
        if (this.editor) {
            this.editor.setBackgroundColor(startColor, stopColor);
        }
    },

    /**
     * 开始批注编辑
     *
     */
    editAnnotationBegin: function editAnnotationBegin() {
        // 如果没有设置批注模式，则自动进入批注模式
        this.initAnnotation();
        this.editor.editBegin();
    },

    /**
     * 完成批注编辑
     *
     */
    editAnnotationEnd: function editAnnotationEnd() {
        if (this.editor) {
            this.editor.editEnd();
        }
    },

    /**
     * 设置批注类型
     *
     * @param {Int} type - 批注类型（{ARROW: 0, RECTANGLE: 1, CIRCLE: 2, CROSS: 3, CLOUD: 4, TEXT: 5}）
     */
    setAnnotationType: function setAnnotationType(type) {
        this.initAnnotation();
        this.editor.setAnnotationType(type);
    },

    /**
     * 设置批注风格
     *
     * @param {Object} style - 批注风格 （{'stroke-width': 3,'stroke-color': '#ff0000','stroke-opacity': 1.0,'fill-color': '#ff0000', 'font-size': 16}）
     * @param {Object} [updateText] - 是否刷新文本风格
     */
    setAnnotationStyle: function setAnnotationStyle(style, updateText) {
        if (this.editor) {

            for (var attr in style) {
                if (attr in this.defaultStyle) {
                    this.defaultStyle[attr] = style[attr];
                }
            }

            this.editor.setAnnotationStyle(this.defaultStyle, updateText);
        }
    },

    /**
     * 加载批注列表
     *
     * @param {Array} [annotations] - 批注列表
     *                          ({  id: id,
     *                              shapeType: shapeType,
     *                              position: position,
     *                              size: size,
     *                              rotation: rotation,
     *                              shapePoints: shapePoints,
     *                              originSize: originSize,
     *                              style: style,
     *                              text: text
     *                          })
     */
    loadAnnotations: function loadAnnotations(annotations) {
        if (annotations) {
            this.initAnnotation();
            this.editor.loadAnnotations(annotations);
        } else {
            this.uninitAnnotation();
        }
    },

    /**
     * 获得批注对象列表
     *
     * @return {Array} 批注对象列表
     */
    getAnnotationInfoList: function getAnnotationInfoList() {
        if (this.editor) {
            return this.editor.getAnnotationInfoList();
        }

        return null;
    },

    /**
     * resize
     *
     */
    resizeAnnotations: function resizeAnnotations() {
        if (this.editor && this.editor.isInitialized()) {
            this.editor.onResize();
        }
    },

    /**
     * 状态变化
     *
     */
    renderAnnotations: function renderAnnotations() {
        if (this.editor && this.editor.isInitialized()) {
            this.editor.onCameraChange();
        }
    },

    /**
     * 特殊处理 - 是否允许双击关闭云图批注
     *
     * @param {Boolean} enable - 是否允许双击封闭云图, true:允许
     */
    enableDblClickCloseCloud: function enableDblClickCloseCloud(enable) {
        this.isDblClickCloseCloud = enable;
    },

    /**
     * 截屏 base64 格式png图片
     * 在chrome 版本 57.0.2987.133 (64-bit)上截不到图，估计是图片异步加载的问题, 采用回调函数处理。
     *
     * @param {base64} dataUrl - base64 背景图
     * @param {function(data)} callback - 回调
     * @return 如果定义了callback，则直接返回null，截屏数据作为 callback 函数参数传入，所有需要获得截屏数据之后进行的操作，在callback中处理；
     *          如果没有定义callback, 则直接返回 base64位图片(可能截不到图)
     */
    captureAnnotationsScreenSnapshot: function captureAnnotationsScreenSnapshot(backgroundClr, callback) {

        if (callback) {

            var scope = this;

            this.viewer.getRenderBufferScreenShot(backgroundClr, function (dataUrl) {
                scope.editor.getScreenSnapshot(dataUrl, callback);
            });

            return null;
        }

        // 这种方式在chrome 版本 57.0.2987.133 (64-bit)上截不到图，估计是图片异步加载的问题
        var dataUrl = this.viewer.getRenderBufferScreenShot(backgroundClr);
        dataUrl = this.editor.getScreenSnapshot(dataUrl);
        return dataUrl;
    },

    /**
     * 设置文字批注文本内容
     *
     * @param {string} text - 弹窗文本
     */
    setTextFromPopupBox: function setTextFromPopupBox(text) {

        if (this.editor) {
            this.editor.setTextFromPopupBox(text);
        }
    },

    /**
     * 取消文字批注文本内容设置
     *
     */
    unsetTextFromPopupBox: function unsetTextFromPopupBox() {

        if (this.editor) {
            this.editor.unsetTextFromPopupBox();
        }
    },

    /**
     * 清除批注
     *
     */
    clearAnnotations: function clearAnnotations() {
        if (this.editor) {
            this.editor.clearAnnotations();
        }
    }

};

CLOUD.Plugins = {
    ViewHouse: "2017.5.11"
};

CLOUD.Plugins.Font = CLOUD.Plugins.Font || {};

CLOUD.Plugins.Font.helvetiker_regular = { "glyphs": { "ο": { "x_min": 0, "x_max": 712, "ha": 815, "o": "m 356 -25 q 96 88 192 -25 q 0 368 0 201 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 " }, "S": { "x_min": 0, "x_max": 788, "ha": 890, "o": "m 788 291 q 662 54 788 144 q 397 -26 550 -26 q 116 68 226 -26 q 0 337 0 168 l 131 337 q 200 152 131 220 q 384 85 269 85 q 557 129 479 85 q 650 270 650 183 q 490 429 650 379 q 194 513 341 470 q 33 739 33 584 q 142 964 33 881 q 388 1041 242 1041 q 644 957 543 1041 q 756 716 756 867 l 625 716 q 561 874 625 816 q 395 933 497 933 q 243 891 309 933 q 164 759 164 841 q 325 609 164 656 q 625 526 475 568 q 788 291 788 454 " }, "¦": { "x_min": 343, "x_max": 449, "ha": 792, "o": "m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 " }, "/": { "x_min": 183.25, "x_max": 608.328125, "ha": 792, "o": "m 608 1041 l 266 -129 l 183 -129 l 520 1041 l 608 1041 " }, "Τ": { "x_min": -0.4375, "x_max": 777.453125, "ha": 839, "o": "m 777 893 l 458 893 l 458 0 l 319 0 l 319 892 l 0 892 l 0 1013 l 777 1013 l 777 893 " }, "y": { "x_min": 0, "x_max": 684.78125, "ha": 771, "o": "m 684 738 l 388 -83 q 311 -216 356 -167 q 173 -279 252 -279 q 97 -266 133 -279 l 97 -149 q 132 -155 109 -151 q 168 -160 155 -160 q 240 -114 213 -160 q 274 -26 248 -98 l 0 738 l 137 737 l 341 139 l 548 737 l 684 738 " }, "Π": { "x_min": 0, "x_max": 803, "ha": 917, "o": "m 803 0 l 667 0 l 667 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 803 1012 l 803 0 " }, "ΐ": { "x_min": -111, "x_max": 339, "ha": 361, "o": "m 339 800 l 229 800 l 229 925 l 339 925 l 339 800 m -1 800 l -111 800 l -111 925 l -1 925 l -1 800 m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 m 302 1040 l 113 819 l 30 819 l 165 1040 l 302 1040 " }, "g": { "x_min": 0, "x_max": 686, "ha": 838, "o": "m 686 34 q 586 -213 686 -121 q 331 -306 487 -306 q 131 -252 216 -306 q 31 -84 31 -190 l 155 -84 q 228 -174 166 -138 q 345 -207 284 -207 q 514 -109 454 -207 q 564 89 564 -27 q 461 6 521 36 q 335 -23 401 -23 q 88 100 184 -23 q 0 370 0 215 q 87 634 0 522 q 330 758 183 758 q 457 728 398 758 q 564 644 515 699 l 564 737 l 686 737 l 686 34 m 582 367 q 529 560 582 481 q 358 652 468 652 q 189 561 250 652 q 135 369 135 482 q 189 176 135 255 q 361 85 251 85 q 529 176 468 85 q 582 367 582 255 " }, "²": { "x_min": 0, "x_max": 442, "ha": 539, "o": "m 442 383 l 0 383 q 91 566 0 492 q 260 668 176 617 q 354 798 354 727 q 315 875 354 845 q 227 905 277 905 q 136 869 173 905 q 99 761 99 833 l 14 761 q 82 922 14 864 q 232 974 141 974 q 379 926 316 974 q 442 797 442 878 q 351 635 442 704 q 183 539 321 611 q 92 455 92 491 l 442 455 l 442 383 " }, "–": { "x_min": 0, "x_max": 705.5625, "ha": 803, "o": "m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 " }, "Κ": { "x_min": 0, "x_max": 819.5625, "ha": 893, "o": "m 819 0 l 650 0 l 294 509 l 139 356 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 " }, "ƒ": { "x_min": -46.265625, "x_max": 392, "ha": 513, "o": "m 392 651 l 259 651 l 79 -279 l -46 -278 l 134 651 l 14 651 l 14 751 l 135 751 q 151 948 135 900 q 304 1041 185 1041 q 334 1040 319 1041 q 392 1034 348 1039 l 392 922 q 337 931 360 931 q 271 883 287 931 q 260 793 260 853 l 260 751 l 392 751 l 392 651 " }, "e": { "x_min": 0, "x_max": 714, "ha": 813, "o": "m 714 326 l 140 326 q 200 157 140 227 q 359 87 260 87 q 488 130 431 87 q 561 245 545 174 l 697 245 q 577 48 670 123 q 358 -26 484 -26 q 97 85 195 -26 q 0 363 0 197 q 94 642 0 529 q 358 765 195 765 q 626 627 529 765 q 714 326 714 503 m 576 429 q 507 583 564 522 q 355 650 445 650 q 206 583 266 650 q 140 429 152 522 l 576 429 " }, "ό": { "x_min": 0, "x_max": 712, "ha": 815, "o": "m 356 -25 q 94 91 194 -25 q 0 368 0 202 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 m 576 1040 l 387 819 l 303 819 l 438 1040 l 576 1040 " }, "J": { "x_min": 0, "x_max": 588, "ha": 699, "o": "m 588 279 q 287 -26 588 -26 q 58 73 126 -26 q 0 327 0 158 l 133 327 q 160 172 133 227 q 288 96 198 96 q 426 171 391 96 q 449 336 449 219 l 449 1013 l 588 1013 l 588 279 " }, "»": { "x_min": -1, "x_max": 503, "ha": 601, "o": "m 503 302 l 280 136 l 281 256 l 429 373 l 281 486 l 280 608 l 503 440 l 503 302 m 221 302 l 0 136 l 0 255 l 145 372 l 0 486 l -1 608 l 221 440 l 221 302 " }, "©": { "x_min": -3, "x_max": 1008, "ha": 1106, "o": "m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 741 394 q 661 246 731 302 q 496 190 591 190 q 294 285 369 190 q 228 497 228 370 q 295 714 228 625 q 499 813 370 813 q 656 762 588 813 q 733 625 724 711 l 634 625 q 589 704 629 673 q 498 735 550 735 q 377 666 421 735 q 334 504 334 597 q 374 340 334 408 q 490 272 415 272 q 589 304 549 272 q 638 394 628 337 l 741 394 " }, "ώ": { "x_min": 0, "x_max": 922, "ha": 1030, "o": "m 687 1040 l 498 819 l 415 819 l 549 1040 l 687 1040 m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 338 0 202 q 45 551 0 444 q 161 737 84 643 l 302 737 q 175 552 219 647 q 124 336 124 446 q 155 179 124 248 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 341 797 257 q 745 555 797 450 q 619 737 705 637 l 760 737 q 874 551 835 640 q 922 339 922 444 " }, "^": { "x_min": 193.0625, "x_max": 598.609375, "ha": 792, "o": "m 598 772 l 515 772 l 395 931 l 277 772 l 193 772 l 326 1013 l 462 1013 l 598 772 " }, "«": { "x_min": 0, "x_max": 507.203125, "ha": 604, "o": "m 506 136 l 284 302 l 284 440 l 506 608 l 507 485 l 360 371 l 506 255 l 506 136 m 222 136 l 0 302 l 0 440 l 222 608 l 221 486 l 73 373 l 222 256 l 222 136 " }, "D": { "x_min": 0, "x_max": 828, "ha": 935, "o": "m 389 1013 q 714 867 593 1013 q 828 521 828 729 q 712 161 828 309 q 382 0 587 0 l 0 0 l 0 1013 l 389 1013 m 376 124 q 607 247 523 124 q 681 510 681 355 q 607 771 681 662 q 376 896 522 896 l 139 896 l 139 124 l 376 124 " }, "∙": { "x_min": 0, "x_max": 142, "ha": 239, "o": "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 " }, "ÿ": { "x_min": 0, "x_max": 47, "ha": 125, "o": "m 47 3 q 37 -7 47 -7 q 28 0 30 -7 q 39 -4 32 -4 q 45 3 45 -1 l 37 0 q 28 9 28 0 q 39 19 28 19 l 47 16 l 47 19 l 47 3 m 37 1 q 44 8 44 1 q 37 16 44 16 q 30 8 30 16 q 37 1 30 1 m 26 1 l 23 22 l 14 0 l 3 22 l 3 3 l 0 25 l 13 1 l 22 25 l 26 1 " }, "w": { "x_min": 0, "x_max": 1009.71875, "ha": 1100, "o": "m 1009 738 l 783 0 l 658 0 l 501 567 l 345 0 l 222 0 l 0 738 l 130 738 l 284 174 l 432 737 l 576 738 l 721 173 l 881 737 l 1009 738 " }, "$": { "x_min": 0, "x_max": 700, "ha": 793, "o": "m 664 717 l 542 717 q 490 825 531 785 q 381 872 450 865 l 381 551 q 620 446 540 522 q 700 241 700 370 q 618 45 700 116 q 381 -25 536 -25 l 381 -152 l 307 -152 l 307 -25 q 81 62 162 -25 q 0 297 0 149 l 124 297 q 169 146 124 204 q 307 81 215 89 l 307 441 q 80 536 148 469 q 13 725 13 603 q 96 910 13 839 q 307 982 180 982 l 307 1077 l 381 1077 l 381 982 q 574 917 494 982 q 664 717 664 845 m 307 565 l 307 872 q 187 831 233 872 q 142 724 142 791 q 180 618 142 656 q 307 565 218 580 m 381 76 q 562 237 562 96 q 517 361 562 313 q 381 423 472 409 l 381 76 " }, "\\": { "x_min": -0.015625, "x_max": 425.0625, "ha": 522, "o": "m 425 -129 l 337 -129 l 0 1041 l 83 1041 l 425 -129 " }, "µ": { "x_min": 0, "x_max": 697.21875, "ha": 747, "o": "m 697 -4 q 629 -14 658 -14 q 498 97 513 -14 q 422 9 470 41 q 313 -23 374 -23 q 207 4 258 -23 q 119 81 156 32 l 119 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 173 124 246 q 308 83 216 83 q 452 178 402 83 q 493 359 493 255 l 493 738 l 617 738 l 617 214 q 623 136 617 160 q 673 92 637 92 q 697 96 684 92 l 697 -4 " }, "Ι": { "x_min": 42, "x_max": 181, "ha": 297, "o": "m 181 0 l 42 0 l 42 1013 l 181 1013 l 181 0 " }, "Ύ": { "x_min": 0, "x_max": 1144.5, "ha": 1214, "o": "m 1144 1012 l 807 416 l 807 0 l 667 0 l 667 416 l 325 1012 l 465 1012 l 736 533 l 1004 1012 l 1144 1012 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 " }, "’": { "x_min": 0, "x_max": 139, "ha": 236, "o": "m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 " }, "Ν": { "x_min": 0, "x_max": 801, "ha": 915, "o": "m 801 0 l 651 0 l 131 822 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 191 l 670 1013 l 801 1013 l 801 0 " }, "-": { "x_min": 8.71875, "x_max": 350.390625, "ha": 478, "o": "m 350 317 l 8 317 l 8 428 l 350 428 l 350 317 " }, "Q": { "x_min": 0, "x_max": 968, "ha": 1072, "o": "m 954 5 l 887 -79 l 744 35 q 622 -11 687 2 q 483 -26 556 -26 q 127 130 262 -26 q 0 504 0 279 q 127 880 0 728 q 484 1041 262 1041 q 841 884 708 1041 q 968 507 968 735 q 933 293 968 398 q 832 104 899 188 l 954 5 m 723 191 q 802 330 777 248 q 828 499 828 412 q 744 790 828 673 q 483 922 650 922 q 228 791 322 922 q 142 505 142 673 q 227 221 142 337 q 487 91 323 91 q 632 123 566 91 l 520 215 l 587 301 l 723 191 " }, "ς": { "x_min": 1, "x_max": 676.28125, "ha": 740, "o": "m 676 460 l 551 460 q 498 595 542 546 q 365 651 448 651 q 199 578 263 651 q 136 401 136 505 q 266 178 136 241 q 508 106 387 142 q 640 -50 640 62 q 625 -158 640 -105 q 583 -278 611 -211 l 465 -278 q 498 -182 490 -211 q 515 -80 515 -126 q 381 12 515 -15 q 134 91 197 51 q 1 388 1 179 q 100 651 1 542 q 354 761 199 761 q 587 680 498 761 q 676 460 676 599 " }, "M": { "x_min": 0, "x_max": 954, "ha": 1067, "o": "m 954 0 l 819 0 l 819 869 l 537 0 l 405 0 l 128 866 l 128 0 l 0 0 l 0 1013 l 200 1013 l 472 160 l 757 1013 l 954 1013 l 954 0 " }, "Ψ": { "x_min": 0, "x_max": 1006, "ha": 1094, "o": "m 1006 678 q 914 319 1006 429 q 571 200 814 200 l 571 0 l 433 0 l 433 200 q 92 319 194 200 q 0 678 0 429 l 0 1013 l 139 1013 l 139 679 q 191 417 139 492 q 433 326 255 326 l 433 1013 l 571 1013 l 571 326 l 580 326 q 813 423 747 326 q 868 679 868 502 l 868 1013 l 1006 1013 l 1006 678 " }, "C": { "x_min": 0, "x_max": 886, "ha": 944, "o": "m 886 379 q 760 87 886 201 q 455 -26 634 -26 q 112 136 236 -26 q 0 509 0 283 q 118 882 0 737 q 469 1041 245 1041 q 748 955 630 1041 q 879 708 879 859 l 745 708 q 649 862 724 805 q 473 920 573 920 q 219 791 312 920 q 136 509 136 675 q 217 229 136 344 q 470 99 311 99 q 672 179 591 99 q 753 379 753 259 l 886 379 " }, "!": { "x_min": 0, "x_max": 138, "ha": 236, "o": "m 138 684 q 116 409 138 629 q 105 244 105 299 l 33 244 q 16 465 33 313 q 0 684 0 616 l 0 1013 l 138 1013 l 138 684 m 138 0 l 0 0 l 0 151 l 138 151 l 138 0 " }, "{": { "x_min": 0, "x_max": 480.5625, "ha": 578, "o": "m 480 -286 q 237 -213 303 -286 q 187 -45 187 -159 q 194 48 187 -15 q 201 141 201 112 q 164 264 201 225 q 0 314 118 314 l 0 417 q 164 471 119 417 q 201 605 201 514 q 199 665 201 644 q 193 772 193 769 q 241 941 193 887 q 480 1015 308 1015 l 480 915 q 336 866 375 915 q 306 742 306 828 q 310 662 306 717 q 314 577 314 606 q 288 452 314 500 q 176 365 256 391 q 289 275 257 337 q 314 143 314 226 q 313 84 314 107 q 310 -11 310 -5 q 339 -131 310 -94 q 480 -182 377 -182 l 480 -286 " }, "X": { "x_min": -0.015625, "x_max": 854.15625, "ha": 940, "o": "m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 428 637 l 675 1013 l 836 1013 l 504 520 l 854 0 " }, "#": { "x_min": 0, "x_max": 963.890625, "ha": 1061, "o": "m 963 690 l 927 590 l 719 590 l 655 410 l 876 410 l 840 310 l 618 310 l 508 -3 l 393 -2 l 506 309 l 329 310 l 215 -2 l 102 -3 l 212 310 l 0 310 l 36 410 l 248 409 l 312 590 l 86 590 l 120 690 l 347 690 l 459 1006 l 573 1006 l 462 690 l 640 690 l 751 1006 l 865 1006 l 754 690 l 963 690 m 606 590 l 425 590 l 362 410 l 543 410 l 606 590 " }, "ι": { "x_min": 42, "x_max": 284, "ha": 361, "o": "m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 738 l 167 738 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 " }, "Ά": { "x_min": 0, "x_max": 906.953125, "ha": 982, "o": "m 283 1040 l 88 799 l 5 799 l 145 1040 l 283 1040 m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1012 l 529 1012 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 " }, ")": { "x_min": 0, "x_max": 318, "ha": 415, "o": "m 318 365 q 257 25 318 191 q 87 -290 197 -141 l 0 -290 q 140 21 93 -128 q 193 360 193 189 q 141 704 193 537 q 0 1024 97 850 l 87 1024 q 257 706 197 871 q 318 365 318 542 " }, "ε": { "x_min": 0, "x_max": 634.71875, "ha": 714, "o": "m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 314 0 265 q 128 390 67 353 q 56 460 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 " }, "Δ": { "x_min": 0, "x_max": 952.78125, "ha": 1028, "o": "m 952 0 l 0 0 l 400 1013 l 551 1013 l 952 0 m 762 124 l 476 867 l 187 124 l 762 124 " }, "}": { "x_min": 0, "x_max": 481, "ha": 578, "o": "m 481 314 q 318 262 364 314 q 282 136 282 222 q 284 65 282 97 q 293 -58 293 -48 q 241 -217 293 -166 q 0 -286 174 -286 l 0 -182 q 143 -130 105 -182 q 171 -2 171 -93 q 168 81 171 22 q 165 144 165 140 q 188 275 165 229 q 306 365 220 339 q 191 455 224 391 q 165 588 165 505 q 168 681 165 624 q 171 742 171 737 q 141 865 171 827 q 0 915 102 915 l 0 1015 q 243 942 176 1015 q 293 773 293 888 q 287 675 293 741 q 282 590 282 608 q 318 466 282 505 q 481 417 364 417 l 481 314 " }, "‰": { "x_min": -3, "x_max": 1672, "ha": 1821, "o": "m 846 0 q 664 76 732 0 q 603 244 603 145 q 662 412 603 344 q 846 489 729 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 846 0 962 0 m 845 103 q 945 143 910 103 q 981 243 981 184 q 947 340 981 301 q 845 385 910 385 q 745 342 782 385 q 709 243 709 300 q 742 147 709 186 q 845 103 781 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 m 1428 0 q 1246 76 1314 0 q 1185 244 1185 145 q 1244 412 1185 344 q 1428 489 1311 489 q 1610 412 1542 489 q 1672 244 1672 343 q 1612 76 1672 144 q 1428 0 1545 0 m 1427 103 q 1528 143 1492 103 q 1564 243 1564 184 q 1530 340 1564 301 q 1427 385 1492 385 q 1327 342 1364 385 q 1291 243 1291 300 q 1324 147 1291 186 q 1427 103 1363 103 " }, "a": { "x_min": 0, "x_max": 698.609375, "ha": 794, "o": "m 698 0 q 661 -12 679 -7 q 615 -17 643 -17 q 536 12 564 -17 q 500 96 508 41 q 384 6 456 37 q 236 -25 312 -25 q 65 31 130 -25 q 0 194 0 88 q 118 390 0 334 q 328 435 180 420 q 488 483 476 451 q 495 523 495 504 q 442 619 495 584 q 325 654 389 654 q 209 617 257 654 q 152 513 161 580 l 33 513 q 123 705 33 633 q 332 772 207 772 q 528 712 448 772 q 617 531 617 645 l 617 163 q 624 108 617 126 q 664 90 632 90 l 698 94 l 698 0 m 491 262 l 491 372 q 272 329 350 347 q 128 201 128 294 q 166 113 128 144 q 264 83 205 83 q 414 130 346 83 q 491 262 491 183 " }, "—": { "x_min": 0, "x_max": 941.671875, "ha": 1039, "o": "m 941 334 l 0 334 l 0 410 l 941 410 l 941 334 " }, "=": { "x_min": 8.71875, "x_max": 780.953125, "ha": 792, "o": "m 780 510 l 8 510 l 8 606 l 780 606 l 780 510 m 780 235 l 8 235 l 8 332 l 780 332 l 780 235 " }, "N": { "x_min": 0, "x_max": 801, "ha": 914, "o": "m 801 0 l 651 0 l 131 823 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 193 l 670 1013 l 801 1013 l 801 0 " }, "ρ": { "x_min": 0, "x_max": 712, "ha": 797, "o": "m 712 369 q 620 94 712 207 q 362 -26 521 -26 q 230 2 292 -26 q 119 83 167 30 l 119 -278 l 0 -278 l 0 362 q 91 643 0 531 q 355 764 190 764 q 617 647 517 764 q 712 369 712 536 m 583 366 q 530 559 583 480 q 359 651 469 651 q 190 562 252 651 q 135 370 135 483 q 189 176 135 257 q 359 85 250 85 q 528 175 466 85 q 583 366 583 254 " }, "2": { "x_min": 59, "x_max": 731, "ha": 792, "o": "m 731 0 l 59 0 q 197 314 59 188 q 457 487 199 315 q 598 691 598 580 q 543 819 598 772 q 411 867 488 867 q 272 811 328 867 q 209 630 209 747 l 81 630 q 182 901 81 805 q 408 986 271 986 q 629 909 536 986 q 731 694 731 826 q 613 449 731 541 q 378 316 495 383 q 201 122 235 234 l 731 122 l 731 0 " }, "¯": { "x_min": 0, "x_max": 941.671875, "ha": 938, "o": "m 941 1033 l 0 1033 l 0 1109 l 941 1109 l 941 1033 " }, "Z": { "x_min": 0, "x_max": 779, "ha": 849, "o": "m 779 0 l 0 0 l 0 113 l 621 896 l 40 896 l 40 1013 l 779 1013 l 778 887 l 171 124 l 779 124 l 779 0 " }, "u": { "x_min": 0, "x_max": 617, "ha": 729, "o": "m 617 0 l 499 0 l 499 110 q 391 10 460 45 q 246 -25 322 -25 q 61 58 127 -25 q 0 258 0 136 l 0 738 l 125 738 l 125 284 q 156 148 125 202 q 273 82 197 82 q 433 165 369 82 q 493 340 493 243 l 493 738 l 617 738 l 617 0 " }, "k": { "x_min": 0, "x_max": 612.484375, "ha": 697, "o": "m 612 738 l 338 465 l 608 0 l 469 0 l 251 382 l 121 251 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 402 l 456 738 l 612 738 " }, "Η": { "x_min": 0, "x_max": 803, "ha": 917, "o": "m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 " }, "Α": { "x_min": 0, "x_max": 906.953125, "ha": 985, "o": "m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 " }, "s": { "x_min": 0, "x_max": 604, "ha": 697, "o": "m 604 217 q 501 36 604 104 q 292 -23 411 -23 q 86 43 166 -23 q 0 238 0 114 l 121 237 q 175 122 121 164 q 300 85 223 85 q 415 112 363 85 q 479 207 479 147 q 361 309 479 276 q 140 372 141 370 q 21 544 21 426 q 111 708 21 647 q 298 761 190 761 q 492 705 413 761 q 583 531 583 643 l 462 531 q 412 625 462 594 q 298 657 363 657 q 199 636 242 657 q 143 558 143 608 q 262 454 143 486 q 484 394 479 397 q 604 217 604 341 " }, "B": { "x_min": 0, "x_max": 778, "ha": 876, "o": "m 580 546 q 724 469 670 535 q 778 311 778 403 q 673 83 778 171 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 892 q 691 633 732 693 q 580 546 650 572 m 393 899 l 139 899 l 139 588 l 379 588 q 521 624 462 588 q 592 744 592 667 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 303 635 219 q 559 436 635 389 q 402 477 494 477 l 139 477 l 139 124 l 419 124 " }, "…": { "x_min": 0, "x_max": 614, "ha": 708, "o": "m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 m 378 0 l 236 0 l 236 151 l 378 151 l 378 0 m 614 0 l 472 0 l 472 151 l 614 151 l 614 0 " }, "?": { "x_min": 0, "x_max": 607, "ha": 704, "o": "m 607 777 q 543 599 607 674 q 422 474 482 537 q 357 272 357 391 l 236 272 q 297 487 236 395 q 411 619 298 490 q 474 762 474 691 q 422 885 474 838 q 301 933 371 933 q 179 880 228 933 q 124 706 124 819 l 0 706 q 94 963 0 872 q 302 1044 177 1044 q 511 973 423 1044 q 607 777 607 895 m 370 0 l 230 0 l 230 151 l 370 151 l 370 0 " }, "H": { "x_min": 0, "x_max": 803, "ha": 915, "o": "m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 " }, "ν": { "x_min": 0, "x_max": 675, "ha": 761, "o": "m 675 738 l 404 0 l 272 0 l 0 738 l 133 738 l 340 147 l 541 738 l 675 738 " }, "c": { "x_min": 1, "x_max": 701.390625, "ha": 775, "o": "m 701 264 q 584 53 681 133 q 353 -26 487 -26 q 91 91 188 -26 q 1 370 1 201 q 92 645 1 537 q 353 761 190 761 q 572 688 479 761 q 690 493 666 615 l 556 493 q 487 606 545 562 q 356 650 428 650 q 186 563 246 650 q 134 372 134 487 q 188 179 134 258 q 359 88 250 88 q 492 136 437 88 q 566 264 548 185 l 701 264 " }, "¶": { "x_min": 0, "x_max": 566.671875, "ha": 678, "o": "m 21 892 l 52 892 l 98 761 l 145 892 l 176 892 l 178 741 l 157 741 l 157 867 l 108 741 l 88 741 l 40 871 l 40 741 l 21 741 l 21 892 m 308 854 l 308 731 q 252 691 308 691 q 227 691 240 691 q 207 696 213 695 l 207 712 l 253 706 q 288 733 288 706 l 288 763 q 244 741 279 741 q 193 797 193 741 q 261 860 193 860 q 287 860 273 860 q 308 854 302 855 m 288 842 l 263 843 q 213 796 213 843 q 248 756 213 756 q 288 796 288 756 l 288 842 m 566 988 l 502 988 l 502 -1 l 439 -1 l 439 988 l 317 988 l 317 -1 l 252 -1 l 252 602 q 81 653 155 602 q 0 805 0 711 q 101 989 0 918 q 309 1053 194 1053 l 566 1053 l 566 988 " }, "β": { "x_min": 0, "x_max": 660, "ha": 745, "o": "m 471 550 q 610 450 561 522 q 660 280 660 378 q 578 64 660 151 q 367 -22 497 -22 q 239 5 299 -22 q 126 82 178 32 l 126 -278 l 0 -278 l 0 593 q 54 903 0 801 q 318 1042 127 1042 q 519 964 436 1042 q 603 771 603 887 q 567 644 603 701 q 471 550 532 586 m 337 79 q 476 138 418 79 q 535 279 535 198 q 427 437 535 386 q 226 477 344 477 l 226 583 q 398 620 329 583 q 486 762 486 668 q 435 884 486 833 q 312 935 384 935 q 169 861 219 935 q 126 698 126 797 l 126 362 q 170 169 126 242 q 337 79 224 79 " }, "Μ": { "x_min": 0, "x_max": 954, "ha": 1068, "o": "m 954 0 l 819 0 l 819 868 l 537 0 l 405 0 l 128 865 l 128 0 l 0 0 l 0 1013 l 199 1013 l 472 158 l 758 1013 l 954 1013 l 954 0 " }, "Ό": { "x_min": 0.109375, "x_max": 1120, "ha": 1217, "o": "m 1120 505 q 994 132 1120 282 q 642 -29 861 -29 q 290 130 422 -29 q 167 505 167 280 q 294 883 167 730 q 650 1046 430 1046 q 999 882 868 1046 q 1120 505 1120 730 m 977 504 q 896 784 977 669 q 644 915 804 915 q 391 785 484 915 q 307 504 307 669 q 391 224 307 339 q 644 95 486 95 q 894 224 803 95 q 977 504 977 339 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 " }, "Ή": { "x_min": 0, "x_max": 1158, "ha": 1275, "o": "m 1158 0 l 1022 0 l 1022 475 l 496 475 l 496 0 l 356 0 l 356 1012 l 496 1012 l 496 599 l 1022 599 l 1022 1012 l 1158 1012 l 1158 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 " }, "•": { "x_min": 0, "x_max": 663.890625, "ha": 775, "o": "m 663 529 q 566 293 663 391 q 331 196 469 196 q 97 294 194 196 q 0 529 0 393 q 96 763 0 665 q 331 861 193 861 q 566 763 469 861 q 663 529 663 665 " }, "¥": { "x_min": 0.1875, "x_max": 819.546875, "ha": 886, "o": "m 563 561 l 697 561 l 696 487 l 520 487 l 482 416 l 482 380 l 697 380 l 695 308 l 482 308 l 482 0 l 342 0 l 342 308 l 125 308 l 125 380 l 342 380 l 342 417 l 303 487 l 125 487 l 125 561 l 258 561 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 l 563 561 " }, "(": { "x_min": 0, "x_max": 318.0625, "ha": 415, "o": "m 318 -290 l 230 -290 q 61 23 122 -142 q 0 365 0 190 q 62 712 0 540 q 230 1024 119 869 l 318 1024 q 175 705 219 853 q 125 360 125 542 q 176 22 125 187 q 318 -290 223 -127 " }, "U": { "x_min": 0, "x_max": 796, "ha": 904, "o": "m 796 393 q 681 93 796 212 q 386 -25 566 -25 q 101 95 208 -25 q 0 393 0 211 l 0 1013 l 138 1013 l 138 391 q 204 191 138 270 q 394 107 276 107 q 586 191 512 107 q 656 391 656 270 l 656 1013 l 796 1013 l 796 393 " }, "γ": { "x_min": 0.5, "x_max": 744.953125, "ha": 822, "o": "m 744 737 l 463 54 l 463 -278 l 338 -278 l 338 54 l 154 495 q 104 597 124 569 q 13 651 67 651 l 0 651 l 0 751 l 39 753 q 168 711 121 753 q 242 594 207 676 l 403 208 l 617 737 l 744 737 " }, "α": { "x_min": 0, "x_max": 765.5625, "ha": 809, "o": "m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 728 407 760 q 563 637 524 696 l 563 739 l 685 739 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 96 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 " }, "F": { "x_min": 0, "x_max": 683.328125, "ha": 717, "o": "m 683 888 l 140 888 l 140 583 l 613 583 l 613 458 l 140 458 l 140 0 l 0 0 l 0 1013 l 683 1013 l 683 888 " }, "­": { "x_min": 0, "x_max": 705.5625, "ha": 803, "o": "m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 " }, ":": { "x_min": 0, "x_max": 142, "ha": 239, "o": "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 " }, "Χ": { "x_min": 0, "x_max": 854.171875, "ha": 935, "o": "m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 427 637 l 675 1013 l 836 1013 l 504 521 l 854 0 " }, "*": { "x_min": 116, "x_max": 674, "ha": 792, "o": "m 674 768 l 475 713 l 610 544 l 517 477 l 394 652 l 272 478 l 178 544 l 314 713 l 116 766 l 153 876 l 341 812 l 342 1013 l 446 1013 l 446 811 l 635 874 l 674 768 " }, "†": { "x_min": 0, "x_max": 777, "ha": 835, "o": "m 458 804 l 777 804 l 777 683 l 458 683 l 458 0 l 319 0 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 " }, "°": { "x_min": 0, "x_max": 347, "ha": 444, "o": "m 173 802 q 43 856 91 802 q 0 977 0 905 q 45 1101 0 1049 q 173 1153 90 1153 q 303 1098 255 1153 q 347 977 347 1049 q 303 856 347 905 q 173 802 256 802 m 173 884 q 238 910 214 884 q 262 973 262 937 q 239 1038 262 1012 q 173 1064 217 1064 q 108 1037 132 1064 q 85 973 85 1010 q 108 910 85 937 q 173 884 132 884 " }, "V": { "x_min": 0, "x_max": 862.71875, "ha": 940, "o": "m 862 1013 l 505 0 l 361 0 l 0 1013 l 143 1013 l 434 165 l 718 1012 l 862 1013 " }, "Ξ": { "x_min": 0, "x_max": 734.71875, "ha": 763, "o": "m 723 889 l 9 889 l 9 1013 l 723 1013 l 723 889 m 673 463 l 61 463 l 61 589 l 673 589 l 673 463 m 734 0 l 0 0 l 0 124 l 734 124 l 734 0 " }, " ": { "x_min": 0, "x_max": 0, "ha": 853 }, "Ϋ": { "x_min": 0.328125, "x_max": 819.515625, "ha": 889, "o": "m 588 1046 l 460 1046 l 460 1189 l 588 1189 l 588 1046 m 360 1046 l 232 1046 l 232 1189 l 360 1189 l 360 1046 m 819 1012 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1012 l 140 1012 l 411 533 l 679 1012 l 819 1012 " }, "0": { "x_min": 73, "x_max": 715, "ha": 792, "o": "m 394 -29 q 153 129 242 -29 q 73 479 73 272 q 152 829 73 687 q 394 989 241 989 q 634 829 545 989 q 715 479 715 684 q 635 129 715 270 q 394 -29 546 -29 m 394 89 q 546 211 489 89 q 598 479 598 322 q 548 748 598 640 q 394 871 491 871 q 241 748 298 871 q 190 479 190 637 q 239 211 190 319 q 394 89 296 89 " }, "”": { "x_min": 0, "x_max": 347, "ha": 454, "o": "m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 m 347 851 q 310 737 347 784 q 208 669 273 690 l 208 734 q 267 787 250 741 q 280 873 280 821 l 208 873 l 208 1013 l 347 1013 l 347 851 " }, "@": { "x_min": 0, "x_max": 1260, "ha": 1357, "o": "m 1098 -45 q 877 -160 1001 -117 q 633 -203 752 -203 q 155 -29 327 -203 q 0 360 0 127 q 176 802 0 616 q 687 1008 372 1008 q 1123 854 969 1008 q 1260 517 1260 718 q 1155 216 1260 341 q 868 82 1044 82 q 772 106 801 82 q 737 202 737 135 q 647 113 700 144 q 527 82 594 82 q 367 147 420 82 q 314 312 314 212 q 401 565 314 452 q 639 690 498 690 q 810 588 760 690 l 849 668 l 938 668 q 877 441 900 532 q 833 226 833 268 q 853 182 833 198 q 902 167 873 167 q 1088 272 1012 167 q 1159 512 1159 372 q 1051 793 1159 681 q 687 925 925 925 q 248 747 415 925 q 97 361 97 586 q 226 26 97 159 q 627 -122 370 -122 q 856 -87 737 -122 q 1061 8 976 -53 l 1098 -45 m 786 488 q 738 580 777 545 q 643 615 700 615 q 483 517 548 615 q 425 322 425 430 q 457 203 425 250 q 552 156 490 156 q 722 273 665 156 q 786 488 738 309 " }, "Ί": { "x_min": 0, "x_max": 499, "ha": 613, "o": "m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 m 499 0 l 360 0 l 360 1012 l 499 1012 l 499 0 " }, "i": { "x_min": 14, "x_max": 136, "ha": 275, "o": "m 136 873 l 14 873 l 14 1013 l 136 1013 l 136 873 m 136 0 l 14 0 l 14 737 l 136 737 l 136 0 " }, "Β": { "x_min": 0, "x_max": 778, "ha": 877, "o": "m 580 545 q 724 468 671 534 q 778 310 778 402 q 673 83 778 170 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 891 q 691 632 732 692 q 580 545 650 571 m 393 899 l 139 899 l 139 587 l 379 587 q 521 623 462 587 q 592 744 592 666 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 302 635 219 q 559 435 635 388 q 402 476 494 476 l 139 476 l 139 124 l 419 124 " }, "υ": { "x_min": 0, "x_max": 617, "ha": 725, "o": "m 617 352 q 540 94 617 199 q 308 -24 455 -24 q 76 94 161 -24 q 0 352 0 199 l 0 739 l 126 739 l 126 355 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 355 492 257 l 492 739 l 617 739 l 617 352 " }, "]": { "x_min": 0, "x_max": 275, "ha": 372, "o": "m 275 -281 l 0 -281 l 0 -187 l 151 -187 l 151 920 l 0 920 l 0 1013 l 275 1013 l 275 -281 " }, "m": { "x_min": 0, "x_max": 1019, "ha": 1128, "o": "m 1019 0 l 897 0 l 897 454 q 860 591 897 536 q 739 660 816 660 q 613 586 659 660 q 573 436 573 522 l 573 0 l 447 0 l 447 455 q 412 591 447 535 q 294 657 372 657 q 165 586 213 657 q 122 437 122 521 l 122 0 l 0 0 l 0 738 l 117 738 l 117 640 q 202 730 150 697 q 316 763 254 763 q 437 730 381 763 q 525 642 494 697 q 621 731 559 700 q 753 763 682 763 q 943 694 867 763 q 1019 512 1019 625 l 1019 0 " }, "χ": { "x_min": 8.328125, "x_max": 780.5625, "ha": 815, "o": "m 780 -278 q 715 -294 747 -294 q 616 -257 663 -294 q 548 -175 576 -227 l 379 133 l 143 -277 l 9 -277 l 313 254 l 163 522 q 127 586 131 580 q 36 640 91 640 q 8 637 27 640 l 8 752 l 52 757 q 162 719 113 757 q 236 627 200 690 l 383 372 l 594 737 l 726 737 l 448 250 l 625 -69 q 670 -153 647 -110 q 743 -188 695 -188 q 780 -184 759 -188 l 780 -278 " }, "8": { "x_min": 55, "x_max": 736, "ha": 792, "o": "m 571 527 q 694 424 652 491 q 736 280 736 358 q 648 71 736 158 q 395 -26 551 -26 q 142 69 238 -26 q 55 279 55 157 q 96 425 55 359 q 220 527 138 491 q 120 615 153 562 q 88 726 88 668 q 171 904 88 827 q 395 986 261 986 q 618 905 529 986 q 702 727 702 830 q 670 616 702 667 q 571 527 638 565 m 394 565 q 519 610 475 565 q 563 717 563 655 q 521 823 563 781 q 392 872 474 872 q 265 824 312 872 q 224 720 224 783 q 265 613 224 656 q 394 565 312 565 m 395 91 q 545 150 488 91 q 597 280 597 204 q 546 408 597 355 q 395 465 492 465 q 244 408 299 465 q 194 280 194 356 q 244 150 194 203 q 395 91 299 91 " }, "ί": { "x_min": 42, "x_max": 326.71875, "ha": 361, "o": "m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 102 239 101 q 284 112 257 104 l 284 3 m 326 1040 l 137 819 l 54 819 l 189 1040 l 326 1040 " }, "Ζ": { "x_min": 0, "x_max": 779.171875, "ha": 850, "o": "m 779 0 l 0 0 l 0 113 l 620 896 l 40 896 l 40 1013 l 779 1013 l 779 887 l 170 124 l 779 124 l 779 0 " }, "R": { "x_min": 0, "x_max": 781.953125, "ha": 907, "o": "m 781 0 l 623 0 q 587 242 590 52 q 407 433 585 433 l 138 433 l 138 0 l 0 0 l 0 1013 l 396 1013 q 636 946 539 1013 q 749 731 749 868 q 711 597 749 659 q 608 502 674 534 q 718 370 696 474 q 729 207 722 352 q 781 26 736 62 l 781 0 m 373 551 q 533 594 465 551 q 614 731 614 645 q 532 859 614 815 q 373 896 465 896 l 138 896 l 138 551 l 373 551 " }, "o": { "x_min": 0, "x_max": 713, "ha": 821, "o": "m 357 -25 q 94 91 194 -25 q 0 368 0 202 q 93 642 0 533 q 357 761 193 761 q 618 644 518 761 q 713 368 713 533 q 619 91 713 201 q 357 -25 521 -25 m 357 85 q 528 175 465 85 q 584 369 584 255 q 529 562 584 484 q 357 651 467 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 357 85 250 85 " }, "5": { "x_min": 54.171875, "x_max": 738, "ha": 792, "o": "m 738 314 q 626 60 738 153 q 382 -23 526 -23 q 155 47 248 -23 q 54 256 54 125 l 183 256 q 259 132 204 174 q 382 91 314 91 q 533 149 471 91 q 602 314 602 213 q 538 469 602 411 q 386 528 475 528 q 284 506 332 528 q 197 439 237 484 l 81 439 l 159 958 l 684 958 l 684 840 l 254 840 l 214 579 q 306 627 258 612 q 407 643 354 643 q 636 552 540 643 q 738 314 738 457 " }, "7": { "x_min": 58.71875, "x_max": 730.953125, "ha": 792, "o": "m 730 839 q 469 448 560 641 q 335 0 378 255 l 192 0 q 328 441 235 252 q 593 830 421 630 l 58 830 l 58 958 l 730 958 l 730 839 " }, "K": { "x_min": 0, "x_max": 819.46875, "ha": 906, "o": "m 819 0 l 649 0 l 294 509 l 139 355 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 " }, ",": { "x_min": 0, "x_max": 142, "ha": 239, "o": "m 142 -12 q 105 -132 142 -82 q 0 -205 68 -182 l 0 -138 q 57 -82 40 -124 q 70 0 70 -51 l 0 0 l 0 151 l 142 151 l 142 -12 " }, "d": { "x_min": 0, "x_max": 683, "ha": 796, "o": "m 683 0 l 564 0 l 564 93 q 456 6 516 38 q 327 -25 395 -25 q 87 100 181 -25 q 0 365 0 215 q 90 639 0 525 q 343 763 187 763 q 564 647 486 763 l 564 1013 l 683 1013 l 683 0 m 582 373 q 529 562 582 484 q 361 653 468 653 q 190 561 253 653 q 135 365 135 479 q 189 175 135 254 q 358 85 251 85 q 529 178 468 85 q 582 373 582 258 " }, "¨": { "x_min": -109, "x_max": 247, "ha": 232, "o": "m 247 1046 l 119 1046 l 119 1189 l 247 1189 l 247 1046 m 19 1046 l -109 1046 l -109 1189 l 19 1189 l 19 1046 " }, "E": { "x_min": 0, "x_max": 736.109375, "ha": 789, "o": "m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 " }, "Y": { "x_min": 0, "x_max": 820, "ha": 886, "o": "m 820 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 534 l 679 1012 l 820 1013 " }, "\"": { "x_min": 0, "x_max": 299, "ha": 396, "o": "m 299 606 l 203 606 l 203 988 l 299 988 l 299 606 m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 " }, "‹": { "x_min": 17.984375, "x_max": 773.609375, "ha": 792, "o": "m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 " }, "„": { "x_min": 0, "x_max": 364, "ha": 467, "o": "m 141 -12 q 104 -132 141 -82 q 0 -205 67 -182 l 0 -138 q 56 -82 40 -124 q 69 0 69 -51 l 0 0 l 0 151 l 141 151 l 141 -12 m 364 -12 q 327 -132 364 -82 q 222 -205 290 -182 l 222 -138 q 279 -82 262 -124 q 292 0 292 -51 l 222 0 l 222 151 l 364 151 l 364 -12 " }, "δ": { "x_min": 1, "x_max": 710, "ha": 810, "o": "m 710 360 q 616 87 710 196 q 356 -28 518 -28 q 99 82 197 -28 q 1 356 1 192 q 100 606 1 509 q 355 703 199 703 q 180 829 288 754 q 70 903 124 866 l 70 1012 l 643 1012 l 643 901 l 258 901 q 462 763 422 794 q 636 592 577 677 q 710 360 710 485 m 584 365 q 552 501 584 447 q 451 602 521 555 q 372 611 411 611 q 197 541 258 611 q 136 355 136 472 q 190 171 136 245 q 358 85 252 85 q 528 173 465 85 q 584 365 584 252 " }, "έ": { "x_min": 0, "x_max": 634.71875, "ha": 714, "o": "m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 313 0 265 q 128 390 67 352 q 56 459 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 m 520 1040 l 331 819 l 248 819 l 383 1040 l 520 1040 " }, "ω": { "x_min": 0, "x_max": 922, "ha": 1031, "o": "m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 339 0 203 q 45 551 0 444 q 161 738 84 643 l 302 738 q 175 553 219 647 q 124 336 124 446 q 155 179 124 249 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 342 797 257 q 745 556 797 450 q 619 738 705 638 l 760 738 q 874 551 835 640 q 922 339 922 444 " }, "´": { "x_min": 0, "x_max": 96, "ha": 251, "o": "m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 " }, "±": { "x_min": 11, "x_max": 781, "ha": 792, "o": "m 781 490 l 446 490 l 446 255 l 349 255 l 349 490 l 11 490 l 11 586 l 349 586 l 349 819 l 446 819 l 446 586 l 781 586 l 781 490 m 781 21 l 11 21 l 11 115 l 781 115 l 781 21 " }, "|": { "x_min": 343, "x_max": 449, "ha": 792, "o": "m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 " }, "ϋ": { "x_min": 0, "x_max": 617, "ha": 725, "o": "m 482 800 l 372 800 l 372 925 l 482 925 l 482 800 m 239 800 l 129 800 l 129 925 l 239 925 l 239 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 " }, "§": { "x_min": 0, "x_max": 593, "ha": 690, "o": "m 593 425 q 554 312 593 369 q 467 233 516 254 q 537 83 537 172 q 459 -74 537 -12 q 288 -133 387 -133 q 115 -69 184 -133 q 47 96 47 -6 l 166 96 q 199 7 166 40 q 288 -26 232 -26 q 371 -5 332 -26 q 420 60 420 21 q 311 201 420 139 q 108 309 210 255 q 0 490 0 383 q 33 602 0 551 q 124 687 66 654 q 75 743 93 712 q 58 812 58 773 q 133 984 58 920 q 300 1043 201 1043 q 458 987 394 1043 q 529 814 529 925 l 411 814 q 370 908 404 877 q 289 939 336 939 q 213 911 246 939 q 180 841 180 883 q 286 720 180 779 q 484 612 480 615 q 593 425 593 534 m 467 409 q 355 544 467 473 q 196 630 228 612 q 146 587 162 609 q 124 525 124 558 q 239 387 124 462 q 398 298 369 315 q 448 345 429 316 q 467 409 467 375 " }, "b": { "x_min": 0, "x_max": 685, "ha": 783, "o": "m 685 372 q 597 99 685 213 q 347 -25 501 -25 q 219 5 277 -25 q 121 93 161 36 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 634 q 214 723 157 692 q 341 754 272 754 q 591 637 493 754 q 685 372 685 526 m 554 356 q 499 550 554 470 q 328 644 437 644 q 162 556 223 644 q 108 369 108 478 q 160 176 108 256 q 330 83 221 83 q 498 169 435 83 q 554 356 554 245 " }, "q": { "x_min": 0, "x_max": 683, "ha": 876, "o": "m 683 -278 l 564 -278 l 564 97 q 474 8 533 39 q 345 -23 415 -23 q 91 93 188 -23 q 0 364 0 203 q 87 635 0 522 q 337 760 184 760 q 466 727 408 760 q 564 637 523 695 l 564 737 l 683 737 l 683 -278 m 582 375 q 527 564 582 488 q 358 652 466 652 q 190 565 253 652 q 135 377 135 488 q 189 179 135 261 q 361 84 251 84 q 530 179 469 84 q 582 375 582 260 " }, "Ω": { "x_min": -0.171875, "x_max": 969.5625, "ha": 1068, "o": "m 969 0 l 555 0 l 555 123 q 744 308 675 194 q 814 558 814 423 q 726 812 814 709 q 484 922 633 922 q 244 820 334 922 q 154 567 154 719 q 223 316 154 433 q 412 123 292 199 l 412 0 l 0 0 l 0 124 l 217 124 q 68 327 122 210 q 15 572 15 444 q 144 911 15 781 q 484 1041 274 1041 q 822 909 691 1041 q 953 569 953 777 q 899 326 953 443 q 750 124 846 210 l 969 124 l 969 0 " }, "ύ": { "x_min": 0, "x_max": 617, "ha": 725, "o": "m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 535 1040 l 346 819 l 262 819 l 397 1040 l 535 1040 " }, "z": { "x_min": -0.015625, "x_max": 613.890625, "ha": 697, "o": "m 613 0 l 0 0 l 0 100 l 433 630 l 20 630 l 20 738 l 594 738 l 593 636 l 163 110 l 613 110 l 613 0 " }, "™": { "x_min": 0, "x_max": 894, "ha": 1000, "o": "m 389 951 l 229 951 l 229 503 l 160 503 l 160 951 l 0 951 l 0 1011 l 389 1011 l 389 951 m 894 503 l 827 503 l 827 939 l 685 503 l 620 503 l 481 937 l 481 503 l 417 503 l 417 1011 l 517 1011 l 653 580 l 796 1010 l 894 1011 l 894 503 " }, "ή": { "x_min": 0.78125, "x_max": 697, "ha": 810, "o": "m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 721 124 755 q 200 630 193 687 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 m 479 1040 l 290 819 l 207 819 l 341 1040 l 479 1040 " }, "Θ": { "x_min": 0, "x_max": 960, "ha": 1056, "o": "m 960 507 q 833 129 960 280 q 476 -32 698 -32 q 123 129 255 -32 q 0 507 0 280 q 123 883 0 732 q 476 1045 255 1045 q 832 883 696 1045 q 960 507 960 732 m 817 500 q 733 789 817 669 q 476 924 639 924 q 223 792 317 924 q 142 507 142 675 q 222 222 142 339 q 476 89 315 89 q 730 218 636 89 q 817 500 817 334 m 716 449 l 243 449 l 243 571 l 716 571 l 716 449 " }, "®": { "x_min": -3, "x_max": 1008, "ha": 1106, "o": "m 503 532 q 614 562 566 532 q 672 658 672 598 q 614 747 672 716 q 503 772 569 772 l 338 772 l 338 532 l 503 532 m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 788 146 l 678 146 q 653 316 655 183 q 527 449 652 449 l 338 449 l 338 146 l 241 146 l 241 854 l 518 854 q 688 808 621 854 q 766 658 766 755 q 739 563 766 607 q 668 497 713 519 q 751 331 747 472 q 788 164 756 190 l 788 146 " }, "~": { "x_min": 0, "x_max": 833, "ha": 931, "o": "m 833 958 q 778 753 833 831 q 594 665 716 665 q 402 761 502 665 q 240 857 302 857 q 131 795 166 857 q 104 665 104 745 l 0 665 q 54 867 0 789 q 237 958 116 958 q 429 861 331 958 q 594 765 527 765 q 704 827 670 765 q 729 958 729 874 l 833 958 " }, "Ε": { "x_min": 0, "x_max": 736.21875, "ha": 778, "o": "m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 " }, "³": { "x_min": 0, "x_max": 450, "ha": 547, "o": "m 450 552 q 379 413 450 464 q 220 366 313 366 q 69 414 130 366 q 0 567 0 470 l 85 567 q 126 470 85 504 q 225 437 168 437 q 320 467 280 437 q 360 552 360 498 q 318 632 360 608 q 213 657 276 657 q 195 657 203 657 q 176 657 181 657 l 176 722 q 279 733 249 722 q 334 815 334 752 q 300 881 334 856 q 220 907 267 907 q 133 875 169 907 q 97 781 97 844 l 15 781 q 78 926 15 875 q 220 972 135 972 q 364 930 303 972 q 426 817 426 888 q 344 697 426 733 q 421 642 392 681 q 450 552 450 603 " }, "[": { "x_min": 0, "x_max": 273.609375, "ha": 371, "o": "m 273 -281 l 0 -281 l 0 1013 l 273 1013 l 273 920 l 124 920 l 124 -187 l 273 -187 l 273 -281 " }, "L": { "x_min": 0, "x_max": 645.828125, "ha": 696, "o": "m 645 0 l 0 0 l 0 1013 l 140 1013 l 140 126 l 645 126 l 645 0 " }, "σ": { "x_min": 0, "x_max": 803.390625, "ha": 894, "o": "m 803 628 l 633 628 q 713 368 713 512 q 618 93 713 204 q 357 -25 518 -25 q 94 91 194 -25 q 0 368 0 201 q 94 644 0 533 q 356 761 194 761 q 481 750 398 761 q 608 739 564 739 l 803 739 l 803 628 m 360 85 q 529 180 467 85 q 584 374 584 262 q 527 566 584 490 q 352 651 463 651 q 187 559 247 651 q 135 368 135 478 q 189 175 135 254 q 360 85 251 85 " }, "ζ": { "x_min": 0, "x_max": 573, "ha": 642, "o": "m 573 -40 q 553 -162 573 -97 q 510 -278 543 -193 l 400 -278 q 441 -187 428 -219 q 462 -90 462 -132 q 378 -14 462 -14 q 108 45 197 -14 q 0 290 0 117 q 108 631 0 462 q 353 901 194 767 l 55 901 l 55 1012 l 561 1012 l 561 924 q 261 669 382 831 q 128 301 128 489 q 243 117 128 149 q 458 98 350 108 q 573 -40 573 80 " }, "θ": { "x_min": 0, "x_max": 674, "ha": 778, "o": "m 674 496 q 601 160 674 304 q 336 -26 508 -26 q 73 153 165 -26 q 0 485 0 296 q 72 840 0 683 q 343 1045 166 1045 q 605 844 516 1045 q 674 496 674 692 m 546 579 q 498 798 546 691 q 336 935 437 935 q 178 798 237 935 q 126 579 137 701 l 546 579 m 546 475 l 126 475 q 170 233 126 348 q 338 80 230 80 q 504 233 447 80 q 546 475 546 346 " }, "Ο": { "x_min": 0, "x_max": 958, "ha": 1054, "o": "m 485 1042 q 834 883 703 1042 q 958 511 958 735 q 834 136 958 287 q 481 -26 701 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 729 q 485 1042 263 1042 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 670 q 480 913 640 913 q 226 785 321 913 q 142 504 142 671 q 226 224 142 339 q 480 98 319 98 " }, "Γ": { "x_min": 0, "x_max": 705.28125, "ha": 749, "o": "m 705 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 705 1012 l 705 886 " }, " ": { "x_min": 0, "x_max": 0, "ha": 375 }, "%": { "x_min": -3, "x_max": 1089, "ha": 1186, "o": "m 845 0 q 663 76 731 0 q 602 244 602 145 q 661 412 602 344 q 845 489 728 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 845 0 962 0 m 844 103 q 945 143 909 103 q 981 243 981 184 q 947 340 981 301 q 844 385 909 385 q 744 342 781 385 q 708 243 708 300 q 741 147 708 186 q 844 103 780 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 " }, "P": { "x_min": 0, "x_max": 726, "ha": 806, "o": "m 424 1013 q 640 931 555 1013 q 726 719 726 850 q 637 506 726 587 q 413 426 548 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 379 889 l 140 889 l 140 548 l 372 548 q 522 589 459 548 q 593 720 593 637 q 528 845 593 801 q 379 889 463 889 " }, "Έ": { "x_min": 0, "x_max": 1078.21875, "ha": 1118, "o": "m 1078 0 l 342 0 l 342 1013 l 1067 1013 l 1067 889 l 481 889 l 481 585 l 1019 585 l 1019 467 l 481 467 l 481 125 l 1078 125 l 1078 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 " }, "Ώ": { "x_min": 0.125, "x_max": 1136.546875, "ha": 1235, "o": "m 1136 0 l 722 0 l 722 123 q 911 309 842 194 q 981 558 981 423 q 893 813 981 710 q 651 923 800 923 q 411 821 501 923 q 321 568 321 720 q 390 316 321 433 q 579 123 459 200 l 579 0 l 166 0 l 166 124 l 384 124 q 235 327 289 210 q 182 572 182 444 q 311 912 182 782 q 651 1042 441 1042 q 989 910 858 1042 q 1120 569 1120 778 q 1066 326 1120 443 q 917 124 1013 210 l 1136 124 l 1136 0 m 277 1040 l 83 800 l 0 800 l 140 1041 l 277 1040 " }, "_": { "x_min": 0, "x_max": 705.5625, "ha": 803, "o": "m 705 -334 l 0 -334 l 0 -234 l 705 -234 l 705 -334 " }, "Ϊ": { "x_min": -110, "x_max": 246, "ha": 275, "o": "m 246 1046 l 118 1046 l 118 1189 l 246 1189 l 246 1046 m 18 1046 l -110 1046 l -110 1189 l 18 1189 l 18 1046 m 136 0 l 0 0 l 0 1012 l 136 1012 l 136 0 " }, "+": { "x_min": 23, "x_max": 768, "ha": 792, "o": "m 768 372 l 444 372 l 444 0 l 347 0 l 347 372 l 23 372 l 23 468 l 347 468 l 347 840 l 444 840 l 444 468 l 768 468 l 768 372 " }, "½": { "x_min": 0, "x_max": 1050, "ha": 1149, "o": "m 1050 0 l 625 0 q 712 178 625 108 q 878 277 722 187 q 967 385 967 328 q 932 456 967 429 q 850 484 897 484 q 759 450 798 484 q 721 352 721 416 l 640 352 q 706 502 640 448 q 851 551 766 551 q 987 509 931 551 q 1050 385 1050 462 q 976 251 1050 301 q 829 179 902 215 q 717 68 740 133 l 1050 68 l 1050 0 m 834 985 l 215 -28 l 130 -28 l 750 984 l 834 985 m 224 422 l 142 422 l 142 811 l 0 811 l 0 867 q 104 889 62 867 q 164 973 157 916 l 224 973 l 224 422 " }, "Ρ": { "x_min": 0, "x_max": 720, "ha": 783, "o": "m 424 1013 q 637 933 554 1013 q 720 723 720 853 q 633 508 720 591 q 413 426 546 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 378 889 l 140 889 l 140 548 l 371 548 q 521 589 458 548 q 592 720 592 637 q 527 845 592 801 q 378 889 463 889 " }, "'": { "x_min": 0, "x_max": 139, "ha": 236, "o": "m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 " }, "ª": { "x_min": 0, "x_max": 350, "ha": 397, "o": "m 350 625 q 307 616 328 616 q 266 631 281 616 q 247 673 251 645 q 190 628 225 644 q 116 613 156 613 q 32 641 64 613 q 0 722 0 669 q 72 826 0 800 q 247 866 159 846 l 247 887 q 220 934 247 916 q 162 953 194 953 q 104 934 129 953 q 76 882 80 915 l 16 882 q 60 976 16 941 q 166 1011 104 1011 q 266 979 224 1011 q 308 891 308 948 l 308 706 q 311 679 308 688 q 331 670 315 670 l 350 672 l 350 625 m 247 757 l 247 811 q 136 790 175 798 q 64 726 64 773 q 83 682 64 697 q 132 667 103 667 q 207 690 174 667 q 247 757 247 718 " }, "΅": { "x_min": 0, "x_max": 450, "ha": 553, "o": "m 450 800 l 340 800 l 340 925 l 450 925 l 450 800 m 406 1040 l 212 800 l 129 800 l 269 1040 l 406 1040 m 110 800 l 0 800 l 0 925 l 110 925 l 110 800 " }, "T": { "x_min": 0, "x_max": 777, "ha": 835, "o": "m 777 894 l 458 894 l 458 0 l 319 0 l 319 894 l 0 894 l 0 1013 l 777 1013 l 777 894 " }, "Φ": { "x_min": 0, "x_max": 915, "ha": 997, "o": "m 527 0 l 389 0 l 389 122 q 110 231 220 122 q 0 509 0 340 q 110 785 0 677 q 389 893 220 893 l 389 1013 l 527 1013 l 527 893 q 804 786 693 893 q 915 509 915 679 q 805 231 915 341 q 527 122 696 122 l 527 0 m 527 226 q 712 310 641 226 q 779 507 779 389 q 712 705 779 627 q 527 787 641 787 l 527 226 m 389 226 l 389 787 q 205 698 275 775 q 136 505 136 620 q 206 308 136 391 q 389 226 276 226 " }, "⁋": { "x_min": 0, "x_max": 0, "ha": 694 }, "j": { "x_min": -77.78125, "x_max": 167, "ha": 349, "o": "m 167 871 l 42 871 l 42 1013 l 167 1013 l 167 871 m 167 -80 q 121 -231 167 -184 q -26 -278 76 -278 l -77 -278 l -77 -164 l -41 -164 q 26 -143 11 -164 q 42 -65 42 -122 l 42 737 l 167 737 l 167 -80 " }, "Σ": { "x_min": 0, "x_max": 756.953125, "ha": 819, "o": "m 756 0 l 0 0 l 0 107 l 395 523 l 22 904 l 22 1013 l 745 1013 l 745 889 l 209 889 l 566 523 l 187 125 l 756 125 l 756 0 " }, "1": { "x_min": 215.671875, "x_max": 574, "ha": 792, "o": "m 574 0 l 442 0 l 442 697 l 215 697 l 215 796 q 386 833 330 796 q 475 986 447 875 l 574 986 l 574 0 " }, "›": { "x_min": 18.0625, "x_max": 774, "ha": 792, "o": "m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 " }, "<": { "x_min": 17.984375, "x_max": 773.609375, "ha": 792, "o": "m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 " }, "£": { "x_min": 0, "x_max": 704.484375, "ha": 801, "o": "m 704 41 q 623 -10 664 5 q 543 -26 583 -26 q 359 15 501 -26 q 243 36 288 36 q 158 23 197 36 q 73 -21 119 10 l 6 76 q 125 195 90 150 q 175 331 175 262 q 147 443 175 383 l 0 443 l 0 512 l 108 512 q 43 734 43 623 q 120 929 43 854 q 358 1010 204 1010 q 579 936 487 1010 q 678 729 678 857 l 678 684 l 552 684 q 504 838 552 780 q 362 896 457 896 q 216 852 263 896 q 176 747 176 815 q 199 627 176 697 q 248 512 217 574 l 468 512 l 468 443 l 279 443 q 297 356 297 398 q 230 194 297 279 q 153 107 211 170 q 227 133 190 125 q 293 142 264 142 q 410 119 339 142 q 516 96 482 96 q 579 105 550 96 q 648 142 608 115 l 704 41 " }, "t": { "x_min": 0, "x_max": 367, "ha": 458, "o": "m 367 0 q 312 -5 339 -2 q 262 -8 284 -8 q 145 28 183 -8 q 108 143 108 64 l 108 638 l 0 638 l 0 738 l 108 738 l 108 944 l 232 944 l 232 738 l 367 738 l 367 638 l 232 638 l 232 185 q 248 121 232 140 q 307 102 264 102 q 345 104 330 102 q 367 107 360 107 l 367 0 " }, "¬": { "x_min": 0, "x_max": 706, "ha": 803, "o": "m 706 411 l 706 158 l 630 158 l 630 335 l 0 335 l 0 411 l 706 411 " }, "λ": { "x_min": 0, "x_max": 750, "ha": 803, "o": "m 750 -7 q 679 -15 716 -15 q 538 59 591 -15 q 466 214 512 97 l 336 551 l 126 0 l 0 0 l 270 705 q 223 837 247 770 q 116 899 190 899 q 90 898 100 899 l 90 1004 q 152 1011 125 1011 q 298 938 244 1011 q 373 783 326 901 l 605 192 q 649 115 629 136 q 716 95 669 95 l 736 95 q 750 97 745 97 l 750 -7 " }, "W": { "x_min": 0, "x_max": 1263.890625, "ha": 1351, "o": "m 1263 1013 l 995 0 l 859 0 l 627 837 l 405 0 l 265 0 l 0 1013 l 136 1013 l 342 202 l 556 1013 l 701 1013 l 921 207 l 1133 1012 l 1263 1013 " }, ">": { "x_min": 18.0625, "x_max": 774, "ha": 792, "o": "m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 " }, "v": { "x_min": 0, "x_max": 675.15625, "ha": 761, "o": "m 675 738 l 404 0 l 272 0 l 0 738 l 133 737 l 340 147 l 541 737 l 675 738 " }, "τ": { "x_min": 0.28125, "x_max": 644.5, "ha": 703, "o": "m 644 628 l 382 628 l 382 179 q 388 120 382 137 q 436 91 401 91 q 474 94 447 91 q 504 97 501 97 l 504 0 q 454 -9 482 -5 q 401 -14 426 -14 q 278 67 308 -14 q 260 233 260 118 l 260 628 l 0 628 l 0 739 l 644 739 l 644 628 " }, "ξ": { "x_min": 0, "x_max": 624.9375, "ha": 699, "o": "m 624 -37 q 608 -153 624 -96 q 563 -278 593 -211 l 454 -278 q 491 -183 486 -200 q 511 -83 511 -126 q 484 -23 511 -44 q 370 1 452 1 q 323 0 354 1 q 283 -1 293 -1 q 84 76 169 -1 q 0 266 0 154 q 56 431 0 358 q 197 538 108 498 q 94 613 134 562 q 54 730 54 665 q 77 823 54 780 q 143 901 101 867 l 27 901 l 27 1012 l 576 1012 l 576 901 l 380 901 q 244 863 303 901 q 178 745 178 820 q 312 600 178 636 q 532 582 380 582 l 532 479 q 276 455 361 479 q 118 281 118 410 q 165 173 118 217 q 274 120 208 133 q 494 101 384 110 q 624 -37 624 76 " }, "&": { "x_min": -3, "x_max": 894.25, "ha": 992, "o": "m 894 0 l 725 0 l 624 123 q 471 0 553 40 q 306 -41 390 -41 q 168 -7 231 -41 q 62 92 105 26 q 14 187 31 139 q -3 276 -3 235 q 55 433 -3 358 q 248 581 114 508 q 170 689 196 640 q 137 817 137 751 q 214 985 137 922 q 384 1041 284 1041 q 548 988 483 1041 q 622 824 622 928 q 563 666 622 739 q 431 556 516 608 l 621 326 q 649 407 639 361 q 663 493 653 426 l 781 493 q 703 229 781 352 l 894 0 m 504 818 q 468 908 504 877 q 384 940 433 940 q 293 907 331 940 q 255 818 255 875 q 289 714 255 767 q 363 628 313 678 q 477 729 446 682 q 504 818 504 771 m 556 209 l 314 499 q 179 395 223 449 q 135 283 135 341 q 146 222 135 253 q 183 158 158 192 q 333 80 241 80 q 556 209 448 80 " }, "Λ": { "x_min": 0, "x_max": 862.5, "ha": 942, "o": "m 862 0 l 719 0 l 426 847 l 143 0 l 0 0 l 356 1013 l 501 1013 l 862 0 " }, "I": { "x_min": 41, "x_max": 180, "ha": 293, "o": "m 180 0 l 41 0 l 41 1013 l 180 1013 l 180 0 " }, "G": { "x_min": 0, "x_max": 921, "ha": 1011, "o": "m 921 0 l 832 0 l 801 136 q 655 15 741 58 q 470 -28 568 -28 q 126 133 259 -28 q 0 499 0 284 q 125 881 0 731 q 486 1043 259 1043 q 763 957 647 1043 q 905 709 890 864 l 772 709 q 668 866 747 807 q 486 926 589 926 q 228 795 322 926 q 142 507 142 677 q 228 224 142 342 q 483 94 323 94 q 712 195 625 94 q 796 435 796 291 l 477 435 l 477 549 l 921 549 l 921 0 " }, "ΰ": { "x_min": 0, "x_max": 617, "ha": 725, "o": "m 524 800 l 414 800 l 414 925 l 524 925 l 524 800 m 183 800 l 73 800 l 73 925 l 183 925 l 183 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 489 1040 l 300 819 l 216 819 l 351 1040 l 489 1040 " }, "`": { "x_min": 0, "x_max": 138.890625, "ha": 236, "o": "m 138 699 l 0 699 l 0 861 q 36 974 0 929 q 138 1041 72 1020 l 138 977 q 82 931 95 969 q 69 839 69 893 l 138 839 l 138 699 " }, "·": { "x_min": 0, "x_max": 142, "ha": 239, "o": "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 " }, "Υ": { "x_min": 0.328125, "x_max": 819.515625, "ha": 889, "o": "m 819 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 " }, "r": { "x_min": 0, "x_max": 355.5625, "ha": 432, "o": "m 355 621 l 343 621 q 179 569 236 621 q 122 411 122 518 l 122 0 l 0 0 l 0 737 l 117 737 l 117 604 q 204 719 146 686 q 355 753 262 753 l 355 621 " }, "x": { "x_min": 0, "x_max": 675, "ha": 764, "o": "m 675 0 l 525 0 l 331 286 l 144 0 l 0 0 l 256 379 l 12 738 l 157 737 l 336 473 l 516 738 l 661 738 l 412 380 l 675 0 " }, "μ": { "x_min": 0, "x_max": 696.609375, "ha": 747, "o": "m 696 -4 q 628 -14 657 -14 q 498 97 513 -14 q 422 8 470 41 q 313 -24 374 -24 q 207 3 258 -24 q 120 80 157 31 l 120 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 172 124 246 q 308 82 216 82 q 451 177 402 82 q 492 358 492 254 l 492 738 l 616 738 l 616 214 q 623 136 616 160 q 673 92 636 92 q 696 95 684 92 l 696 -4 " }, "h": { "x_min": 0, "x_max": 615, "ha": 724, "o": "m 615 472 l 615 0 l 490 0 l 490 454 q 456 590 490 535 q 338 654 416 654 q 186 588 251 654 q 122 436 122 522 l 122 0 l 0 0 l 0 1013 l 122 1013 l 122 633 q 218 727 149 694 q 362 760 287 760 q 552 676 484 760 q 615 472 615 600 " }, ".": { "x_min": 0, "x_max": 142, "ha": 239, "o": "m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 " }, "φ": { "x_min": -2, "x_max": 878, "ha": 974, "o": "m 496 -279 l 378 -279 l 378 -17 q 101 88 204 -17 q -2 367 -2 194 q 68 626 -2 510 q 283 758 151 758 l 283 646 q 167 537 209 626 q 133 373 133 462 q 192 177 133 254 q 378 93 259 93 l 378 758 q 445 764 426 763 q 476 765 464 765 q 765 659 653 765 q 878 377 878 553 q 771 96 878 209 q 496 -17 665 -17 l 496 -279 m 496 93 l 514 93 q 687 183 623 93 q 746 380 746 265 q 691 569 746 491 q 522 658 629 658 l 496 656 l 496 93 " }, ";": { "x_min": 0, "x_max": 142, "ha": 239, "o": "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 -12 q 105 -132 142 -82 q 0 -206 68 -182 l 0 -138 q 58 -82 43 -123 q 68 0 68 -56 l 0 0 l 0 151 l 142 151 l 142 -12 " }, "f": { "x_min": 0, "x_max": 378, "ha": 472, "o": "m 378 638 l 246 638 l 246 0 l 121 0 l 121 638 l 0 638 l 0 738 l 121 738 q 137 935 121 887 q 290 1028 171 1028 q 320 1027 305 1028 q 378 1021 334 1026 l 378 908 q 323 918 346 918 q 257 870 273 918 q 246 780 246 840 l 246 738 l 378 738 l 378 638 " }, "“": { "x_min": 1, "x_max": 348.21875, "ha": 454, "o": "m 140 670 l 1 670 l 1 830 q 37 943 1 897 q 140 1011 74 990 l 140 947 q 82 900 97 940 q 68 810 68 861 l 140 810 l 140 670 m 348 670 l 209 670 l 209 830 q 245 943 209 897 q 348 1011 282 990 l 348 947 q 290 900 305 940 q 276 810 276 861 l 348 810 l 348 670 " }, "A": { "x_min": 0.03125, "x_max": 906.953125, "ha": 1008, "o": "m 906 0 l 756 0 l 648 303 l 251 303 l 142 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 610 421 l 452 867 l 293 421 l 610 421 " }, "6": { "x_min": 53, "x_max": 739, "ha": 792, "o": "m 739 312 q 633 62 739 162 q 400 -31 534 -31 q 162 78 257 -31 q 53 439 53 206 q 178 859 53 712 q 441 986 284 986 q 643 912 559 986 q 732 713 732 833 l 601 713 q 544 830 594 786 q 426 875 494 875 q 268 793 331 875 q 193 517 193 697 q 301 597 240 570 q 427 624 362 624 q 643 540 552 624 q 739 312 739 451 m 603 298 q 540 461 603 400 q 404 516 484 516 q 268 461 323 516 q 207 300 207 401 q 269 137 207 198 q 405 83 325 83 q 541 137 486 83 q 603 298 603 197 " }, "‘": { "x_min": 1, "x_max": 139.890625, "ha": 236, "o": "m 139 670 l 1 670 l 1 830 q 37 943 1 897 q 139 1011 74 990 l 139 947 q 82 900 97 940 q 68 810 68 861 l 139 810 l 139 670 " }, "ϊ": { "x_min": -70, "x_max": 283, "ha": 361, "o": "m 283 800 l 173 800 l 173 925 l 283 925 l 283 800 m 40 800 l -70 800 l -70 925 l 40 925 l 40 800 m 283 3 q 232 -10 257 -5 q 181 -15 206 -15 q 84 26 118 -15 q 41 200 41 79 l 41 737 l 166 737 l 167 215 q 171 141 167 157 q 225 101 182 101 q 247 103 238 101 q 283 112 256 104 l 283 3 " }, "π": { "x_min": -0.21875, "x_max": 773.21875, "ha": 857, "o": "m 773 -7 l 707 -11 q 575 40 607 -11 q 552 174 552 77 l 552 226 l 552 626 l 222 626 l 222 0 l 97 0 l 97 626 l 0 626 l 0 737 l 773 737 l 773 626 l 676 626 l 676 171 q 695 103 676 117 q 773 90 714 90 l 773 -7 " }, "ά": { "x_min": 0, "x_max": 765.5625, "ha": 809, "o": "m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 727 407 760 q 563 637 524 695 l 563 738 l 685 738 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 95 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 m 604 1040 l 415 819 l 332 819 l 466 1040 l 604 1040 " }, "O": { "x_min": 0, "x_max": 958, "ha": 1057, "o": "m 485 1041 q 834 882 702 1041 q 958 512 958 734 q 834 136 958 287 q 481 -26 702 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 728 q 485 1041 263 1041 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 669 q 480 912 640 912 q 226 784 321 912 q 142 504 142 670 q 226 224 142 339 q 480 98 319 98 " }, "n": { "x_min": 0, "x_max": 615, "ha": 724, "o": "m 615 463 l 615 0 l 490 0 l 490 454 q 453 592 490 537 q 331 656 410 656 q 178 585 240 656 q 117 421 117 514 l 117 0 l 0 0 l 0 738 l 117 738 l 117 630 q 218 728 150 693 q 359 764 286 764 q 552 675 484 764 q 615 463 615 593 " }, "3": { "x_min": 54, "x_max": 737, "ha": 792, "o": "m 737 284 q 635 55 737 141 q 399 -25 541 -25 q 156 52 248 -25 q 54 308 54 140 l 185 308 q 245 147 185 202 q 395 96 302 96 q 539 140 484 96 q 602 280 602 190 q 510 429 602 390 q 324 454 451 454 l 324 565 q 487 584 441 565 q 565 719 565 617 q 515 835 565 791 q 395 879 466 879 q 255 824 307 879 q 203 661 203 769 l 78 661 q 166 909 78 822 q 387 992 250 992 q 603 921 513 992 q 701 723 701 844 q 669 607 701 656 q 578 524 637 558 q 696 434 655 499 q 737 284 737 369 " }, "9": { "x_min": 53, "x_max": 739, "ha": 792, "o": "m 739 524 q 619 94 739 241 q 362 -32 516 -32 q 150 47 242 -32 q 59 244 59 126 l 191 244 q 246 129 191 176 q 373 82 301 82 q 526 161 466 82 q 597 440 597 255 q 363 334 501 334 q 130 432 216 334 q 53 650 53 521 q 134 880 53 786 q 383 986 226 986 q 659 841 566 986 q 739 524 739 719 m 388 449 q 535 514 480 449 q 585 658 585 573 q 535 805 585 744 q 388 873 480 873 q 242 809 294 873 q 191 658 191 745 q 239 514 191 572 q 388 449 292 449 " }, "l": { "x_min": 41, "x_max": 166, "ha": 279, "o": "m 166 0 l 41 0 l 41 1013 l 166 1013 l 166 0 " }, "¤": { "x_min": 40.09375, "x_max": 728.796875, "ha": 825, "o": "m 728 304 l 649 224 l 512 363 q 383 331 458 331 q 256 363 310 331 l 119 224 l 40 304 l 177 441 q 150 553 150 493 q 184 673 150 621 l 40 818 l 119 898 l 267 749 q 321 766 291 759 q 384 773 351 773 q 447 766 417 773 q 501 749 477 759 l 649 898 l 728 818 l 585 675 q 612 618 604 648 q 621 553 621 587 q 591 441 621 491 l 728 304 m 384 682 q 280 643 318 682 q 243 551 243 604 q 279 461 243 499 q 383 423 316 423 q 487 461 449 423 q 525 553 525 500 q 490 641 525 605 q 384 682 451 682 " }, "κ": { "x_min": 0, "x_max": 632.328125, "ha": 679, "o": "m 632 0 l 482 0 l 225 384 l 124 288 l 124 0 l 0 0 l 0 738 l 124 738 l 124 446 l 433 738 l 596 738 l 312 466 l 632 0 " }, "4": { "x_min": 48, "x_max": 742.453125, "ha": 792, "o": "m 742 243 l 602 243 l 602 0 l 476 0 l 476 243 l 48 243 l 48 368 l 476 958 l 602 958 l 602 354 l 742 354 l 742 243 m 476 354 l 476 792 l 162 354 l 476 354 " }, "p": { "x_min": 0, "x_max": 685, "ha": 786, "o": "m 685 364 q 598 96 685 205 q 350 -23 504 -23 q 121 89 205 -23 l 121 -278 l 0 -278 l 0 738 l 121 738 l 121 633 q 220 726 159 691 q 351 761 280 761 q 598 636 504 761 q 685 364 685 522 m 557 371 q 501 560 557 481 q 330 651 437 651 q 162 559 223 651 q 108 366 108 479 q 162 177 108 254 q 333 87 224 87 q 502 178 441 87 q 557 371 557 258 " }, "‡": { "x_min": 0, "x_max": 777, "ha": 835, "o": "m 458 238 l 458 0 l 319 0 l 319 238 l 0 238 l 0 360 l 319 360 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 l 777 804 l 777 683 l 458 683 l 458 360 l 777 360 l 777 238 l 458 238 " }, "ψ": { "x_min": 0, "x_max": 808, "ha": 907, "o": "m 465 -278 l 341 -278 l 341 -15 q 87 102 180 -15 q 0 378 0 210 l 0 739 l 133 739 l 133 379 q 182 195 133 275 q 341 98 242 98 l 341 922 l 465 922 l 465 98 q 623 195 563 98 q 675 382 675 278 l 675 742 l 808 742 l 808 381 q 720 104 808 213 q 466 -13 627 -13 l 465 -278 " }, "η": { "x_min": 0.78125, "x_max": 697, "ha": 810, "o": "m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 720 124 755 q 200 630 193 686 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 " } }, "cssFontWeight": "normal", "ascender": 1189, "underlinePosition": -100, "cssFontStyle": "normal", "boundingBox": { "yMin": -334, "xMin": -111, "yMax": 1189, "xMax": 1672 }, "resolution": 1000, "original_font_information": { "postscript_name": "Helvetiker-Regular", "version_string": "Version 1.00 2004 initial release", "vendor_url": "http://www.magenta.gr/", "full_font_name": "Helvetiker", "font_family_name": "Helvetiker", "copyright": "Copyright (c) Μagenta ltd, 2004", "description": "", "trademark": "", "designer": "", "designer_url": "", "unique_font_identifier": "Μagenta ltd:Helvetiker:22-10-104", "license_url": "http://www.ellak.gr/fonts/MgOpen/license.html", "license_description": "Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license (\"Fonts\") and associated documentation files (the \"Font Software\"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \r\n\r\nThe above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\r\n\r\nThe Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word \"MgOpen\", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\r\n\r\nThis License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the \"MgOpen\" name.\r\n\r\nThe Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \r\n\r\nTHE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.", "manufacturer_name": "Μagenta ltd", "font_sub_family_name": "Regular" }, "descender": -334, "familyName": "Helvetiker", "lineHeight": 1522, "underlineThickness": 50 };
/**
 * View house widget.
 * By default, the rotation between the main scene and the view house is synchronized.
 * However, callback 'preRotationHandle' can be provided to control the synchronization from view house to main scene.
 * When rotate view house, preRotationHandle is called. If preRotationHandle return false, view house and main scene
 * are stopped to rotation.
 *
 * @param {CLOUD.Viewer} viewer - viewer of the main scene
 * @param {Function}preRotationHandle - callback function to be called before rotation. No argument provided.
 * @constructor
 */
CLOUD.ViewHouse = function (viewer, preRotationHandle) {

    var scope = this;

    this.viewer = viewer;
    this.preRotationHandle = preRotationHandle;
    // Mouse buttons
    this.mouseButtons = { LEFT: THREE.MOUSE.LEFT, RIGHT: THREE.MOUSE.RIGHT };
    this.visible = true;
    this.isAnimationFinish = true; // 是否动画结束
    this.pickedColor = 0xb1d1ec;
    this.width = 0;
    this.height = 0;
    this.isDisable = false;

    var _houseContainer, _renderer;

    var _jsonFont = CLOUD.Plugins.Font.helvetiker_regular;

    // House 尺寸规格
    var _enumSizeMode = {
        Big: 0,
        Medium: 1,
        Small: 2
    };

    // House 尺寸
    var _enumSize = {
        Big: 220,
        Medium: 165,
        Small: 110
    };

    var _enumViewMode = {
        Home: 0,
        Top: 1,
        Bottom: 2,
        Front: 3,
        Back: 4,
        Right: 5,
        Left: 6,
        SouthEast: 7,
        SouthWest: 8,
        NorthEast: 9,
        NorthWest: 10,
        BottomFront: 11,
        BottomBack: 12,
        BottomRight: 13,
        BottomLeft: 14,
        BottomSouthEast: 15,
        BottomSouthWest: 16,
        BottomNorthEast: 17,
        BottomNorthWest: 18,
        RoofFront: 19,
        RoofBack: 20,
        RoofRight: 21,
        RoofLeft: 22,
        RoofSouthEast: 23,
        RoofSouthWest: 24,
        RoofNorthEast: 25,
        RoofNorthWest: 26,
        TopTurnRight: 27,
        TopTurnBack: 28,
        TopTurnLeft: 29,
        BottomTurnRight: 30,
        BottomTurnBack: 31,
        BottomTurnLeft: 32,
        FrontTurnRight: 33,
        FrontTurnTop: 34,
        FrontTurnLeft: 35,
        RightTurnBack: 36,
        RightTurnTop: 37,
        RightTurnFront: 38,
        BackTurnRight: 39,
        BackTurnTop: 40,
        BackTurnLeft: 41,
        LeftTurnFront: 42,
        LeftTurnTop: 43,
        LeftTurnBack: 44
    };

    // 房屋各构件名字
    var _componentNames = {
        Compass: "compass",
        Home: "home",
        BottomFloor: "Bottom_Floor",
        BottomSouth: "Bottom_South",
        BottomNorth: "Bottom_North",
        BottomEast: "Bottom_East",
        BottomWest: "Bottom_West",
        BottomSouthEast: "Bottom_SouthEast",
        BottomSouthWest: "Bottom_SouthWest",
        BottomNorthWest: "Bottom_NorthWest",
        BottomNorthEast: "Bottom_NorthEast",
        MiddleSouth: "Middle_South",
        MiddleNorth: "Middle_North",
        MiddleEast: "Middle_East",
        MiddleWest: "Middle_West",
        MiddleSouthEast: "Middle_SouthEast",
        MiddleSouthWest: "Middle_SouthWest",
        MiddleNorthWest: "Middle_NorthWest",
        MiddleNorthEast: "Middle_NorthEast",
        MiddleDoor: "Middle_Door",
        MiddleRightWindow: "Middle_RightWindow",
        MiddleLeftWindow: "Middle_LeftWindow",
        RoofCenter: "Roof_Center",
        RoofSouth: "Roof_South",
        RoofNorth: "Roof_North",
        RoofEast: "Roof_East",
        RoofWest: "Roof_West",
        RoofEaves: "Roof_Eaves",
        RoofSouthEast: "Roof_SouthEast",
        RoofSouthWest: "Roof_SouthWest",
        RoofNorthWest: "Roof_NorthWest",
        RoofNorthEast: "Roof_NorthEast",
        ControlPointNorth: "ControlPoint_North",
        ControlPointSouth: "ControlPoint_South",
        ControlPointEast: "ControlPoint_East",
        ControlPointWest: "ControlPoint_West",
        ControlRingNorthEast: "ControlRing_NorthEast",
        ControlRingSouthWest: "ControlRing_SouthWest",
        ControlRingNorthWest: "ControlRing_NorthWest",
        ControlRingSouthEast: "ControlRing_SouthEast"
    };

    var _threshold = 0.0001; // 精度阈值 (1e-4)

    // house
    var _houseScene = new THREE.Scene();
    var _houseCamera = new THREE.OrthographicCamera(-_enumSize.Big / 2, _enumSize.Big / 2, _enumSize.Big / 2, -_enumSize.Big / 2, -_enumSize.Big / 2, _enumSize.Big / 2);
    var _houseRaycaster = new THREE.Raycaster();

    // home(Billboard)
    var _homeScene = new THREE.Scene();
    var _homeCamera = _houseCamera.clone(); // 克隆一份，这样鼠标位置可以通用
    var _homeRaycaster = new THREE.Raycaster();

    var _groupCompass = new THREE.Group(); // 指北针组
    var _groupControlRing = new THREE.Group(); // 控制圆环组
    var _groupHouse = new THREE.Group(); // 房屋组
    var _groupHome = new THREE.Group(); // 主页组
    var _groupPick = new THREE.Group(); // 参与挑选
    var _groupHightLight = new THREE.Group(); // 高亮组

    // 保存初始位置
    var _groupControlRingPos = new THREE.Vector3();
    var _groupHightLightPos = new THREE.Vector3();

    // ------ 状态保存 S ------ //
    // 门
    var _houseDoorMesh = null;
    var _houseDoorColor = null;
    // 前墙
    var _houseFrontMesh = null;
    var _houseFrontColor = null;
    // 左窗
    var _houseLeftWindowMesh = null;
    var _houseLeftWindowColor = null;
    // 右窗
    var _houseRightWindowMesh = null;
    var _houseRightWindowColor = null;
    // 左墙
    var _houseLeftMesh = null;
    var _houseLeftColor = null;
    // 右墙
    var _houseRightMesh = null;
    var _houseRightColor = null;

    // 高亮圆环
    var _highLightRingRadius = 0;
    var _highlightRingMesh = null;
    var _highlightRingQuat = null;
    var _highlightRingPos = null;

    // 高亮圆环控制点
    var _highlightPointMesh = null;
    var _highlightPointQuat = null;
    var _highlightPointPos = null;

    // 高亮圆环箭头
    var _highlightArrowMesh = null;
    var _highlightArrowQuat = null;
    var _highlightArrowPos = null;
    // ------ 状态保存 E ------ //

    // 注意启用禁用和显示隐藏的区别：启用禁用由外部用户决定；显示隐藏由是否标准视图模式来决定。
    // 启用禁用优先级高。
    var _isEnableCompass = true; // 是否启用或禁用指北针
    var _isShowHome = false; // 是否显示home
    var _isRotate = false; // 旋转控制
    var _isTransparent = true; // 是否透明
    var _opacityCoe = 0.6; // 不透明度

    // 保持旋转量
    var _rotateStart = new THREE.Vector2();
    var _rotateEnd = new THREE.Vector2();
    var _rotateDelta = new THREE.Vector2();

    var _mouseCoord = new THREE.Vector2();
    var _hasPickedObject = false;
    var _lastPickedObjectName = ""; // 上次选中对象的名字
    var _intersected = null;

    var _viewHouseRadius = 110; // 最大半径
    var _halfHeight = 0; // 房屋半高
    var _halfWidth = 0; // 房屋前后墙半宽
    var _lineWidth = 5; // 线宽

    var _currentViewMode = -1; // 当前观察模式

    var _lastMouseOverHouse = false;

    /// 构造房屋线框
    // @param {object} container 父容器
    // @param {Array} vertices 顶点集
    // @param {Array} indices 索引集
    // @param {Number} color 颜色
    // @returns
    var createWireFrame = function createWireFrame(container, vertices, indices, color, lineWidth) {

        var len = vertices.length;
        var positions = new Float32Array(len * 3);

        for (var i = 0; i < len; ++i) {
            positions[i * 3] = vertices[i].x;
            positions[i * 3 + 1] = vertices[i].y;
            positions[i * 3 + 2] = vertices[i].z;
        }

        var geometry = new THREE.BufferGeometry();

        geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));
        geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));

        var material = new THREE.LineBasicMaterial({ color: color, linewidth: lineWidth });
        var mesh = new THREE.Line(geometry, material);
        container.add(mesh);
    };

    // 保持需要特殊处理的mesh
    var holdSpecialMesh = function holdSpecialMesh(name, mesh, color) {
        // 特殊处理
        if (name === _componentNames.MiddleDoor) {
            _houseDoorMesh = mesh;
            _houseDoorColor = color;
        }
        if (name === _componentNames.MiddleSouth) {
            _houseFrontMesh = mesh;
            _houseFrontColor = color;
        }
        if (name === _componentNames.MiddleLeftWindow) {
            _houseLeftWindowMesh = mesh;
            _houseLeftWindowColor = color;
        }
        if (name === _componentNames.MiddleRightWindow) {
            _houseRightWindowMesh = mesh;
            _houseRightWindowColor = color;
        }
        if (name === _componentNames.MiddleWest) {
            _houseLeftMesh = mesh;
            _houseLeftColor = color;
        }
        if (name === _componentNames.MiddleEast) {
            _houseRightMesh = mesh;
            _houseRightColor = color;
        }
    };

    /// 构造房屋面
    // @param {object} container 父容器
    // @param {Array} vertices 顶点集
    // @param {Array} indices 索引集
    // @param {Number} color 颜色
    // @returns
    var createMesh = function createMesh(container, vertices, indices, color, name) {

        var geometry = new THREE.Geometry();
        var vertex;
        var face;
        var offset = 0;
        var len = vertices.length;

        while (offset < len) {

            vertex = new THREE.Vector3();
            vertex = vertices[offset++];
            geometry.vertices.push(vertex);
        }

        offset = 0;
        len = indices.length;

        while (offset < len) {

            face = new THREE.Face3();
            face.a = indices[offset++];
            face.b = indices[offset++];
            face.c = indices[offset++];

            geometry.faces.push(face);
        }

        var material = new THREE.MeshBasicMaterial({ color: color /*, side: THREE.DoubleSide*/ });
        var mesh = new THREE.Mesh(geometry, material);
        mesh.name = name;

        // 保持需要特殊处理的mesh
        holdSpecialMesh(name, mesh, color);

        container.add(mesh);
    };

    // 构造房屋
    var createHouse = function createHouse() {

        // ----------- 房屋 ----------- //
        // 房屋颜色
        var houseWallColor = 0xe7e7ec;
        var houseDoorRoofColor = 0x99a4b5;
        var houseWireFrameColor = 0x787878;
        // 墙
        var houseWallLength = 85.0; // 左右墙间宽度(长)
        var houseWallWidth = 70.0; // 前后墙间宽度(宽)
        var houseWallHeight = 50.0; // 墙高(高)
        // 门槛
        var houseSillHeight = 6.0;
        var houseSillBottomWidth = 54.0;
        var houseSillBottomDepth = 12.0;
        var houseSillTopWidth = 42.0;
        var houseSillTopDepth = 6.0;
        // 门
        var houseDoorWidth = 30.0;
        var houseDoorHeight = 28.0;
        // 窗
        var houseWindowWidth = 25.0;
        // 房檐
        var houseRoofTopLength = 54.0; // 上房檐左右宽度(长)
        var houseRoofTopWidth = 42.0; // 上房檐前后宽度(宽)
        var houseRoofBottomLength = 100.0; // 下房檐左右宽度(长)
        var houseRoofBottomWidth = 80.0; // 下房檐前后宽度(宽)
        var houseRoofHeight = 30.0; // 房顶高度
        // 房屋高度
        var houseHeight = houseWallHeight + houseRoofHeight; // 房屋总高度
        var houseHalfHeight = houseHeight / 2; // 房屋半高
        var houseCornerWidth = 9.0; // 房屋角落宽度

        _halfHeight = houseHalfHeight; // 保持半高
        _halfWidth = houseWallWidth / 2;

        // 房子坐北朝南(门在南)，相机从南往北看
        // 以向上为Z轴正方向，North为Y轴正方向，East为X轴正方向建立模型：房子前墙在Y负方向，后墙在Y正方向。
        // -----------------------------------
        //                  N (Y 正)
        //                   ^
        //                  |
        //     W  < ------- |------- >  E （X 正）
        //                  |
        //                  v
        //                S
        // -----------------------------------


        // 以中心点为基准
        var wallFarOffsetX = houseWallLength / 2.0;
        var wallNearOffsetX = houseWallLength / 2.0 - houseCornerWidth;
        var wallFarOffsetY = houseWallWidth / 2.0;
        var wallNearOffsetY = houseWallWidth / 2.0 - houseCornerWidth;

        // ------ House Bottom ------ //
        var bottomNearOffsetZ = houseHalfHeight - houseCornerWidth;
        var bottomFarOffsetZ = houseHalfHeight;

        // 1-1. South (Front)
        var sillBottomNearOffsetX = houseSillBottomWidth / 2.0;
        var sillBottomFarOffsetY = houseWallWidth / 2.0 + houseSillBottomDepth + 0.01;
        var sillBottomNearOffsetY = houseWallWidth / 2.0 + 0.01;
        var sillBottomNearOffsetZ = houseHalfHeight - houseSillHeight;
        var sillBottomFarOffsetZ = houseHalfHeight;

        var sillTopNearOffsetX = houseSillTopWidth / 2.0;
        var sillTopFarOffsetY = houseWallWidth / 2.0 + houseSillTopDepth + 0.01;
        var sillTopNearOffsetY = houseWallWidth / 2.0 + 0.01;
        var sillTopNearOffsetZ = houseHalfHeight - houseSillHeight * 2;
        var sillTopFarOffsetZ = houseHalfHeight - houseSillHeight;

        var bottomSouthFace = [];
        // sill bottom
        bottomSouthFace.push(new THREE.Vector3(-sillBottomNearOffsetX, -sillBottomFarOffsetY, -sillBottomFarOffsetZ));
        bottomSouthFace.push(new THREE.Vector3(sillBottomNearOffsetX, -sillBottomFarOffsetY, -sillBottomFarOffsetZ));
        bottomSouthFace.push(new THREE.Vector3(sillBottomNearOffsetX, -sillBottomFarOffsetY, -sillBottomNearOffsetZ));
        bottomSouthFace.push(new THREE.Vector3(-sillBottomNearOffsetX, -sillBottomFarOffsetY, -sillBottomNearOffsetZ));
        bottomSouthFace.push(new THREE.Vector3(-sillBottomNearOffsetX, -sillBottomNearOffsetY, -sillBottomFarOffsetZ));
        bottomSouthFace.push(new THREE.Vector3(sillBottomNearOffsetX, -sillBottomNearOffsetY, -sillBottomFarOffsetZ));
        bottomSouthFace.push(new THREE.Vector3(sillBottomNearOffsetX, -sillBottomNearOffsetY, -sillBottomNearOffsetZ));
        bottomSouthFace.push(new THREE.Vector3(-sillBottomNearOffsetX, -sillBottomNearOffsetY, -sillBottomNearOffsetZ));
        // sill top
        bottomSouthFace.push(new THREE.Vector3(-sillTopNearOffsetX, -sillTopFarOffsetY, -sillTopFarOffsetZ));
        bottomSouthFace.push(new THREE.Vector3(sillTopNearOffsetX, -sillTopFarOffsetY, -sillTopFarOffsetZ));
        bottomSouthFace.push(new THREE.Vector3(sillTopNearOffsetX, -sillTopFarOffsetY, -sillTopNearOffsetZ));
        bottomSouthFace.push(new THREE.Vector3(-sillTopNearOffsetX, -sillTopFarOffsetY, -sillTopNearOffsetZ));
        bottomSouthFace.push(new THREE.Vector3(-sillTopNearOffsetX, -sillTopNearOffsetY, -sillTopFarOffsetZ));
        bottomSouthFace.push(new THREE.Vector3(sillTopNearOffsetX, -sillTopNearOffsetY, -sillTopFarOffsetZ));
        bottomSouthFace.push(new THREE.Vector3(sillTopNearOffsetX, -sillTopNearOffsetY, -sillTopNearOffsetZ));
        bottomSouthFace.push(new THREE.Vector3(-sillTopNearOffsetX, -sillTopNearOffsetY, -sillTopNearOffsetZ));
        var bottomSouthFaceIndex = [4, 5, 6, 6, 7, 4, 5, 1, 2, 2, 6, 5, 0, 4, 7, 7, 3, 0, 7, 6, 2, 2, 3, 7, 0, 1, 5, 5, 4, 0, 12, 13, 14, 14, 15, 12, 13, 9, 10, 10, 14, 13, 8, 12, 15, 15, 11, 8, 15, 14, 10, 10, 11, 15, 8, 9, 13, 13, 12, 8];
        //var bottomSouthFaceWireIndex = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0];

        // 1-2. South East
        var bottomSouthEastFace = [];
        bottomSouthEastFace.push(new THREE.Vector3(wallFarOffsetX, -wallFarOffsetY, -bottomFarOffsetZ));
        bottomSouthEastFace.push(new THREE.Vector3(wallNearOffsetX, -wallFarOffsetY, -bottomFarOffsetZ));
        bottomSouthEastFace.push(new THREE.Vector3(wallNearOffsetX, -wallFarOffsetY, -bottomNearOffsetZ));
        bottomSouthEastFace.push(new THREE.Vector3(wallFarOffsetX, -wallFarOffsetY, -bottomNearOffsetZ));
        bottomSouthEastFace.push(new THREE.Vector3(wallFarOffsetX, -wallNearOffsetY, -bottomNearOffsetZ));
        bottomSouthEastFace.push(new THREE.Vector3(wallFarOffsetX, -wallNearOffsetY, -bottomFarOffsetZ));
        bottomSouthEastFace.push(new THREE.Vector3(wallNearOffsetX, -wallNearOffsetY, -bottomFarOffsetZ));
        var bottomSouthEastFaceIndex = [0, 3, 2, 2, 1, 0, 3, 0, 5, 5, 4, 3, 0, 1, 6, 6, 5, 0];
        //var bottomSouthEastFaceWireIndex = [ 0, 1, 2, 3, 4, 5, 6 ];

        // 1-3. East (Right)
        var bottomEastFace = [];
        bottomEastFace.push(new THREE.Vector3(wallFarOffsetX, wallNearOffsetY, -bottomFarOffsetZ));
        bottomEastFace.push(new THREE.Vector3(wallFarOffsetX, wallNearOffsetY, -bottomNearOffsetZ));
        bottomEastFace.push(new THREE.Vector3(wallFarOffsetX, -wallNearOffsetY, -bottomNearOffsetZ));
        bottomEastFace.push(new THREE.Vector3(wallFarOffsetX, -wallNearOffsetY, -bottomFarOffsetZ));
        bottomEastFace.push(new THREE.Vector3(wallNearOffsetX, -wallNearOffsetY, -bottomFarOffsetZ));
        bottomEastFace.push(new THREE.Vector3(wallNearOffsetX, wallNearOffsetY, -bottomFarOffsetZ));
        var bottomEastFaceIndex = [0, 1, 2, 2, 3, 0, 3, 4, 5, 5, 0, 3];

        // 1-4. North East
        var bottomNorthEastFace = [];
        bottomNorthEastFace.push(new THREE.Vector3(wallFarOffsetX, wallFarOffsetY, -bottomFarOffsetZ));
        bottomNorthEastFace.push(new THREE.Vector3(wallNearOffsetX, wallFarOffsetY, -bottomFarOffsetZ));
        bottomNorthEastFace.push(new THREE.Vector3(wallNearOffsetX, wallFarOffsetY, -bottomNearOffsetZ));
        bottomNorthEastFace.push(new THREE.Vector3(wallFarOffsetX, wallFarOffsetY, -bottomNearOffsetZ));
        bottomNorthEastFace.push(new THREE.Vector3(wallFarOffsetX, wallNearOffsetY, -bottomNearOffsetZ));
        bottomNorthEastFace.push(new THREE.Vector3(wallFarOffsetX, wallNearOffsetY, -bottomFarOffsetZ));
        bottomNorthEastFace.push(new THREE.Vector3(wallNearOffsetX, wallNearOffsetY, -bottomFarOffsetZ));
        var bottomNorthEastFaceIndex = [0, 1, 2, 2, 3, 0, 3, 4, 5, 5, 0, 3, 0, 5, 6, 6, 1, 0];

        // 1-5. North (Back)
        var bottomNorthFace = [];
        bottomNorthFace.push(new THREE.Vector3(-wallNearOffsetX, wallFarOffsetY, -bottomFarOffsetZ));
        bottomNorthFace.push(new THREE.Vector3(-wallNearOffsetX, wallFarOffsetY, -bottomNearOffsetZ));
        bottomNorthFace.push(new THREE.Vector3(wallNearOffsetX, wallFarOffsetY, -bottomNearOffsetZ));
        bottomNorthFace.push(new THREE.Vector3(wallNearOffsetX, wallFarOffsetY, -bottomFarOffsetZ));
        bottomNorthFace.push(new THREE.Vector3(wallNearOffsetX, wallNearOffsetY, -bottomFarOffsetZ));
        bottomNorthFace.push(new THREE.Vector3(-wallNearOffsetX, wallNearOffsetY, -bottomFarOffsetZ));
        var bottomNorthFaceIndex = [0, 1, 2, 2, 3, 0, 3, 4, 5, 5, 0, 3];

        // 1-6. North West
        var bottomNorthWestFace = [];
        bottomNorthWestFace.push(new THREE.Vector3(-wallFarOffsetX, wallFarOffsetY, -bottomFarOffsetZ));
        bottomNorthWestFace.push(new THREE.Vector3(-wallNearOffsetX, wallFarOffsetY, -bottomFarOffsetZ));
        bottomNorthWestFace.push(new THREE.Vector3(-wallNearOffsetX, wallFarOffsetY, -bottomNearOffsetZ));
        bottomNorthWestFace.push(new THREE.Vector3(-wallFarOffsetX, wallFarOffsetY, -bottomNearOffsetZ));
        bottomNorthWestFace.push(new THREE.Vector3(-wallFarOffsetX, wallNearOffsetY, -bottomNearOffsetZ));
        bottomNorthWestFace.push(new THREE.Vector3(-wallFarOffsetX, wallNearOffsetY, -bottomFarOffsetZ));
        bottomNorthWestFace.push(new THREE.Vector3(-wallNearOffsetX, wallNearOffsetY, -bottomFarOffsetZ));
        var bottomNorthWestFaceIndex = [0, 3, 2, 2, 1, 0, 3, 0, 5, 5, 4, 3, 0, 1, 6, 6, 5, 0];

        // 1-7. West (Left)
        var bottomWestFace = [];
        bottomWestFace.push(new THREE.Vector3(-wallFarOffsetX, wallNearOffsetY, -bottomFarOffsetZ));
        bottomWestFace.push(new THREE.Vector3(-wallFarOffsetX, wallNearOffsetY, -bottomNearOffsetZ));
        bottomWestFace.push(new THREE.Vector3(-wallFarOffsetX, -wallNearOffsetY, -bottomNearOffsetZ));
        bottomWestFace.push(new THREE.Vector3(-wallFarOffsetX, -wallNearOffsetY, -bottomFarOffsetZ));
        bottomWestFace.push(new THREE.Vector3(-wallNearOffsetX, -wallNearOffsetY, -bottomFarOffsetZ));
        bottomWestFace.push(new THREE.Vector3(-wallNearOffsetX, wallNearOffsetY, -bottomFarOffsetZ));
        var bottomWestFaceIndex = [0, 3, 2, 2, 1, 0, 3, 0, 5, 5, 4, 3];

        // 1-8. South West
        var bottomSouthWestFace = [];
        bottomSouthWestFace.push(new THREE.Vector3(-wallFarOffsetX, -wallFarOffsetY, -bottomFarOffsetZ));
        bottomSouthWestFace.push(new THREE.Vector3(-wallNearOffsetX, -wallFarOffsetY, -bottomFarOffsetZ));
        bottomSouthWestFace.push(new THREE.Vector3(-wallNearOffsetX, -wallFarOffsetY, -bottomNearOffsetZ));
        bottomSouthWestFace.push(new THREE.Vector3(-wallFarOffsetX, -wallFarOffsetY, -bottomNearOffsetZ));
        bottomSouthWestFace.push(new THREE.Vector3(-wallFarOffsetX, -wallNearOffsetY, -bottomNearOffsetZ));
        bottomSouthWestFace.push(new THREE.Vector3(-wallFarOffsetX, -wallNearOffsetY, -bottomFarOffsetZ));
        bottomSouthWestFace.push(new THREE.Vector3(-wallNearOffsetX, -wallNearOffsetY, -bottomFarOffsetZ));
        var bottomSouthWestFaceIndex = [0, 1, 2, 2, 3, 0, 3, 4, 5, 5, 0, 3, 0, 5, 6, 6, 1, 0];

        // 1-9. Floor
        var bottomFloorFace = [];
        bottomFloorFace.push(new THREE.Vector3(-wallNearOffsetX, -wallFarOffsetY, -bottomFarOffsetZ));
        bottomFloorFace.push(new THREE.Vector3(-wallNearOffsetX, wallNearOffsetY, -bottomFarOffsetZ));
        bottomFloorFace.push(new THREE.Vector3(wallNearOffsetX, wallNearOffsetY, -bottomFarOffsetZ));
        bottomFloorFace.push(new THREE.Vector3(wallNearOffsetX, -wallFarOffsetY, -bottomFarOffsetZ));
        var bottomFloorFaceIndex = [0, 1, 2, 2, 3, 0];

        // ----- House Middle -----
        var middleFarOffsetZ = houseHalfHeight - houseCornerWidth;
        var middleNearOffsetZ = houseWallHeight - houseHalfHeight;

        // 2-1. South (Front)
        var middleSouthFace = [];
        middleSouthFace.push(new THREE.Vector3(-wallNearOffsetX, -wallFarOffsetY, -bottomFarOffsetZ));
        middleSouthFace.push(new THREE.Vector3(wallNearOffsetX, -wallFarOffsetY, -bottomFarOffsetZ));
        middleSouthFace.push(new THREE.Vector3(wallNearOffsetX, -wallFarOffsetY, middleNearOffsetZ));
        middleSouthFace.push(new THREE.Vector3(-wallNearOffsetX, -wallFarOffsetY, middleNearOffsetZ));
        var middleSouthFaceIndex = [0, 1, 2, 2, 3, 0];

        // 2-2. South East
        var middleSouthEastFace = [];
        middleSouthEastFace.push(new THREE.Vector3(wallNearOffsetX, -wallFarOffsetY, -middleFarOffsetZ));
        middleSouthEastFace.push(new THREE.Vector3(wallNearOffsetX, -wallFarOffsetY, middleNearOffsetZ));
        middleSouthEastFace.push(new THREE.Vector3(wallFarOffsetX, -wallFarOffsetY, middleNearOffsetZ));
        middleSouthEastFace.push(new THREE.Vector3(wallFarOffsetX, -wallFarOffsetY, -middleFarOffsetZ));
        middleSouthEastFace.push(new THREE.Vector3(wallFarOffsetX, -wallNearOffsetY, -middleFarOffsetZ));
        middleSouthEastFace.push(new THREE.Vector3(wallFarOffsetX, -wallNearOffsetY, middleNearOffsetZ));
        var middleSouthEastFaceIndex = [0, 3, 2, 2, 1, 0, 3, 4, 5, 5, 2, 3];

        // 2-3. East (Right)
        // Wall
        var middleEastFace = [];
        middleEastFace.push(new THREE.Vector3(wallFarOffsetX, -wallNearOffsetY, -middleFarOffsetZ));
        middleEastFace.push(new THREE.Vector3(wallFarOffsetX, wallNearOffsetY, -middleFarOffsetZ));
        middleEastFace.push(new THREE.Vector3(wallFarOffsetX, wallNearOffsetY, middleNearOffsetZ));
        middleEastFace.push(new THREE.Vector3(wallFarOffsetX, -wallNearOffsetY, middleNearOffsetZ));
        var middleEastFaceIndex = [0, 1, 2, 2, 3, 0];

        // 2-4. North East
        var middleNorthEastFace = [];
        middleNorthEastFace.push(new THREE.Vector3(wallNearOffsetX, wallFarOffsetY, -middleFarOffsetZ));
        middleNorthEastFace.push(new THREE.Vector3(wallNearOffsetX, wallFarOffsetY, middleNearOffsetZ));
        middleNorthEastFace.push(new THREE.Vector3(wallFarOffsetX, wallFarOffsetY, middleNearOffsetZ));
        middleNorthEastFace.push(new THREE.Vector3(wallFarOffsetX, wallFarOffsetY, -middleFarOffsetZ));
        middleNorthEastFace.push(new THREE.Vector3(wallFarOffsetX, wallNearOffsetY, -middleFarOffsetZ));
        middleNorthEastFace.push(new THREE.Vector3(wallFarOffsetX, wallNearOffsetY, middleNearOffsetZ));
        var middleNorthEastFaceIndex = [0, 1, 2, 2, 3, 0, 3, 2, 5, 5, 4, 3];

        // 2-5. North (Back)
        var middleNorthFace = [];
        middleNorthFace.push(new THREE.Vector3(-wallNearOffsetX, wallFarOffsetY, -middleFarOffsetZ));
        middleNorthFace.push(new THREE.Vector3(wallNearOffsetX, wallFarOffsetY, -middleFarOffsetZ));
        middleNorthFace.push(new THREE.Vector3(wallNearOffsetX, wallFarOffsetY, middleNearOffsetZ));
        middleNorthFace.push(new THREE.Vector3(-wallNearOffsetX, wallFarOffsetY, middleNearOffsetZ));
        var middleNorthFaceIndex = [0, 3, 2, 2, 1, 0];

        // 2-6. North West
        var middleNorthWestFace = [];
        middleNorthWestFace.push(new THREE.Vector3(-wallNearOffsetX, wallFarOffsetY, -middleFarOffsetZ));
        middleNorthWestFace.push(new THREE.Vector3(-wallNearOffsetX, wallFarOffsetY, middleNearOffsetZ));
        middleNorthWestFace.push(new THREE.Vector3(-wallFarOffsetX, wallFarOffsetY, middleNearOffsetZ));
        middleNorthWestFace.push(new THREE.Vector3(-wallFarOffsetX, wallFarOffsetY, -middleFarOffsetZ));
        middleNorthWestFace.push(new THREE.Vector3(-wallFarOffsetX, wallNearOffsetY, -middleFarOffsetZ));
        middleNorthWestFace.push(new THREE.Vector3(-wallFarOffsetX, wallNearOffsetY, middleNearOffsetZ));
        var middleNorthWestFaceIndex = [0, 3, 2, 2, 1, 0, 3, 4, 5, 5, 2, 3];

        // 2-7. West (Left)
        // Wall
        var middleWestFace = [];
        middleWestFace.push(new THREE.Vector3(-wallFarOffsetX, -wallNearOffsetY, -middleFarOffsetZ));
        middleWestFace.push(new THREE.Vector3(-wallFarOffsetX, wallNearOffsetY, -middleFarOffsetZ));
        middleWestFace.push(new THREE.Vector3(-wallFarOffsetX, wallNearOffsetY, middleNearOffsetZ));
        middleWestFace.push(new THREE.Vector3(-wallFarOffsetX, -wallNearOffsetY, middleNearOffsetZ));
        var middleWestFaceIndex = [0, 3, 2, 2, 1, 0];

        // 2-8. South West
        var middleSouthWestFace = [];
        middleSouthWestFace.push(new THREE.Vector3(-wallNearOffsetX, -wallFarOffsetY, -middleFarOffsetZ));
        middleSouthWestFace.push(new THREE.Vector3(-wallNearOffsetX, -wallFarOffsetY, middleNearOffsetZ));
        middleSouthWestFace.push(new THREE.Vector3(-wallFarOffsetX, -wallFarOffsetY, middleNearOffsetZ));
        middleSouthWestFace.push(new THREE.Vector3(-wallFarOffsetX, -wallFarOffsetY, -middleFarOffsetZ));
        middleSouthWestFace.push(new THREE.Vector3(-wallFarOffsetX, -wallNearOffsetY, -middleFarOffsetZ));
        middleSouthWestFace.push(new THREE.Vector3(-wallFarOffsetX, -wallNearOffsetY, middleNearOffsetZ));
        var middleSouthWestFaceIndex = [0, 1, 2, 2, 3, 0, 3, 2, 5, 5, 4, 3];

        // Door
        var doorFarOffsetX = houseDoorWidth / 2.0;
        var doorFarOffsetY = wallFarOffsetY + 0.01;
        var doorNearOffsetZ = houseSillHeight * 2 + houseDoorHeight - houseHalfHeight;
        var doorFarOffsetZ = houseHalfHeight - houseSillHeight * 2;
        var middleDoorFace = [];
        middleDoorFace.push(new THREE.Vector3(-doorFarOffsetX, -doorFarOffsetY, -doorFarOffsetZ));
        middleDoorFace.push(new THREE.Vector3(doorFarOffsetX, -doorFarOffsetY, -doorFarOffsetZ));
        middleDoorFace.push(new THREE.Vector3(doorFarOffsetX, -doorFarOffsetY, doorNearOffsetZ));
        middleDoorFace.push(new THREE.Vector3(-doorFarOffsetX, -doorFarOffsetY, doorNearOffsetZ));
        var middleDoorFaceIndex = [0, 1, 2, 2, 3, 0];

        // Right Window
        var windowFarOffsetX = wallFarOffsetX + 0.01;
        var windowFarOffsetY = houseWindowWidth / 2.0;
        var windowFarOffsetZ = houseSillHeight * 2 + houseDoorHeight - houseHalfHeight;
        var windowNearOffsetZ = houseSillHeight * 2 + houseDoorHeight - houseWindowWidth - houseHalfHeight;
        var middleRightWindowFace = [];
        middleRightWindowFace.push(new THREE.Vector3(windowFarOffsetX, -windowFarOffsetY, windowNearOffsetZ));
        middleRightWindowFace.push(new THREE.Vector3(windowFarOffsetX, windowFarOffsetY, windowNearOffsetZ));
        middleRightWindowFace.push(new THREE.Vector3(windowFarOffsetX, windowFarOffsetY, windowFarOffsetZ));
        middleRightWindowFace.push(new THREE.Vector3(windowFarOffsetX, -windowFarOffsetY, windowFarOffsetZ));
        var middleRightWindowFaceIndex = [0, 1, 2, 2, 3, 0];

        // Left Window
        var middleLeftWindowFace = [];
        middleLeftWindowFace.push(new THREE.Vector3(-windowFarOffsetX, -windowFarOffsetY, windowNearOffsetZ));
        middleLeftWindowFace.push(new THREE.Vector3(-windowFarOffsetX, windowFarOffsetY, windowNearOffsetZ));
        middleLeftWindowFace.push(new THREE.Vector3(-windowFarOffsetX, windowFarOffsetY, windowFarOffsetZ));
        middleLeftWindowFace.push(new THREE.Vector3(-windowFarOffsetX, -windowFarOffsetY, windowFarOffsetZ));
        var middleLeftWindowFaceIndex = [0, 3, 2, 2, 1, 0];

        // ----- House Roof -----
        var roofBottomFarOffsetX = houseRoofBottomLength / 2.0;
        var roofBottomNearOffsetX = houseRoofBottomLength / 2.0 - houseCornerWidth;
        var roofBottomFarOffsetY = houseRoofBottomWidth / 2.0;
        var roofBottomNearOffsetY = houseRoofBottomWidth / 2.0 - houseCornerWidth;

        var roofTopFarOffsetX = houseRoofTopLength / 2.0;
        var roofTopNearOffsetX = houseRoofTopLength / 2.0 - houseCornerWidth;
        var roofTopFarOffsetY = houseRoofTopWidth / 2.0;
        var roofTopNearOffsetY = houseRoofTopWidth / 2.0 - houseCornerWidth;

        var roofFarOffsetZ = houseHalfHeight;
        var roofNearOffsetZ = houseWallHeight - houseHalfHeight;

        // 3-1. South (Front)
        var roofSouthFace = [];
        roofSouthFace.push(new THREE.Vector3(-roofBottomNearOffsetX, -roofBottomFarOffsetY, roofNearOffsetZ));
        roofSouthFace.push(new THREE.Vector3(roofBottomNearOffsetX, -roofBottomFarOffsetY, roofNearOffsetZ));
        roofSouthFace.push(new THREE.Vector3(roofTopNearOffsetX, -roofTopFarOffsetY, roofFarOffsetZ));
        roofSouthFace.push(new THREE.Vector3(-roofTopNearOffsetX, -roofTopFarOffsetY, roofFarOffsetZ));
        roofSouthFace.push(new THREE.Vector3(-roofTopNearOffsetX, -roofTopNearOffsetY, roofFarOffsetZ));
        roofSouthFace.push(new THREE.Vector3(roofTopNearOffsetX, -roofTopNearOffsetY, roofFarOffsetZ));
        var roofSouthFaceIndex = [0, 1, 2, 0, 2, 3, 4, 3, 2, 4, 2, 5];

        // 3-2. South East
        var roofSouthEastFace = [];
        roofSouthEastFace.push(new THREE.Vector3(roofTopFarOffsetX, -roofTopFarOffsetY, roofFarOffsetZ));
        roofSouthEastFace.push(new THREE.Vector3(roofTopFarOffsetX, -roofTopNearOffsetY, roofFarOffsetZ));
        roofSouthEastFace.push(new THREE.Vector3(roofTopNearOffsetX, -roofTopNearOffsetY, roofFarOffsetZ));
        roofSouthEastFace.push(new THREE.Vector3(roofTopNearOffsetX, -roofTopFarOffsetY, roofFarOffsetZ));
        roofSouthEastFace.push(new THREE.Vector3(roofBottomNearOffsetX, -roofBottomFarOffsetY, roofNearOffsetZ));
        roofSouthEastFace.push(new THREE.Vector3(roofBottomFarOffsetX, -roofBottomFarOffsetY, roofNearOffsetZ));
        roofSouthEastFace.push(new THREE.Vector3(roofBottomFarOffsetX, -roofBottomNearOffsetY, roofNearOffsetZ));
        var roofSouthEastFaceIndex = [0, 1, 2, 2, 3, 0, 3, 4, 5, 5, 0, 3, 0, 5, 6, 6, 1, 0];

        // 3-3. East (Right)
        var roofEastFace = [];
        roofEastFace.push(new THREE.Vector3(roofBottomFarOffsetX, -roofBottomNearOffsetY, roofNearOffsetZ));
        roofEastFace.push(new THREE.Vector3(roofBottomFarOffsetX, roofBottomNearOffsetY, roofNearOffsetZ));
        roofEastFace.push(new THREE.Vector3(roofTopFarOffsetX, roofTopNearOffsetY, roofFarOffsetZ));
        roofEastFace.push(new THREE.Vector3(roofTopFarOffsetX, -roofTopNearOffsetY, roofFarOffsetZ));
        roofEastFace.push(new THREE.Vector3(roofTopFarOffsetX - houseCornerWidth, -roofTopNearOffsetY, roofFarOffsetZ));
        roofEastFace.push(new THREE.Vector3(roofTopFarOffsetX - houseCornerWidth, roofTopNearOffsetY, roofFarOffsetZ));
        var roofEastFaceIndex = [0, 1, 2, 0, 2, 3, 4, 3, 2, 4, 2, 5];

        // 3-4. North East
        var roofNorthEastFace = [];
        roofNorthEastFace.push(new THREE.Vector3(roofTopFarOffsetX, roofTopFarOffsetY, roofFarOffsetZ));
        roofNorthEastFace.push(new THREE.Vector3(roofTopFarOffsetX, roofTopNearOffsetY, roofFarOffsetZ));
        roofNorthEastFace.push(new THREE.Vector3(roofTopNearOffsetX, roofTopNearOffsetY, roofFarOffsetZ));
        roofNorthEastFace.push(new THREE.Vector3(roofTopNearOffsetX, roofTopFarOffsetY, roofFarOffsetZ));
        roofNorthEastFace.push(new THREE.Vector3(roofBottomNearOffsetX, roofBottomFarOffsetY, roofNearOffsetZ));
        roofNorthEastFace.push(new THREE.Vector3(roofBottomFarOffsetX, roofBottomFarOffsetY, roofNearOffsetZ));
        roofNorthEastFace.push(new THREE.Vector3(roofBottomFarOffsetX, roofBottomNearOffsetY, roofNearOffsetZ));
        var roofNorthEastFaceIndex = [0, 3, 2, 2, 1, 0, 3, 0, 5, 5, 4, 3, 0, 1, 6, 6, 5, 0];

        // 3-5. North (Back)
        var roofNorthFace = [];
        roofNorthFace.push(new THREE.Vector3(roofBottomNearOffsetX, roofBottomFarOffsetY, roofNearOffsetZ));
        roofNorthFace.push(new THREE.Vector3(-roofBottomNearOffsetX, roofBottomFarOffsetY, roofNearOffsetZ));
        roofNorthFace.push(new THREE.Vector3(-roofTopNearOffsetX, roofTopFarOffsetY, roofFarOffsetZ));
        roofNorthFace.push(new THREE.Vector3(roofTopNearOffsetX, roofTopFarOffsetY, roofFarOffsetZ));
        roofNorthFace.push(new THREE.Vector3(roofTopNearOffsetX, roofTopNearOffsetY, roofFarOffsetZ));
        roofNorthFace.push(new THREE.Vector3(-roofTopNearOffsetX, roofTopNearOffsetY, roofFarOffsetZ));
        var roofNorthFaceIndex = [0, 1, 2, 0, 2, 3, 4, 3, 2, 4, 2, 5];

        // 3-6. North West
        var roofNorthWestFace = [];
        roofNorthWestFace.push(new THREE.Vector3(-roofTopFarOffsetX, roofTopFarOffsetY, roofFarOffsetZ));
        roofNorthWestFace.push(new THREE.Vector3(-roofTopFarOffsetX, roofTopNearOffsetY, roofFarOffsetZ));
        roofNorthWestFace.push(new THREE.Vector3(-roofTopNearOffsetX, roofTopNearOffsetY, roofFarOffsetZ));
        roofNorthWestFace.push(new THREE.Vector3(-roofTopNearOffsetX, roofTopFarOffsetY, roofFarOffsetZ));
        roofNorthWestFace.push(new THREE.Vector3(-roofBottomNearOffsetX, roofBottomFarOffsetY, roofNearOffsetZ));
        roofNorthWestFace.push(new THREE.Vector3(-roofBottomFarOffsetX, roofBottomFarOffsetY, roofNearOffsetZ));
        roofNorthWestFace.push(new THREE.Vector3(-roofBottomFarOffsetX, roofBottomNearOffsetY, roofNearOffsetZ));
        var roofNorthWestFaceIndex = [0, 1, 2, 2, 3, 0, 3, 4, 5, 5, 0, 3, 0, 5, 6, 6, 1, 0];

        // 3-7. West (Left)
        var roofWestFace = [];
        roofWestFace.push(new THREE.Vector3(-roofBottomFarOffsetX, roofBottomNearOffsetY, roofNearOffsetZ));
        roofWestFace.push(new THREE.Vector3(-roofBottomFarOffsetX, -roofBottomNearOffsetY, roofNearOffsetZ));
        roofWestFace.push(new THREE.Vector3(-roofTopFarOffsetX, -roofTopNearOffsetY, roofFarOffsetZ));
        roofWestFace.push(new THREE.Vector3(-roofTopFarOffsetX, roofTopNearOffsetY, roofFarOffsetZ));
        roofWestFace.push(new THREE.Vector3(-roofTopNearOffsetX, roofTopNearOffsetY, roofFarOffsetZ));
        roofWestFace.push(new THREE.Vector3(-roofTopNearOffsetX, -roofTopNearOffsetY, roofFarOffsetZ));
        var roofWestFaceIndex = [0, 1, 2, 0, 2, 3, 4, 3, 2, 4, 2, 5];

        // 3-8. South West
        var roofSouthWestFace = [];
        roofSouthWestFace.push(new THREE.Vector3(-roofTopFarOffsetX, -roofTopFarOffsetY, roofFarOffsetZ));
        roofSouthWestFace.push(new THREE.Vector3(-roofTopFarOffsetX, -roofTopNearOffsetY, roofFarOffsetZ));
        roofSouthWestFace.push(new THREE.Vector3(-roofTopNearOffsetX, -roofTopNearOffsetY, roofFarOffsetZ));
        roofSouthWestFace.push(new THREE.Vector3(-roofTopNearOffsetX, -roofTopFarOffsetY, roofFarOffsetZ));
        roofSouthWestFace.push(new THREE.Vector3(-roofBottomNearOffsetX, -roofBottomFarOffsetY, roofNearOffsetZ));
        roofSouthWestFace.push(new THREE.Vector3(-roofBottomFarOffsetX, -roofBottomFarOffsetY, roofNearOffsetZ));
        roofSouthWestFace.push(new THREE.Vector3(-roofBottomFarOffsetX, -roofBottomNearOffsetY, roofNearOffsetZ));
        var roofSouthWestFaceIndex = [0, 3, 2, 2, 1, 0, 3, 0, 5, 5, 4, 3, 0, 1, 6, 6, 5, 0];

        // 3-9. Roof Top
        // Center
        var roofCenterFace = [];
        roofCenterFace.push(new THREE.Vector3(roofTopNearOffsetX, -roofTopNearOffsetY, roofFarOffsetZ));
        roofCenterFace.push(new THREE.Vector3(-roofTopNearOffsetX, -roofTopNearOffsetY, roofFarOffsetZ));
        roofCenterFace.push(new THREE.Vector3(-roofTopNearOffsetX, roofTopNearOffsetY, roofFarOffsetZ));
        roofCenterFace.push(new THREE.Vector3(roofTopNearOffsetX, roofTopNearOffsetY, roofFarOffsetZ));
        var roofCenterFaceIndex = [0, 2, 1, 0, 3, 2];

        // Eaves bottom
        var roofEavesFace = [];
        roofEavesFace.push(new THREE.Vector3(roofBottomFarOffsetX, roofBottomFarOffsetY, roofNearOffsetZ));
        roofEavesFace.push(new THREE.Vector3(-roofBottomFarOffsetX, roofBottomFarOffsetY, roofNearOffsetZ));
        roofEavesFace.push(new THREE.Vector3(-roofBottomFarOffsetX, -roofBottomFarOffsetY, roofNearOffsetZ));
        roofEavesFace.push(new THREE.Vector3(roofBottomFarOffsetX, -roofBottomFarOffsetY, roofNearOffsetZ));
        roofEavesFace.push(new THREE.Vector3(wallFarOffsetX, wallFarOffsetY, roofNearOffsetZ));
        roofEavesFace.push(new THREE.Vector3(-wallFarOffsetX, wallFarOffsetY, roofNearOffsetZ));
        roofEavesFace.push(new THREE.Vector3(-wallFarOffsetX, -wallFarOffsetY, roofNearOffsetZ));
        roofEavesFace.push(new THREE.Vector3(wallFarOffsetX, -wallFarOffsetY, roofNearOffsetZ));
        var roofEavesFaceIndex = [0, 4, 5, 5, 1, 0, 1, 5, 6, 6, 2, 1, 2, 6, 7, 7, 3, 2, 3, 7, 4, 4, 0, 3];

        var verticesList = [bottomSouthFace, bottomSouthEastFace, bottomEastFace, bottomNorthEastFace, bottomNorthFace, bottomNorthWestFace, bottomWestFace, bottomSouthWestFace, bottomFloorFace, middleSouthFace, middleSouthEastFace, middleEastFace, middleNorthEastFace, middleNorthFace, middleNorthWestFace, middleWestFace, middleSouthWestFace, middleDoorFace, middleRightWindowFace, middleLeftWindowFace, roofSouthFace, roofSouthEastFace, roofEastFace, roofNorthEastFace, roofNorthFace, roofNorthWestFace, roofWestFace, roofSouthWestFace, roofCenterFace, roofEavesFace];

        var indicesList = [bottomSouthFaceIndex, bottomSouthEastFaceIndex, bottomEastFaceIndex, bottomNorthEastFaceIndex, bottomNorthFaceIndex, bottomNorthWestFaceIndex, bottomWestFaceIndex, bottomSouthWestFaceIndex, bottomFloorFaceIndex, middleSouthFaceIndex, middleSouthEastFaceIndex, middleEastFaceIndex, middleNorthEastFaceIndex, middleNorthFaceIndex, middleNorthWestFaceIndex, middleWestFaceIndex, middleSouthWestFaceIndex, middleDoorFaceIndex, middleRightWindowFaceIndex, middleLeftWindowFaceIndex, roofSouthFaceIndex, roofSouthEastFaceIndex, roofEastFaceIndex, roofNorthEastFaceIndex, roofNorthFaceIndex, roofNorthWestFaceIndex, roofWestFaceIndex, roofSouthWestFaceIndex, roofCenterFaceIndex, roofEavesFaceIndex];

        var namesList = [_componentNames.BottomSouth, _componentNames.BottomSouthEast, _componentNames.BottomEast, _componentNames.BottomNorthEast, _componentNames.BottomNorth, _componentNames.BottomNorthWest, _componentNames.BottomWest, _componentNames.BottomSouthWest, _componentNames.BottomFloor, _componentNames.MiddleSouth, _componentNames.MiddleSouthEast, _componentNames.MiddleEast, _componentNames.MiddleNorthEast, _componentNames.MiddleNorth, _componentNames.MiddleNorthWest, _componentNames.MiddleWest, _componentNames.MiddleSouthWest, _componentNames.MiddleDoor, _componentNames.MiddleRightWindow, _componentNames.MiddleLeftWindow, _componentNames.RoofSouth, _componentNames.RoofSouthEast, _componentNames.RoofEast, _componentNames.RoofNorthEast, _componentNames.RoofNorth, _componentNames.RoofNorthWest, _componentNames.RoofWest, _componentNames.RoofSouthWest, _componentNames.RoofCenter, _componentNames.RoofEaves];

        var colors = [houseDoorRoofColor, houseWallColor, houseWallColor, houseWallColor, houseWallColor, houseWallColor, houseWallColor, houseWallColor, houseWallColor, houseWallColor, houseWallColor, houseWallColor, houseWallColor, houseWallColor, houseWallColor, houseWallColor, houseWallColor, houseDoorRoofColor, houseDoorRoofColor, houseDoorRoofColor, houseDoorRoofColor, houseDoorRoofColor, houseDoorRoofColor, houseDoorRoofColor, houseDoorRoofColor, houseDoorRoofColor, houseDoorRoofColor, houseDoorRoofColor, houseWallColor, houseWallColor];

        for (var i = 0; i < verticesList.length; ++i) {
            createMesh(_groupHouse, verticesList[i], indicesList[i], colors[i], namesList[i]);
        }

        // --------------------- house wire frame --------------------- //
        var houseWireVertex = []; // house wire frame

        // floor
        houseWireVertex.push(new THREE.Vector3(-wallFarOffsetX, -wallFarOffsetY, -bottomFarOffsetZ));
        houseWireVertex.push(new THREE.Vector3(wallFarOffsetX, -wallFarOffsetY, -bottomFarOffsetZ));
        houseWireVertex.push(new THREE.Vector3(wallFarOffsetX, wallFarOffsetY, -bottomFarOffsetZ));
        houseWireVertex.push(new THREE.Vector3(-wallFarOffsetX, wallFarOffsetY, -bottomFarOffsetZ));

        // ceiling
        houseWireVertex.push(new THREE.Vector3(-wallFarOffsetX, -wallFarOffsetY, roofNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(wallFarOffsetX, -wallFarOffsetY, roofNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(wallFarOffsetX, wallFarOffsetY, roofNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(-wallFarOffsetX, wallFarOffsetY, roofNearOffsetZ));

        // roof bottom
        houseWireVertex.push(new THREE.Vector3(-roofBottomFarOffsetX, -roofBottomFarOffsetY, roofNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(roofBottomFarOffsetX, -roofBottomFarOffsetY, roofNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(roofBottomFarOffsetX, roofBottomFarOffsetY, roofNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(-roofBottomFarOffsetX, roofBottomFarOffsetY, roofNearOffsetZ));

        // roof top
        houseWireVertex.push(new THREE.Vector3(-roofTopFarOffsetX, -roofTopFarOffsetY, roofFarOffsetZ));
        houseWireVertex.push(new THREE.Vector3(roofTopFarOffsetX, -roofTopFarOffsetY, roofFarOffsetZ));
        houseWireVertex.push(new THREE.Vector3(roofTopFarOffsetX, roofTopFarOffsetY, roofFarOffsetZ));
        houseWireVertex.push(new THREE.Vector3(-roofTopFarOffsetX, roofTopFarOffsetY, roofFarOffsetZ));

        // sill bottom
        houseWireVertex.push(new THREE.Vector3(-sillBottomNearOffsetX, -sillBottomFarOffsetY, -sillBottomFarOffsetZ));
        houseWireVertex.push(new THREE.Vector3(sillBottomNearOffsetX, -sillBottomFarOffsetY, -sillBottomFarOffsetZ));
        houseWireVertex.push(new THREE.Vector3(sillBottomNearOffsetX, -sillBottomFarOffsetY, -sillBottomNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(-sillBottomNearOffsetX, -sillBottomFarOffsetY, -sillBottomNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(-sillBottomNearOffsetX, -sillBottomNearOffsetY, -sillBottomFarOffsetZ));
        houseWireVertex.push(new THREE.Vector3(sillBottomNearOffsetX, -sillBottomNearOffsetY, -sillBottomFarOffsetZ));
        houseWireVertex.push(new THREE.Vector3(sillBottomNearOffsetX, -sillBottomNearOffsetY, -sillBottomNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(-sillBottomNearOffsetX, -sillBottomNearOffsetY, -sillBottomNearOffsetZ));
        // sill top
        houseWireVertex.push(new THREE.Vector3(-sillTopNearOffsetX, -sillTopFarOffsetY, -sillTopFarOffsetZ));
        houseWireVertex.push(new THREE.Vector3(sillTopNearOffsetX, -sillTopFarOffsetY, -sillTopFarOffsetZ));
        houseWireVertex.push(new THREE.Vector3(sillTopNearOffsetX, -sillTopFarOffsetY, -sillTopNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(-sillTopNearOffsetX, -sillTopFarOffsetY, -sillTopNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(-sillTopNearOffsetX, -sillTopNearOffsetY, -bottomNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(sillTopNearOffsetX, -sillTopNearOffsetY, -bottomNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(sillTopNearOffsetX, -sillTopNearOffsetY, -sillTopNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(-sillTopNearOffsetX, -sillTopNearOffsetY, -sillTopNearOffsetZ));

        // door
        houseWireVertex.push(new THREE.Vector3(-doorFarOffsetX, -doorFarOffsetY, -doorFarOffsetZ));
        houseWireVertex.push(new THREE.Vector3(doorFarOffsetX, -doorFarOffsetY, -doorFarOffsetZ));
        houseWireVertex.push(new THREE.Vector3(doorFarOffsetX, -doorFarOffsetY, doorNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(-doorFarOffsetX, -doorFarOffsetY, doorNearOffsetZ));

        // left window
        houseWireVertex.push(new THREE.Vector3(-windowFarOffsetX, -windowFarOffsetY, windowNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(-windowFarOffsetX, windowFarOffsetY, windowNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(-windowFarOffsetX, windowFarOffsetY, windowFarOffsetZ));
        houseWireVertex.push(new THREE.Vector3(-windowFarOffsetX, -windowFarOffsetY, windowFarOffsetZ));
        // right window
        houseWireVertex.push(new THREE.Vector3(windowFarOffsetX, -windowFarOffsetY, windowNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(windowFarOffsetX, windowFarOffsetY, windowNearOffsetZ));
        houseWireVertex.push(new THREE.Vector3(windowFarOffsetX, windowFarOffsetY, windowFarOffsetZ));
        houseWireVertex.push(new THREE.Vector3(windowFarOffsetX, -windowFarOffsetY, windowFarOffsetZ));

        // 外框
        var wireFrameIndexList = [[0, 1, 2, 3, 0], [4, 5, 6, 7, 4], [0, 4], [1, 5], [3, 7], [2, 6], [8, 9, 10, 11, 8], [12, 13, 14, 15, 12], [8, 12], [9, 13], [10, 14], [11, 15], [16, 17, 18, 19, 16], [20, 21, 22, 23, 20], [16, 20], [17, 21], [18, 22], [19, 23], [24, 25, 26, 27, 24], [28, 29, 30, 31, 28], [24, 28], [25, 29], [26, 30], [27, 31], [32, 33, 34, 35, 32], [36, 37, 38, 39, 36], [40, 41, 42, 43, 40]];

        for (var j = 0; j < wireFrameIndexList.length; ++j) {
            createWireFrame(_groupHouse, houseWireVertex, wireFrameIndexList[j], houseWireFrameColor, _lineWidth);
        }
    };

    // 构造指北针转盘
    var createCompass = function createCompass() {

        // ----------- 指北针 ----------- //
        var compassOutsiderRadius = 82; // 指北针圆盘外环
        var compassInsiderRadius = 65; // 指北针圆盘内环
        var compassTriangleHeight = 30; // 指北针文字对应三角形垂直线长度
        var compassNorthColor = 0x9f4a4a; // 指北针N方向颜色
        var compassColor = 0xdbdbdb; // 指北针圆盘颜色
        var compassFontColor = 0xff0000; // 字体颜色

        // 转盘材质
        var materialDisc = new THREE.MeshBasicMaterial({ color: compassColor, side: THREE.DoubleSide });
        // N方向材质
        var materialNorth = new THREE.MeshBasicMaterial({
            color: compassNorthColor,
            side: THREE.DoubleSide,
            depthTest: false
        });
        // 字体材质
        var materialFont = new THREE.MeshBasicMaterial({
            color: compassFontColor,
            overdraw: 0.0,
            side: THREE.DoubleSide,
            depthTest: false
        });

        // -------- 三角面 -------- //
        var triangleShape = new THREE.Shape();
        triangleShape.moveTo(compassTriangleHeight, 0);
        triangleShape.lineTo(0, compassTriangleHeight / 2);
        triangleShape.lineTo(0, -compassTriangleHeight / 2);
        triangleShape.lineTo(compassTriangleHeight, 0);

        var geometry = new THREE.ShapeGeometry(triangleShape);

        // East
        var meshE = new THREE.Mesh(geometry, materialDisc);
        meshE.translateX(compassOutsiderRadius - 2);

        // West
        var meshW = new THREE.Mesh(geometry, materialDisc);
        meshW.rotateZ(Math.PI);
        meshW.translateX(compassOutsiderRadius - 2);

        // North
        var meshN = new THREE.Mesh(geometry, materialNorth);
        meshN.rotateZ(Math.PI / 2);
        meshN.translateX(compassOutsiderRadius - 2);

        // South
        var meshS = new THREE.Mesh(geometry, materialDisc);
        meshS.rotateZ(-Math.PI / 2);
        meshS.translateX(compassOutsiderRadius - 2);

        _groupCompass.add(meshE);
        _groupCompass.add(meshW);
        _groupCompass.add(meshN);
        _groupCompass.add(meshS);

        // -------- 文字标注 S -------- //

        var font = new THREE.Font(_jsonFont);
        var theTextN = "N";
        var theTextS = "S";
        var theTextE = "E";
        var theTextW = "W";
        var font_parameters = {
            size: 12,
            height: 1,
            curveSegments: 2,
            font: font
        };

        // 文字坐标原点为左下角
        //     - - - -
        //   |   A   |
        //  o - - - -
        var geoTextN = new THREE.TextGeometry(theTextN, font_parameters);
        var geoTextS = new THREE.TextGeometry(theTextS, font_parameters);
        var geoTextE = new THREE.TextGeometry(theTextE, font_parameters);
        var geoTextW = new THREE.TextGeometry(theTextW, font_parameters);

        // 计算包围框
        geoTextN.computeBoundingBox();
        geoTextS.computeBoundingBox();
        geoTextE.computeBoundingBox();
        geoTextW.computeBoundingBox();

        var offsetX;
        var meshTextN, meshTextS, meshTextE, meshTextW;

        offsetX = -0.5 * (geoTextN.boundingBox.max.x - geoTextN.boundingBox.min.x);
        meshTextN = new THREE.Mesh(geoTextN, materialFont);
        meshTextN.translateX(offsetX);
        meshTextN.translateY(compassOutsiderRadius);

        offsetX = -0.5 * (geoTextS.boundingBox.max.x - geoTextS.boundingBox.min.x);
        meshTextS = new THREE.Mesh(geoTextS, materialFont);
        meshTextS.rotateZ(Math.PI);
        meshTextS.translateX(offsetX);
        meshTextS.translateY(compassOutsiderRadius);

        offsetX = -0.5 * (geoTextE.boundingBox.max.x - geoTextE.boundingBox.min.x);
        meshTextE = new THREE.Mesh(geoTextE, materialFont);
        meshTextE.rotateZ(-Math.PI / 2);
        meshTextE.translateX(offsetX);
        meshTextE.translateY(compassOutsiderRadius);

        offsetX = -0.5 * (geoTextE.boundingBox.max.x - geoTextE.boundingBox.min.x);
        meshTextW = new THREE.Mesh(geoTextW, materialFont);
        meshTextW.rotateZ(Math.PI / 2);
        meshTextW.translateX(offsetX);
        meshTextW.translateY(compassOutsiderRadius);

        _groupCompass.add(meshTextN);
        _groupCompass.add(meshTextS);
        _groupCompass.add(meshTextE);
        _groupCompass.add(meshTextW);

        // -------- 文字标注 E -------- //

        // -------- 指北针圆盘 -------- //
        var discShape = new THREE.RingGeometry(compassInsiderRadius, compassOutsiderRadius, 32, 5, 0, Math.PI * 2);
        var mesh = new THREE.Mesh(discShape, materialDisc);
        mesh.name = _componentNames.Compass;
        _groupCompass.add(mesh);
    };

    // 构造控制圆环
    var createControlRing = function createControlRing() {
        // ----------- 控制圆环 ----------- //
        var ringColor = 0x99a4b5; // 圆环及圆环控制点颜色
        var ringRadius = 75; // 圆环半径
        var ringPointRadius = 10; // 圆环控制点半径
        var ringWidth = 3; // 圆环宽度

        // 圆环材质
        var materialRingParameter = { color: ringColor, side: THREE.DoubleSide };
        var materialPointParameter = { color: ringColor, side: THREE.DoubleSide };

        // -------- 圆环 由4段构成 -------- //
        var startAngle = Math.asin(ringPointRadius / ringRadius);
        var endAngle = Math.PI / 2 - startAngle * 2;
        var ringShape = new THREE.RingGeometry(ringRadius - ringWidth / 2, ringRadius + ringWidth / 2, 32, 5, startAngle, endAngle);

        // NorthEast
        var mesh = new THREE.Mesh(ringShape, new THREE.MeshBasicMaterial(materialRingParameter));
        mesh.name = _componentNames.ControlRingNorthEast;
        _groupControlRing.add(mesh);

        // NorthWest
        var mesh = new THREE.Mesh(ringShape, new THREE.MeshBasicMaterial(materialRingParameter));
        mesh.name = _componentNames.ControlRingNorthWest;
        mesh.rotateZ(Math.PI / 2);
        _groupControlRing.add(mesh);

        // SouthWest
        var mesh = new THREE.Mesh(ringShape, new THREE.MeshBasicMaterial(materialRingParameter));
        mesh.name = _componentNames.ControlRingSouthWest;
        mesh.rotateZ(Math.PI);
        _groupControlRing.add(mesh);

        // SouthEast
        var mesh = new THREE.Mesh(ringShape, new THREE.MeshBasicMaterial(materialRingParameter));
        mesh.name = _componentNames.ControlRingSouthEast;
        mesh.rotateZ(-Math.PI / 2);
        _groupControlRing.add(mesh);

        // -------- 圆形控制点 -------- //
        var circleShape = new THREE.Shape();
        circleShape.moveTo(ringPointRadius, 0);
        circleShape.absarc(0, 0, ringPointRadius, 0, Math.PI * 2, false);
        var geometry = new THREE.ShapeGeometry(circleShape);

        // N
        var mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial(materialPointParameter));
        mesh.name = _componentNames.ControlPointNorth;
        mesh.rotateZ(Math.PI / 2);
        mesh.translateX(ringRadius);
        _groupControlRing.add(mesh);

        // S
        var mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial(materialPointParameter));
        mesh.name = _componentNames.ControlPointSouth;
        mesh.rotateZ(-Math.PI / 2);
        mesh.translateX(ringRadius);
        _groupControlRing.add(mesh);

        // E
        var mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial(materialPointParameter));
        mesh.name = _componentNames.ControlPointEast;
        mesh.translateX(ringRadius);
        _groupControlRing.add(mesh);

        // W
        var mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial(materialPointParameter));
        mesh.name = _componentNames.ControlPointWest;
        mesh.translateX(-ringRadius);
        _groupControlRing.add(mesh);
    };

    // 构造Home模型
    var createHome = function createHome() {
        // ----------- Home ----------- //
        var homeWallColor = 0xe7e7ec; // 墙壁颜色
        var homeWireFrameColor = 0x787878; // 线框颜色
        var homeWallHeight = 15; // 墙高
        var homeWallWidth = 24; // 墙宽
        var homeRoofHeight = 15; // 屋顶高
        var homeRoofWidth = 30; // 屋顶宽
        var homeDoorHeight = 13; // 门高
        var homeDoorWidth = 8; // 门宽
        var homeScaleCoe = 1.0; // 缩放系数
        var homeOffsetX = _viewHouseRadius - homeRoofWidth / 2; // 距离中心点偏移量
        var homeOffsetZ = _viewHouseRadius - (homeWallHeight + homeRoofHeight); // 距离中心点偏移量

        var houseVertices = [];
        houseVertices.push(new THREE.Vector3(0, homeWallHeight + homeRoofHeight, 0));
        houseVertices.push(new THREE.Vector3(-homeRoofWidth / 2, homeWallHeight, 0));
        houseVertices.push(new THREE.Vector3(-homeWallWidth / 2, homeWallHeight, 0));
        houseVertices.push(new THREE.Vector3(-homeWallWidth / 2, 0, 0));
        houseVertices.push(new THREE.Vector3(-homeDoorWidth / 2, 0, 0));
        houseVertices.push(new THREE.Vector3(-homeDoorWidth / 2, homeDoorHeight, 0));
        houseVertices.push(new THREE.Vector3(homeDoorWidth / 2, homeDoorHeight, 0));
        houseVertices.push(new THREE.Vector3(homeDoorWidth / 2, 0, 0));
        houseVertices.push(new THREE.Vector3(homeWallWidth / 2, 0, 0));
        houseVertices.push(new THREE.Vector3(homeWallWidth / 2, homeWallHeight, 0));
        houseVertices.push(new THREE.Vector3(homeRoofWidth / 2, homeWallHeight, 0));
        houseVertices.push(new THREE.Vector3(0, homeWallHeight + homeRoofHeight, 0));

        // 轮廓线
        var geometry = new THREE.Geometry();

        for (var i = 0; i < houseVertices.length; ++i) {
            geometry.vertices.push(houseVertices[i].multiplyScalar(homeScaleCoe));
        }

        var mesh = new THREE.Line(geometry, new THREE.LineBasicMaterial({
            color: homeWireFrameColor,
            linewidth: _lineWidth
        }));
        mesh.position.x = -homeOffsetX;
        mesh.position.y = homeOffsetZ;
        _groupHome.add(mesh);

        // 内部面
        var houseShape = new THREE.Shape();
        houseShape.moveTo(houseVertices[0].x, houseVertices[0].y);

        for (var j = 1; j < houseVertices.length; ++j) {
            houseShape.lineTo(houseVertices[j].x, houseVertices[j].y);
        }

        var geometry = new THREE.ShapeGeometry(houseShape);
        var mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
            color: homeWallColor,
            side: THREE.DoubleSide
        }));
        mesh.position.x = -homeOffsetX;
        mesh.position.y = homeOffsetZ;
        mesh.name = _componentNames.Home;
        _groupHome.add(mesh);

        // ------ 主视图图标 E ------ //
    };

    // 构建高亮圆环
    var createHighLightRing = function createHighLightRing() {

        // ----------- 高亮 ----------- //
        var activeColor = 0xb1d1ec; // 选中区域高亮颜色
        var activeEdgeColor = 0x776d4; // 选中区域高亮边线颜色
        var ringPointRadius = 10; // 圆环控制点半径
        var ringRadius = 75; // 圆环半径

        // 选中高亮材质
        var materialActiveParameter = { color: activeColor, side: THREE.DoubleSide /*, depthTest: false*/ };
        //  旋转箭头
        var materialArrowParameter = { color: activeEdgeColor, linewidth: _lineWidth };
        // 高亮区域圆环
        var startAngle = Math.asin(ringPointRadius / ringRadius);
        var endAngle = Math.PI / 2 - startAngle * 2;
        var ringShape = new THREE.RingGeometry(ringRadius - ringPointRadius / 3, ringRadius + ringPointRadius / 3, 32, 5, startAngle, endAngle);

        _highLightRingRadius = ringRadius;

        // ------------ 圆环 ------------ //
        _highlightRingMesh = new THREE.Mesh(ringShape, new THREE.MeshBasicMaterial(materialActiveParameter));
        _highlightRingMesh.translateZ(0.01);
        _groupHightLight.add(_highlightRingMesh);

        // 保存旋转量
        _highlightRingQuat = new THREE.Quaternion();
        _highlightRingQuat.copy(_highlightRingMesh.quaternion);
        _highlightRingPos = new THREE.Vector3();
        _highlightRingPos.copy(_highlightRingMesh.position);

        // ------------ 高亮圆形控制点 ------------ //
        var circleShape = new THREE.Shape();
        circleShape.moveTo(ringPointRadius, 0);
        circleShape.absarc(0, 0, ringPointRadius, 0, Math.PI * 2, false);
        var geometry = new THREE.ShapeGeometry(circleShape);

        _highlightPointMesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial(materialActiveParameter));
        _highlightPointMesh.translateZ(0.01);
        _groupHightLight.add(_highlightPointMesh);

        // 保存旋转量
        _highlightPointQuat = new THREE.Quaternion();
        _highlightPointQuat.copy(_highlightPointMesh.quaternion);
        _highlightPointPos = new THREE.Vector3();
        _highlightPointPos.copy(_highlightPointMesh.position);

        //  ------------ 旋转箭头 ------------ //
        // ---------------------
        //   0
        //   |
        //   |
        //  1 ------- 2
        // ---------------------
        // 箭头点集
        var baseEdge = ringPointRadius * 2 * 0.707;
        var lineVertices = [new THREE.Vector3(baseEdge / 4, baseEdge / 2, 0), new THREE.Vector3(-baseEdge / 4, 0, 0), new THREE.Vector3(baseEdge / 4, -baseEdge / 2, 0)];
        var geometry = new THREE.Geometry();
        for (var i = 0; i < lineVertices.length; ++i) {
            geometry.vertices.push(lineVertices[i]);
        }

        _highlightArrowMesh = new THREE.Line(geometry, new THREE.LineBasicMaterial(materialArrowParameter));
        _highlightArrowMesh.translateZ(0.015);
        _groupHightLight.add(_highlightArrowMesh);

        // 保持旋转量
        _highlightArrowQuat = new THREE.Quaternion();
        _highlightArrowQuat.copy(_highlightArrowMesh.quaternion);
        _highlightArrowPos = new THREE.Vector3();
        _highlightArrowPos.copy(_highlightArrowMesh.position);

        // 不显示
        _highlightRingMesh.visible = false;
        _highlightPointMesh.visible = false;
        _highlightArrowMesh.visible = false;
    };

    var createViewHouse = function createViewHouse() {

        createCompass();
        createHouse();
        createControlRing();
        createHome();
        createHighLightRing();

        // 指北针位置下移半个房屋高度
        _groupCompass.translateZ(-_halfHeight);

        _houseScene.add(_groupCompass);
        _houseScene.add(_groupHouse);

        // BIMFACEDM-2451 SketchUp scene get wrong direction from viewhouse.
        // '_houseScene' is set up based on Zup, while three.js get Yup.
        // rotate houseScene from Zup to Yup.
        var rotation = new THREE.Euler(-Math.PI / 2, 0, 0, THREE.Euler.DefaultOrder);
        _houseScene.rotation.copy(rotation);

        _groupPick.add(_groupHome);
        _groupPick.add(_groupControlRing);

        _groupControlRing.translateZ(30);

        _homeScene.add(_groupPick);
        _homeScene.add(_groupHightLight);
    };

    var setSize = function setSize(mode) {
        switch (mode) {
            case _enumSizeMode.Big:
                scope.width = _enumSize.Big;
                scope.height = _enumSize.Big;
                break;
            case _enumSizeMode.Medium:
                scope.width = _enumSize.Medium;
                scope.height = _enumSize.Medium;
                break;
            case _enumSizeMode.Small:
                scope.width = _enumSize.Small;
                scope.height = _enumSize.Small;
                break;
            default:
                scope.width = _enumSize.Small;
                scope.height = _enumSize.Small;
                break;
        }

        _houseContainer.style.width = scope.width + "px";
        _houseContainer.style.height = scope.height + "px";
    };

    var isValidRange = function isValidRange(mouse) {

        var domElement = _houseContainer;

        if (domElement !== undefined) {
            var dim = CLOUD.DomUtil.getContainerOffsetToClient(domElement);
            var relativeMouse = new THREE.Vector2();

            // 计算鼠标点相对于viewhouse所在视口的位置
            relativeMouse.x = mouse.x - dim.left;
            relativeMouse.y = mouse.y - dim.top;

            // 规范化坐标系
            if (relativeMouse.x > 0 && relativeMouse.x < scope.width && relativeMouse.y > 0 && relativeMouse.y < scope.height) {
                _mouseCoord.x = relativeMouse.x / scope.width * 2 - 1;
                _mouseCoord.y = -relativeMouse.y / scope.height * 2 + 1;

                return true;
            }
        }

        return false;
    };

    var showHome = function showHome(isShow) {
        _isShowHome = isShow;

        if (isShow) {
            _groupHome.visible = true;
        } else {
            _groupHome.visible = false;
        }
    };
    var enableTransparent = function enableTransparent(enable) {
        _isTransparent = enable;

        if (enable) {
            var houseObjects = _groupHouse.children;
            for (var i = 0; i < houseObjects.length; i++) {
                houseObjects[i].material.transparent = true;
                houseObjects[i].material.opacity = _opacityCoe;
            }

            var ringObjects = _groupControlRing.children;
            for (var i = 0; i < ringObjects.length; i++) {
                ringObjects[i].material.transparent = true;
                ringObjects[i].material.opacity = _opacityCoe;
            }

            var compassObjects = _groupCompass.children;
            for (var i = 0; i < compassObjects.length; i++) {
                compassObjects[i].material.transparent = true;
                compassObjects[i].material.opacity = _opacityCoe;
            }

            var homeObjects = _groupHome.children;
            for (var i = 0; i < homeObjects.length; i++) {
                homeObjects[i].material.transparent = true;
                homeObjects[i].material.opacity = _opacityCoe;
            }
        } else {
            var houseObjects = _groupHouse.children;
            for (var i = 0; i < houseObjects.length; i++) {
                houseObjects[i].material.transparent = false;
                houseObjects[i].material.opacity = 1.0;
            }

            var ringObjects = _groupControlRing.children;
            for (var i = 0; i < ringObjects.length; i++) {
                ringObjects[i].material.transparent = false;
                ringObjects[i].material.opacity = 1.0;
            }

            var compassObjects = _groupCompass.children;
            for (var i = 0; i < compassObjects.length; i++) {
                compassObjects[i].material.transparent = false;
                compassObjects[i].material.opacity = 1.0;
            }

            var homeObjects = _groupHome.children;
            for (var i = 0; i < homeObjects.length; i++) {
                homeObjects[i].material.transparent = false;
                homeObjects[i].material.opacity = 1.0;
            }
        }
    };

    var switchView = function switchView(name) {

        //var viewMode = enumView.ISO;
        var viewMode = -1;

        // 计算鼠标所在的象限
        var isClockWise = false;
        if (_mouseCoord.x * _mouseCoord.y > 0) {
            isClockWise = true;
        }

        //console.log("[intersects][name = " + _intersected.name +",isClockWise = " + isClockWise + "]" );

        switch (name) {
            case _componentNames.Home:
                viewMode = _enumViewMode.Home;
                break;
            case _componentNames.RoofCenter:
                if (_currentViewMode === _enumViewMode.RoofFront || _currentViewMode === _enumViewMode.RoofSouthEast || _currentViewMode === _enumViewMode.RoofSouthWest) {
                    viewMode = _enumViewMode.Top;
                } else if (_currentViewMode === _enumViewMode.RoofRight) {
                    viewMode = _enumViewMode.TopTurnRight;
                } else if (_currentViewMode === _enumViewMode.RoofBack || _currentViewMode === _enumViewMode.RoofNorthEast || _currentViewMode === _enumViewMode.RoofNorthWest) {
                    viewMode = _enumViewMode.TopTurnBack;
                } else if (_currentViewMode === _enumViewMode.RoofLeft) {
                    viewMode = _enumViewMode.TopTurnLeft;
                } else if (_currentViewMode === _enumViewMode.TopTurnRight) {
                    viewMode = _enumViewMode.TopTurnRight;
                } else if (_currentViewMode === _enumViewMode.TopTurnBack) {
                    viewMode = _enumViewMode.TopTurnBack;
                } else if (_currentViewMode === _enumViewMode.TopTurnLeft) {
                    viewMode = _enumViewMode.TopTurnLeft;
                } else {
                    viewMode = _enumViewMode.Top; // 默认
                }
                break;
            case _componentNames.BottomFloor:
                if (_currentViewMode === _enumViewMode.BottomFront || _currentViewMode === _enumViewMode.BottomSouthEast || _currentViewMode === _enumViewMode.BottomSouthWest) {
                    viewMode = _enumViewMode.Bottom;
                } else if (_currentViewMode === _enumViewMode.BottomRight) {
                    viewMode = _enumViewMode.BottomTurnLeft;
                } else if (_currentViewMode === _enumViewMode.BottomBack || _currentViewMode === _enumViewMode.BottomNorthEast || _currentViewMode === _enumViewMode.BottomNorthWest) {
                    viewMode = _enumViewMode.BottomTurnBack;
                } else if (_currentViewMode === _enumViewMode.BottomLeft) {
                    viewMode = _enumViewMode.BottomTurnRight;
                } else if (_currentViewMode === _enumViewMode.BottomTurnRight) {
                    viewMode = _enumViewMode.BottomTurnRight;
                } else if (_currentViewMode === _enumViewMode.BottomTurnBack) {
                    viewMode = _enumViewMode.BottomTurnBack;
                } else if (_currentViewMode === _enumViewMode.BottomTurnLeft) {
                    viewMode = _enumViewMode.BottomTurnLeft;
                } else {
                    viewMode = _enumViewMode.Bottom; // 默认
                }
                break;
            case _componentNames.BottomSouth:
                viewMode = _enumViewMode.BottomFront;
                break;
            case _componentNames.BottomNorth:
                viewMode = _enumViewMode.BottomBack;
                break;
            case _componentNames.BottomEast:
                viewMode = _enumViewMode.BottomRight;
                break;
            case _componentNames.BottomWest:
                viewMode = _enumViewMode.BottomLeft;
                break;
            case _componentNames.BottomSouthEast:
                viewMode = _enumViewMode.BottomSouthEast;
                break;
            case _componentNames.BottomSouthWest:
                viewMode = _enumViewMode.BottomSouthWest;
                break;
            case _componentNames.BottomNorthWest:
                viewMode = _enumViewMode.BottomNorthWest;
                break;
            case _componentNames.BottomNorthEast:
                viewMode = _enumViewMode.BottomNorthEast;
                break;
            case _componentNames.MiddleSouth:
            case _componentNames.MiddleDoor:
                viewMode = _enumViewMode.Front;
                break;
            case _componentNames.MiddleNorth:
                viewMode = _enumViewMode.Back;
                break;
            case _componentNames.MiddleRightWindow:
            case _componentNames.MiddleEast:
                viewMode = _enumViewMode.Right;
                break;
            case _componentNames.MiddleWest:
            case _componentNames.MiddleLeftWindow:
                viewMode = _enumViewMode.Left;
                break;
            case _componentNames.MiddleSouthEast:
                viewMode = _enumViewMode.SouthEast;
                break;
            case _componentNames.MiddleSouthWest:
                viewMode = _enumViewMode.SouthWest;
                break;
            case _componentNames.MiddleNorthWest:
                viewMode = _enumViewMode.NorthWest;
                break;
            case _componentNames.MiddleNorthEast:
                viewMode = _enumViewMode.NorthEast;
                break;
            case _componentNames.RoofSouth:
                viewMode = _enumViewMode.RoofFront;
                break;
            case _componentNames.RoofNorth:
                viewMode = _enumViewMode.RoofBack;
                break;
            case _componentNames.RoofEast:
                viewMode = _enumViewMode.RoofRight;
                break;
            case _componentNames.RoofWest:
                viewMode = _enumViewMode.RoofLeft;
                break;
            case _componentNames.RoofSouthEast:
                viewMode = _enumViewMode.RoofSouthEast;
                break;
            case _componentNames.RoofSouthWest:
                viewMode = _enumViewMode.RoofSouthWest;
                break;
            case _componentNames.RoofNorthWest:
                viewMode = _enumViewMode.RoofNorthWest;
                break;
            case _componentNames.RoofNorthEast:
                viewMode = _enumViewMode.RoofNorthEast;
                break;
            case _componentNames.ControlPointNorth:
                // 前 - 顶 - 后 - 后顶 - 前
                if (_currentViewMode === _enumViewMode.Front) {
                    viewMode = _enumViewMode.Top;
                } else if (_currentViewMode === _enumViewMode.Top) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.Back) {
                    viewMode = _enumViewMode.TopTurnBack;
                } else if (_currentViewMode === _enumViewMode.TopTurnBack) {
                    viewMode = _enumViewMode.Front;
                } else if (_currentViewMode === _enumViewMode.Right) {
                    viewMode = _enumViewMode.TopTurnRight;
                } else if (_currentViewMode === _enumViewMode.TopTurnRight) {
                    viewMode = _enumViewMode.Left;
                } else if (_currentViewMode === _enumViewMode.Left) {
                    viewMode = _enumViewMode.TopTurnLeft;
                } else if (_currentViewMode === _enumViewMode.TopTurnLeft) {
                    viewMode = _enumViewMode.Right;
                } else if (_currentViewMode === _enumViewMode.BackTurnRight) {
                    viewMode = _enumViewMode.Left;
                } else if (_currentViewMode === _enumViewMode.BackTurnLeft) {
                    viewMode = _enumViewMode.Right;
                } else if (_currentViewMode === _enumViewMode.BackTurnTop) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.RightTurnFront) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.RightTurnBack) {
                    viewMode = _enumViewMode.Front;
                } else if (_currentViewMode === _enumViewMode.RightTurnTop) {
                    viewMode = _enumViewMode.Bottom;
                } else if (_currentViewMode === _enumViewMode.LeftTurnFront) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.LeftTurnBack) {
                    viewMode = _enumViewMode.Front;
                } else if (_currentViewMode === _enumViewMode.LeftTurnTop) {
                    viewMode = _enumViewMode.Bottom;
                } else if (_currentViewMode === _enumViewMode.BottomTurnRight) {
                    viewMode = _enumViewMode.Left;
                } else if (_currentViewMode === _enumViewMode.BottomTurnLeft) {
                    viewMode = _enumViewMode.Right;
                } else if (_currentViewMode === _enumViewMode.BottomTurnBack) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.FrontTurnRight) {
                    viewMode = _enumViewMode.Left;
                } else if (_currentViewMode === _enumViewMode.FrontTurnLeft) {
                    viewMode = _enumViewMode.Right;
                } else if (_currentViewMode === _enumViewMode.FrontTurnTop) {
                    viewMode = _enumViewMode.Bottom;
                } else {
                    viewMode = _enumViewMode.Top; // 默认
                }
                break;
            case _componentNames.ControlPointSouth:
                // 前 - 底 - 后 - 后底 - 前
                if (_currentViewMode === _enumViewMode.Front) {
                    viewMode = _enumViewMode.Bottom;
                } else if (_currentViewMode === _enumViewMode.Bottom) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.Back) {
                    viewMode = _enumViewMode.BottomTurnBack;
                } else if (_currentViewMode === _enumViewMode.BottomTurnBack) {
                    viewMode = _enumViewMode.Front;
                } else if (_currentViewMode === _enumViewMode.Right) {
                    viewMode = _enumViewMode.BottomTurnRight;
                } else if (_currentViewMode === _enumViewMode.BottomTurnRight) {
                    viewMode = _enumViewMode.Left;
                } else if (_currentViewMode === _enumViewMode.Left) {
                    viewMode = _enumViewMode.BottomTurnLeft;
                } else if (_currentViewMode === _enumViewMode.BottomTurnLeft) {
                    viewMode = _enumViewMode.Right;
                } else if (_currentViewMode === _enumViewMode.FrontTurnRight) {
                    viewMode = _enumViewMode.Right;
                } else if (_currentViewMode === _enumViewMode.FrontTurnLeft) {
                    viewMode = _enumViewMode.Left;
                } else if (_currentViewMode === _enumViewMode.FrontTurnTop) {
                    viewMode = _enumViewMode.Top;
                } else if (_currentViewMode === _enumViewMode.RightTurnFront) {
                    viewMode = _enumViewMode.Front;
                } else if (_currentViewMode === _enumViewMode.RightTurnBack) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.RightTurnTop) {
                    viewMode = _enumViewMode.Top;
                } else if (_currentViewMode === _enumViewMode.BackTurnRight) {
                    viewMode = _enumViewMode.Right;
                } else if (_currentViewMode === _enumViewMode.BackTurnLeft) {
                    viewMode = _enumViewMode.Left;
                } else if (_currentViewMode === _enumViewMode.BackTurnTop) {
                    viewMode = _enumViewMode.Top;
                } else if (_currentViewMode === _enumViewMode.LeftTurnFront) {
                    viewMode = _enumViewMode.Front;
                } else if (_currentViewMode === _enumViewMode.LeftTurnBack) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.LeftTurnTop) {
                    viewMode = _enumViewMode.Top;
                } else if (_currentViewMode === _enumViewMode.Top) {
                    viewMode = _enumViewMode.Front;
                } else if (_currentViewMode === _enumViewMode.TopTurnRight) {
                    viewMode = _enumViewMode.Right;
                } else if (_currentViewMode === _enumViewMode.TopTurnBack) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.TopTurnLeft) {
                    viewMode = _enumViewMode.Left;
                } else {
                    viewMode = _enumViewMode.Bottom; // 默认
                }
                break;
            case _componentNames.ControlPointEast:
                // 前 - 右 - 后 - 左 - 前
                if (_currentViewMode === _enumViewMode.Front) {
                    viewMode = _enumViewMode.Right;
                } else if (_currentViewMode === _enumViewMode.Right) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.Back) {
                    viewMode = _enumViewMode.Left;
                } else if (_currentViewMode === _enumViewMode.Left) {
                    viewMode = _enumViewMode.Front;
                } else if (_currentViewMode === _enumViewMode.Top) {
                    viewMode = _enumViewMode.Right;
                } else if (_currentViewMode === _enumViewMode.TopTurnRight) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.TopTurnBack) {
                    viewMode = _enumViewMode.Left;
                } else if (_currentViewMode === _enumViewMode.TopTurnLeft) {
                    viewMode = _enumViewMode.Front;
                } else if (_currentViewMode === _enumViewMode.Bottom) {
                    viewMode = _enumViewMode.Right;
                } else if (_currentViewMode === _enumViewMode.BottomTurnRight) {
                    viewMode = _enumViewMode.Front;
                } else if (_currentViewMode === _enumViewMode.BottomTurnBack) {
                    viewMode = _enumViewMode.Left;
                } else if (_currentViewMode === _enumViewMode.BottomTurnLeft) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.FrontTurnRight) {
                    viewMode = _enumViewMode.Top;
                } else if (_currentViewMode === _enumViewMode.FrontTurnLeft) {
                    viewMode = _enumViewMode.Bottom;
                } else if (_currentViewMode === _enumViewMode.FrontTurnTop) {
                    viewMode = _enumViewMode.Left;
                } else if (_currentViewMode === _enumViewMode.RightTurnFront) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.RightTurnBack) {
                    viewMode = _enumViewMode.Top;
                } else if (_currentViewMode === _enumViewMode.RightTurnTop) {
                    viewMode = _enumViewMode.Front;
                } else if (_currentViewMode === _enumViewMode.BackTurnRight) {
                    viewMode = _enumViewMode.Top;
                } else if (_currentViewMode === _enumViewMode.BackTurnLeft) {
                    viewMode = _enumViewMode.Bottom;
                } else if (_currentViewMode === _enumViewMode.BackTurnTop) {
                    viewMode = _enumViewMode.Left;
                } else if (_currentViewMode === _enumViewMode.LeftTurnFront) {
                    viewMode = _enumViewMode.Top;
                } else if (_currentViewMode === _enumViewMode.LeftTurnBack) {
                    viewMode = _enumViewMode.Bottom;
                } else if (_currentViewMode === _enumViewMode.LeftTurnTop) {
                    viewMode = _enumViewMode.Back;
                } else {
                    viewMode = _enumViewMode.Right; // 默认
                }
                break;
            case _componentNames.ControlPointWest:
                // 前 - 左 - 后 - 右 - 前
                if (_currentViewMode === _enumViewMode.Front) {
                    viewMode = _enumViewMode.Left;
                } else if (_currentViewMode === _enumViewMode.Left) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.Back) {
                    viewMode = _enumViewMode.Right;
                } else if (_currentViewMode === _enumViewMode.Right) {
                    viewMode = _enumViewMode.Front;
                } else if (_currentViewMode === _enumViewMode.Front) {
                    viewMode = _enumViewMode.Left;
                } else if (_currentViewMode === _enumViewMode.Top) {
                    viewMode = _enumViewMode.Left;
                } else if (_currentViewMode === _enumViewMode.TopTurnRight) {
                    viewMode = _enumViewMode.Front;
                } else if (_currentViewMode === _enumViewMode.TopTurnBack) {
                    viewMode = _enumViewMode.Right;
                } else if (_currentViewMode === _enumViewMode.TopTurnLeft) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.Bottom) {
                    viewMode = _enumViewMode.Left;
                } else if (_currentViewMode === _enumViewMode.BottomTurnRight) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.BottomTurnBack) {
                    viewMode = _enumViewMode.Right;
                } else if (_currentViewMode === _enumViewMode.BottomTurnLeft) {
                    viewMode = _enumViewMode.Front;
                } else if (_currentViewMode === _enumViewMode.FrontTurnRight) {
                    viewMode = _enumViewMode.Bottom;
                } else if (_currentViewMode === _enumViewMode.FrontTurnLeft) {
                    viewMode = _enumViewMode.Top;
                } else if (_currentViewMode === _enumViewMode.FrontTurnTop) {
                    viewMode = _enumViewMode.Right;
                } else if (_currentViewMode === _enumViewMode.RightTurnFront) {
                    viewMode = _enumViewMode.Top;
                } else if (_currentViewMode === _enumViewMode.RightTurnBack) {
                    viewMode = _enumViewMode.Bottom;
                } else if (_currentViewMode === _enumViewMode.RightTurnTop) {
                    viewMode = _enumViewMode.Back;
                } else if (_currentViewMode === _enumViewMode.BackTurnRight) {
                    viewMode = _enumViewMode.Top;
                } else if (_currentViewMode === _enumViewMode.BackTurnLeft) {
                    viewMode = _enumViewMode.Bottom;
                } else if (_currentViewMode === _enumViewMode.BackTurnTop) {
                    viewMode = _enumViewMode.Right;
                } else if (_currentViewMode === _enumViewMode.LeftTurnFront) {
                    viewMode = _enumViewMode.Bottom;
                } else if (_currentViewMode === _enumViewMode.LeftTurnBack) {
                    viewMode = _enumViewMode.Top;
                } else if (_currentViewMode === _enumViewMode.LeftTurnTop) {
                    viewMode = _enumViewMode.Front;
                } else {
                    viewMode = _enumViewMode.Left; // 默认
                }
                break;
            case _componentNames.ControlRingNorthEast:
            case _componentNames.ControlRingSouthWest:
            case _componentNames.ControlRingNorthWest:
            case _componentNames.ControlRingSouthEast:
                if (isClockWise) {
                    // clockwise
                    if (_currentViewMode === _enumViewMode.Front) {
                        viewMode = _enumViewMode.FrontTurnRight;
                    } else if (_currentViewMode === _enumViewMode.FrontTurnRight) {
                        viewMode = _enumViewMode.FrontTurnTop;
                    } else if (_currentViewMode === _enumViewMode.FrontTurnTop) {
                        viewMode = _enumViewMode.FrontTurnLeft;
                    } else if (_currentViewMode === _enumViewMode.FrontTurnLeft) {
                        viewMode = _enumViewMode.Front;
                    } else if (_currentViewMode === _enumViewMode.Right) {
                        viewMode = _enumViewMode.RightTurnBack;
                    } else if (_currentViewMode === _enumViewMode.RightTurnBack) {
                        viewMode = _enumViewMode.RightTurnTop;
                    } else if (_currentViewMode === _enumViewMode.RightTurnTop) {
                        viewMode = _enumViewMode.RightTurnFront;
                    } else if (_currentViewMode === _enumViewMode.RightTurnFront) {
                        viewMode = _enumViewMode.Right;
                    } else if (_currentViewMode === _enumViewMode.Back) {
                        viewMode = _enumViewMode.BackTurnRight;
                    } else if (_currentViewMode === _enumViewMode.BackTurnRight) {
                        viewMode = _enumViewMode.BackTurnTop;
                    } else if (_currentViewMode === _enumViewMode.BackTurnTop) {
                        viewMode = _enumViewMode.BackTurnLeft;
                    } else if (_currentViewMode === _enumViewMode.BackTurnLeft) {
                        viewMode = _enumViewMode.Back;
                    } else if (_currentViewMode === _enumViewMode.Left) {
                        viewMode = _enumViewMode.LeftTurnFront;
                    } else if (_currentViewMode === _enumViewMode.LeftTurnFront) {
                        viewMode = _enumViewMode.LeftTurnTop;
                    } else if (_currentViewMode === _enumViewMode.LeftTurnTop) {
                        viewMode = _enumViewMode.LeftTurnBack;
                    } else if (_currentViewMode === _enumViewMode.LeftTurnBack) {
                        viewMode = _enumViewMode.Left;
                    } else if (_currentViewMode === _enumViewMode.Top) {
                        viewMode = _enumViewMode.TopTurnRight;
                    } else if (_currentViewMode === _enumViewMode.TopTurnRight) {
                        viewMode = _enumViewMode.TopTurnBack;
                    } else if (_currentViewMode === _enumViewMode.TopTurnBack) {
                        viewMode = _enumViewMode.TopTurnLeft;
                    } else if (_currentViewMode === _enumViewMode.TopTurnLeft) {
                        viewMode = _enumViewMode.Top;
                    } else if (_currentViewMode === _enumViewMode.Bottom) {
                        viewMode = _enumViewMode.BottomTurnRight;
                    } else if (_currentViewMode === _enumViewMode.BottomTurnRight) {
                        viewMode = _enumViewMode.BottomTurnBack;
                    } else if (_currentViewMode === _enumViewMode.BottomTurnBack) {
                        viewMode = _enumViewMode.BottomTurnLeft;
                    } else if (_currentViewMode === _enumViewMode.BottomTurnLeft) {
                        viewMode = _enumViewMode.Bottom;
                    } else {
                        viewMode = _enumViewMode.FrontTurnRight; // 默认
                    }
                } else {
                    if (_currentViewMode === _enumViewMode.Front) {
                        viewMode = _enumViewMode.FrontTurnLeft;
                    } else if (_currentViewMode === _enumViewMode.FrontTurnLeft) {
                        viewMode = _enumViewMode.FrontTurnTop;
                    } else if (_currentViewMode === _enumViewMode.FrontTurnTop) {
                        viewMode = _enumViewMode.FrontTurnRight;
                    } else if (_currentViewMode === _enumViewMode.FrontTurnRight) {
                        viewMode = _enumViewMode.Front;
                    } else if (_currentViewMode === _enumViewMode.Right) {
                        viewMode = _enumViewMode.RightTurnFront;
                    } else if (_currentViewMode === _enumViewMode.RightTurnFront) {
                        viewMode = _enumViewMode.RightTurnTop;
                    } else if (_currentViewMode === _enumViewMode.RightTurnTop) {
                        viewMode = _enumViewMode.RightTurnBack;
                    } else if (_currentViewMode === _enumViewMode.RightTurnBack) {
                        viewMode = _enumViewMode.Right;
                    } else if (_currentViewMode === _enumViewMode.Back) {
                        viewMode = _enumViewMode.BackTurnLeft;
                    } else if (_currentViewMode === _enumViewMode.BackTurnLeft) {
                        viewMode = _enumViewMode.BackTurnTop;
                    } else if (_currentViewMode === _enumViewMode.BackTurnTop) {
                        viewMode = _enumViewMode.BackTurnRight;
                    } else if (_currentViewMode === _enumViewMode.BackTurnRight) {
                        viewMode = _enumViewMode.Back;
                    } else if (_currentViewMode === _enumViewMode.Left) {
                        viewMode = _enumViewMode.LeftTurnBack;
                    } else if (_currentViewMode === _enumViewMode.LeftTurnBack) {
                        viewMode = _enumViewMode.LeftTurnTop;
                    } else if (_currentViewMode === _enumViewMode.LeftTurnTop) {
                        viewMode = _enumViewMode.LeftTurnFront;
                    } else if (_currentViewMode === _enumViewMode.LeftTurnFront) {
                        viewMode = _enumViewMode.Left;
                    } else if (_currentViewMode === _enumViewMode.Top) {
                        viewMode = _enumViewMode.TopTurnLeft;
                    } else if (_currentViewMode === _enumViewMode.TopTurnLeft) {
                        viewMode = _enumViewMode.TopTurnBack;
                    } else if (_currentViewMode === _enumViewMode.TopTurnBack) {
                        viewMode = _enumViewMode.TopTurnRight;
                    } else if (_currentViewMode === _enumViewMode.TopTurnRight) {
                        viewMode = _enumViewMode.Top;
                    } else if (_currentViewMode === _enumViewMode.Bottom) {
                        viewMode = _enumViewMode.BottomTurnLeft;
                    } else if (_currentViewMode === _enumViewMode.BottomTurnLeft) {
                        viewMode = _enumViewMode.BottomTurnBack;
                    } else if (_currentViewMode === _enumViewMode.BottomTurnBack) {
                        viewMode = _enumViewMode.BottomTurnRight;
                    } else if (_currentViewMode === _enumViewMode.BottomTurnRight) {
                        viewMode = _enumViewMode.Bottom;
                    } else {
                        viewMode = _enumViewMode.FrontTurnLeft; // 默认
                    }
                }

                break;
        }

        _currentViewMode = viewMode;
    };
    var setHighlight = function setHighlight(name, highlight) {
        if (highlight) {

            // 计算鼠标所在的象限
            var isClockWise = false;
            if (_mouseCoord.x * _mouseCoord.y > 0) {
                isClockWise = true;
            }

            // ---------- 处理联动高亮 S ---------- //
            if (name === _componentNames.MiddleDoor) {
                // 选中Door，前墙也高亮
                _houseFrontMesh.material.color.setHex(scope.pickedColor);
            } else {
                if (name !== _componentNames.MiddleSouth) {
                    _houseFrontMesh.material.color.setHex(_houseFrontColor);
                }
            }

            if (name === _componentNames.MiddleSouth) {
                // 选中前墙，Door也高亮
                _houseDoorMesh.material.color.setHex(scope.pickedColor);
            } else {
                if (name !== _componentNames.MiddleDoor) {
                    _houseDoorMesh.material.color.setHex(_houseDoorColor);
                }
            }

            if (name === _componentNames.MiddleWest) {
                // 选中左墙，左窗也高亮
                _houseLeftWindowMesh.material.color.setHex(scope.pickedColor);
            } else {
                if (name !== _componentNames.MiddleLeftWindow) {
                    _houseLeftWindowMesh.material.color.setHex(_houseLeftWindowColor);
                }
            }

            if (name === _componentNames.MiddleLeftWindow) {
                // 选中左窗，左墙也高亮
                _houseLeftMesh.material.color.setHex(scope.pickedColor);
            } else {
                if (name !== _componentNames.MiddleWest) {
                    _houseLeftMesh.material.color.setHex(_houseLeftColor);
                }
            }

            if (name === _componentNames.MiddleEast) {
                // 选中右窗，右墙也高亮
                _houseRightWindowMesh.material.color.setHex(scope.pickedColor);
            } else {
                if (name !== _componentNames.MiddleRightWindow) {
                    _houseRightWindowMesh.material.color.setHex(_houseRightWindowColor);
                }
            }

            if (name === _componentNames.MiddleRightWindow) {
                // 选中右墙，右窗也高亮
                _houseRightMesh.material.color.setHex(scope.pickedColor);
            } else {
                if (name !== _componentNames.MiddleEast) {
                    _houseRightMesh.material.color.setHex(_houseRightColor);
                }
            }

            // ---------- 处理联动高亮 E ---------- //

            switch (name) {
                case _componentNames.ControlRingNorthEast:
                    _highlightRingMesh.visible = true;
                    _highlightRingMesh.quaternion.copy(_highlightRingQuat);
                    _highlightRingMesh.position.copy(_highlightRingPos);

                    _highlightPointMesh.visible = true;
                    _highlightPointMesh.quaternion.copy(_highlightPointQuat);
                    _highlightPointMesh.position.copy(_highlightPointPos);
                    _highlightPointMesh.rotateZ(Math.PI / 4);
                    _highlightPointMesh.translateX(_highLightRingRadius);

                    _highlightArrowMesh.visible = true;
                    _highlightArrowMesh.quaternion.copy(_highlightArrowQuat);
                    _highlightArrowMesh.position.copy(_highlightArrowPos);
                    _highlightArrowMesh.rotateZ(Math.PI / 4);
                    _highlightArrowMesh.translateX(_highLightRingRadius);
                    if (isClockWise) {
                        // 箭头朝下
                        _highlightArrowMesh.rotateZ(Math.PI / 2);
                    } else {
                        _highlightArrowMesh.rotateZ(-Math.PI / 2);
                    }
                    break;
                case _componentNames.ControlRingNorthWest:
                    _highlightRingMesh.visible = true;
                    _highlightRingMesh.quaternion.copy(_highlightRingQuat);
                    _highlightRingMesh.position.copy(_highlightRingPos);
                    _highlightRingMesh.rotateZ(Math.PI / 2);

                    _highlightPointMesh.visible = true;
                    _highlightPointMesh.quaternion.copy(_highlightPointQuat);
                    _highlightPointMesh.position.copy(_highlightPointPos);
                    _highlightPointMesh.rotateZ(Math.PI * 3 / 4);
                    _highlightPointMesh.translateX(_highLightRingRadius);

                    _highlightArrowMesh.visible = true;
                    _highlightArrowMesh.quaternion.copy(_highlightArrowQuat);
                    _highlightArrowMesh.position.copy(_highlightArrowPos);
                    _highlightArrowMesh.rotateZ(Math.PI * 3 / 4);
                    _highlightArrowMesh.translateX(_highLightRingRadius);
                    if (isClockWise) {
                        _highlightArrowMesh.rotateZ(Math.PI / 2);
                    } else {
                        _highlightArrowMesh.rotateZ(-Math.PI / 2);
                    }
                    break;
                case _componentNames.ControlRingSouthWest:
                    _highlightRingMesh.visible = true;
                    _highlightRingMesh.quaternion.copy(_highlightRingQuat);
                    _highlightRingMesh.position.copy(_highlightRingPos);
                    _highlightRingMesh.rotateZ(Math.PI);

                    _highlightPointMesh.visible = true;
                    _highlightPointMesh.quaternion.copy(_highlightPointQuat);
                    _highlightPointMesh.position.copy(_highlightPointPos);
                    _highlightPointMesh.rotateZ(-Math.PI * 3 / 4);
                    _highlightPointMesh.translateX(_highLightRingRadius);

                    _highlightArrowMesh.visible = true;
                    _highlightArrowMesh.quaternion.copy(_highlightArrowQuat);
                    _highlightArrowMesh.position.copy(_highlightArrowPos);
                    _highlightArrowMesh.rotateZ(-Math.PI * 3 / 4);
                    _highlightArrowMesh.translateX(_highLightRingRadius);
                    if (isClockWise) {
                        _highlightArrowMesh.rotateZ(Math.PI / 2);
                    } else {
                        _highlightArrowMesh.rotateZ(-Math.PI / 2);
                    }
                    break;
                case _componentNames.ControlRingSouthEast:
                    _highlightRingMesh.visible = true;
                    _highlightRingMesh.quaternion.copy(_highlightRingQuat);
                    _highlightRingMesh.position.copy(_highlightRingPos);
                    _highlightRingMesh.rotateZ(-Math.PI / 2);

                    _highlightPointMesh.visible = true;
                    _highlightPointMesh.quaternion.copy(_highlightPointQuat);
                    _highlightPointMesh.position.copy(_highlightPointPos);
                    _highlightPointMesh.rotateZ(-Math.PI / 4);
                    _highlightPointMesh.translateX(_highLightRingRadius);

                    _highlightArrowMesh.visible = true;
                    _highlightArrowMesh.quaternion.copy(_highlightArrowQuat);
                    _highlightArrowMesh.position.copy(_highlightArrowPos);
                    _highlightArrowMesh.rotateZ(-Math.PI / 4);
                    _highlightArrowMesh.translateX(_highLightRingRadius);
                    if (isClockWise) {
                        _highlightArrowMesh.rotateZ(Math.PI / 2);
                    } else {
                        _highlightArrowMesh.rotateZ(-Math.PI / 2);
                    }
                    break;
                case _componentNames.ControlPointNorth:
                    _highlightRingMesh.visible = false;
                    _highlightPointMesh.visible = false;

                    _highlightArrowMesh.visible = true;
                    _highlightArrowMesh.quaternion.copy(_highlightArrowQuat);
                    _highlightArrowMesh.position.copy(_highlightArrowPos);
                    _highlightArrowMesh.rotateZ(Math.PI / 2);
                    _highlightArrowMesh.translateX(_highLightRingRadius);
                    break;
                case _componentNames.ControlPointSouth:
                    _highlightRingMesh.visible = false;
                    _highlightPointMesh.visible = false;

                    _highlightArrowMesh.visible = true;
                    _highlightArrowMesh.quaternion.copy(_highlightArrowQuat);
                    _highlightArrowMesh.position.copy(_highlightArrowPos);
                    _highlightArrowMesh.rotateZ(-Math.PI / 2);
                    _highlightArrowMesh.translateX(_highLightRingRadius);
                    break;
                case _componentNames.ControlPointEast:
                    _highlightRingMesh.visible = false;
                    _highlightPointMesh.visible = false;

                    _highlightArrowMesh.visible = true;
                    _highlightArrowMesh.quaternion.copy(_highlightArrowQuat);
                    _highlightArrowMesh.position.copy(_highlightArrowPos);
                    _highlightArrowMesh.translateX(_highLightRingRadius);
                    break;
                case _componentNames.ControlPointWest:
                    _highlightRingMesh.visible = false;
                    _highlightPointMesh.visible = false;

                    _highlightArrowMesh.visible = true;
                    _highlightArrowMesh.quaternion.copy(_highlightArrowQuat);
                    _highlightArrowMesh.position.copy(_highlightArrowPos);
                    _highlightArrowMesh.rotateZ(Math.PI);
                    _highlightArrowMesh.translateX(_highLightRingRadius);
                    break;
                default:
                    _highlightRingMesh.visible = false;
                    _highlightPointMesh.visible = false;
                    _highlightArrowMesh.visible = false;
                    break;
            }
        } else {

            if (_highlightRingMesh.visible) {
                _highlightRingMesh.visible = false;
            }

            if (_highlightPointMesh.visible) {
                _highlightPointMesh.visible = false;
            }

            if (_highlightArrowMesh.visible) {
                _highlightArrowMesh.visible = false;
            }
        }
    };
    var setObjectHighlight = function setObjectHighlight(object) {
        if (_intersected != object) {
            if (_intersected) {
                _intersected.material.color.setHex(_intersected.currentHex);
            }

            _intersected = object;
            _intersected.currentHex = _intersected.material.color.getHex();

            if (_intersected.name !== "") {
                _intersected.material.color.setHex(scope.pickedColor);
            }

            setHighlight(_intersected.name, true);

            //console.log("[intersects - 1][length = " + intersects.length + ",name = " + _intersected.name +"]");
        }
    };
    var clearObjectHighlight = function clearObjectHighlight() {
        if (_intersected) {
            _intersected.material.color.setHex(_intersected.currentHex);
        }

        setHighlight("", false);

        _intersected = null;
    };
    var picked = function picked() {

        // 优先选择控制圆环

        _homeRaycaster.setFromCamera(_mouseCoord, _homeCamera);
        var homeIntersects = _homeRaycaster.intersectObjects(_groupPick.children, true);

        if (homeIntersects.length > 0) {

            setObjectHighlight(homeIntersects[0].object);
        } else {

            _houseRaycaster.setFromCamera(_mouseCoord, _houseCamera);
            var houseIntersects = _houseRaycaster.intersectObjects(_houseScene.children, true);

            if (houseIntersects.length > 0) {
                setObjectHighlight(houseIntersects[0].object);
            } else {
                clearObjectHighlight();
            }
        }
    };

    // 判断两个值是否在允许误差范围内
    var isEquals = function isEquals(value1, value2, epsilon) {
        return value1 > value2 ? value1 - value2 <= epsilon : value2 - value1 <= epsilon;
    };
    var isCompassView = function isCompassView(dir) {

        //  非标准视图及顶、底视图
        var dirNorm = dir.clone();
        dirNorm.normalize();

        // 当dirNorm.y为0时，指北针与视线平行
        if (isEquals(dirNorm.y, 0, _threshold)) {
            return false;
        }

        return true;
    };
    var isStandardView = function isStandardView(dir) {

        // 标准视图：上、下、左、右、前、后

        var dirNorm = dir.clone();
        dirNorm.normalize();

        // Top (0, -1, 0)
        // Bottom (0, 1, 0)
        // Front (0, 0, -1)
        // Back (0, 0, 1)
        // Right (-1, 0, 0)
        // Left (1, 0, 0)

        // 两个为0，即为标准视图
        if (isEquals(dirNorm.x, 0, _threshold) && isEquals(dirNorm.y, 0, _threshold) || isEquals(dirNorm.x, 0, _threshold) && isEquals(dirNorm.z, 0, _threshold) || isEquals(dirNorm.y, 0, _threshold) && isEquals(dirNorm.z, 0, _threshold)) {
            return true;
        }

        return false;
    };
    var isBottomView = function isBottomView(dir) {
        var dirNorm = dir.clone();
        dirNorm.normalize();

        // Bottom (0, 1, 0)
        if (isEquals(dirNorm.x, 0, _threshold) && isEquals(dirNorm.y, 1, _threshold) && isEquals(dirNorm.z, 0, _threshold)) {
            return true;
        }

        return false;
    };
    var getCurrentStandardView = function getCurrentStandardView(dir, up) {
        var dirNorm = dir.clone();
        dirNorm.normalize();

        var upNorm = up.clone();
        upNorm.normalize();

        // Top - dir(0, -1, 0)
        if (isEquals(dirNorm.x, 0, _threshold) && isEquals(dirNorm.y, -1, _threshold) && isEquals(dirNorm.z, 0, _threshold)) {

            // Top - up(0, 0, -1)
            if (isEquals(upNorm.x, 0, _threshold) && isEquals(upNorm.y, 0, _threshold) && isEquals(upNorm.z, -1, _threshold)) {
                return _enumViewMode.Top;
            }

            // TopTurnRight - up(-1, 0, 0)
            if (isEquals(upNorm.x, -1, _threshold) && isEquals(upNorm.y, 0, _threshold) && isEquals(upNorm.z, 0, _threshold)) {
                return _enumViewMode.TopTurnRight;
            }

            // TopTurnBack - up(0, 0, 1)
            if (isEquals(upNorm.x, 0, _threshold) && isEquals(upNorm.y, 0, _threshold) && isEquals(upNorm.z, 1, _threshold)) {
                return _enumViewMode.TopTurnBack;
            }

            // TopTurnLeft - up(1, 0, 0)
            if (isEquals(upNorm.x, 1, _threshold) && isEquals(upNorm.y, 0, _threshold) && isEquals(upNorm.z, 0, _threshold)) {
                return _enumViewMode.TopTurnLeft;
            }
        }

        // Bottom - dir(0, 1, 0)
        if (isEquals(dirNorm.x, 0, _threshold) && isEquals(dirNorm.y, 1, _threshold) && isEquals(dirNorm.z, 0, _threshold)) {

            // Bottom - up(0, 0, 1)
            if (isEquals(upNorm.x, 0, _threshold) && isEquals(upNorm.y, 0, _threshold) && isEquals(upNorm.z, 1, _threshold)) {
                return _enumViewMode.Bottom;
            }

            // BottomTurnRight - up(-1, 0, 0)
            if (isEquals(upNorm.x, -1, _threshold) && isEquals(upNorm.y, 0, _threshold) && isEquals(upNorm.z, 0, _threshold)) {
                return _enumViewMode.BottomTurnRight;
            }

            // BottomTurnBack - up(0, 0, -1)
            if (isEquals(upNorm.x, 0, _threshold) && isEquals(upNorm.y, 0, _threshold) && isEquals(upNorm.z, -1, _threshold)) {
                return _enumViewMode.BottomTurnBack;
            }

            // BottomTurnLeft - up(1, 0, 0)
            if (isEquals(upNorm.x, 1, _threshold) && isEquals(upNorm.y, 0, _threshold) && isEquals(upNorm.z, 0, _threshold)) {
                return _enumViewMode.Bottom;
            }
        }

        // Front - dir(0, 0, -1)
        if (isEquals(dirNorm.x, 0, _threshold) && isEquals(dirNorm.y, 0, _threshold) && isEquals(dirNorm.z, -1, _threshold)) {

            // Front - up(0, 1, 0)
            if (isEquals(upNorm.x, 0, _threshold) && isEquals(upNorm.y, 1, _threshold) && isEquals(upNorm.z, 0, _threshold)) {
                return _enumViewMode.Front;
            }

            // FrontTurnTop - up(0, -1, 0)
            if (isEquals(upNorm.x, 0, _threshold) && isEquals(upNorm.y, -1, _threshold) && isEquals(upNorm.z, 0, _threshold)) {
                return _enumViewMode.FrontTurnTop;
            }

            // FrontTurnLeft - up(1, 0, 0)
            if (isEquals(upNorm.x, 1, _threshold) && isEquals(upNorm.y, 0, _threshold) && isEquals(upNorm.z, 0, _threshold)) {
                return _enumViewMode.FrontTurnLeft;
            }

            // FrontTurnRight - up(-1, 0, 0)
            if (isEquals(upNorm.x, -1, _threshold) && isEquals(upNorm.y, 0, _threshold) && isEquals(upNorm.z, 0, _threshold)) {
                return _enumViewMode.FrontTurnRight;
            }
        }

        // Back - dir(0, 0, 1)
        if (isEquals(dirNorm.x, 0, _threshold) && isEquals(dirNorm.y, 0, _threshold) && isEquals(dirNorm.z, 1, _threshold)) {

            // Back - up(0, 1, 0)
            if (isEquals(upNorm.x, 0, _threshold) && isEquals(upNorm.y, 1, _threshold) && isEquals(upNorm.z, 0, _threshold)) {
                return _enumViewMode.Back;
            }

            // BackTurnTop - up(0, -1, 0)
            if (isEquals(upNorm.x, 0, _threshold) && isEquals(upNorm.y, -1, _threshold) && isEquals(upNorm.z, 0, _threshold)) {
                return _enumViewMode.BackTurnTop;
            }

            // BackTurnLeft - up(-1, 0, 0)
            if (isEquals(upNorm.x, -1, _threshold) && isEquals(upNorm.y, 0, _threshold) && isEquals(upNorm.z, 0, _threshold)) {
                return _enumViewMode.BackTurnLeft;
            }

            // BackTurnRight - up(1, 0, 0)
            if (isEquals(upNorm.x, 1, _threshold) && isEquals(upNorm.y, 0, _threshold) && isEquals(upNorm.z, 0, _threshold)) {
                return _enumViewMode.BackTurnRight;
            }
        }

        // Right - dir(-1, 0, 0)
        if (isEquals(dirNorm.x, -1, _threshold) && isEquals(dirNorm.y, 0, _threshold) && isEquals(dirNorm.z, 0, _threshold)) {

            // Right - up(0, 1, 0)
            if (isEquals(upNorm.x, 0, _threshold) && isEquals(upNorm.y, 1, _threshold) && isEquals(upNorm.z, 0, _threshold)) {
                return _enumViewMode.Right;
            }

            // RightTurnTop - up(0, -1, 0)
            if (isEquals(upNorm.x, 0, _threshold) && isEquals(upNorm.y, -1, _threshold) && isEquals(upNorm.z, 0, _threshold)) {
                return _enumViewMode.RightTurnTop;
            }

            // RightTurnFront - up(0, 0, -1)
            if (isEquals(upNorm.x, 0, _threshold) && isEquals(upNorm.y, 0, _threshold) && isEquals(upNorm.z, -1, _threshold)) {
                return _enumViewMode.RightTurnFront;
            }

            // RightTurnBack - up(0, 0, 1)
            if (isEquals(upNorm.x, 0, _threshold) && isEquals(upNorm.y, 0, _threshold) && isEquals(upNorm.z, 1, _threshold)) {
                return _enumViewMode.RightTurnBack;
            }
        }

        // Left - dir(1, 0, 0)
        if (isEquals(dirNorm.x, 1, _threshold) && isEquals(dirNorm.y, 0, _threshold) && isEquals(dirNorm.z, 0, _threshold)) {

            // Left - up(0, 1, 0)
            if (isEquals(upNorm.x, 0, _threshold) && isEquals(upNorm.y, 1, _threshold) && isEquals(upNorm.z, 0, _threshold)) {
                return _enumViewMode.Left;
            }

            // LeftTurnTop - up(0, -1, 0)
            if (isEquals(upNorm.x, 0, _threshold) && isEquals(upNorm.y, -1, _threshold) && isEquals(upNorm.z, 0, _threshold)) {
                return _enumViewMode.LeftTurnTop;
            }

            // LeftTurnFront - up(0, 0, -1)
            if (isEquals(upNorm.x, 0, _threshold) && isEquals(upNorm.y, 0, _threshold) && isEquals(upNorm.z, -1, _threshold)) {
                return _enumViewMode.LeftTurnFront;
            }

            // LeftTurnBack - up(0, 0, 1)
            if (isEquals(upNorm.x, 0, _threshold) && isEquals(upNorm.y, 0, _threshold) && isEquals(upNorm.z, 1, _threshold)) {
                return _enumViewMode.LeftTurnBack;
            }
        }

        return -1;
    };

    // 设置容器元素style
    var setContainerElementStyle = function setContainerElementStyle(container) {
        container.style.position = "absolute";
        container.style.display = "block";
        container.style.outline = "0";
        container.style.right = "20px";
        container.style.top = "20px";
        container.style.opacity = ".6";
        container.style.webkitTransition = "opacity .2s ease";
        container.style.mozTransition = "opacity .2s ease";
        container.style.msTransform = "opacity .2s ease";
        container.style.oTransform = "opacity .2s ease";
        container.style.transition = "opacity .2s ease";
    };

    this.init = function (container) {

        _houseContainer = document.createElement("div");
        setContainerElementStyle(_houseContainer);
        container.appendChild(_houseContainer);

        _renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });

        _houseContainer.appendChild(_renderer.domElement);

        // 设置视口大小
        this.resize(container.offsetWidth, container.offsetHeight, this.viewer.isMobile);

        this.addDomEventListeners();
    };

    this.uninit = function () {

        this.removeDomEventListeners();

        if (_houseContainer) {

            _houseContainer.removeChild(_renderer.domElement);
            _houseContainer = null;
        }
    };

    this.enable = function () {

        if (_houseContainer && _renderer && !_renderer.domElement.parentNode) {

            _houseContainer.appendChild(_renderer.domElement);

            this.addDomEventListeners();
        }
    };

    this.disable = function () {

        if (_houseContainer && _renderer && _renderer.domElement.parentNode) {

            this.removeDomEventListeners();
            _houseContainer.removeChild(_renderer.domElement);
        }
    };

    // 是否禁用指北针转盘
    this.enableCompass = function (enable) {
        _isEnableCompass = enable;
    };

    this.addDomEventListeners = function () {

        if (_houseContainer) {

            _houseContainer.addEventListener('contextmenu', function (event) {
                event.preventDefault();
            }, false);
            _houseContainer.addEventListener('mousedown', this.onMouseDownBinded, false);
            window.addEventListener('mousemove', this.onMouseMoveBinded, false);
            window.addEventListener('mouseup', this.onMouseUpBinded, false);
        }
    };

    this.removeDomEventListeners = function () {

        if (_houseContainer) {

            _houseContainer.removeEventListener('contextmenu', function (event) {
                event.preventDefault();
            }, false);
            _houseContainer.removeEventListener('mousedown', this.onMouseDownBinded, false);
            window.removeEventListener('mousemove', this.onMouseMoveBinded, false);
            window.removeEventListener('mouseup', this.onMouseUpBinded, false);
        }
    };

    this.mouseUp = function (event) {

        // mark: 对应注册到window上的事件，如果调用会取消事件的默认动作，导致document上其他元素（例如textarea)的行为出现问题（例如，鼠标移动无法选择文本）
        //event.preventDefault();
        event.stopPropagation();

        var mouse = new THREE.Vector2(event.clientX, event.clientY);
        var mouseOverHouse = isValidRange(mouse);

        // 允许鼠标移出viewhouse区域
        if (_isRotate) {
            _isRotate = false;
            _rotateEnd.set(mouse.x, mouse.y);
            _rotateDelta.subVectors(_rotateEnd, _rotateStart);
            //callback(null, _rotateDelta);
            if (!this.preRotationHandle || this.preRotationHandle()) {
                this.viewer.rotateCamera(_rotateDelta);
                _rotateStart.copy(_rotateEnd);
            }
        } else {
            if (mouseOverHouse) {

                //picked();  // 不需再次选择

                if (event.button === scope.mouseButtons.LEFT) {

                    if (_intersected) {

                        //var viewMode = _currentViewMode;
                        //
                        //// 切换新ViewMode
                        //switchView(_intersected.name);
                        //
                        //if (_currentViewMode !== -1 && viewMode !== _currentViewMode) {
                        //    // 反馈到主视图
                        //    callback(_currentViewMode);
                        //}

                        // 切换新ViewMode
                        _currentViewMode = -1;
                        if (!this.preRotationHandle || this.preRotationHandle()) {
                            switchView(_intersected.name);
                        }

                        if (_currentViewMode !== -1) {
                            // 反馈到主视图
                            //callback(_currentViewMode);

                            // 0代表home，不能用 if (view) 判断
                            if (_currentViewMode !== undefined && _currentViewMode !== null) {
                                this.viewer.setStandardView(_currentViewMode, null, function () {
                                    scope.render();
                                });
                            }
                        }
                    }
                }
            }
        }

        return mouseOverHouse;
    };

    this.mouseMove = function (event) {

        // mark: 对应注册到window上的事件，如果调用会取消事件的默认动作，导致document上其他元素（例如textarea)的行为出现问题（例如，鼠标移动无法选择文本）
        //event.preventDefault();
        event.stopPropagation();

        var change = false;
        var mouse = new THREE.Vector2(event.clientX, event.clientY);
        var mouseOverHouse = isValidRange(mouse);

        // 允许鼠标移出viewhouse区域
        if (_isRotate) {

            _rotateEnd.set(mouse.x, mouse.y);
            _rotateDelta.subVectors(_rotateEnd, _rotateStart);
            //callback(_rotateDelta);
            if (!this.preRotationHandle || this.preRotationHandle()) {
                this.viewer.rotateCamera(_rotateDelta);

                _rotateStart.copy(_rotateEnd);
            }
        } else {

            if (mouseOverHouse) {

                // 禁用透明
                if (_isTransparent) {
                    enableTransparent(false);
                    change = true;
                }

                // 显示home
                if (_isShowHome === false) {
                    showHome(true);
                    change = true;
                }

                picked();

                // 存在选中的对象
                if (_intersected) {

                    if (_intersected.name !== "") {

                        // 处理联动状态：前墙与门，左墙与左窗，右墙与右窗存在联动
                        var linkageName = _intersected.name;
                        if (linkageName === _componentNames.MiddleDoor) {
                            linkageName = _componentNames.MiddleSouth;
                        } else if (linkageName === _componentNames.MiddleLeftWindow) {
                            linkageName = _componentNames.MiddleWest;
                        } else if (linkageName === _componentNames.MiddleRightWindow) {
                            linkageName = _componentNames.MiddleEast;
                        }

                        if (_lastPickedObjectName !== linkageName) {
                            _lastPickedObjectName = linkageName;
                            _hasPickedObject = true;
                            change = true;
                        }
                    }
                } else {
                    // 不存在选中的对象

                    // 判断上次是否有选中的对象，如果上次有选中的对象，则需要刷新
                    if (_lastPickedObjectName !== "") {
                        _lastPickedObjectName = ""; // 置为空字符串
                        _hasPickedObject = false;
                        change = true;
                    }
                }

                // 不用每次刷新
                if (change) {
                    //callback();
                    this.render();
                }

                _lastMouseOverHouse = true;
            } else {

                if (_lastMouseOverHouse) {

                    _lastMouseOverHouse = false;

                    if (_hasPickedObject) {
                        clearObjectHighlight();
                        _hasPickedObject = false;
                        change = true;
                    }

                    // 启用透明
                    if (_isTransparent === false) {
                        enableTransparent(true);
                        change = true;
                    }

                    // 隐藏home
                    if (_isShowHome) {
                        showHome(false);
                        change = true;
                    }

                    // 不用每次刷新
                    if (change) {
                        //callback();
                        this.render();
                    }
                }
            }
        }

        return mouseOverHouse;
    };

    this.mouseDown = function (event) {

        event.preventDefault();
        event.stopPropagation();

        var mouse = new THREE.Vector2(event.clientX, event.clientY);
        var mouseOverHouse = isValidRange(mouse);

        if (mouseOverHouse) {

            // 旋转
            if (event.button === scope.mouseButtons.LEFT) {

                // 右键启用旋转
                _isRotate = false;

                if (_intersected) {
                    var name = _intersected.name;

                    if (name === _componentNames.Compass) {
                        _isRotate = true;
                        _rotateStart.set(mouse.x, mouse.y);
                    }
                }
            }
        }

        return mouseOverHouse;
    };

    this.render = function () {

        if (!this.visible || this.isDisable) return;

        if (!_renderer) {
            return;
        }

        var mainCameraInfo = this.viewer.getActiveCameraInfo();

        _houseCamera.up.copy(mainCameraInfo.up);
        _houseCamera.lookAt(mainCameraInfo.dir);
        _houseCamera.updateMatrixWorld();

        // 获得当前标准视图
        var dir = mainCameraInfo.dir;
        if (_currentViewMode === -1) {
            _currentViewMode = getCurrentStandardView(dir, _houseCamera.up);
        }

        // 判断是否标准视图
        if (isStandardView(dir)) {
            _groupControlRing.visible = true;
        } else {
            _groupControlRing.visible = false;
        }

        // 动画过程中，不显示控制圆环
        // 动画为结束
        if (!this.isAnimationFinish) {
            _groupControlRing.visible = false;
        }

        // 高亮圆环的显示控制
        if (_groupControlRing.visible === false) {
            _highlightRingMesh.visible = false;
            _highlightPointMesh.visible = false;
            _highlightArrowMesh.visible = false;
        }

        _groupControlRing.position.copy(_groupControlRingPos);
        _groupHightLight.position.copy(_groupHightLightPos);

        if (_groupControlRing.visible) {
            // 如果是底视图，让控制圆环显示
            if (isBottomView(dir)) {
                _groupControlRing.translateZ(_halfHeight + 1);
                _groupHightLight.translateZ(_halfHeight + 1);
            }
        }

        // 是否禁用指北针
        if (_isEnableCompass) {
            // 是否显示指北针
            if (isCompassView(dir)) {
                _groupCompass.visible = true;
            } else {
                _groupCompass.visible = false;
            }
        } else {
            _groupCompass.visible = false;
        }

        // 绘制house
        _renderer.autoClear = true;
        _renderer.render(_houseScene, _houseCamera);

        // 绘制home
        _renderer.autoClear = false;
        _renderer.render(_homeScene, _homeCamera);
        _renderer.autoClear = true;
    };

    // resize view house based on scene size
    this.resize = function (width, height, bMobile) {

        var offset = 20;
        if (width < 400 || bMobile) {
            setSize(_enumSizeMode.Small);
            //offset = offset + _enumSize.Small;
        }
        //else if (width < 800) {
        //    setSize(_enumSizeMode.Medium);
        //}
        else {
                setSize(_enumSizeMode.Medium);
                //offset = offset + _enumSize.Medium;
            }

        _renderer.setSize(this.width, this.height);
    };

    this.onMouseDownBinded = this.mouseDown.bind(this);
    this.onMouseMoveBinded = this.mouseMove.bind(this);
    this.onMouseUpBinded = this.mouseUp.bind(this);

    // 创建view house
    createViewHouse();

    // 设置透明
    enableTransparent(true);

    // 隐藏home
    showHome(false);
};

(function () {
    var AuthenticationNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Authentication");
    var Config = function Config() {
        return {
            APIHost: 'https://api.bimface.com',
            viewToken: null
        };
    };

    AuthenticationNS.AuthenticationConfig = Config;
})();

(function () {
    var authenticationNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Authentication");
    var webNS = Glodon.Web;
    var $ = Glodon.Web.Lang.Utility.HttpRequest;
    var AuthenticationManager = function AuthenticationManager(config) {
        this.config = config;
    };
    // 验证viewToken 获取viewToken数据
    AuthenticationManager.prototype.authenticate = function (_success, _failure) {
        var self = this;
        var config = self.config;
        $.ajax({
            url: config.APIHost + "/inside/databag?viewToken=" + config.viewToken,
            success: function success(res) {
                var data = JSON.parse(res);
                if (data.code == 'success') {
                    data.data.viewToken = config.viewToken;
                    self.data = data.data;
                    _success && _success(data.data);
                } else {
                    _failure && _failure(data);
                }
            },
            failure: function failure(res) {
                var data = JSON.parse(res);
                _failure && _failure(data);
            }
        });
    };

    authenticationNS.AuthenticationManager = AuthenticationManager;
})();

(function () {
    var dataNs = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Data");
    var $ = Glodon.Web.Lang.Utility.HttpRequest;

    var MetaDataManager = function MetaDataManager(config) {
        this._config = config;
        if (!config.viewToken) {
            return false;
        }
    };

    MetaDataManager.prototype = {

        getComponentProperty: function getComponentProperty(elementId, _success2, _failure2) {
            if (!elementId) {
                console.warn("elementId must not be empty!.");
                _failure2 && _failure2();
                return;
            }
            var self = this;
            var config = self._config;
            var url = void 0;
            if (config.dataEnvType == "Local") {
                if (!self._objectData) {
                    var objectData = new Glodon.Bimface.Data.ObjectPropertyManager("./" + config.databagId + "/property");
                    objectData.load(function () {
                        _success2({
                            properties: objectData.getElementProperties(elementId)
                        });
                    });
                    self._objectData = objectData;
                } else {
                    _success2({
                        properties: self._objectData.getElementProperties(elementId)
                    });
                }
                return;
            } else {
                if (config.modelType == "singleModel") {
                    url = config.APIHost + "/data/v2/files/" + config.modelId + "/elements/" + elementId + "?view_token=" + config.viewToken;
                } else {
                    var arr = elementId.split('.');
                    url = config.APIHost + "/data/v2/integrations/" + config.modelId + "/files/" + arr[0] + "/elements/" + arr[1] + "?view_token=" + config.viewToken;
                }
            }
            $.ajax({
                url: url,
                success: function success(res) {
                    var data = JSON.parse(res);
                    if (config.dataEnvType == "Local") {
                        self._objectData = data;
                        _success2 && _success2({
                            properties: data[elementId]
                        });
                    } else if (data.code == 'success') {
                        _success2 && _success2(data.data);
                    } else {
                        _failure2 && _failure2(data);
                    }
                },
                failure: function failure(res) {
                    var data = JSON.parse(res);
                    _failure2 && _failure2(data);
                }
            });
        },

        getModelTree: function getModelTree(_success3, _failure3) {
            var self = this;
            var config = self._config;
            var url = void 0;
            if (config.dataEnvType == "Local") {
                if (config.modelType == "singleModel") {
                    url = "./" + config.databagId + "/metadata/tree.json";
                } else {
                    url = "./" + config.databagId + "/metadata/specialtyTree.json";
                }
            } else {
                if (config.modelType == "singleModel") {
                    url = config.APIHost + "/data/v2/files/" + config.modelId + "/tree?v=2.0&view_token=" + config.viewToken;
                } else {
                    url = config.APIHost + "/data/v2/integrations/" + config.modelId + "/tree?view_token=" + config.viewToken + "&treeType=specialty";
                }
            }
            $.ajax({
                url: url,
                success: function success(res) {
                    var data = JSON.parse(res);
                    if (data.code) {
                        if (data.code == 'success') {
                            data = data.data;
                        } else {
                            _failure3 && _failure3(data);
                            return false;
                        }
                    }
                    _success3 && _success3(data, config.modelType);
                },
                failure: function failure(res) {
                    var data = JSON.parse(res);
                    _failure3 && _failure3(data);
                }
            });
        },
        getModeTree: function getModeTree(success, failure) {
            console.warn("This function is deprecated. Please use getModelTree instead.");
            this.getModelTree(success, failure);
        }
    };

    dataNs.MetaDataManager = MetaDataManager;
})();

(function () {
    var AuthenticationNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Data");
    var MetaDataManagerConfig = function MetaDataManagerConfig() {
        return {
            APIHost: 'https://api.bimface.com',
            viewToken: null,
            modelId: null,
            modelType: "singleModel",
            dataEnvType: "BIMFACE"
        };
    };

    AuthenticationNS.MetaDataManagerConfig = MetaDataManagerConfig;
})();

(function () {
    var dataNs = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Data");
    var $ = Glodon.Web.Lang.Utility.HttpRequest;

    var FamilyDataManager = function FamilyDataManager(config) {
        if (!config.databagId) {
            return false;
        }
        this.__config = config;
    };

    FamilyDataManager.prototype.getFamilyTypes = function (_success4, _failure4) {
        var config = this.__config,
            url = void 0;
        if (config.dataEnvType == "Local") {
            url = "./" + config.databagId + "/metadata/floorTree.json";
        } else {
            url = config.resourceHost + "/" + config.databagId + "/metadata/familyInfo.json";
        }
        $.ajax({
            url: url,
            success: function success(res) {
                var res = JSON.parse(res);
                var types = res.Types || res.types;
                for (var i = 0, len = types.length; i < len; i++) {
                    types[i].id = types[i].Id || types[i].id;
                    types[i].name = types[i].Name || types[i].name;

                    delete types[i].Id;
                    delete types[i].Name;
                }
                _success4 && _success4(types);
            },
            failure: function failure(res) {
                var data = JSON.parse(res);
                _failure4 && _failure4(data);
            }
        });
    };

    dataNs.FamilyDataManager = FamilyDataManager;
})();

(function () {
    var AuthenticationNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Data");
    var FamilyDataManagerConfig = function FamilyDataManagerConfig() {
        return {
            resourceHost: 'https://m.bimface.com',
            databagId: null
        };
    };

    AuthenticationNS.FamilyDataManagerConfig = FamilyDataManagerConfig;
})();

(function () {
    var dataNs = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Data");
    var $ = Glodon.Web.Lang.Utility.HttpRequest;

    var OPM = OPM || {};
    OPM.version = 1;

    OPM.EnumObjectTableIndex = {
        OTI_OBJECTS_VALUES: 0,
        OTI_PROPERTY_SCHEMAS: 1,
        OTI_ELEMENT_PROPERTIES: 2,
        OTI_ELEMENTS: 3
    };

    var ObjectPropertyManager = function ObjectPropertyManager(url) {
        this.url = url;
        this.objectsDB = [];
    };

    ObjectPropertyManager.prototype = {

        load: function load(callback) {

            var scope = this;
            var items = ["Values.json", "Schemas.json", "ElementProperties.json", "Elements.json"];
            var count = items.length;

            for (var ii = 0, len = items.length; ii < len; ++ii) {

                (function (index) {
                    var loader = new THREE.FileLoader();
                    loader.load(scope.url + "/" + items[index], function (text) {
                        scope.objectsDB[index] = JSON.parse(text);
                        count -= 1;
                        if (count == 0) {
                            callback();
                        }
                    });
                })(ii);
            }
        },

        getElementProperties: function getElementProperties(id) {
            if (id == null) return null;

            var elements = this.objectsDB[OPM.EnumObjectTableIndex.OTI_ELEMENTS];
            var elementInfo = elements[id];
            if (elementInfo === undefined) return null;

            var valueTable = this.objectsDB[OPM.EnumObjectTableIndex.OTI_OBJECTS_VALUES];
            var elementProperty = this.objectsDB[OPM.EnumObjectTableIndex.OTI_ELEMENT_PROPERTIES];
            var schemaTable = this.objectsDB[OPM.EnumObjectTableIndex.OTI_PROPERTY_SCHEMAS];

            var offset = 0;
            var schemaId = 0;
            var valId = 0;

            var propertiesMap = {};
            var groups = [];

            var groupId = 0;

            for (var ii = 0, count = elementInfo[2], start = elementInfo[1]; ii < count; ++ii) {
                offset = (start + ii) * 2;
                schemaId = elementProperty[offset] * 4;
                valId = elementProperty[offset + 1];

                groupId = schemaTable[schemaId];
                var group = propertiesMap[groupId];
                if (group === undefined) {
                    group = [];
                    propertiesMap[groupId] = group;
                    groups.push(groupId);
                }

                group.push({ "key": valueTable[schemaTable[schemaId + 1]], "unit": valueTable[schemaTable[schemaId + 3]], "valueType": schemaTable[schemaId + 2], "value": valueTable[valId] });
            }

            var properties = [];

            for (var ii = 0, len = groups.length; ii < len; ++ii) {
                groupId = groups[ii];
                properties.push({ "group": valueTable[groupId], "items": propertiesMap[groupId] });
            }

            return properties;
        }

    };

    dataNs.ObjectPropertyManager = ObjectPropertyManager;
})();

(function () {
    var ViewerNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Control");
    var ControlConfig = function ControlConfig() {
        var defaults = {
            id: null,
            tagName: 'div',
            className: 'bf-control',
            title: '',
            element: ''
        };
        return defaults;
    };

    ViewerNS.ControlConfig = ControlConfig;
})();

(function () {
    var ControlEvent = Object.freeze({
        "Click": "Click",
        // "DblClick": "DblClick",
        "MouseEnter": "MouseEnter",
        "MouseLeave": "MouseLeave",
        "MouseMove": "MouseMove",
        "StateChange": "StateChange",
        "Change": "Change"
    });

    var ControlNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Control");
    ControlNS.ControlEvent = ControlEvent;
})();

(function () {
    var ControlNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Control");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");

    var Control = function Control(config) {
        var self = this;
        self.eventManager = new Glodon.Web.Lang.EventManager();
        self.element = DomNS.create(config.tagName, config.className);
        self.id = config.id || Glodon.Web.Lang.Utility.UUID.createUUID();
        if (config.title) {
            self.setTitle(config.title);
        }
        if (config.element) {
            config.element.appendChild(self.element);
        }
    };

    Control.prototype = {
        addEventListener: function addEventListener(eventName, handler) {
            var self = this,
                EventManager = self.eventManager;
            self.element.addEventListener(eventName.toLocaleLowerCase(), handler);
            EventManager.addEvent(eventName, handler);
        },
        removeEventListener: function removeEventListener(eventName, handler) {
            var self = this,
                EventManager = self.eventManager;
            EventManager.removeEvent(eventName, handler);
            self.element.removeEventListener(eventName.toLocaleLowerCase(), handler);
        },

        show: function show() {
            this.element.style.display = '';
        },

        hide: function hide() {
            this.element.style.display = 'none';
        },

        setTitle: function setTitle(title) {
            this.element.setAttribute('title', title);
        },

        getTitle: function getTitle() {
            return this.element.getAttribute('title');
        },

        setClassNames: function setClassNames(className) {
            this.element.setAttribute('class', className);
        },

        getClassNames: function getClassNames() {
            return this.element.getClass();
        },

        addClassName: function addClassName(className) {
            this.element.addClass(className);
        },

        removeClassName: function removeClassName(className) {
            this.element.removeClass(className);
        },

        toggleClassName: function toggleClassName(className, enable) {
            this.element.toggleClass(className, enable);
        },

        setDomId: function setDomId(id) {
            this.element.setAttribute('id', id);
        },

        getDomId: function getDomId() {
            return this.element.getAttribute('id');
        },

        getId: function getId() {
            return this.id;
        },

        setHtml: function setHtml(html) {
            this.element.innerHTML = html;
        },

        setStyle: function setStyle(style) {
            this.element.setCss(style);
        },

        destroy: function destroy() {
            this.element.parentElement && this.element.parentElement.removeChild(this.element);
        }

    };

    ControlNS.Control = Control;
})();

(function () {
    var ToolbarNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Toolbar");
    var ControlConfig = new Glodon.Bimface.UI.Control.ControlConfig();
    var ToolbarConfig = function ToolbarConfig() {
        var defaults = {
            className: 'bf-toolbar'
        };
        var config = Object.assign({}, ControlConfig, defaults);
        return config;
    };

    ToolbarNS.ToolbarConfig = ToolbarConfig;
})();

(function () {
    var ControlNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Control");
    var ToolbarNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Toolbar");
    var UtilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var Toolbar = function Toolbar(config) {
        this._controls = [];
        ControlNS.Control.call(this, config);
    };

    UtilityNS.Type.inheritPrototype(Toolbar, ControlNS.Control);

    Toolbar.prototype.addControl = function (arg) {
        var controls = this.getControls();
        controls.push(arg);
        this.element.appendChild(arg.element);
    };

    Toolbar.prototype.addControls = function (arr) {
        var self = this;
        for (var i = 0, len = arr.length; i < len; i++) {
            self.addControl(arr[i]);
        }
        var controls = this.getControls();
        return controls;
    };

    Toolbar.prototype.insertControl = function (index, arg) {
        var controls = this.getControls();
        controls.insert(index, arg);
        var next = controls[index + 1];
        if (next) {
            this.element.insertBefore(arg.element, next.element);
        } else {
            this.element.appendChild(arg.element);
        }
    };
    Toolbar.prototype.removeControl = function (id) {
        var controls = this.getControls();
        var control = controls.getObjectByAttribute('id', id);
        controls.removeObjectByAttribute('id', id);
        this.element.removeChild(control.element);
    };

    Toolbar.prototype.getControls = function () {
        return this._controls;
    };

    Toolbar.prototype.getControl = function (id) {
        var controls = this.getControls();
        return controls.getObjectByAttribute('id', id);
    };

    ToolbarNS.Toolbar = Toolbar;
})();

(function () {
    var ButtonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Button");
    var ButtonOption = Glodon.Bimface.UI.Button.ButtonOption;
    var ControlConfig = new Glodon.Bimface.UI.Control.ControlConfig();
    var ButtonConfig = function ButtonConfig() {
        var defaults = {
            className: 'bf-button',
            title: 'button',
            checkedState: false,
            defaultClass: "",
            changeClass: "",
            inheritTitle: false
        };
        var config = Object.assign({}, ControlConfig, defaults);
        return config;
    };

    ButtonNS.ButtonConfig = ButtonConfig;
})();

(function () {
    var ControlNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Control");
    var ButtonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Button");
    var UtilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");

    var Button = function Button(config) {
        ControlNS.Control.call(this, config);
    };

    UtilityNS.Type.inheritPrototype(Button, ControlNS.Control);

    ButtonNS.Button = Button;
})();

(function () {
    var ButtonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Button");
    var UtilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");
    var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;
    var ToggleButton = function ToggleButton(config) {
        ButtonNS.Button.call(this, config);
        var self = this;
        self._checked = config.checkedState;
        if (self._checked) {
            this.addClassName('bf-checked');
        }
        self.addEventListener(controlEvent.Click, function () {
            self.toggleCheckedState();
        });
    };

    UtilityNS.Type.inheritPrototype(ToggleButton, ButtonNS.Button);

    ToggleButton.prototype.toggleCheckedState = function () {
        this.setCheckedState(!this._checked);
    };
    ToggleButton.prototype.setCheckedState = function (isChecked) {
        var currentState = this._checked;
        if (currentState != isChecked) {
            this._checked = isChecked;
            this.toggleClassName('bf-checked', isChecked);
            this.eventManager.fireEvent(controlEvent.StateChange, isChecked);
        }
    };
    ToggleButton.prototype.isChecked = function () {
        return this._checked;
    };

    ButtonNS.ToggleButton = ToggleButton;
})();

(function () {
    var ControlNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Control");
    var ButtonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Button");
    var ToolbarNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Toolbar");
    var UtilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");
    var ToolbarConfig = new ToolbarNS.ToolbarConfig();
    var ControlConfig = new ControlNS.ControlConfig();
    var ComboBox = function ComboBox(config) {
        ControlNS.Control.call(this, config);
        var self = this;
        self._inheritTitle = config.inheritTitle;
        self.setClassNames('bf-combobox');
        var currentElement = new ControlNS.Control(ControlConfig);
        currentElement.setClassNames('bf-current');
        ToolbarConfig.element = self.element;
        ToolbarConfig.className = 'bf-sub-toolbar';
        var subToolbar = new ToolbarNS.Toolbar(ToolbarConfig);
        self.currentElement = currentElement;
        self._subToolbar = subToolbar;

        self.element.appendChild(self.currentElement.element);
        self.addEventListener('Click', function () {
            self.toggleDropDownList();
        });
    };

    UtilityNS.Type.inheritPrototype(ComboBox, ControlNS.Control);

    ComboBox.prototype.toggleDropDownList = function () {
        this.checked = !this.checked;
        this.toggleClassName('bf-expand');
    };

    ComboBox.prototype.showDropDownList = function () {
        this._checked = true;
        this.addClassName('bf-expand');
    };

    ComboBox.prototype.hideDropDownList = function (enableChecked) {
        this._checked = false;
        this.removeClassName('bf-expand');
    };

    ComboBox.prototype.addControl = function (arg) {
        var self = this;
        var controls = self.getControls();
        self._subToolbar.addControl(arg);
        if (controls.length == 1) {
            self.setSelectedControlById(arg.id);
        }
        arg.addEventListener('Click', function () {
            for (var i = 0, len = controls.length; i < len; i++) {
                controls[i].setCheckedState(false);
            }
            self.currentElement.setHtml(this.outerHTML.replace('checked', ''));
            arg.setCheckedState(true);
            self._currentControl = arg;
            self.eventManager.fireEvent("Change", arg);
        });
    };

    ComboBox.prototype.removeControl = function (id) {
        this._subToolbar.removeControl(id);
    };

    ComboBox.prototype.getControls = function () {
        return this._subToolbar.getControls();
    };

    ComboBox.prototype.getControl = function (id) {
        return this._subToolbar.getControl(id);
    };

    ComboBox.prototype.getCurrentControl = function () {
        return this._currentControl;
    };

    ComboBox.prototype.setSelectedControlById = function (id) {
        var selectedControl = this.getControl(id);
        selectedControl.setCheckedState(false);
        var currentElement = selectedControl.element.cloneNode(true);
        if (!this._inheritTitle) {
            currentElement.removeAttribute("title");
        }
        this.currentElement.setHtml(currentElement.outerHTML);
        selectedControl.setCheckedState(true);
        this._currentControl = selectedControl;
    };

    ButtonNS.ComboBox = ComboBox;
})();

(function () {
    var ButtonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Button");
    var UtilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");

    var ComboBoxOptionButton = function ComboBoxOptionButton(config) {
        ButtonNS.ToggleButton.call(this, config);
    };

    UtilityNS.Type.inheritPrototype(ComboBoxOptionButton, ButtonNS.ToggleButton);

    ButtonNS.ComboBoxOptionButton = ComboBoxOptionButton;
})();

(function () {
    var ButtonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Button");
    var UtilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");

    var ChangeButton = function ChangeButton(config) {
        ButtonNS.Button.call(this, config);
        var self = this;
        self._defaultClass = config.defaultClass;
        self._changeClass = config.changeClass;
        self._title = config.title;
        self._changeTitle = config.changeTitle;
        if (self._checked) {
            this.addClassName('bf-checked');
        }
        self.addEventListener('Click', function () {
            self.toggleCheckedState();
        });
    };

    UtilityNS.Type.inheritPrototype(ChangeButton, ButtonNS.Button);

    ChangeButton.prototype.toggleCheckedState = function () {
        this.toggleClassName(this._defaultClass);
        this.toggleClassName(this._changeClass);
        this.setTitle(this._changeTitle);
        var curretnTitle = this._title;
        this._title = this._changeTitle;
        this._changeTitle = curretnTitle;
    };

    ButtonNS.ChangeButton = ChangeButton;
})();

(function () {
    var ButtonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Button");
    var UtilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");
    var group = {};

    var SingleButton = function SingleButton(config) {
        ButtonNS.Button.call(this, config);
        var self = this;
        self._checked = config.checkedState;

        self.addEventListener('Click', function () {
            self.setChecked();
        });

        if (!group[config.groupName]) {
            group[config.groupName] = [self];
            this._groupList = group[config.groupName];
            self.setChecked();
        } else {
            group[config.groupName].push(self);
            this._groupList = group[config.groupName];
        }
    };

    UtilityNS.Type.inheritPrototype(SingleButton, ButtonNS.Button);

    SingleButton.prototype.setChecked = function () {
        var list = this._groupList;
        for (var i = 0, len = list.length; i < len; i++) {
            list[i].removeClassName('bf-checked');
        }
        this.addClassName('bf-checked');
    };

    ButtonNS.SingleButton = SingleButton;
})();

(function () {
    var MenuNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Menu");
    var ControlConfig = new Glodon.Bimface.UI.Control.ControlConfig();
    var MenuConfig = function MenuConfig() {
        var defaults = {
            className: 'bf-menu',
            isSubMenu: false,
            text: null
        };
        var config = Object.assign({}, ControlConfig, defaults);
        return config;
    };

    MenuNS.MenuConfig = MenuConfig;
})();

(function () {
    var MenuNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Menu");
    var ControlConfig = new Glodon.Bimface.UI.Control.ControlConfig();
    var MenuItemConfig = function MenuItemConfig() {
        var defaults = {
            className: 'bf-menu-item'
        };
        var config = Object.assign({}, ControlConfig, defaults);
        return config;
    };

    MenuNS.MenuItemConfig = MenuItemConfig;
})();

(function () {
    var ButtonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Button");
    var MenuNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Menu");
    var UtilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var MenuItem = function MenuItem(config) {
        this._controls = [];
        ButtonNS.Button.call(this, config);
        this.isDisabled = false;
    };

    UtilityNS.Type.inheritPrototype(MenuItem, ButtonNS.Button);

    MenuItem.prototype.setText = function (text) {
        this.element.innerText = text;
    };

    MenuItem.prototype.disabled = function (text) {
        this.element.addClass("bf-disabled");
        this.isDisabled = true;
    };

    MenuItem.prototype.enabled = function (text) {
        this.element.removeClass("bf-disabled");
        this.isDisabled = false;
    };

    MenuItem.prototype.addEventListener = function (eventName, handler) {
        var self = this,
            EventManager = self.eventManager;
        if (!this.isDisabled) {
            self.element.addEventListener(eventName.toLocaleLowerCase(), handler);
            EventManager.addEvent(eventName, handler);
        }
    };

    MenuNS.MenuItem = MenuItem;
})();

(function () {
    var MenuNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Menu");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");

    var Spacer = function Spacer() {
        var self = this;
        self.element = DomNS.create("div", "bf-spacer");
    };

    MenuNS.Spacer = Spacer;
})();

(function () {
    var ToolbarNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Toolbar");
    var MenuNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Menu");
    var UtilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var Menu = function Menu(config) {
        ToolbarNS.Toolbar.call(this, config);
        this.element.addEventListener("mousedown", function (event) {
            event.stopPropagation();
        });
        this.element.addEventListener("contextmenu", function (event) {
            event.preventDefault();
        });
        this.isDisabled = false;
        if (config.isSubMenu) {
            var item = DomNS.create("div", "bf-menu-item");
            item.innerText = config.text;
            var subElement = DomNS.create("div", "bf-menu");
            this.element.appendChild(item);
            this.element.appendChild(subElement);
            this.subElement = subElement;
        }
    };

    UtilityNS.Type.inheritPrototype(Menu, ToolbarNS.Toolbar);

    Menu.prototype.setPosition = function (point) {
        this.element.style.left = point.x + "px";
        this.element.style.top = point.y + "px";
    };

    Menu.prototype.addControl = function (arg) {
        var controls = this.getControls();
        controls.push(arg);
        if (this.subElement) {
            this.subElement.appendChild(arg.element);
        } else {
            this.element.appendChild(arg.element);
        }
    };

    Menu.prototype.disabled = function (text) {
        this.element.addClass("bf-disabled");
        this.isDisabled = true;
    };

    Menu.prototype.enabled = function (text) {
        this.element.removeClass("bf-disabled");
        this.isDisabled = false;
    };

    Menu.prototype.destroy = function (point) {
        this.element.remove();
        this.element = null;
    };

    MenuNS.Menu = Menu;
})();

(function () {
    var ControlNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Control");
    var PanelNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Panel");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var UtilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");

    var Panel = function Panel(config) {
        ControlNS.Control.call(this, config);
        this._controls = [];
        var self = this;
        var element = self.element;

        self.isShow = true;
        var cantainer = DomNS.create('div', 'bf-cantainer');
        var close = DomNS.create('div', 'bf-close');
        var css = config.css;
        for (var attr in css) {
            element.style[attr] = "" + css[attr];
        }
        if (!config.easyMode) {
            element.appendChild(close);
        }

        if (config.title) {
            var title = DomNS.create('div', 'bf-title');
            title.textContent = config.title;
            element.appendChild(title);
            element.addClass("bf-has-title");
            if (config.enableDrag) {
                Glodon.Web.Lang.Utility.Dom.drag({
                    element: this.element,
                    handle: title,
                    move: function move(start, end, distance) {
                        self.eventManager.fireEvent('Move', start, end, distance);
                    }
                });
            }
        }
        element.appendChild(cantainer);
        this.cantainer = cantainer;
        if (config.enableSizable) {
            Glodon.Web.Lang.Utility.Dom.sizable({
                element: this.element,
                axis: 'all',
                sizable: function sizable(start, end, distance) {
                    self.eventManager.fireEvent('Sizable', start, end, distance);
                }
            });
        }
        close.addEventListener('click', function () {
            self.hide();
        });
        cantainer.addEventListener('click', function (e) {
            var tr = e.target.closest('.bf-group-title');
            if (tr && tr.hasClass('bf-group-title')) {
                var group = tr.parentNode;
                group.toggleClass('bf-collapse');
            }
        });
    };

    UtilityNS.Type.inheritPrototype(Panel, ControlNS.Control);

    Panel.prototype.setData = function (data) {
        var cantainer = this.cantainer;
        var table = '<table class="bf-table">';
        for (var i = 0, len = data.length; i < len; i++) {
            var group = "<tbody class=\"bf-group\"><tr class=\"bf-group-title\"><td colspan=\"2\"><i class=\"bf-icon\"></i>" + data[i].group + "</td></tr>";
            var items = data[i].items;
            for (var _j = 0, tdLen = items.length; _j < tdLen; _j++) {
                var obj = items[_j];
                var tr = "<tr class=\"bf-group-content\"><td class=\"bf-key\">" + obj.key + "</td><td class=\"bf-value\">" + obj.value + "</td></tr>";
                group += tr;
            }
            group += '</tbody>';
            table += group;
        }
        table += '</table>';
        cantainer.innerHTML = table;
    };
    Panel.prototype.close = function () {
        this.eventManager.fireEvent('Close');
        this.destroy();
    };
    Panel.prototype.hide = function () {
        this.eventManager.fireEvent('Hide');
        this.isShow = false;
        this.element.style.display = 'none';
    };
    Panel.prototype.show = function () {
        this.eventManager.fireEvent('Show');
        this.isShow = true;
        this.element.style.display = '';
    };
    Panel.prototype.toggle = function () {
        if (this.isShow) {
            this.element.style.display = 'none';
        } else {
            this.element.style.display = '';
        }
        this.isShow = !this.isShow;
    };
    Panel.prototype.addControl = function (arg) {
        var controls = this.getControls();
        controls.push(arg);
        this.cantainer.appendChild(arg.element);
    };

    Panel.prototype.getControls = function () {
        return this._controls;
    };

    Panel.prototype.getControl = function (id) {
        var controls = this.getControls();
        return controls.getObjectByAttribute('id', id);
    };

    Panel.prototype.setHtml = function (html) {
        this.cantainer.innerHTML = html;
    };

    PanelNS.Panel = Panel;
})();

(function () {
    var PanelNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Panel");
    var ControlConfig = new Glodon.Bimface.UI.Control.ControlConfig();
    var PanelConfig = function PanelConfig() {
        var defaults = {
            className: 'bf-panel',
            title: 'panel',
            css: {
                width: "200px",
                height: "200px",
                minWidth: "200px",
                minHeight: "200px"
            },
            enableDrag: true,
            enableSizable: true
        };
        var config = Object.assign({}, ControlConfig, defaults);
        return config;
    };

    PanelNS.PanelConfig = PanelConfig;
})();

(function () {
    var TreeNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Tree");
    var Tree = function Tree(node) {
        var self = this;
        self._root = node;
        self.element = node.element;
        self.eventManager = node.eventManager;
        self.addEventListener = node.addEventListener;
        self.removeEventListener = node.removeEventListener;
        node.addEventListener("SelectionChanged", function (arg) {
            if (self._selectionNode == arg) {
                self._selectionNode = null;
            } else {
                self._selectionNode && self._selectionNode.deselect();
                self._selectionNode = arg;
            }
        });
    };
    Tree.prototype = {
        getRoot: function getRoot() {
            return this._root;
        },
        getChecked: function getChecked() {
            var root = this._root,
                state = [];
            getChildrenChecked(root, {});

            function getChildrenChecked(node, tempState) {
                var checkedState = node.getCheckedState();
                var filter = node.element.getAttribute("data-filter");
                switch (checkedState) {
                    case "unchecked":
                        break;
                    case "checked":
                        if (node == root) {
                            state = "all";
                        } else {
                            var endState = Object.assign({}, tempState);
                            endState[filter] = node.id;
                            state.push(endState);
                        }
                        break;
                    case "half":
                        var children = node.getControls();
                        var nextState = Object.assign({}, tempState);
                        if (node != root) {
                            nextState[filter] = node.id;
                        }
                        for (var i = 0, len = children.length; i < len; i++) {
                            getChildrenChecked(children[i], nextState);
                        }
                        break;
                }
            }
            return state;
        },
        getSelection: function getSelection() {
            var node = this._selectionNode;
            var state = {};
            if (!node) return false;
            getState(node, state);

            function getState(node, tempState) {
                var filter = node.element.getAttribute("data-filter"),
                    parent = node.getParent();
                if (parent) {
                    tempState[filter] = node.id;
                    getState(parent, tempState);
                } else {
                    return tempState;
                }
            }
            return state;
        }
    };
    TreeNS.Tree = Tree;
})();

(function () {
    var ToolbarNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Toolbar");
    var TreeNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Tree");
    var UtilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var TreeNode = function TreeNode(config) {
        ToolbarNS.Toolbar.call(this, config);
        this._opt = Object.assign({}, config);
        if (config.hasCheckbox) {
            this._checkedState = config.isChecked ? 'checked' : 'unchecked';
        }
        this._selection = config.selection;
        this._selectionState = 'unSelected';
    };

    UtilityNS.Type.inheritPrototype(TreeNode, ToolbarNS.Toolbar);

    TreeNode.prototype.setData = function (id, name) {
        var self = this;
        var config = this._opt;
        var treeNode = DomNS.create('div', 'bf-tree-node bf-collapse');
        if (config.hasCheckbox) {
            var checkedClass = config.isChecked ? 'bf-checked' : '';
            var checkbox = DomNS.create('span', 'bf-label ' + checkedClass);
            checkbox.innerHTML = "<input type=\"checkbox\" checked=\"" + config.isChecked + "\"><span class=\"bf-checkbox\"></span>";
            this.checkbox = checkbox;
            treeNode.appendChild(checkbox);
            checkbox.addEventListener('click', function (ev) {
                var isChecked = checkbox.getElementsByTagName('input')[0].checked;
                var checkedState = !isChecked ? 'checked' : 'unchecked';
                self.setCheckedState(!isChecked);
                self.eventManager.fireEvent('CheckedChanged', checkedState);
            });
        }
        var treeName = DomNS.create('span', 'bf-tree-name');
        treeName.textContent = name ? name : "未命名";
        treeName.addEventListener('click', function (ev) {
            if (!self._selection) {
                return false;
            }
            var isSelected = this.hasClass('bf-selected');
            isSelected ? self.deselect() : self.select();
            isSelected = !isSelected;
            self._selectionState = isSelected ? 'selected' : 'unselected';
            self.eventManager.fireEvent('SelectionChanged', self, isSelected);
        });
        treeNode.appendChild(treeName);
        this.element.appendChild(treeNode);
        this.treeNode = treeNode;
        this.treeName = treeName;
        this.id = id;
    };

    TreeNode.prototype.addChildNode = function (node) {
        var self = this;
        this._controls.push(node);
        node._parent = this;
        if (!this.subTree) {
            var icon = DomNS.create('span', 'bf-icon');
            var treeNode = this.treeNode;
            icon.addEventListener('click', function () {
                treeNode.toggleClass('bf-collapse');
            });
            treeNode.insertBefore(icon, this.treeNode.children[0]);
            this.subTree = DomNS.create('div', 'bf-sub-tree');
            this.element.appendChild(this.subTree);
        }
        this.subTree.appendChild(node.element);

        node.addEventListener("CheckedChanged", function (enable) {
            self.setParentCheckedState();
        });
        node.addEventListener("SelectionChanged", function (obj, isSelected) {
            self.eventManager.fireEvent("SelectionChanged", obj, isSelected);
        });
    };

    TreeNode.prototype.getCheckedState = function () {
        return this._checkedState;
    };

    TreeNode.prototype.getSelectionState = function () {
        return this._selectionState;
    };

    TreeNode.prototype.getParent = function () {
        if (this._parent) {
            return this._parent;
        } else {
            return false;
        }
    };

    TreeNode.prototype.setCheckedState = function (enable) {
        var config = this._opt;
        this._checkedState = enable ? 'checked' : 'unchecked';
        if (config.hasCheckbox) {
            this.checkbox.getElementsByTagName('input')[0].checked = enable;
            this.checkbox.toggleClass('bf-checked', enable);
            this.checkbox.toggleClass('bf-unchecked', !enable);
            this.checkbox.removeClass('bf-half');
        }
        this.setChildrenCheckedState(enable);
    };

    TreeNode.prototype.setParentCheckedState = function () {
        var children = this.getControls();
        if (children && children.length > 0) {
            var checkedState;
            for (var i = 0, len = children.length; i < len; i++) {
                var testState = children[i].getCheckedState();
                if (!checkedState) {
                    checkedState = testState;
                } else if (testState != checkedState) {
                    checkedState = 'half';
                }
            }
            this._checkedState = checkedState;
        }
        switch (this._checkedState) {
            case 'checked':
                this.checkbox.getElementsByTagName('input')[0].checked = true;
                this.checkbox.addClass('bf-checked');
                this.checkbox.removeClass('bf-unchecked');
                this.checkbox.removeClass('bf-half');
                break;
            case 'unchecked':
                this.checkbox.getElementsByTagName('input')[0].checked = false;
                this.checkbox.addClass('bf-unchecked');
                this.checkbox.removeClass('bf-checked');
                this.checkbox.removeClass('bf-half');
                break;
            case 'half':
                this.checkbox.getElementsByTagName('input')[0].checked = true;
                this.checkbox.addClass('bf-half');
                this.checkbox.removeClass('bf-unchecked');
                this.checkbox.removeClass('bf-checked');
                break;
        }
        this.eventManager.fireEvent('CheckedChanged', checkedState);
    };

    TreeNode.prototype.setChildrenCheckedState = function (enable) {
        var children = this.getControls(),
            len = children.length;
        if (children && len > 0) {
            for (var i = 0; i < len; i++) {
                children[i].setCheckedState(enable);
            }
        }
    };

    TreeNode.prototype.expand = function () {
        this.treeNode.removeClass('bf-collapse');
    };

    TreeNode.prototype.collapse = function () {
        this.treeNode.addClass('bf-collapse');
    };

    TreeNode.prototype.toggleExpansion = function (enable) {
        this.treeNode.toggleClass('bf-collapse', enable);
    };

    TreeNode.prototype.select = function () {
        return this.treeName.addClass('bf-selected');
    };

    TreeNode.prototype.deselect = function () {
        return this.treeName.removeClass('bf-selected');
    };

    TreeNS.TreeNode = TreeNode;
})();

(function () {
    var TreeNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.UI.Tree");
    var ControlConfig = new Glodon.Bimface.UI.Control.ControlConfig();
    var TreeNodeConfig = function TreeNodeConfig() {
        var defaults = {
            className: 'bf-tree',
            title: 'tree',
            hasCheckbox: true,
            isChecked: true,
            selection: true
        };
        var config = Object.assign(ControlConfig, defaults);
        return config;
    };

    TreeNS.TreeNodeConfig = TreeNodeConfig;
})();

(function () {
    var viewNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");

    var IsolateEnum = Object.freeze({
        "TranslucentOthers": "",
        "HideOthers": ""
    });
    var Viewer = function Viewer() {
        var eventManager = new Glodon.Web.Lang.EventManager();
        this.getEventManager = function () {
            return eventManager;
        };
    };
    Viewer.prototype.init = function () {};

    Viewer.prototype.addView = function (viewToken) {
        var self = this;
        var authenticateNS = Glodon.Bimface.Authentication.AuthenticationManager;
        var viewer2DConfing = self._opt;
        var authenticateConfig = new Glodon.Bimface.Authentication.AuthenticationConfig();
        authenticateConfig.viewToken = viewToken;
        authenticateConfig.APIHost = this._opt.APIHost;
        var authenticate = this.authenticate = new authenticateNS(authenticateConfig);

        authenticate.authenticate(function (data) {
            if (data.renderType == "bimView") {
                data.renderType = "3DView";
            }
            self._data = data;
            self.loadViewCore(data);
        }, function (res) {
            var viewerEvents = Glodon.Bimface.Viewer.Viewer3DEvent;
            self.getEventManager().fireEvent(viewerEvents.Error, res);
        });
    };
    Viewer.prototype.loadViewCore = function () {};
    Viewer.prototype.addEventListener = function (eventName, handler) {
        this.getEventManager().addEvent(eventName, handler);
    };
    Viewer.prototype.removeEventListener = function (eventName, handler) {
        this.getEventManager().removeEvent(eventName, handler);
    };
    Viewer.prototype.enableFullScreen = function (isEnabled) {
        var element = this._opt.domElement,
            self = this;
        if (isEnabled) {
            Glodon.Web.Lang.Utility.FullScreen.fullScreen(element);
        } else {
            Glodon.Web.Lang.Utility.FullScreen.exitFullScreen();
        }
        setTimeout(function () {
            self.resize();
        }, 200);
    };

    viewNS.Viewer = Viewer;
})();

(function () {
    var ViewerNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    var Viewer2DConfig = function Viewer2DConfig() {
        var defaults = {
            domElement: null,
            resourceHost: "https://m.bimface.com",
            APIHost: "https://api.bimface.com"
        };
        return defaults;
    };

    ViewerNS.Viewer2DConfig = Viewer2DConfig;
})();

(function () {
    var Viewer2DEvent = Object.freeze({
        "Loaded": "Loaded",
        "MouseClicked": "MouseClicked",
        "Rendered": "Rendered",
        "ViewChanged": "ViewChanged",
        "ViewMoving": "ViewMoving",
        "ViewMoved": "ViewMoved",
        "ViewZooming": "ViewZooming",
        "Error": "Error"
    });

    var viewerNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    viewerNS.Viewer2DEvent = Viewer2DEvent;
})();

(function () {
    var NavigationMode2D = Object.freeze({
        "Pan": "Pan",
        "Zoom": "Zoom"
    });

    var viewerNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    viewerNS.NavigationMode2D = NavigationMode2D;
})();

(function () {
    var viewNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    var utilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");
    var DomNs = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, 'Web.Lang.Utility.Dom');
    var $ = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, 'Web.Lang.Utility.HttpRequest');
    var ViewerEvent = Glodon.Bimface.Viewer.Viewer2DEvent;
    var Viewer2D = function Viewer2D(option) {
        viewNS.Viewer.call(this);
        var self = this;
        var domElement = DomNs.create("div", "bf-dwg");
        option.domElement.appendChild(domElement);
        self._opt = option;
        self._domElement = domElement;
        self._viewLoaded = false;
        self._dwgViewer = self.createDwgViewer();
        self.currentViewId = null;
        var startTime, endTime;
        domElement.addEventListener("mousedown", function () {
            startTime = new Date().getTime();
        });
        domElement.addEventListener("mouseup", function (event) {
            var viewer = self._dwgViewer,
                endTime = new Date().getTime(),
                position = domElement.getBoundingClientRect(),
                clientPosition = {
                x: event.clientX - position.left,
                y: event.clientY - position.top
            },
                worldPosition = self.clientToWorld(clientPosition);
            if (endTime - startTime < 300) {
                self.getEventManager().fireEvent(ViewerEvent.MouseClicked, {
                    worldPosition: worldPosition,
                    clientPosition: clientPosition
                });
            }
            startTime = endTime = null;
        });
        this.getDomElement = function () {
            return domElement;
        };
    };

    utilityNS.Type.inheritPrototype(Viewer2D, viewNS.Viewer);

    Viewer2D.prototype = Object.assign({}, viewNS.Viewer.prototype, {
        createDwgViewer: function createDwgViewer() {
            var viewer2d = this;
            return {

                __container: null,

                __options: null,

                __unit: 512,

                __state: 'pan', //none:无状态，rectzoom:窗口缩放

                __rect: null,

                __defaultTileURL: '//static.bimface.com/components/images/tile-default.jpg',

                __curLevel: 1,

                __zoomFact: 1.6, //缩放因子

                __zoomScale: 1, //当前缩放规模

                __canMove: false,

                __startPos: null,

                __startPoint: null,

                __endPoint: null,

                __startDistance: null, //缩放开始距离

                __endDistance: null, //缩放结束距离

                __startScale: null, //缩放开始时的比例

                __moveLevel: null, //移动中记录下计算好的level值

                __viewWidth: 0,

                __viewHeight: 0,

                __viewLeft: 0, //视口的left，这个是当前视口的left偏移量，和视口中心点的坐标要区分，view panel设置的是中心的点left,top

                __viewTop: 0, //解释如上

                __sceneInViewPoint: {}, //场景在view点的坐标，left，top百分比

                __endCallback: null,

                __mouseInViewPoint: {
                    left: 0,
                    top: 0
                }, //以鼠标哪个位置来进行缩放，如果是屏幕中间，就直接设置下

                __imgObjCache: [],

                __zoomStart: null,

                __zoomDelta: 800,

                __zoomTimer: null,

                __pinchStart: null,

                __pinchDelta: 2000,

                __pinchTimer: null,

                init: function init(container, options) {
                    var self = this;
                    var __tpl = DomNs.create('div', 'bf-scene');
                    var __rect = DomNs.create('div', 'bf-rect');
                    __tpl.innerHTML = "<div class=\"bf-dwg-view\"></div>";
                    container.appendChild(__rect);

                    self.__container = container;
                    self.__panel && self.__panel.parentElement.removeChild(self.__panel);

                    self.__panel = self.__container.appendChild(__tpl);

                    self.__rect = __rect;

                    self.__viewWidth = container.offsetWidth;
                    self.__viewHeight = container.offsetHeight;

                    if (typeof options == "string") {
                        var img = new Image();
                        img.src = options;
                        self.__panel.appendChild(img);
                        self.__options = Object.assign({
                            lod: {
                                maxLevel: 1,
                                ext: '',
                                url: ''
                            }
                        }, options);
                    } else {
                        self.__options = Object.assign({
                            lod: {
                                maxLevel: 11,
                                ext: '',
                                url: ''
                            }
                        }, options);
                        var lod = self.__options.lod;
                        self.__firstImgUrl = lod.url + '/L1/Model_0_0.' + lod.ext;
                        self.fit();
                    }

                    self.__bindEvent();
                    self.__bindMobileEvent();
                },

                getPanel: function getPanel() {
                    return this.__panel;
                },

                setState: function setState(state) {
                    this.__state = state;
                },

                getViewInfo: function getViewInfo() {
                    var self = this;
                    var zoomScale = self.__zoomScale;
                    var unit = self.__unit;
                    return {
                        view: {
                            width: self.__viewWidth,
                            height: self.__viewHeight,
                            top: self.__viewTop,
                            left: self.__viewLeft
                        },
                        scene: {
                            width: unit * zoomScale,
                            height: unit * zoomScale,
                            scale: self.__zoomScale
                        }
                    };
                },

                windowResize: function windowResize() {
                    var self = this;
                    var container = self.__container;
                    self.__viewWidth = container.offsetWidth;
                    self.__viewHeight = container.offsetHeight;
                    self.zoom(self.__zoomScale);
                },

                //画缩放框
                drawRect: function drawRect(offset) {
                    this.__rect.style.width = offset.offsetX + "px";
                    this.__rect.style.height = offset.offsetY + "px";
                },

                //窗口缩放
                rectZoom: function rectZoom() {
                    var self = this;
                    var rect = self.__rect;
                    if (rect.style.display == "none") return false;
                    var offsetTop = rect.offsetTop;
                    var offsetLeft = rect.offsetLeft;
                    var tw = self.__viewWidth;
                    var th = self.__viewHeight;
                    var w = rect.offsetWidth;
                    var h = rect.offsetHeight;
                    var zoomScale = self.__zoomScale;
                    var fact = 1;
                    if (w < 10 || h < 10) {
                        rect.style.width = "0";
                        rect.style.height = "0";
                        rect.style.display = "none";
                        return false;
                    }

                    if (tw / th > w / h) {
                        fact = th / h;
                    } else {
                        fact = tw / w;
                    }
                    zoomScale = zoomScale * fact;
                    var o;
                    var point = {
                        top: offsetTop + h / 2,
                        left: offsetLeft + w / 2
                    };

                    rect.style.width = "0";
                    rect.style.height = "0";
                    rect.style.display = "none";

                    self.zoom(zoomScale, point);
                },

                pan: function pan(offset) {
                    var self = this;
                    self.__viewLeft = self.__startPos.left - offset.offsetX;
                    self.__viewTop = self.__startPos.top - offset.offsetY;

                    self.__resetSceneInViewPoint();
                    self.__changeViewPos();
                    viewer2d.getEventManager().fireEvent(ViewerEvent.ViewMoving, offset);
                    viewer2d.getEventManager().fireEvent(ViewerEvent.Rendered);
                },

                //放大
                zoomIn: function zoomIn(mousePoint) {
                    var self = this;

                    var zoomScale = self.__zoomScale * self.__zoomFact; //.toFixed(2)

                    self.zoom(zoomScale, mousePoint);
                },

                //缩小
                zoomOut: function zoomOut(mousePoint) {
                    var self = this;
                    var zoomScale = self.__zoomScale / self.__zoomFact; //.toFixed(2)

                    self.zoom(zoomScale, mousePoint);
                },

                zoomTo: function zoomTo(zoomScale, mousePoint) {
                    this.zoom(zoomScale, mousePoint);
                },

                //回到第一层并自适应
                fit: function fit() {
                    var self = this;
                    self.__curLevel = 1;
                    self.__zoomScale = 1;

                    self.__viewLeft = 0;
                    self.__viewTop = 0;

                    self.__viewPoint();

                    self.__genTiles();
                },
                zoom: function zoom(zoomScale, mousePoint) {
                    var self = this;
                    var panel = self.__panel;
                    var options = self.__options;
                    var viewPanel = panel.getElementsByClassName('bf-dwg-view')[0];
                    var unit = self.__unit;
                    var curLevel = self.__curLevel;
                    var lod = options.lod;

                    if (zoomScale <= 1) {
                        zoomScale = 1;
                        curLevel = 1;
                    } else {
                        //如果放大比例比当前的比例大
                        var level = Math.log(zoomScale) / Math.log(2);
                        var curLevel = parseInt(level, 10) + 2;
                    }

                    //如果增加后的比最大的还大
                    if (curLevel >= lod.maxLevel) {
                        var maxScale = Math.pow(2, lod.maxLevel - 1);
                        if (zoomScale >= maxScale) {
                            zoomScale = maxScale;
                        }
                        curLevel = lod.maxLevel;
                    }

                    //正在的缩放比例，主要是放大到最大的时候可能不是zoomFact(1.6)的倍数
                    var scaleFact = zoomScale / self.__zoomScale;

                    //先把原始图片放大，产生模糊的效果
                    var tiles = viewPanel.getElementsByClassName("bf-dwg-tile");
                    for (var i = 0, len = tiles.length; i < len; i++) {
                        var item = tiles[i];
                        var level = item.getAttribute('data-level');
                        //计算当前比例下图片的大小
                        var unitScale = self.__zoomScale / Math.pow(2, level - 1);
                        item.style.width = unit * unitScale * scaleFact + "px";
                        item.style.height = unit * unitScale * scaleFact + "px";
                    }
                    //如果是缩小则添加第一级的图片
                    if (zoomScale < self.__zoomScale) {
                        var tile = DomNs.create('img', 'bf-dwg-tile');
                        tile.src = self.__firstImgUrl;
                        tile.setAttribute("data-col", "0");
                        tile.setAttribute("data-row", "0");
                        tile.setAttribute("data-level", "1");
                        tile.style.width = unit * zoomScale + "px";
                        tile.style.height = unit * zoomScale + "px";
                        tile.style.zIndex = 0;
                        viewPanel.appendChild(tile);
                    }

                    //调整缩放参照点
                    if (mousePoint) {
                        self.__mouseInViewPoint = mousePoint;
                    } else {
                        self.__mouseInViewPoint = {
                            left: self.__viewWidth / 2,
                            top: self.__viewHeight / 2
                        };
                    }
                    self.__resetSceneInViewPoint();
                    self.__zoomScale = zoomScale;

                    self.__viewPoint(true);

                    self.__curLevel = curLevel;

                    //状态已经改变，没有加载完成的图片不进行处理
                    self.__stateChange();
                    var zoomStart = self.__zoomStart;
                    var zoomDelta = self.__zoomDelta;
                    var now = new Date();
                    window.clearTimeout(self.__zoomTimer);

                    if (!zoomStart) {
                        zoomStart = new Date();
                    } else {
                        if (now.getTime() - zoomStart.getTime() >= zoomDelta) {
                            self.__zoomEvent();
                        } else {
                            self.__zoomTimer = window.setTimeout(function () {
                                self.__zoomEvent();
                            }, zoomDelta);
                        }
                    }

                    self.__zoomStart = now;
                    if (!mousePoint) {
                        mousePoint = {
                            left: 0,
                            top: 0
                        };
                    }
                    viewer2d.getEventManager().fireEvent(ViewerEvent.ViewZooming, {
                        zoomScale: zoomScale,
                        mouseClientPosition: {
                            x: mousePoint.left,
                            y: mousePoint.top
                        }
                    });
                    viewer2d.getEventManager().fireEvent(ViewerEvent.Rendered);
                },

                __zoomEvent: function __zoomEvent() {
                    var self = this;
                    self.__genTiles();

                    self.__viewPoint(true);

                    self.__zoomStart = null;
                },

                __removeLast: function __removeLast() {
                    var self = this;
                    var viewPanel = self.__panel.getElementsByTagName('view')[0];

                    var pastImages = viewPanel.getElementsByTagName('bf-dwg-past');
                    for (var i = 0, len = pastImages.length; i < len; i++) {
                        viewPanel.removeChild(pastImages[i]);
                    }
                },

                __bindEvent: function __bindEvent() {
                    var self = this;
                    var container = self.__container;
                    var rect = self.__rect;
                    var scale = self.__zoomScale;

                    window.addEventListener('resize', function () {
                        self.windowResize();
                    });
                    var eventStart = function eventStart(evt, point) {
                        var state = self.__state;
                        scale = self.__zoomScale;
                        evt = point || evt;
                        self.__canMove = true;
                        container.style.cursor = "pointer";

                        var point = self.__startPoint = self.__getEventPoint(evt);
                        self.__startPos = {
                            top: self.__viewTop,
                            left: self.__viewLeft
                        };
                        if (state == 'rectzoom') {
                            var getPosition = function getPosition(element) {
                                if (element.offsetParent) {
                                    offsetTop += element.offsetParent.offsetTop;
                                    offsetLeft += element.offsetParent.offsetLeft;
                                    getPosition(element.offsetParent);
                                }
                            };

                            var offsetTop = self.__container.offsetTop;
                            var offsetLeft = self.__container.offsetLeft;
                            getPosition(self.__container);

                            var top = document.documentElement.scrollTop;
                            var left = document.documentElement.scrollLeft;
                            rect.style.top = top + point.y - offsetTop + "px";
                            rect.style.left = left + point.x - offsetLeft + "px";
                            rect.style.display = 'block';
                        }
                        evt.preventDefault();
                        return false;
                    };
                    var eventMove = function eventMove(evt) {
                        var state = self.__state;
                        if (!self.__canMove) return false;
                        var endPoint = self.__endPoint = self.__getEventPoint(evt);
                        var startPoint = self.__startPoint;
                        var offset = {
                            offsetX: endPoint.x - startPoint.x,
                            offsetY: endPoint.y - startPoint.y
                        };
                        if (Math.abs(offset.offsetX) > 10 || Math.abs(offset.offsetX) > 10) {
                            switch (state.toLocaleLowerCase()) {
                                case 'pan':
                                    self.pan(offset);
                                    break;
                                case 'rectzoom':
                                    self.drawRect(offset);
                                    break;
                                case 'zoom':
                                    if (Math.abs(offset.y) > 20) {
                                        var newScale = -offset.y / 200 + scale;
                                        newScale = newScale < 1 ? 1 : newScale;
                                        self.zoom(newScale);
                                    }
                                    break;
                            }
                        }
                        return false;
                    };
                    var eventEnd = function eventEnd(evt) {
                        if (!self.__startPoint) {
                            return false;
                        }
                        var state = self.__state,
                            startPoint = self.__startPoint,
                            endPoint = self.__getEventPoint(evt),
                            offset = {
                            offsetX: endPoint.x - startPoint.x,
                            offsetY: endPoint.y - startPoint.y
                        };
                        self.__canMove = false;
                        container.style.cursor = "default";

                        self.__startPoint = null;
                        self.__endPoint = null;

                        switch (state.toLocaleLowerCase()) {
                            case 'pan':
                                //状态已经改变，没有加载完成的图片不进行处理
                                self.__stateChange();
                                break;
                            case 'rectzoom':
                                self.rectZoom();
                                break;
                        }
                        self.__genTiles();
                        if (self.__endCallback) {
                            self.__endCallback();
                        }
                        viewer2d.getEventManager().fireEvent(ViewerEvent.ViewMoved, offset);
                        return false;
                    };
                    //point是外面触发了mousedown传给该事件的值
                    container.addEventListener('mousedown', eventStart);
                    container.addEventListener('mouseup', eventEnd);
                    container.addEventListener('mouseleave', eventEnd);
                    container.addEventListener('mousemove', eventMove);
                    container.addEventListener('mousewheel', function (evt) {
                        self.__wheelEvent(evt);
                        evt.preventDefault();
                    });
                    container.addEventListener('DOMMouseScroll', function (evt) {
                        self.__wheelEvent(evt);
                        evt.preventDefault();
                    });
                },

                __wheelEvent: function __wheelEvent(evt) {
                    var self = this;
                    var delta = evt.wheelDelta && (evt.wheelDelta > 0 ? 1 : -1) || evt.detail && (evt.detail > 0 ? -1 : 1);
                    var scale = self.__zoomScale;
                    var newScale = scale + delta * scale / 10;
                    var containerLeft = self.__container.offsetLeft;
                    var containerTop = self.__container.offsetTop;
                    var mousePoint = {
                        left: evt.pageX - containerLeft,
                        top: evt.pageY - containerTop
                    };
                    self.zoom(newScale, mousePoint);
                },
                __bindMobileEvent: function __bindMobileEvent() {
                    var self = this;
                    var container = self.__container;

                    window.addEventListener('resize', function () {
                        self.windowResize();
                    });
                    container.addEventListener('touchstart', function (evt) {
                        evt.preventDefault();
                        var evt = self.__getMobileEvt(evt);
                        if (evt.isMulti) {
                            //如果是双指
                            self.__startScale = self.__zoomScale;
                            self.__startDistance = evt.distance;
                        } else {
                            self.__startPoint = evt.point;
                            self.__startPos = {
                                top: self.__viewTop,
                                left: self.__viewLeft
                            };
                        }
                        return false;
                    });
                    container.addEventListener('touchend', function (evt) {
                        var evt = self.__getMobileEvt(evt);
                        if (!self.__startDistance) {
                            //状态已经改变，没有加载完成的图片不进行处理
                            self.__stateChange();
                            self.__genTiles();
                        } else {

                            // self.__curLevel = self.__moveLevel

                            //状态已经改变，没有加载完成的图片不进行处理
                            self.__stateChange();
                            self.__genTiles();

                            self.__viewPoint(true);
                        }
                        self.__startPoint = null;
                        self.__endPoint = null;
                        self.__startDistance = null;
                        self.__endDistance = null;
                        self.__startScale = null;
                        viewer2d.getEventManager().fireEvent(ViewerEvent.ViewMoved, offset);
                        return false;
                    });
                    container.addEventListener('touchmove', function (evt) {
                        var evt = self.__getMobileEvt(evt);
                        if (evt.isMulti) {
                            //双指
                            var endDistance = self.__endDistance = evt.distance;
                            var startDistance = self.__startDistance;

                            var zoomScale = self.__startScale * endDistance / startDistance;
                            self.zoom(zoomScale);
                        } else {
                            //单指
                            var endPoint = self.__endPoint = evt.point;
                            var startPoint = self.__startPoint || evt.point;
                            var offset = {
                                offsetX: endPoint.x - startPoint.x,
                                offsetY: endPoint.y - startPoint.y
                            };
                            if (Math.abs(offset.offsetX) > 10 || Math.abs(offset.offsetY) > 10) {
                                self.pan(offset);
                            }
                        }
                    });
                },

                __getMobileEvt: function __getMobileEvt(evt) {
                    var self = this;
                    var evt = evt.originalEvent || evt;
                    //多指触摸， 返回多个手势位置信息
                    var posi = [];
                    var src = null;

                    for (var t = 0, len = evt.touches.length; t < len; t++) {
                        src = evt.touches[t];
                        posi.push({
                            x: src.pageX,
                            y: src.pageY
                        });
                    }
                    if (posi.length <= 1) {
                        return {
                            isMulti: false,
                            point: posi[0]
                        };
                    } else {
                        return {
                            isMulti: true,
                            distance: self.__getDistance(posi[0], posi[1]),
                            point: posi
                        };
                    }
                },

                __getDistance: function __getDistance(pos1, pos2) {
                    var x = pos2.x - pos1.x;
                    var y = pos2.y - pos1.y;
                    return Math.sqrt(x * x + y * y);
                },
                /**
                 * 在改变view位置的时候先调整view的位置到鼠标点位置，默认是屏幕中心
                 * @param isInited,是否初始化完成了。
                 * @private
                 */
                __viewPoint: function __viewPoint(isInited) {
                    var self = this;
                    var unit = self.__unit;
                    var zoomScale = self.__zoomScale;

                    var viewWidth = self.__viewWidth;
                    var viewHeight = self.__viewHeight;
                    var tileWidth = unit * zoomScale;
                    var tileHeight = tileWidth;

                    if (!isInited) {
                        //第一次加载
                        self.__viewLeft = (tileWidth - viewWidth) / 2;
                        self.__viewTop = (tileHeight - viewHeight) / 2;

                        self.__mouseInViewPoint = {
                            left: viewWidth / 2,
                            top: viewHeight / 2
                        };
                        //初始化场景在视口中间点的坐标百分比
                        self.__resetSceneInViewPoint();

                        self.__changeViewPos();
                        return false;
                    }

                    var viewLeft = self.__viewLeft;
                    var viewTop = self.__viewTop;

                    var sceneInViewPoint = self.__sceneInViewPoint;
                    var mouseInViewPoint = self.__mouseInViewPoint;

                    var scenePointLeft = zoomScale * unit * sceneInViewPoint.left;
                    var scenePointTop = zoomScale * unit * sceneInViewPoint.top;

                    viewLeft = scenePointLeft - mouseInViewPoint.left;
                    viewTop = scenePointTop - mouseInViewPoint.top;

                    self.__viewLeft = viewLeft;
                    self.__viewTop = viewTop;

                    self.__changeViewPos();
                },

                /**
                 * 改变view的位置
                 * @private
                 */
                __changeViewPos: function __changeViewPos() {
                    var self = this;
                    var panel = self.__panel;
                    var zoomScale = self.__zoomScale;
                    var curLevel = self.__curLevel;
                    var unit = self.__unit;

                    var viewPanel = panel.getElementsByClassName('bf-dwg-view')[0];
                    var viewLeft = self.__viewLeft;
                    var viewTop = self.__viewTop;

                    var viewCenterTop = self.__viewHeight / 2 + viewTop;
                    var viewCenterLeft = self.__viewWidth / 2 + viewLeft;
                    //把view的位置设置到屏幕中间，view的top,left是视口的左上角的坐标。特别注意
                    viewPanel.style.top = viewCenterTop + "px";
                    viewPanel.style.left = viewCenterLeft + "px";

                    //为了让view在可视范围，需要调整场景的位置。
                    panel.style.top = -viewTop + "px";
                    panel.style.left = -viewLeft + "px";

                    //改变图片的位置
                    var tiles = viewPanel.getElementsByTagName('img');
                    for (var i = 0, len = tiles.length; i < len; i++) {
                        var item = tiles[i];
                        var level = item.getAttribute('data-level');
                        var factUnit = unit * zoomScale / Math.pow(2, level - 1);
                        var col = item.getAttribute('data-col');
                        var row = item.getAttribute('data-row');
                        var top = row * factUnit - viewCenterTop;
                        var left = col * factUnit - viewCenterLeft;
                        item.style.top = top + "px";
                        item.style.left = left + "px";
                    }
                },

                /**
                 * 生成tile视图
                 * @param level 需要生成的层级
                 * @param needKeep  是否需要保留原tiles
                 * @private
                 */
                __genTiles: function __genTiles() {
                    var self = this;
                    var level = self.__curLevel;
                    var zoomScale = self.__zoomScale;
                    var panel = self.__panel;
                    var options = self.__options;
                    var viewPanel = panel.getElementsByClassName('bf-dwg-view')[0];

                    var images = self.__getShowTiles(level, self.__viewLeft, self.__viewTop, self.__viewWidth, self.__viewHeight, options.lod.maxLevel);
                    self.__images = images;
                    //为了解决换图片闪的问题，决定不清除图片,而是再初始化完以后来进行删除
                    var tileImgs = viewPanel.getElementsByClassName('bf-dwg-tile');
                    for (var i = 0, len = tileImgs.length; i < len; i++) {
                        tileImgs[i].addClass('bf-dwg-past');
                    }

                    var imgLength = images.length;
                    var loadCount = 0;

                    function imagesLoaded(item, stateChange) {
                        //如果已经缩放或者平移
                        if (stateChange) return false;
                        if (loadCount === imgLength) {
                            var loaded = viewPanel.getElementsByClassName('bf-dwg-past');
                            var len = loaded.length;
                            for (var i = len; i > 0; i--) {
                                viewPanel.removeChild(loaded[0]);
                            }
                        }

                        item && viewPanel.appendChild(item);
                        //加载完成需要根据zoomScale来计算当前显示的大小
                    }

                    for (var i = 0, len = images.length; i < len; i++) {
                        var img = DomNs.create('img', 'bf-dwg-tile'),
                            item = images[i],
                            unit = self.__unit,
                            scale = zoomScale / Math.pow(2, self.__curLevel - 1);
                        item.src = item.src.replace(/[#+? ]/g, function (word) {
                            return escape(word);
                        });
                        img.onload = function () {
                            loadCount++;
                            imagesLoaded(this, this.stateChange);
                        };
                        img.onerror = function () {
                            loadCount++;
                            imagesLoaded('', this.stateChange);
                        };
                        img.onabort = function () {
                            item.src = self.__defaultTileURL;
                            loadCount++;
                            imagesLoaded(this, this.stateChange);
                        };

                        img.src = item.src;
                        img.setAttribute('data-row', item.row);
                        img.setAttribute('data-col', item.col);
                        img.setAttribute('data-level', item.level);
                        img.style.top = item.top + "px";
                        img.style.left = item.left + "px";
                        img.style.width = unit * scale + "px";
                        img.style.height = unit * scale + "px";

                        self.__imgObjCache.push(img);
                    }
                    viewer2d.getEventManager().fireEvent(ViewerEvent.Rendered);
                },

                /**
                 * 重置场景中需要在视口中鼠标的点
                 * @private
                 */
                __resetSceneInViewPoint: function __resetSceneInViewPoint() {
                    var self = this;
                    var unit = self.__unit;
                    var zoomScale = self.__zoomScale;
                    var viewLeft = self.__viewLeft;
                    var viewTop = self.__viewTop;
                    var sceneInViewPointer = self.__sceneInViewPoint;
                    var mouseInViewPoint = self.__mouseInViewPoint;

                    sceneInViewPointer.left = (viewLeft + mouseInViewPoint.left) / (unit * zoomScale);
                    sceneInViewPointer.top = (viewTop + mouseInViewPoint.top) / (unit * zoomScale);
                },

                /**
                 * 获得当前视口下需要显示的图片
                 * @param level 当前级别
                 * @param viewLeft     视口x坐标
                 * @param viewTop     视口y坐标
                 * @param viewWidth 视口宽度
                 * @param viewHeight 视口高度
                 * @param maxLevel 最大的级别
                 * @private
                 */
                __getShowTiles: function __getShowTiles(level, viewLeft, viewTop, viewWidth, viewHeight, maxLevel) {
                    var self = this;
                    var url = self.__options.lod.url;
                    var ext = self.__options.lod.ext;
                    var images = [];
                    var unit = self.__unit * self.__zoomScale / Math.pow(2, self.__curLevel - 1);

                    var startTile = {
                        row: parseInt(viewTop / unit, 10),
                        col: parseInt(viewLeft / unit, 10)
                    };

                    var cols = 1;
                    var offsetLeft = unit - viewLeft % unit;

                    if (offsetLeft === 0) {
                        offsetLeft += unit;
                    }

                    while (offsetLeft < viewWidth) {
                        offsetLeft += unit;

                        cols++;
                    }

                    var rows = 1;
                    var offsetTop = unit - viewTop % unit;

                    if (offsetTop === 0) {
                        offsetTop += unit;
                    }

                    while (offsetTop < viewHeight) {
                        offsetTop += unit;

                        rows++;
                    }

                    var viewCenterLeft = viewLeft + viewWidth / 2;
                    var viewCenterTop = viewTop + viewHeight / 2;

                    var maxCount = Math.pow(2, level - 1);
                    if (maxLevel == 1) {
                        return false;
                    } else {
                        for (var i = 0; i < rows; i++) {
                            var row = startTile.row + i;
                            if (row >= maxCount || row < 0) continue;
                            for (var j = 0; j < cols; j++) {
                                var col = startTile.col + j;
                                if (col >= maxCount || col < 0) continue;
                                images.push({
                                    row: row,
                                    col: col,
                                    src: url + '/L' + level + '/Model_' + row + '_' + col + '.' + ext,
                                    top: row * unit - viewCenterTop,
                                    left: col * unit - viewCenterLeft,
                                    level: self.__curLevel
                                });
                            }
                        }
                        return images;
                    }
                },

                __stateChange: function __stateChange() {
                    var self = this;
                    var imgs = self.__imgObjCache;

                    for (var i = 0, len = imgs.length; i < len; i++) {
                        imgs[i].stateChange = true;
                    }

                    self.__imgObjCache = [];
                },

                __getEventPoint: function __getEventPoint(evt) {
                    var result = {
                        x: evt.clientX || evt.pageX || evt.originalEvent && (evt.originalEvent.clientX || evt.originalEvent.pageX),
                        y: evt.clientY || evt.pageY || evt.originalEvent && (evt.originalEvent.clientY || evt.originalEvent.pageY),
                        offsetX: evt.offsetX || evt.originalEvent && evt.originalEvent.layerX,
                        offsetY: evt.offsetY || evt.originalEvent && evt.originalEvent.layerY
                    };
                    return result;
                },

                __showInfo: function __showInfo(message) {
                    var self = this;
                    self.debugPanel.html(self.debugPanel.html() + '<br/>' + message).scrollTop(self.debugPanel[0].scrollHeight);
                }
            };
        },
        load: function load(viewToken) {
            if (this._viewLoaded == false) {
                this._viewLoaded = true;
                this.addView(viewToken);
            }
        },
        loadViewCore: function loadViewCore(data) {
            var self = this,
                _opt = self._opt;
            $.ajax({
                async: false,
                url: _opt.resourceHost + "/" + data.databagId + "/manifest.json",
                success: function success(res) {
                    var data = JSON.parse(res);
                    if (data.Views) {
                        var viewsList = [];
                        for (var i = 0, len = data.Views.length; i < len; i++) {
                            var item = data.Views[i],
                                file = item.Representations.getObjectByAttribute("MIME", "image/tiles");
                            viewsList.push({
                                name: item.Name,
                                id: item.ID,
                                file: file
                            });
                        }
                        self._views = viewsList;
                        self.showViewById(viewsList[0].id);
                        self.getEventManager().fireEvent(ViewerEvent.Loaded, self);
                    }
                }
            });
        },
        showFile: function showFile(file) {
            var self = this,
                _opt = self._opt,
                _data = self._data,
                _dwgViewer = self._dwgViewer;
            _dwgViewer.init(self._domElement, {
                lod: {
                    maxLevel: parseInt(file.Attributes.DwgLevel, 10),
                    ext: file.Attributes.DwgExt || 'jpg',
                    url: _opt.resourceHost + '/' + _data.databagId + '/' + file.Path
                }
            });
        },
        showImage: function showImage(path) {
            this._dwgViewer.init(this._domElement, path);
        },
        render: function render() {},
        home: function home() {
            this._dwgViewer.fit();
        },
        setNavigationMode: function setNavigationMode(navigationMode) {
            this._dwgViewer.setState(navigationMode);
        },
        zoomIn: function zoomIn() {
            this._dwgViewer.zoomIn();
        },
        zoomOut: function zoomOut() {
            this._dwgViewer.zoomOut();
        },
        zoom: function zoom(zoomScale) {
            this._dwgViewer.zoomTo(zoomScale);
        },
        rectZoom: function rectZoom(callback) {
            this._dwgViewer.setState('rectzoom');
            if (callback) {
                this._dwgViewer.__endCallback = callback;
            }
        },
        getViews: function getViews() {
            return this._views;
        },
        showViewById: function showViewById(id) {
            if (this.currentViewId == id) {
                return;
            }
            var viewsList = this._views,
                item = viewsList.getObjectByAttribute("id", id);
            if (!item) {
                return;
            }
            this.currentViewId = id;
            this.showFile(item.file);
            this.getEventManager().fireEvent(ViewerEvent.ViewChanged, id);
        },
        resize: function resize() {
            this._dwgViewer.windowResize();
        },

        worldToClient: function worldToClient(worldPosition) {
            var viewer = this._dwgViewer,
                maxLevel = this.getMaxLevel(),
                zoomScale = viewer.__zoomScale,
                left = viewer.__viewLeft,
                top = viewer.__viewTop;
            var position = new Glodon.Web.Geometry.Point3d(worldPosition.x * zoomScale / maxLevel - left, worldPosition.y * zoomScale / maxLevel - top, 0);
            return position;
        },

        clientToWorld: function clientToWorld(clientPosition) {
            var viewer = this._dwgViewer,
                maxLevel = viewer.__options.lod.maxLevel,
                zoomScale = viewer.__zoomScale,
                left = viewer.__viewLeft,
                top = viewer.__viewTop;
            var position = new Glodon.Web.Geometry.Point3d((clientPosition.x + left) * maxLevel / zoomScale, (clientPosition.y + top) * maxLevel / zoomScale, 0);
            return position;
        },

        isInViewFrustum: function isInViewFrustum(worldPosition) {
            var viewer = this._dwgViewer,
                viewWidth = viewer.__viewWidth,
                viewHeight = viewer.__viewHeight,
                clientPosition = this.worldToClient(worldPosition);
            if (clientPosition.x > 0 && clientPosition.x < viewWidth && clientPosition.y > 0 && clientPosition.y < viewHeight) {
                return true;
            } else {
                return false;
            }
        },

        getMaxLevel: function getMaxLevel() {
            return this._dwgViewer.__options.lod.maxLevel;
        },

        getCurrentLevel: function getCurrentLevel() {
            return this._dwgViewer.__curLevel;
        },

        getZoomScale: function getZoomScale() {
            return this._dwgViewer.__zoomScale;
        },

        getCurrentState: function getCurrentState() {
            var self = this,
                viewer = self._dwgViewer,
                viewState = {
                viewTop: viewer.__viewTop,
                viewLeft: viewer.__viewLeft,
                level: viewer.__curLevel,
                zoomScale: viewer.__zoomScale,
                viewId: self.currentViewId
            };
            return viewState;
        },

        setState: function setState(viewState) {
            var self = this,
                viewer = self._dwgViewer;
            if (self.currentViewId != viewState.viewId) {
                self.showViewById(viewState.viewId);
            }
            viewer.zoom(viewState.zoomScale);
            viewer.__viewTop = viewState.viewTop;
            viewer.__viewLeft = viewState.viewLeft;
            viewer.__genTiles();
        },
        createSnapshotAsync: function createSnapshotAsync(backgroundColor, callback) {
            var self = this,
                canvas = DomNs.create("canvas", "bf-canvas"),
                ctx = canvas.getContext("2d"),
                dwgViewer = self._dwgViewer,
                viewWidth = dwgViewer.__viewWidth,
                viewHeight = dwgViewer.__viewHeight,
                viewCenterLeft = viewWidth / 2,
                viewCenterTop = viewHeight / 2,
                viewTop = dwgViewer.__viewTop,
                viewLeft = dwgViewer.__viewLeft,
                images = dwgViewer.__images,
                imagesLength = images.length,
                viewUnit = dwgViewer.__unit * dwgViewer.__zoomScale / Math.pow(2, dwgViewer.__curLevel - 1),
                drawImage = function drawImage(item, unit) {
                var img = new Glodon.Web.Graphics.Utility.ImageContainer(item.src).then(function (data) {
                    item.isLoad = true;
                    ctx.drawImage(data, item.left + viewCenterLeft, item.top + viewCenterTop, unit, unit);
                    imagesLength--;
                    isLoaded();
                }, function (error) {
                    item.isLoad = true;
                    imagesLength--;
                    isLoaded();
                });
            },
                isLoaded = function isLoaded() {
                if (imagesLength == 0) {
                    var image = canvas.toDataURL("image/png");
                    callback && callback(image);
                }
            };
            canvas.setAttribute("width", viewWidth);
            canvas.setAttribute("height", viewHeight);
            ctx.rect(0, 0, viewWidth, viewHeight);
            if (backgroundColor instanceof Glodon.Web.Graphics.Color) {
                ctx.fillStyle = backgroundColor.getRGBA();
            } else {
                ctx.fillStyle = "#000";
            }
            ctx.fillRect(0, 0, viewWidth, viewHeight);
            for (var i = 0; i < imagesLength; i++) {

                drawImage(images[i], viewUnit);
            }
        }
    });

    viewNS.Viewer2D = Viewer2D;
})();

(function () {
    var Viewer3DEvent = Object.freeze({
        "ViewAdded": "ViewAdded",
        "ViewLoading": "ViewLoading",
        "Rendered": "Rendered",
        "ComponentsSelectionChanged": "ComponentsSelectionChanged",
        "SelectionChanged": "SelectionChanged",
        "MouseClicked": "MouseClicked",
        "ContextMenu": "ContextMenu",
        "RectSelection": "RectSelection",
        "Error": "Error"
    });

    var viewerNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    viewerNS.Viewer3DEvent = Viewer3DEvent;
})();

(function () {
    var ViewerNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    var Viewer3DConfig = function Viewer3DConfig(options) {
        var orbitButton = Glodon.Bimface.Viewer.OrbitButton;
        var viewOption = Glodon.Bimface.Viewer.ViewOption;
        var defaults = {
            domElement: null,
            APIHost: 'https://api.bimface.com',
            resourceHost: 'https://m.bimface.com',
            initialViewOption: viewOption.Home, // 初始化视角
            homeViewOption: viewOption.Home, // Home视角
            enableViewHouse: true, // 是否开启viewHouse
            minimumFPS: 15, // 渲染帧率
            enableOrbit: true, // 是否可以旋转
            // toolbarVisible: true, // 是否显示工具条
            orbitButton: orbitButton.Left, // 设置鼠标左（右）键旋转，默认左键
            suffix: ".gz",
            loading: true
        };
        var customConfig = Object.assign(defaults, options);
        return customConfig;
    };

    ViewerNS.Viewer3DConfig = Viewer3DConfig;
})();

(function () {
    var IsolateOption = Object.freeze({
        "HideOthers": "HideOthers",
        "MakeOthersTranslucent": "MakeOthersTranslucent"
    });

    var viewerNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    viewerNS.IsolateOption = IsolateOption;
})();

(function () {
    var ViewOption = Object.freeze({
        "Home": "Home",
        "Top": "Top",
        "Bottom": "Bottom",
        "North": "North",
        "South": "South",
        "West": "West",
        "East": "East",
        "SouthEast": "SouthEast",
        "SouthWest": "SouthWest",
        "NorthEast": "NorthEast",
        "NorthWest": "NorthWest"
    });

    var viewerNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    viewerNS.ViewOption = ViewOption;
})();

(function () {
    var ColorOption = Object.freeze({
        "Red": "Red",
        // "Orange": "Orange",
        "Yellow": "Yellow",
        "Green": "Green",
        "Blue": "Blue",
        // "Indigo": "Indigo",
        // "Purple": "Purple",
        "Black": "Black"
    });

    var viewerNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    viewerNS.ColorOption = ColorOption;
})();

(function () {
    var NavigationMode3D = Object.freeze({
        "Fly": "Fly",
        "Orbit": "Orbit",
        "Select": "Select",
        "Zoom": "Zoom",
        "OrbitWithModelCenter": "OrbitWithModelCenter",
        "PickWithRect": "PickWithRect",
        "ZoomWithRect": "ZoomWithRect"
    });

    var viewerNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    viewerNS.NavigationMode3D = NavigationMode3D;
})();

(function () {
    var OpacityOption = Object.freeze({
        "Translucent": "Translucent",
        "Opaque": "Opaque"
    });

    var viewerNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    viewerNS.OpacityOption = OpacityOption;
})();

(function () {
    var OrbitButton = Object.freeze({
        "Left": "Left",
        "Right": "Right"
    });

    var viewerNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    viewerNS.OrbitButton = OrbitButton;
})();

(function () {
    var AxisOption = Object.freeze({
        "X": "X",
        "Y": "Y",
        "Z": "Z"
    });

    var viewerNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    viewerNS.AxisOption = AxisOption;
})();

(function () {
    var SectionBoxMode = Object.freeze({
        "Default": "Default",
        "Rotate": "Rotate"
    });

    var viewerNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    viewerNS.SectionBoxMode = SectionBoxMode;
})();

(function () {
    var Direction = Object.freeze({
        "Up": "Up",
        "Down": "Down",
        "Left": "Left",
        "Right": "Right"
    });

    var viewerNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    viewerNS.Direction = Direction;
})();

(function () {
    var viewNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    var utilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");
    var DomNs = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, 'Web.Lang.Utility.Dom');
    var $ = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, 'Web.Lang.Utility.HttpRequest');
    var APIAndDataNotMatchHint = "The API doesn't support the version of current data.";
    var APIAxisLockHint = "The API supports AxisOption.Z only for now.";
    var SectionBoxLockHint = "Please call enableSectionBox before using this method.";
    var Viewer3D = function Viewer3D(option) {
        viewNS.Viewer.call(this);
        var self = this;
        this._beforeInitialize(option);
        this._opt = option;
        this._colorOverridedMap = {};
        this._colorOverridedList = [];

        var CloudViewer = new CLOUD.Viewer();
        var globalData = CLOUD.GlobalData;
        var isDesktop = Glodon.Web.Lang.Utility.ClientHelper.getIsDesktop();
        if (isDesktop) {
            console.log("client: desktop");
        } else {
            console.log("client: mobile");
        }

        var container = DomNs.create('div', 'bf-view');
        option.domElement.appendChild(container);
        CloudViewer.init(container);
        this.view = {};

        if (CloudViewer.setDeviceMobile) {
            CloudViewer.setDeviceMobile(!isDesktop);
        }

        this.getViewer = function () {
            return CloudViewer;
        };
        this.getDomElement = function () {
            return container;
        };
        this.hookContextMenu(container);
        this.hookCloudViewerEvents();
        this._config(option);
        window.addEventListener("resize", function () {
            self.resize();
        });
    };
    utilityNS.Type.inheritPrototype(Viewer3D, viewNS.Viewer);

    Viewer3D.prototype = Object.assign({}, viewNS.Viewer.prototype, {
        hookContextMenu: function hookContextMenu(domElement) {
            var self = this,
                position = domElement.getBoundingClientRect(),
                startTime,
                endTime;
            domElement.addEventListener("mousedown", function () {
                startTime = new Date().getTime();
            });
            domElement.addEventListener("mouseup", function (e) {
                var e = e || event,
                    contextMenuButton,
                    clientPosition = {
                    x: e.clientX - position.left,
                    y: e.clientY - position.top
                };
                if (e.button == 0) {
                    contextMenuButton = "Right";
                } else {
                    contextMenuButton = "Left";
                }
                endTime = new Date().getTime();
                if (endTime - startTime < 300 && e.button == 2) {
                    if (!self._disableContextMenu) {
                        self.getEventManager().fireEvent(Glodon.Bimface.Viewer.Viewer3DEvent.ContextMenu, self, clientPosition);
                    }
                }
            });
        },
        toggleContextMenuDisplay: function toggleContextMenuDisplay() {
            this._disableContextMenu = !this._disableContextMenu;
        },

        hookCloudViewerEvents: function hookCloudViewerEvents() {
            var self = this,
                _opt = self._opt,
                viewer = this.getViewer(),
                eventManager = this.getEventManager(),
                viewerEvent = Glodon.Bimface.Viewer.Viewer3DEvent,
                loading = DomNs.create("div", "bf-loading"),
                loadingImg = DomNs.create('div', "bf-loading-gif"),
                loadingProgress = DomNs.create('div', "bf-loading-progress"),
                loadingText = DomNs.create('div', "bf-loading-text"),
                isShowUi = false,
                rectSelectionUi = DomNs.create("div", "bf-rect-selcetion"),
                selectionChanged = function selectionChanged(res) {
                var data = null;
                var eventType = res.doubleClick ? "DoubleClick" : "Click";
                var click = res.doubleClick ? 2 : 1;
                if (res.intersectInfo && res.intersectInfo.tag == "Marker3D") {
                    return false;
                }
                if (res.intersectInfo) {
                    data = {
                        objectId: res.intersectInfo.selectedObjectId,
                        fileId: null,
                        elementId: res.intersectInfo.selectedObjectId,
                        boundingBox: res.intersectInfo.worldBoundingBox,
                        // objectData: res.intersectInfo.object.userData,
                        click: click,
                        worldPosition: res.intersectInfo.worldPosition,
                        clientPosition: res.canvasPos,
                        eventType: eventType
                    };
                    if (res.intersectInfo.selectedObjectId && typeof res.intersectInfo.selectedObjectId == "string") {
                        var arr = res.intersectInfo.selectedObjectId.split(".");
                        if (arr.length > 1) {
                            data.elementId = arr[1];
                            data.fileId = arr[0];
                        }
                    }
                } else {
                    data = {
                        screenPosition: res.canvasPos,
                        click: click,
                        eventType: eventType
                    };
                }
                if (res.event.altKey) {
                    console.log(data);
                }
                eventManager.fireEvent(viewerEvent.MouseClicked, data);
                eventManager.fireEvent(viewerEvent.ComponentsSelectionChanged, data);
            },
                rectSelection = function rectSelection(data) {
                if (data.visible) {
                    rectSelectionUi.setCss({
                        left: data.left + "px",
                        top: data.top + "px",
                        width: data.width + "px",
                        height: data.height + "px",
                        opacity: data.dir ? .5 : .1
                    });
                    _opt.domElement.appendChild(rectSelectionUi);
                    isShowUi = true;
                } else {
                    if (isShowUi) {
                        _opt.domElement.removeChild(rectSelectionUi);
                        isShowUi = false;
                    }
                    eventManager.fireEvent(viewerEvent.RectSelection, data);
                }
            };
            loadingProgress.innerText = "0%";
            loadingText.innerText = "正在加载，请稍候...";
            loading.appendChild(loadingImg);
            loading.appendChild(loadingProgress);
            loading.appendChild(loadingText);

            viewer.registerEventListener(CLOUD.EVENTS.ON_LOAD_START, function () {
                if (_opt.loading) {
                    _opt.domElement.appendChild(loading);
                }
            });
            viewer.registerEventListener(CLOUD.EVENTS.ON_LOAD_COMPLETE, function () {
                if (_opt.enableViewHouse) {
                    self.showViewHouse();
                }
                if (_opt.loading) {
                    _opt.domElement.removeChild(loading);
                }
                self.setNavigationMode(Glodon.Bimface.Viewer.NavigationMode3D.PickWithRect);
                viewer.enableTextureMapping(true);
                eventManager.fireEvent(viewerEvent.ViewAdded, self);
            });
            viewer.registerEventListener(CLOUD.EVENTS.ON_LOAD_PROGRESS, function (res) {
                var data = res.progress,
                    progress = Math.round(data.loaded / data.total * 100);
                data.progress = progress;
                loadingProgress.innerText = progress + "%";
                eventManager.fireEvent(viewerEvent.ViewLoading, data);
            });
            viewer.registerEventListener(CLOUD.EVENTS.ON_LOAD_EMPTY_SCENE, function () {
                if (_opt.loading) {
                    _opt.domElement.removeChild(loading);
                }
                eventManager.fireEvent(viewerEvent.Error, {
                    code: 'EmptyData',
                    message: 'this view is empty.'
                });
            });
            viewer.registerEventListener(CLOUD.EVENTS.ON_EDITOR_UPDATEUI, function (res) {
                // console.log(res)
                rectSelection(res.data);
            });
            viewer.registerEventListener(CLOUD.EVENTS.ON_EDITOR_BEGIN, function () {
                // console.log('begin')
            });
            viewer.registerEventListener(CLOUD.EVENTS.ON_EDITOR_END, function () {
                // console.log('end')
            });
            viewer.registerEventListener(CLOUD.EVENTS.ON_CLICK_PICK, function (res) {
                selectionChanged(res);
            });
            viewer.registerEventListener(CLOUD.EVENTS.ON_SELECTION_CHANGED, function (res) {
                eventManager.fireEvent(Glodon.Bimface.Viewer.Viewer3DEvent.SelectionChanged, res.selectionList);
            });
            viewer.addCallbacks("render", function () {
                eventManager.fireEvent(Glodon.Bimface.Viewer.Viewer3DEvent.Rendered);
            });
        },
        render: function render() {
            var viewer = this.getViewer();
            viewer.render();
        },
        enableOrbit: function enableOrbit(isEnabled) {
            // 禁止旋转
            this.getViewer().cameraControl.noRotate = isEnabled == undefined ? false : !isEnabled;
        },

        setMinimumFPS: function setMinimumFPS(num) {
            // 设置帧率
            if (typeof num != 'number') return false;
            num = num > 60 ? 60 : num < 4 ? 4 : num;
            this.getViewer().limitFrameRate(num);
        },

        exitWalk: function exitWalk() {
            //var viewer = this.getViewer(),
            var walkBtn = document.querySelector('.gld-bf-firstperson.bf-checked');
            if (walkBtn) {
                walkBtn.click();
            }
        },

        setView: function setView(view) {
            var viewMap = {
                "Home": 0,
                "Top": 1,
                "Bottom": 2,
                "North": 3,
                "South": 4,
                "West": 5,
                "East": 6,
                "SouthEast": 7,
                "SouthWest": 8,
                "NorthEast": 9,
                "NorthWest": 10
            };
            this.exitWalk();
            var viewer = this.getViewer();
            viewer.editorManager.setStandardView(viewMap[view], viewer);
        },

        showAllComponents: function showAllComponents() {
            // Clear hide condition·
            var viewer = this.getViewer();
            var filters = viewer.getFilters();
            filters.clear();
            // viewer.recalculationPlanes();
        },

        zoomToSelectedComponents: function zoomToSelectedComponents() {
            // 缩放到选择构件
            this.getViewer().zoomToSelection();
        },

        zoomToBoundingBox: function zoomToBoundingBox(box) {
            // 缩放到指定盒子大小
            if (!box || !box.min || !box.max) return;
            var boundingBox = [[box.min.x, box.min.y, box.min.z], [box.max.x, box.max.y, box.max.z]];
            this.getViewer().zoomToBBox(CLOUD.Utils.computeBBox(boundingBox), -0.5);
        },

        setNavigationMode: function setNavigationMode(NavigationMode) {
            var isDeprecatedEngine = this._adapter.isDeprecatedEngine();
            var viewer = this.getViewer();
            if (!isDeprecatedEngine) {
                switch (NavigationMode) {
                    case "Fly":
                        viewer.setEditorMode('fly');
                        break;
                    case "Orbit":
                        viewer.setEditorMode('orbit');
                        break;
                    case "Select":
                        viewer.setEditorMode('pick');
                        viewer.setPointRotateMode(CLOUD.PointRotateMode.SELECTION);
                        break;
                    case "Zoom":
                        viewer.setEditorMode('zoom');
                        break;
                    case "OrbitWithModelCenter":
                        viewer.setEditorMode('pick');
                        viewer.setPointRotateMode(CLOUD.PointRotateMode.CENTER);
                        break;
                    case "PickWithRect":
                        viewer.setEditorMode('pickByRect');
                        viewer.setPointRotateMode(CLOUD.PointRotateMode.SELECTION);
                        break;
                    case "ZoomWithRect":
                        viewer.setEditorMode('zoomByRect');
                        viewer.setPointRotateMode(CLOUD.PointRotateMode.SELECTION);
                        break;
                }
            } else {
                switch (NavigationMode) {
                    case "Fly":
                        viewer.setFlyMode();
                        break;
                    case "Orbit":
                        viewer.setOrbitMode();
                        break;
                    case "Select":
                        viewer.setPickMode(true);
                        break;
                    case "Zoom":
                        viewer.setZoomMode();
                        break;
                    default:
                        console.log(APIAndDataNotMatchHint);
                        break;
                }
            }
        },

        setOrbitButton: function setOrbitButton(orbitButton) {
            var orbitButtonMap = {
                "Left": 'left',
                "Right": 'right'
            };
            this._opt.orbitButton = orbitButton;
            this.getViewer().setOrbitButton(orbitButtonMap[orbitButton]);
        },

        setUseLeftHandedInput: function setUseLeftHandedInput(bool) {

            this._opt.leftHandedMouseSetup = bool;
            this.getViewer().setOrbitButton(bool && 'left' || 'right');
        },

        getUseLeftHandedInput: function getUseLeftHandedInput() {
            if (this._opt.leftHandedMouseSetup === undefined) {
                return true;
            } else {
                return this._opt.leftHandedMouseSetup;
            }
        },
        setReverseWheelDirection: function setReverseWheelDirection(value) {

            this.getViewer().setReverseWheelDirection(value);
        },

        enableHover: function enableHover(value) {

            this.getViewer().enableHover(value);
        },

        isolateComponentsByObjectData: function isolateComponentsByObjectData(conditions, state) {
            // 显示符合条件的构件
            var self = this;
            var viewer = self.getViewer();
            var filter = viewer.getFilters();
            var engineAdapter = self._adapter;
            var isolateOption = engineAdapter.getIsolateOptionValue(state);
            var isDeprecatedEngine = this._adapter.isDeprecatedEngine();
            if (!isDeprecatedEngine) {
                var map = {
                    MakeOthersTranslucent: 3,
                    HideOthers: 1
                };
                filter.clearAllIsolateConditions();
                if (conditions) {
                    filter.setIsolateConditions(conditions, map[state]);
                }
            } else {
                filter.setIsolateCondition(conditions);
                viewer.recalculationPlanes();
                filter.enableSceneOverrider(isolateOption);
            }
        },

        isolateComponentsById: function isolateComponentsById(ids, state) {
            // 显示指定的构件
            var viewer = this.getViewer();
            var filter = viewer.getFilters();
            var engineAdapter = this._adapter;
            var isolateOption = engineAdapter.getIsolateOptionValue(state);
            var isDeprecatedEngine = this._adapter.isDeprecatedEngine();
            if (!isDeprecatedEngine) {
                filter.clearAllIsolateList();
                filter.addToIsolateList(isolateOption, ids);
            } else {
                filters.setIsolateByUserIds(ids);
                viewer.recalculationPlanes();
                filters.enableSceneOverrider(isolateOption);
            }
        },

        clearIsolation: function clearIsolation() {
            // 取消隔离
            var viewer = this.getViewer();
            var filter = viewer.getFilters();
            var isDeprecatedEngine = this._adapter.isDeprecatedEngine();
            if (!isDeprecatedEngine) {
                filter.clearAllIsolateConditions();
                filter.clearAllIsolateList();
            } else {
                filter.setIsolateCondition();
                filter.enableSceneOverrider(0);
            }
            // viewer.recalculationPlanes();
        },

        hideComponents: function hideComponents(arr) {
            // hide components
            this.getViewer().getFilters().addToIdList(CLOUD.EnumIdBasedType.HIDDEN, arr);
        },

        showComponents: function showComponents(arr) {
            // show all components
            this.getViewer().getFilters().removeFromIdList(CLOUD.EnumIdBasedType.HIDDEN, arr);
        },

        showExclusiveComponentsByObjectData: function showExclusiveComponentsByObjectData(conditions) {
            var viewer = this.getViewer();
            var filter = viewer.getFilters();
            var isDeprecatedEngine = this._adapter.isDeprecatedEngine();
            if (!isDeprecatedEngine) {
                filter.clearAllConditions();
                if (conditions && conditions.length == 0) {
                    filter.hideScene();
                } else {
                    filter.showScene();
                    filter.setConditions(0, conditions);
                }
            } else {
                filter.setVisibleConditions(conditions);
            }
        },

        getCameraStatus: function getCameraStatus() {
            // get camera infomation
            return JSON.parse(this.getViewer().getCamera());
        },

        setCameraStatus: function setCameraStatus(camera) {
            // set camera position
            if ((typeof camera === "undefined" ? "undefined" : _typeof(camera)) == 'object') {
                camera = JSON.stringify(camera);
            }
            this.exitWalk();
            this.getViewer().setCamera(camera);
        },

        highlightComponentsById: function highlightComponentsById(ids, color, name) {
            if (!name) return false;
            var filter = this.getViewer().getFilters();
            var colorMap = {
                "Red": "red",
                "Orange": "beforeEdit",
                "Yellow": "yellow",
                "Green": "green",
                "Blue": "blue",
                "Black": "black"
            };
            filter.setOverriderByUserIds(name, ids, colorMap[color]);
        },

        highlightComponentsByObjectData: function highlightComponentsByObjectData(objectData, color) {
            var filter = this.getViewer().getFilters();
            var colorMap = {
                "Red": "red",
                "Orange": "beforeEdit",
                "Yellow": "yellow",
                "Green": "green",
                "Blue": "blue",
                "Black": "black "
            };
            var conditions = [];
            for (var i = 0, len = objectData.length; i < len; i++) {
                conditions.push({
                    condition: objectData[i],
                    material: colorMap[color]
                });
            }
            filter.setConditionOverrider(conditions);
        },

        setComponentsOpacity: function setComponentsOpacity(ids, opacity) {
            // 半透明指定构件
            var isDeprecatedEngine = this._adapter.isDeprecatedEngine();
            if (!isDeprecatedEngine) {
                var filter = this.getViewer().getFilters();
                if (opacity == 'Translucent') {
                    filter.makeTranslucentByIds(ids);
                } else if (opacity == 'Opaque') {
                    filter.removeFromIdList(CLOUD.EnumIdBasedType.TRANSLUCENT, ids);
                }
            } else {
                console.log(APIAndDataNotMatchHint);
            }
        },

        loadViewCore: function loadViewCore(data) {
            if (this._data && this._data.renderVersion != data.renderVersion) {
                console.log("this model can not be added.");
                return false;
            }
            var self = this,
                viewer = self.getViewer(),
                _opt = self._opt,
                engineAdapter = self._engineAdapter(data.renderVersion),
                databagResource = _opt.databagResource || "/" + data.databagId + "/resource/v3/model";

            viewer.load(databagResource, _opt.resourceHost);
            self._adapter = engineAdapter;
            if (data.isSupportFamilyTypeList) {
                var config = new Glodon.Bimface.Data.FamilyDataManagerConfig();
                config.databagId = data.databagId;
                config.resourceHost = self._opt.resourceHost;
                var familyDataManager = new Glodon.Bimface.Data.FamilyDataManager(config);
                familyDataManager.getFamilyTypes(function (res) {
                    self._data.familyTypes = res;
                });
            }
            self.view[data.viewToken] = databagResource;
        },

        addModel: function addModel(data) {
            if (this._data && this._data.renderVersion != data.renderVersion) {
                console.log("this model can not be added.");
                return false;
            }
            var self = this,
                viewer = self.getViewer(),
                _opt = self._opt,
                engineAdapter = self._engineAdapter(data.renderVersion),
                databagResource = "./" + data.databagId + "/resource/v3/model";
            CLOUD.GlobalData.ZipResourcePostfix = "";
            data.dataEnvType = "Local";
            self._data = data;
            viewer.load(databagResource, "");
            self._adapter = engineAdapter;
            if (data.isSupportFamilyTypeList) {
                var config = new Glodon.Bimface.Data.FamilyDataManagerConfig();
                config.databagId = data.databagId;
                config.resourceHost = self._opt.resourceHost;
                var familyDataManager = new Glodon.Bimface.Data.FamilyDataManager(config);
                familyDataManager.getFamilyTypes(function (res) {
                    self._data.familyTypes = res;
                });
            }
            self.view[data.viewToken] = databagResource;
        },

        removeView: function removeView(viewToken) {
            var viewer = this.getViewer();
            var databagResource = this.view[viewToken];
            viewer.unload(databagResource);
            delete this.view[viewToken];
        },

        showView: function showView(viewToken) {
            var viewer = this.getViewer();
            var clients = viewer.modelManager.models;
            var databagResource = this.view[viewToken];
            if (databagResource && clients[databagResource]) {
                viewer.showScene(clients[databagResource]);
            }
        },

        hideView: function hideView(viewToken) {
            var viewer = this.getViewer();
            var clients = viewer.modelManager.models;
            var databagResource = this.view[viewToken];
            if (databagResource && clients[databagResource]) {
                viewer.showScene(clients[databagResource], false);
            }
        },

        getSelectedComponents: function getSelectedComponents() {
            // 获取选择构件集合
            var filter = this.getViewer().getFilters();
            return filter._filterImpl._getSelected();
        },

        setSelectedComponentsById: function setSelectedComponentsById(ids) {
            // 设置构件选择集合
            this.getViewer().setSelection(ids);
        },

        addSelectedComponentsById: function addSelectedComponentsById(ids) {
            // 往构件选择集合添加构件
            this.getViewer().addToSelection(ids);
        },

        removeSelectedId: function removeSelectedId(ids) {
            // 从构件选择集合删除构件
            this.getViewer().removeFromSelection(ids);
        },

        resize: function resize(width, height) {
            // 设置场景大小
            var domElement = this._opt.domElement,
                _width = width || domElement.clientWidth,
                _height = height || domElement.clientHeight;
            this.getViewer().resize(_width, _height);
        },

        setBackgroundColor: function setBackgroundColor(color) {
            // 设置模型区域背景颜色
            var Color = Glodon.Web.Graphics.Color,
                colorMap = {
                "Black": new Color(0, 0, 0, 1),
                "Blue": new Color(0, 0, 189, 1),
                "Green": new Color(0, 255, 0, 1),
                "Red": new Color(255, 0, 0, 1),
                "Yellow": new Color(250, 189, 5, 1)
            },
                bimBox = this._opt.domElement;
            if (typeof color === "string") {
                color = bimBox.style.backgroundColor = colorMap[color];
            }
            bimBox.style.backgroundColor = color.getRGBA();
        },

        getCurrentState: function getCurrentState() {
            var state = this.getViewer().getFilters().saveState();
            var camera = this.getCameraStatus();
            return {
                state: state,
                camera: camera
            };
        },

        setState: function setState(state) {
            var camera = state.camera;
            var viewer = this.getViewer();
            this.setCameraStatus(camera);
            viewer.getFilters().loadState(state.state);
            // viewer.recalculationPlanes();
        },

        createSnapshot: function createSnapshot(backgroundColor) {
            // 获取当前模型快照
            console.warn("This function is deprecated. Please use createSnapshotAsync instead.");
            return this.getViewer().canvas2image(backgroundColor);
        },

        createSnapshotAsync: function createSnapshotAsync(backgroundColor, callback) {
            // 获取当前模型快照
            var self = this;
            var viewer = self.getViewer();
            var isDeprecatedEngine = self._adapter.isDeprecatedEngine();
            if (isDeprecatedEngine) {
                var img = viewer.getRenderBufferScreenShot(backgroundColor.getRGBA());
                callback && callback(img);
                self.render();
            } else {
                viewer.getRenderBufferScreenShot(backgroundColor.getRGBA(), function (img) {
                    callback && callback(img);
                    self.render();
                });
            }
        },

        section: function section() {
            var self = this,
                viewer = this.getViewer(),
                scene = viewer.getScene(),
                ClipPlanes = scene.getClipPlanes();
            if (!self._section) {
                viewer.setClipPlanesMode();
                var clipPlanesEditor = viewer.editorManager.editors.clipByBox;
                ClipPlanes.enable(true, true);
                clipPlanesEditor.enablePick = false;
                self._section = {
                    visible: function visible(enable) {
                        ClipPlanes.visible = enable;
                        clipPlanesEditor.enablePick = !enable;
                    },
                    enableRotation: function enableRotation(enable) {
                        ClipPlanes.rotatable = enable;
                    },
                    enable: function enable(_enable) {
                        ClipPlanes.enable(_enable, _enable);
                        _enable ? viewer.setClipPlanesMode() : self.setNavigationMode(Glodon.Bimface.Viewer.NavigationMode3D.PickWithRect);
                    },
                    reset: function reset() {
                        ClipPlanes.rotatable = false;
                        ClipPlanes.visible = true;
                        clipPlanesEditor.enablePick = false;
                        ClipPlanes.reset();
                    },
                    close: function close() {
                        ClipPlanes.enable(false, false);
                        self.setNavigationMode(Glodon.Bimface.Viewer.NavigationMode3D.PickWithRect);
                        self._section = null;
                    },
                    save: function save() {
                        return ClipPlanes.store();
                    },
                    load: function load(obj) {
                        if (!obj) {
                            ClipPlanes.reset();
                        } else {
                            ClipPlanes.restore(obj);
                        }
                        ClipPlanes.restore(obj);
                    }
                };
            }
            return self._section;
        },

        enableSectionBox: function enableSectionBox() {
            var self = this,
                viewer = this.getViewer(),
                clipPlanes = viewer.getScene().getClipPlanes();
            clipPlanes.enable(true, true);
            viewer.setClipPlanesMode();
            self._isSection = true;
        },

        disableSectionBox: function disableSectionBox() {
            var self = this,
                viewer = this.getViewer(),
                clipPlanes = viewer.getScene().getClipPlanes();
            clipPlanes.enable(false, false);
            self.setNavigationMode(Glodon.Bimface.Viewer.NavigationMode3D.PickWithRect);
            self._isSection = false;
        },
        resetSectionBox: function resetSectionBox() {
            if (!this._isSection) {
                console.log(SectionBoxLockHint);
                return;
            }
            var self = this,
                viewer = this.getViewer(),
                clipPlanes = viewer.getScene().getClipPlanes(),
                clipPlanesEditor = viewer.editorManager.editors.clipByBox;
            clipPlanes.rotatable = false;
            clipPlanes.visible = true;
            clipPlanesEditor.enablePick = false;
            clipPlanes.reset();
        },
        setSectionBoxMode: function setSectionBoxMode(sectionBoxMode) {
            if (!this._isSection) {
                console.log(SectionBoxLockHint);
                return;
            }
            var self = this,
                viewer = this.getViewer(),
                clipPlanes = viewer.getScene().getClipPlanes();
            if (sectionBoxMode == "Rotate") {
                clipPlanes.rotatable = true;
            } else {
                clipPlanes.rotatable = false;
            }
        },
        showSectionBox: function showSectionBox() {
            if (!this._isSection) {
                console.log(SectionBoxLockHint);
                return;
            }
            var self = this,
                viewer = this.getViewer(),
                clipPlanes = viewer.getScene().getClipPlanes(),
                clipPlanesEditor = viewer.editorManager.editors.clipByBox;
            clipPlanes.visible = true;
            clipPlanesEditor.enablePick = false;
        },
        hideSectionBox: function hideSectionBox() {
            if (!this._isSection) {
                console.log(SectionBoxLockHint);
                return;
            }
            var self = this,
                viewer = this.getViewer(),
                clipPlanes = viewer.getScene().getClipPlanes(),
                clipPlanesEditor = viewer.editorManager.editors.clipByBox;
            clipPlanes.visible = false;
            clipPlanesEditor.enablePick = true;
        },
        getSectionBoxState: function getSectionBoxState() {
            if (!this._isSection) {
                console.log(SectionBoxLockHint);
                return;
            }
            var self = this,
                viewer = this.getViewer(),
                clipPlanes = viewer.getScene().getClipPlanes();
            return clipPlanes.store();
        },
        setSectionBoxState: function setSectionBoxState(sectionBoxState) {
            var self = this,
                viewer = this.getViewer(),
                clipPlanes = viewer.getScene().getClipPlanes();
            if (sectionBoxState) {
                clipPlanes.restore(sectionBoxState);
            }
        },

        getFamilyTypes: function getFamilyTypes() {
            var self = this;
            var types = this._data.familyTypes;
            if (types) {
                return types;
            } else {
                return false;
            }
        },

        showFamilyTypeById: function showFamilyTypeById(id) {
            var isolateOption = Glodon.Bimface.Viewer.IsolateOption;
            this.isolateComponentsByObjectData([{
                "typeId": id
            }], isolateOption.HideOthers);
        },

        getModelTree: function getModelTree(callback) {
            if (!this._MetaDataManager) {
                var dataNS = Glodon.Bimface.Data;
                var config = new dataNS.MetaDataManagerConfig();
                var data = this._data;
                config.APIHost = this._opt.APIHost;
                config.viewToken = data.viewToken;
                config.databagId = data.databagId;
                config.modelId = data.modelId;
                config.modelType = data.modelType;
                config.dataEnvType = data.dataEnvType;
                this._MetaDataManager = new dataNS.MetaDataManager(config);
            }
            this._MetaDataManager.getModelTree(callback);
        },

        getModeTree: function getModeTree(callback) {
            console.warn("This function is deprecated. Please use getModelTree instead.");
            this.getModelTree(callback);
        },

        getComponentProperty: function getComponentProperty(elementId, callback) {
            if (!this._MetaDataManager) {
                var dataNS = Glodon.Bimface.Data;
                var config = new dataNS.MetaDataManagerConfig();
                var data = this._data;
                config.APIHost = this._opt.APIHost;
                config.viewToken = data.viewToken;
                config.databagId = data.databagId;
                config.modelId = data.modelId;
                config.modelType = data.modelType;
                config.dataEnvType = data.dataEnvType;
                this._MetaDataManager = new dataNS.MetaDataManager(config);
            }
            this._MetaDataManager.getComponentProperty(elementId, callback);
        },

        showViewHouse: function showViewHouse() {
            var self = this;
            if (self._viewHouse) {
                self._viewHouse.enableViewHouse(true);
            } else {
                var _opt = self._opt,
                    config = Glodon.Bimface.Plugins.ViewHouseConfig();
                config.domElement = _opt.domElement;
                config.viewer = self;
                self._viewHouse = new Glodon.Bimface.Plugins.ViewHouse(config);
            }
        },

        hideViewHouse: function hideViewHouse() {
            if (this._viewHouse) {
                this._viewHouse.enableViewHouse(false);
            }
        },

        startAutoRotate: function startAutoRotate(speed) {
            var self = this;
            var viewer = this.getViewer();
            var cameraControl = self._adapter.getCameraControl(viewer);
            if (cameraControl == null) {
                console.log('Auto-rotate is not supported.');
                return;
            }
            cameraControl.autoRotateSpeed = speed;
            if (speed == 0) {
                self.stopAutoRotate();
                return;
            }
            if (self._animationFrameHandle) {
                self.stopAutoRotate();
            }
            animation();

            function animation() {
                cameraControl.rotateLeft();
                cameraControl.updateAuto();
                self._animationFrameHandle = requestAnimationFrame(animation);
            }
        },

        stopAutoRotate: function stopAutoRotate() {
            this._animationFrameHandle && cancelAnimationFrame(this._animationFrameHandle);
        },

        overrideComponentsColorById: function overrideComponentsColorById(ids, color) {
            var filter = this.getViewer().getFilters();
            var isDeprecatedEngine = this._adapter.isDeprecatedEngine();
            if (!isDeprecatedEngine) {
                var map = this._colorOverridedMap;
                var list = this._colorOverridedList;
                var colorName = color.getHEX() + (color.getAlpha() * 100).toString(16);
                for (var i = 0, len = ids.length; i < len; i++) {
                    var item = ids[i];
                    var obj = list.getObjectByAttribute("id", item);
                    if (obj) {
                        var mapList = map[obj.color];
                        mapList && mapList.removeByValue(item);
                        filter.removeFromOverrideList(obj.color, [item]);
                        obj.color = colorName;
                    } else {
                        list.push({
                            id: item,
                            color: colorName
                        });
                    }
                }
                if (!map[colorName]) {
                    map[colorName] = [];
                }
                map[colorName] = map[colorName].concat(ids);
                map[colorName] = Array.from(new Set(map[colorName]));
                filter.setOverrideListByColor(colorName, map[colorName], {
                    color: parseInt(color.getHEX(), 16),
                    opacity: color.getAlpha()
                });
            } else {
                console.log(APIAndDataNotMatchHint);
            }
        },

        restoreComponentsColorById: function restoreComponentsColorById(ids) {
            var filter = this.getViewer().getFilters();
            var isDeprecatedEngine = this._adapter.isDeprecatedEngine();
            if (!isDeprecatedEngine) {
                var map = this._colorOverridedMap;
                var list = this._colorOverridedList;
                for (var i = 0, len = ids.length; i < len; i++) {
                    var item = ids[i];
                    var obj = list.getObjectByAttribute("id", item);
                    if (obj) {
                        var mapList = map[obj.color];
                        mapList && mapList.removeByValue(item);
                        filter.removeFromOverrideList(obj.color, [item]);
                        list.removeObjectByAttribute("id", item);
                    }
                }
            } else {
                console.log(APIAndDataNotMatchHint);
            }
        },

        overrideComponentsColorByObjectData: function overrideComponentsColorByObjectData(conditions, color) {
            var filter = this.getViewer().getFilters();
            var isDeprecatedEngine = this._adapter.isDeprecatedEngine();
            var overrideConditions = [];
            var colorName = color.getHEX() + (color.getAlpha() * 100).toString(16);
            if (!isDeprecatedEngine) {
                for (var i = 0, len = conditions.length; i < len; i++) {
                    overrideConditions.push({
                        condition: conditions[i],
                        color: {
                            color: parseInt(color.getHEX(), 16),
                            opacity: color.getAlpha()
                        }
                    });
                }
                filter.setConditions(2, overrideConditions);
            } else {
                console.log(APIAndDataNotMatchHint);
            }
        },

        restoreComponentsColorByObjectData: function restoreComponentsColorByObjectData() {
            var filter = this.getViewer().getFilters();
            var isDeprecatedEngine = this._adapter.isDeprecatedEngine();
            if (!isDeprecatedEngine) {
                filter.clearConditions(2);
            } else {
                console.log(APIAndDataNotMatchHint);
            }
        },

        disableComponentsSelectionById: function disableComponentsSelectionById(ids) {
            var filter = this.getViewer().getFilters();
            filter.addToFrozenList(ids);
        },

        enableComponentsSelectionById: function enableComponentsSelectionById(ids) {
            var filter = this.getViewer().getFilters();
            filter.removeFromFrozenList(ids);
        },

        isIsolate: function isIsolate() {
            return this.getViewer().getFilters().isIsolate();
        },

        isFiltering: function isFiltering() {
            return this.getViewer().getFilters().isFiltering();
        },

        worldToClient: function worldToClient(worldPosition) {
            return this.getViewer().worldToCanvas(worldPosition);
        },

        clientToWorld: function clientToWorld(clientPosition) {
            return this.getViewer().canvasToWorld(clientPosition);
        },

        hitTest: function hitTest(clientPosition, callback) {
            var viewer = this.getViewer();
            viewer.pickByPointWithNormal(clientPosition, function (intersects) {
                if (intersects) {
                    var intersectInfo = intersects[0];
                    var data = {
                        objectId: intersectInfo.userId,
                        boundingBox: intersectInfo.worldBoundingBox,
                        worldPosition: intersectInfo.worldPosition,
                        clientPosition: clientPosition
                    };
                    callback && callback(data);
                }
            });
        },

        isInViewFrustum: function isInViewFrustum(worldPosition) {
            return this.getViewer().insideCamera(worldPosition);
        },

        lockAxis: function lockAxis(axis) {
            if (axis != "Z") {
                console.warn(APIAxisLockHint);
                return;
            }
            var viewer = this.getViewer();
            viewer.lockAxisZ(true);
        },

        unlockAxis: function unlockAxis(axis) {
            if (axis != "Z") {
                console.warn(APIAxisLockHint);
                return;
            }
            var viewer = this.getViewer();
            viewer.lockAxisZ(false);
        },

        enableMouseHoverHighlight: function enableMouseHoverHighlight() {
            this.getViewer().enableHover(true);
        },

        disableMouseHoverHighlight: function disableMouseHoverHighlight() {
            this.getViewer().enableHover(false);
        },

        setOverallLightIntensity: function setOverallLightIntensity(num) {
            this.getViewer().setLightIntensityFactor(num);
        },

        getOverallLightIntensity: function getOverallLightIntensity(num) {
            return CLOUD.GlobalData.LightIntensityFactor;
        },

        moveTo: function moveTo(direction) {
            var moveDirection = CLOUD.MoveDirection;
            var moveDirection = {
                "Up": CLOUD.MoveDirection.UP,
                "Down": CLOUD.MoveDirection.DOWN,
                "Left": CLOUD.MoveDirection.LEFT,
                "Right": CLOUD.MoveDirection.RIGHT,
                "Forward": CLOUD.MoveDirection.FORWARD,
                "Back": CLOUD.MoveDirection.BACK
            };
            this.getViewer().moveTo(moveDirection[direction]);
        },

        getInformation: function getInformation() {
            var viewer = this.getViewer();
            var elements = viewer.getNumOfElements();
            var renderables = viewer.getNumOfRenderables();
            var triangles = viewer.getNumOfTriangles();
            return {
                elements: elements,
                renderables: renderables,
                triangles: triangles
            };
        },

        _beforeInitialize: function _beforeInitialize(config) {
            CLOUD.GlobalData.LimitFrameTime = 1000 / config.minimumFPS;
            CLOUD.GlobalData.EnableDemolishByDClick = false;
            CLOUD.GlobalData.DisableRotation = config.rotation;
            // CLOUD.GlobalData.LightOptions = CLOUD.EnumLightOptions.AdvandceLighting;
            CLOUD.GlobalData.UseMpkWorker = false;
            CLOUD.GlobalData.ZipResourcePostfix = config.suffix;
            CLOUD.GlobalData.LightIntensityFactor = 1.2;
        },
        _config: function _config(config) {
            var viewer = this.getViewer();
            var orbitButtonMap = {
                "Left": 'left',
                "Right": 'right'

            };
            var viewMap = {
                "Home": 0,
                "Top": 1,
                "Bottom": 2,
                "North": 3,
                "South": 4,
                "West": 5,
                "East": 6,
                "SouthEast": 7,
                "SouthWest": 8,
                "NorthEast": 9,
                "NorthWest": 10
            };
            try {
                viewer.setInitialView(viewMap[config.initialViewOption]);
                viewer.setHomeView(viewMap[config.homeViewOption]);
            } catch (e) {
                viewer.setInitialViewType(config.initialViewOption);
                viewer.setHomeViewType(config.homeViewOption);
            }
            viewer.setOrbitButton(orbitButtonMap[config.orbitButton]);
        },

        _engineAdapter: function _engineAdapter(engineType) {
            var engineAdapter = {
                getIsolateOptionValue: function getIsolateOptionValue(option) {
                    var map = {
                        MakeOthersTranslucent: 3,
                        HideOthers: 1
                    };
                    return map[option];
                },
                getDataBagResource: function getDataBagResource() {
                    return '/resource/v3/model';
                },
                getCameraControl: function getCameraControl(viewer) {
                    return viewer.cameraControl;
                },
                setIsolateConditions: function setIsolateConditions() {
                    return "setConditions";
                },
                isDeprecatedEngine: function isDeprecatedEngine() {
                    return false;
                }
            };
            var deprecatedEngineAdapter = {
                getIsolateOptionValue: function getIsolateOptionValue(option) {
                    var map = {
                        MakeOthersTranslucent: 1,
                        HideOthers: 2
                    };
                    return map[option];
                },
                getDataBagResource: function getDataBagResource() {
                    return '/resource/model';
                },
                getCameraControl: function getCameraControl(viewer) {
                    return null;
                },
                setIsolateConditions: function setIsolateConditions() {
                    return "setIsolateCondition";
                },
                isDeprecatedEngine: function isDeprecatedEngine() {
                    return true;
                }
            };
            if (engineType == "1.0") {
                return deprecatedEngineAdapter;
            } else {
                return engineAdapter;
            }
        }

    });

    viewNS.Viewer3D = Viewer3D;
})();

(function () {
    var PluginsNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins");
    var MiniMapConfig = function MiniMapConfig() {
        return {
            name: 'defaultMap',
            domElement: null,
            width: 240,
            height: 240,
            viewer: null,
            axis: false,
            host: 'https://m.bimface.com',
            onCameraChanged: null,
            inMoveOnAxisGrid: null
        };
    };

    PluginsNS.MiniMapConfig = MiniMapConfig;
})();

(function () {
    var PluginsNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var $ = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.HttpRequest");

    var MiniMap = function MiniMap(options) {
        var self = this,
            _opt = options;
        self._opt = _opt;
        if (!_opt.domElement) {
            console.log("domElement must be empty.");
            return false;
        }
        if (!_opt.viewer) {
            console.log("viewer is not defined.");
            return false;
        }
        var viewer = _opt.viewer.getViewer();
        self._helper = new CLOUD.Extensions.MiniMapHelper(_opt.viewer.getViewer());
        var renderCB = function renderCB() {
            self._helper.renderMiniMap();
        };
        viewer.addCallbacks("render", renderCB);
        self.init();
    };

    MiniMap.prototype = {
        init: function init() {
            var self = this,
                _opt = self._opt,
                axisGrid = {},
                floors = [],
                helper = self._helper;

            $.ajax({
                url: _opt.host + "/" + _opt.viewer._data.databagId + "/metadata/grids.json",
                async: false,
                success: function success(res) {
                    var Grids = JSON.parse(res);
                    var arr = [];
                    for (var i = 0, len = Grids.grids.length; i < len; i++) {
                        var item = Grids.grids[i];
                        item.start.X = item.start.x;
                        item.start.Y = item.start.y;
                        item.start.Z = item.start.z;
                        item.end.X = item.end.x;
                        item.end.Y = item.end.y;
                        item.end.Z = item.end.z;
                        arr.push(item);
                    }
                    axisGrid.Grids = arr;
                }
            });
            $.ajax({
                async: false,
                url: _opt.host + "/" + _opt.viewer._data.databagId + "/metadata/levels.json",
                success: function success(res) {
                    axisGrid.Levels = JSON.parse(res).levels;
                }
            });
            $.ajax({
                async: false,
                url: _opt.host + "/" + _opt.viewer._data.databagId + "/resource/model/maps/output.json",
                dataType: "text",
                success: function success(res) {
                    var data = JSON.parse(res);
                    for (var key in data) {
                        var obj = data[key];
                        obj.path = _opt.host + "/" + _opt.viewer._data.databagId + "/resource/model/maps/" + key + ".png";
                        obj.id = key;
                        obj.name = key;
                        floors.push(obj);
                    }
                }
            });
            if (axisGrid.Grids && axisGrid.Levels) {
                helper.setAxisGridData(axisGrid);
            } else {
                _opt.domElement.innerHTML = '<p class="bf-message">axis grids not found.</p>';
                return false;
            }
            if (floors.length > 0) {
                helper.setFloorPlaneData(floors[0]);
            }
            self._floors = floors;
            self.createMap();
        },
        createMap: function createMap(axisGrid, floors) {
            var helper = this._helper,
                _opt = this._opt,
                map,
                style = {
                left: 0,
                bottom: 0,
                outling: "none",
                position: "relative"
            };
            helper.createMiniMap(_opt.name, _opt.domElement, _opt.width, _opt.height, style, _opt.onCameraChanged, _opt.inMoveOnAxisGrid);
            helper.generateAxisGrid(_opt.name);
            helper.generateFloorPlane(_opt.name, false);
            helper.showAxisGrid(_opt.name, _opt.axis);
            map = helper.getMiniMap(_opt.name);
            map.setMapClickCallback(function () {});
        },
        getFloors: function getFloors() {
            return this._floors;
        },

        showAxisGrid: function showAxisGrid() {
            var helper = this._helper;
            helper.showAxisGrid(this._opt.name, true);
        },

        hideAxisGrid: function hideAxisGrid() {
            var helper = this._helper;
            helper.showAxisGrid(this._opt.name, false);
        },

        showFloorById: function showFloorById(id) {
            var self = this,
                name = self._opt.name,
                floors = self._floors,
                obj = floors.getObjectByAttribute("name", id);
            self._helper.setFloorPlaneData(obj);
            self._helper.generateFloorPlane(name, true);
        },

        resize: function resize(width, height) {
            this._helper.resize(this._opt.name, width, height);
        },

        /**
         * 小地图点击事件
         * @param {string} mode
         * @param {function} callback
         */
        onClick: function onClick(mode, callback) {
            var self = this,
                opt = self._opt,
                mode = mode || "default";
            var map = self._helper.getMiniMap(opt.name);
            map.setMapClickMode(mode);
            map.setMapClickCallback(function (worldPoint) {
                if (callback && typeof callback === "function") {
                    callback(worldPoint);
                }
            });
        },

        toLocation: function toLocation(point, callback) {
            var self = this,
                opt = self._opt;
            var map = self._helper.getMiniMap(opt.name);
            map.toLocation(point, callback);
        },

        imageCoord2WordCoord: function imageCoord2WordCoord(x, y) {
            var self = this,
                opt = self._opt;
            var map = self._helper.getMiniMap(opt.name);
            return map.imageCoord2WordCoord(_defineProperty({
                x: x }, "x", y));
        }
    };

    PluginsNS.MiniMap = MiniMap;
})();

(function () {
    var mapNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Map");
    var MapConfig = function MapConfig() {
        return {
            id: 'defaultMap',
            domElement: null,
            viewer: null,
            width: 240,
            height: 240,
            isShowGrid: false,
            navigationMode: "Default",
            resourceHost: 'https://m.bimface.com'
        };
    };

    mapNS.MapConfig = MapConfig;
})();

(function () {
    var MapEvents = Object.freeze({
        "ViewerCameraChanged": "ViewerCameraChanged",
        "MouseClicked": "MouseClicked",
        "MouseHoveredGrid": "MouseHoveredGrid"
    });

    var mapNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Map");
    mapNS.MapEvents = MapEvents;
})();

(function () {
    var MapNavigationMode = Object.freeze({
        "Default": "Default",
        "Static": "Static"
    });

    var mapNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Map");
    mapNS.MapNavigationMode = MapNavigationMode;
})();

(function () {
    var mapNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Map");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var $ = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.HttpRequest");

    var Map = function Map(options) {
        var self = this,
            _opt = options;
        self._opt = _opt;
        if (!_opt.domElement) {
            console.log("domElement must be empty.");
            return false;
        }
        if (!_opt.viewer) {
            console.log("viewer is not defined.");
            return false;
        }
        var eventManager = new Glodon.Web.Lang.EventManager();
        this.getEventManager = function () {
            return eventManager;
        };
        var viewer = _opt.viewer.getViewer();
        self._helper = new CLOUD.Extensions.MiniMapHelper(_opt.viewer.getViewer());
        var renderCB = function renderCB() {
            self._helper.renderMiniMap();
        };
        viewer.addCallbacks("render", renderCB);
        self.init();
    };

    Map.prototype = {

        addEventListener: function addEventListener(eventName, handler) {
            this.getEventManager().addEvent(eventName, handler);
        },

        removeEventListener: function removeEventListener(eventName, handler) {
            this.getEventManager().removeEvent(eventName, handler);
        },

        init: function init() {
            var self = this,
                _opt = self._opt,
                axisGrid = {},
                floors = [],
                helper = self._helper;

            $.ajax({
                url: _opt.resourceHost + "/" + _opt.viewer._data.databagId + "/metadata/grids.json",
                async: false,
                success: function success(res) {
                    var Grids = JSON.parse(res);
                    var arr = [];
                    for (var i = 0, len = Grids.grids.length; i < len; i++) {
                        var item = Grids.grids[i];
                        item.start.X = item.start.x;
                        item.start.Y = item.start.y;
                        item.start.Z = item.start.z;
                        item.end.X = item.end.x;
                        item.end.Y = item.end.y;
                        item.end.Z = item.end.z;
                        arr.push(item);
                    }
                    axisGrid.Grids = arr;
                }
            });
            $.ajax({
                async: false,
                url: _opt.resourceHost + "/" + _opt.viewer._data.databagId + "/metadata/levels.json",
                success: function success(res) {
                    axisGrid.Levels = JSON.parse(res).levels;
                }
            });
            $.ajax({
                async: false,
                url: _opt.resourceHost + "/" + _opt.viewer._data.databagId + "/resource/model/maps/output.json",
                dataType: "text",
                success: function success(res) {
                    var data = JSON.parse(res);
                    for (var key in data) {
                        var obj = data[key];
                        obj.path = _opt.resourceHost + "/" + _opt.viewer._data.databagId + "/resource/model/maps/" + key + ".png";
                        obj.id = key;
                        obj.name = key;
                        floors.push(obj);
                    }
                }
            });
            if (axisGrid.Grids && axisGrid.Levels) {
                helper.setAxisGridData(axisGrid);
            } else {
                _opt.domElement.innerHTML = '<p class="bf-message">axis grids not found.</p>';
                return false;
            }
            if (floors.length > 0) {
                helper.setFloorPlaneData(floors[0]);
            }
            self._floors = floors;
            self.createMap();
        },
        createMap: function createMap(axisGrid, floors) {
            var self = this,
                eventManager = self.getEventManager(),
                mapEvents = Glodon.Bimface.Plugins.Map.MapEvents,
                mapNavigationMode = Glodon.Bimface.Plugins.Map.MapNavigationMode,
                helper = self._helper,
                _opt = self._opt,
                map,
                style = {
                left: 0,
                bottom: 0,
                outling: "none",
                position: "relative"
            };
            var cameraChange = function cameraChange(data) {
                eventManager.fireEvent(mapEvents.ViewerCameraChanged, data);
            };
            var mouseHoverGrid = function mouseHoverGrid(data) {
                eventManager.fireEvent(mapEvents.MouseHoveredGrid, data);
            };
            var mouserClicked = function mouserClicked(data) {
                eventManager.fireEvent(mapEvents.MouseClicked, data);
            };
            helper.createMiniMap(_opt.name, _opt.domElement, _opt.width, _opt.height, style, cameraChange, mouseHoverGrid);
            helper.generateAxisGrid(_opt.name);
            helper.generateFloorPlane(_opt.name, false);
            helper.showAxisGrid(_opt.name, _opt.isShowGrid);
            map = helper.getMiniMap(_opt.name);
            map.setMapClickMode(_opt.navigationMode.toLocaleLowerCase());
            map.setMapClickCallback(function (data) {
                mouserClicked(data);
            });
        },
        getFloorList: function getFloorList() {
            return this._floors;
        },

        showGrid: function showGrid() {
            var helper = this._helper;
            helper.showAxisGrid(this._opt.name, true);
        },

        hideGrid: function hideGrid() {
            var helper = this._helper;
            helper.showAxisGrid(this._opt.name, false);
        },

        showFloorById: function showFloorById(id) {
            var self = this,
                name = self._opt.name,
                floors = self._floors,
                obj = floors.getObjectByAttribute("name", id);
            self._helper.setFloorPlaneData(obj);
            self._helper.generateFloorPlane(name, true);
        },

        resize: function resize(width, height) {
            this._helper.resize(this._opt.name, width, height);
        },

        setNavigationMode: function setNavigationMode(navigationMode) {
            var _opt = this._opt,
                helper = this._helper,
                map = helper.getMiniMap(_opt.name);
            _opt.navigationMode = navigationMode;
            map.setMapClickMode(_opt.navigationMode.toLocaleLowerCase());
        },

        clientCoord2WorldCoord: function clientCoord2WorldCoord(x, y) {
            var self = this,
                opt = self._opt;
            var map = self._helper.getMiniMap(opt.name);
            return map.imageCoord2WordCoord({
                x: x,
                y: y
            });
        }
    };

    mapNS.Map = Map;
})();

(function () {
    var PluginsNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins");
    var ViewHouseConfig = function ViewHouseConfig() {
        return {
            domElement: null,
            viewer: null
        };
    };

    PluginsNS.ViewHouseConfig = ViewHouseConfig;
})();

(function () {
    var PluginsNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var $ = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.HttpRequest");
    var ViewHouse = function ViewHouse(options) {
        this._opt = options;
        this.init();
    };

    ViewHouse.prototype = {
        init: function init() {
            var self = this,
                _opt = self._opt,
                _viewer = _opt.viewer.getViewer(),
                _viewHouse = new CLOUD.ViewHouse(_viewer, function () {

                var walkBtn = document.querySelector('.gld-bf-firstperson.bf-checked');
                if (walkBtn) {
                    walkBtn.click();
                }
                return true;
            });
            _viewHouse.init(_opt.domElement);
            _viewHouse.render();
            self._viewHouse = _viewHouse;
            _viewer.addRenderCallback(function () {
                _viewHouse.render();
            });
        },
        enableViewHouse: function enableViewHouse(enable) {
            var self = this,
                _viewHouse = self._viewHouse;
            if (enable) {
                _viewHouse.enable();
            } else {
                _viewHouse.disable();
            }
        }
    };

    PluginsNS.ViewHouse = ViewHouse;
})();

(function () {
    var PluginsNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins");
    var AnnotationConfig = function AnnotationConfig() {
        return {
            background: null,
            domElement: null,
            viewer: null,
            style: {
                'stroke-width': 3,
                'stroke-color': '#ff0000',
                'stroke-opacity': 1.0,
                'fill-color': '#ff0000',
                'fill-opacity': 0.0,
                'font-family': 'Arial',
                'font-size': 16,
                'font-style': 'italic',
                'font-weight': 'bold'
            }
        };
    };

    PluginsNS.AnnotationConfig = AnnotationConfig;
})();

(function () {
    var AnnotationTypeOption = Object.freeze({
        "Arrow": "Arrow",
        "Rectangle": "Rectangle",
        "Circle": "Circle",
        "Cross": "Cross",
        "Cloud": "Cloud",
        "Text": "Text"
    });

    var deprecatedAnnotationNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins");

    deprecatedAnnotationNS.AnnotationTypeOption = AnnotationTypeOption;
})();

(function () {
    var PluginsNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var $ = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.HttpRequest");

    var Annotation = function Annotation(options) {
        this._opt = options;

        this.init();
    };

    Annotation.prototype = {

        init: function init() {
            var self = this,
                _opt = self._opt,
                helper;
            if (_opt.viewer) {
                helper = new CLOUD.Extensions.AnnotationHelper3D(_opt.viewer.getViewer());
            } else {
                if (!_opt.domElement) {
                    alert('domElement must not be empty.');
                    return false;
                }
                helper = new CLOUD.Extensions.AnnotationHelper2D();
                helper.setDomContainer(_opt.domElement);
            }
            this._helper = helper;
        },

        begin: function begin() {
            var helper = this._helper,
                _opt = this._opt;

            helper.editAnnotationBegin(_opt.absBasePoint, _opt.screenBasePoint, _opt.zoomFactor);
        },

        end: function end() {
            this._helper.editAnnotationEnd();
        },

        save: function save() {
            return this._helper.getAnnotationInfoList();
        },

        createSnapshot: function createSnapshot(backgroundImage, callback) {
            var self = this;
            var img = self._helper.captureAnnotationsScreenSnapshot(backgroundImage, callback);
            return img;
        },
        // 加载
        load: function load(markerList) {
            var helper = this._helper,
                _opt = this._opt;
            helper.loadAnnotations(markerList);
        },

        setType: function setType(type) {
            var typeOption = {
                "arrow": 0,
                "rectangle": 1,
                "circle": 2,
                "cross": 3,
                "cloud": 4,
                "text": 5
            };
            this._helper.setAnnotationType(typeOption[type.toLocaleLowerCase()]);
        },

        setStyle: function setStyle(style) {
            this._helper.setAnnotationStyle(style);
        },

        destroy: function destroy() {
            this._helper.destroy();
        }

    };

    PluginsNS.Annotation = Annotation;
})();

(function () {
    var AnnotationNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Annotation");
    var AnnotationManagerConfig = function AnnotationManagerConfig() {
        return {
            viewer: null,
            lineWidth: 3,
            lineColor: new Glodon.Web.Graphics.Color(208, 2, 27, 1),
            fillColor: new Glodon.Web.Graphics.Color(255, 255, 255, 0),
            fontFamily: "Arial",
            fontSize: 16
        };
    };

    AnnotationNS.AnnotationManagerConfig = AnnotationManagerConfig;
})();

(function () {
    var AnnotationTypeOption = Object.freeze({
        "Arrow": "Arrow",
        "Rectangle": "Rectangle",
        "Circle": "Circle",
        "Cross": "Cross",
        "Cloud": "Cloud",
        "Text": "Text"
    });

    var annotationNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Annotation");

    annotationNS.AnnotationTypeOption = AnnotationTypeOption;
})();

(function () {
    var AnnotationNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Annotation");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var $ = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.HttpRequest");

    var AnnotationManager = function AnnotationManager(options) {
        var self = this,
            viewer = options.viewer,
            isView3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        this._opt = options;
        this.isView3D = isView3D;
        this.isShowAnnotation = false;
        this.historyQueue = [];
        this.init();
        if (!isView3D) {
            var viewerEvent = Glodon.Bimface.Viewer.Viewer2DEvent;
            viewer.addEventListener(viewerEvent.ViewMoving, function (offset) {
                self.updateSvg();
            });
            viewer.addEventListener(viewerEvent.ViewZooming, function (zoom) {
                self.updateSvg(zoom.zoomScale);
            });
        }
    };

    AnnotationManager.prototype = {

        init: function init() {
            var self = this,
                _opt = self._opt,
                helper;
            if (self.isView3D) {
                helper = new CLOUD.Extensions.AnnotationHelper3D(_opt.viewer.getViewer(), _opt);
            } else {
                helper = new CLOUD.Extensions.AnnotationHelper2D(_opt);
                helper.setDomContainer(_opt.viewer.getDomElement());
            }
            this._helper = helper;
        },

        startDrawing: function startDrawing() {
            var helper = this._helper,
                _opt = this._opt;
            helper.editAnnotationBegin();
            if (!this.isView3D) {
                var zoomScale = _opt.viewer.getZoomScale();
                helper.setZoomFactor(zoomScale);
                var svg = helper.editor.svg;
                svg.addEventListener("mousewheel", function (event) {
                    event.preventDefault();
                    event.stopPropagation();
                });
            }
            this.isShowAnnotation = true;
        },

        endDrawing: function endDrawing() {
            this._helper.editAnnotationEnd();
            this.isShowAnnotation = false;
        },

        getAnnotationList: function getAnnotationList() {
            var self = this,
                annotationList = this._helper.getAnnotationInfoList();
            if (!self.isView3D && annotationList && annotationList.length > 0) {
                var viewer = self._opt.viewer,
                    scale = viewer.getZoomScale();
                for (var i = 0, len = annotationList.length; i < len; i++) {
                    annotationList[i].worldPosition = self.getWorldPosition(annotationList[i]);
                    annotationList[i].defaultSize = {
                        width: annotationList[i].size.width / scale,
                        height: annotationList[i].size.height / scale
                    };
                }
            }
            return annotationList;
        },

        setAnnotationList: function setAnnotationList(annotationList) {
            if (!annotationList || annotationList.length == 0) {
                return false;
            }
            if (!this.isView3D) {
                var zoomScale = this._opt.viewer.getZoomScale();
                for (var i = 0, len = annotationList.length; i < len; i++) {
                    annotationList[i].position = this.getSVGPosition(annotationList[i], zoomScale);
                    annotationList[i].size.width = annotationList[i].defaultSize.width * zoomScale;
                    annotationList[i].size.height = annotationList[i].defaultSize.height * zoomScale;
                }
            }
            this._annotationList = annotationList;
            this._helper.loadAnnotations(annotationList);
            this.isShowAnnotation = true;
        },

        clear: function clear() {
            this.setAnnotationList([]);
            this._helper.clearAnnotations();
        },

        createSnapshot: function createSnapshot(callback) {
            var self = this,
                viewer = self._opt.viewer,
                isView3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
            if (isView3D) {
                self._helper.captureAnnotationsScreenSnapshot("", callback);
            } else {
                viewer.createSnapshotAsync("", function (bg) {
                    self._helper.captureAnnotationsScreenSnapshot(bg, callback);
                });
            }
        },

        resize: function resize() {
            this._helper.resizeAnnotations();
        },

        setAnnotationType: function setAnnotationType(type) {
            var typeOption = {
                "arrow": 0,
                "rectangle": 1,
                "circle": 2,
                "cross": 3,
                "cloud": 4,
                "text": 5
            };
            this._helper.setAnnotationType(typeOption[type.toLocaleLowerCase()]);
        },

        setLineWidth: function setLineWidth(width) {
            this._helper.setAnnotationStyle({
                "stroke-width": width
            });
        },

        setLineColor: function setLineColor(color) {
            this._helper.setAnnotationStyle({
                "stroke-color": "#" + color.getHEX(),
                "stroke-opacity": color.getAlpha()
            });
        },

        setFillColor: function setFillColor(color) {
            this._helper.setAnnotationStyle({
                "fill-color": "#" + color.getHEX(),
                "fill-opacity": color.getAlpha()
            });
        },

        setFontFamily: function setFontFamily(family) {
            this._helper.setAnnotationStyle({
                "font-family": family
            });
        },

        setFontSize: function setFontSize(size) {
            this._helper.setAnnotationStyle({
                "font-size": size
            });
        },

        setStyle: function setStyle(style) {
            this._helper.setAnnotationStyle(style);
        },

        destroy: function destroy() {
            this._helper.destroy();
        },

        getCurrentState: function getCurrentState() {
            var self = this,
                viewer = self._opt.viewer,
                state = {
                annotationList: self.getAnnotationList()
            };
            if (self.isView3D) {
                state.state = viewer.getCameraStatus();
            } else {
                state.state = viewer.getCurrentState();
            }

            return state;
        },

        setState: function setState(state) {
            var self = this,
                viewer = self._opt.viewer;
            if (self.isView3D) {
                viewer.setCameraStatus(state.state);
            } else {
                viewer.setState(state.state);
            }
            self.setAnnotationList(state.annotationList);
        },

        updateSvg: function updateSvg() {
            var self = this,
                annotationList = this._annotationList,
                zoomScale = self._opt.viewer.getZoomScale();
            if (!annotationList || annotationList.length == 0) {
                return false;
            }
            for (var i = 0, len = annotationList.length; i < len; i++) {
                annotationList[i].position = self.getSVGPosition(annotationList[i], zoomScale);
                annotationList[i].size.width = annotationList[i].defaultSize.width * zoomScale;
                annotationList[i].size.height = annotationList[i].defaultSize.height * zoomScale;
            }
            if (this.isShowAnnotation) {
                this.setAnnotationList(annotationList);
            }
        },
        getWorldPosition: function getWorldPosition(item) {
            var viewer = this._opt.viewer,
                viewInfo = viewer._dwgViewer.getViewInfo();
            origin = {
                x: viewInfo.view.width / 2,
                y: viewInfo.view.height / 2
            };
            var clientPosition = {
                x: origin.x + item.position.x,
                y: origin.y - item.position.y
            };
            return viewer.clientToWorld(clientPosition);
        },
        getSVGPosition: function getSVGPosition(item, scale) {
            var viewer = this._opt.viewer,
                viewInfo = viewer._dwgViewer.getViewInfo(),
                origin = {
                x: viewInfo.view.width / 2,
                y: viewInfo.view.height / 2
            },
                clientPosition = viewer.worldToClient(item.worldPosition),
                currentScale = viewInfo.scene.scale;
            var SVGPosition = {
                x: clientPosition.x - origin.x,
                y: origin.y - clientPosition.y
            };
            return SVGPosition;
        },

        revoke: function revoke() {}

    };

    AnnotationNS.AnnotationManager = AnnotationManager;
})();

(function () {
    var AnnotationNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Annotation");
    var AnnotationToolbarConfig = function AnnotationToolbarConfig() {
        var config = {
            viewer: null
        };
    };

    AnnotationNS.AnnotationToolbarConfig = AnnotationToolbarConfig;
})();

(function () {
    var AnnotationNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Annotation");
    var AnnotationToolbarEvent = Object.freeze({
        "Saved": "Saved",
        "Cancelled": "Cancelled"
    });

    AnnotationNS.AnnotationToolbarEvent = AnnotationToolbarEvent;
})();

(function () {
    var AnnotationNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Annotation");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var $ = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.HttpRequest");
    var AnnotationEvent = Glodon.Bimface.Plugins.Annotation.AnnotationToolbarEvent;

    var AnnotationToolbar = function AnnotationToolbar(config) {
        var eventManager = this._eventManager = new Glodon.Web.Lang.EventManager();

        var toolbars = [];

        var viewer = config.viewer;
        var annotationContainer = DomNS.create('div', 'bf-annotation bf-hide');
        this.domElement = annotationContainer;
        var annotationType = Glodon.Bimface.Plugins.Annotation.AnnotationTypeOption;
        var annotationConfig = new Glodon.Bimface.Plugins.Annotation.AnnotationManagerConfig();
        var defaultColor = annotationConfig.lineColor;
        annotationConfig.viewer = viewer;
        annotationConfig.annotationCallback = config.annotationCallback;
        var annotationManager = this._annotationManager = new Glodon.Bimface.Plugins.Annotation.AnnotationManager(annotationConfig);
        var domElement = viewer.getDomElement();
        domElement.appendChild(annotationContainer);

        var annotationToolbarConfig = new Glodon.Bimface.UI.Toolbar.ToolbarConfig();
        annotationToolbarConfig.element = annotationContainer;
        annotationToolbarConfig.className = "bf-toolbar bf-toolbar-annotation";
        var annotationToolbar = new Glodon.Bimface.UI.Toolbar.Toolbar(annotationToolbarConfig);
        toolbars.push(annotationToolbar);

        var controlToolbarConfig = new Glodon.Bimface.UI.Toolbar.ToolbarConfig();
        controlToolbarConfig.element = annotationContainer;
        controlToolbarConfig.className = "bf-toolbar bf-toolbar-control";
        var controlToolbar = new Glodon.Bimface.UI.Toolbar.Toolbar(controlToolbarConfig);
        toolbars.push(controlToolbar);

        var arrowConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        arrowConfig.className = "bf-button gld-bf-narrow";
        arrowConfig.title = "箭头";
        arrowConfig.groupName = "Annotation";
        var arrow = new Glodon.Bimface.UI.Button.SingleButton(arrowConfig);
        arrow.addEventListener("Click", function () {
            annotationManager.setAnnotationType(annotationType.Arrow);
            line.show();
            font.hide();
        });
        annotationToolbar.addControl(arrow);

        var rectangleConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        rectangleConfig.className = "bf-button gld-bf-nrectangle";
        rectangleConfig.title = "矩形";
        rectangleConfig.groupName = "Annotation";
        var rectangle = new Glodon.Bimface.UI.Button.SingleButton(rectangleConfig);
        rectangle.addEventListener("Click", function () {
            annotationManager.setAnnotationType(annotationType.Rectangle);
            line.show();
            font.hide();
        });
        annotationToolbar.addControl(rectangle);

        var circleConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        circleConfig.className = "bf-button gld-bf-noval";
        circleConfig.title = "圆形";
        circleConfig.groupName = "Annotation";
        var circle = new Glodon.Bimface.UI.Button.SingleButton(circleConfig);
        circle.addEventListener("Click", function () {
            annotationManager.setAnnotationType(annotationType.Circle);
            line.show();
            font.hide();
        });
        annotationToolbar.addControl(circle);

        var crossConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        crossConfig.className = "bf-button gld-bf-mark";
        crossConfig.title = "X";
        crossConfig.groupName = "Annotation";
        var cross = new Glodon.Bimface.UI.Button.SingleButton(crossConfig);
        cross.addEventListener("Click", function () {
            annotationManager.setAnnotationType(annotationType.Cross);
            line.show();
            font.hide();
        });
        annotationToolbar.addControl(cross);

        var textConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        textConfig.className = "bf-button gld-bf-ntext";
        textConfig.title = "文字";
        textConfig.groupName = "Annotation";
        var text = new Glodon.Bimface.UI.Button.SingleButton(textConfig);
        text.addEventListener("Click", function () {
            annotationManager.setAnnotationType(annotationType.Text);
            line.hide();
            font.show();
        });
        annotationToolbar.addControl(text);

        var colorConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        colorConfig.className = "bf-button bf-color";
        colorConfig.title = "颜色";
        var color = new Glodon.Bimface.UI.Button.ComboBox(colorConfig);

        var colorRedConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        colorRedConfig.className = "bf-button bf-color";
        colorRedConfig.title = "红";
        var colorRed = new Glodon.Bimface.UI.Button.ComboBoxOptionButton(colorRedConfig);
        colorRed.color = new Glodon.Web.Graphics.Color(208, 2, 27, 1);
        var redButton = DomNS.create("div", "bf-color-button");
        redButton.setCss({
            backgroundColor: "#" + colorRed.color.getHEX()
        });
        colorRed.setHtml(redButton.outerHTML);
        color.addControl(colorRed);

        var colorYellowConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        colorYellowConfig.className = "bf-button bf-color";
        colorYellowConfig.title = "黄";
        var colorYellow = new Glodon.Bimface.UI.Button.ComboBoxOptionButton(colorYellowConfig);
        colorYellow.color = new Glodon.Web.Graphics.Color(245, 166, 35, 1);
        var yellowButton = DomNS.create("div", "bf-color-button");
        yellowButton.setCss({
            backgroundColor: "#" + colorYellow.color.getHEX()
        });
        colorYellow.setHtml(yellowButton.outerHTML);
        color.addControl(colorYellow);

        var colorBlueConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        colorBlueConfig.className = "bf-button bf-color";
        colorBlueConfig.title = "蓝";
        var colorBlue = new Glodon.Bimface.UI.Button.ComboBoxOptionButton(colorBlueConfig);
        colorBlue.color = new Glodon.Web.Graphics.Color(74, 144, 226, 1);
        var blueButton = DomNS.create("div", "bf-color-button");
        blueButton.setCss({
            backgroundColor: "#" + colorBlue.color.getHEX()
        });
        colorBlue.setHtml(blueButton.outerHTML);
        color.addControl(colorBlue);

        var colorGreenConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        colorGreenConfig.className = "bf-button bf-color";
        colorGreenConfig.title = "绿";
        var colorGreen = new Glodon.Bimface.UI.Button.ComboBoxOptionButton(colorGreenConfig);
        colorGreen.color = new Glodon.Web.Graphics.Color(126, 211, 33, 1);
        var greenButton = DomNS.create("div", "bf-color-button");
        greenButton.setCss({
            backgroundColor: "#" + colorGreen.color.getHEX()
        });
        colorGreen.setHtml(greenButton.outerHTML);
        color.addControl(colorGreen);

        annotationToolbar.addControl(color);

        var lineConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        lineConfig.className = "bf-button";
        lineConfig.title = "粗细";
        var line = new Glodon.Bimface.UI.Button.ComboBox(lineConfig);

        var lineConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        lineConfig.className = "bf-button bf-line";
        lineConfig.title = "细";

        var fineLine = new Glodon.Bimface.UI.Button.ComboBoxOptionButton(lineConfig);
        fineLine.lineWidth = 2;
        var fineLineButton = DomNS.create("div", "bf-line-button");
        fineLineButton.setCss({
            height: fineLine.lineWidth + "px",
            backgroundColor: "#" + defaultColor.getHEX(),
            margin: (32 - fineLine.lineWidth) / 2 + "px 4px"
        });
        fineLine.element.appendChild(fineLineButton);
        line.addControl(fineLine);

        lineConfig.title = "中";
        var middleLine = new Glodon.Bimface.UI.Button.ComboBoxOptionButton(lineConfig);
        middleLine.lineWidth = 6;
        var middleLineButton = DomNS.create("div", "bf-line-button");
        middleLineButton.setCss({
            height: middleLine.lineWidth + "px",
            backgroundColor: "#" + defaultColor.getHEX(),
            margin: (32 - middleLine.lineWidth) / 2 + "px 4px"
        });
        middleLine.element.appendChild(middleLineButton);
        line.addControl(middleLine);

        lineConfig.title = "粗";
        var wideLine = new Glodon.Bimface.UI.Button.ComboBoxOptionButton(lineConfig);
        wideLine.lineWidth = 10;
        var wideLineButton = DomNS.create("div", "bf-line-button");
        wideLineButton.setCss({
            height: wideLine.lineWidth + "px",
            backgroundColor: "#" + defaultColor.getHEX(),
            margin: (32 - wideLine.lineWidth) / 2 + "px 4px"
        });
        wideLine.element.appendChild(wideLineButton);
        line.addControl(wideLine);

        color.addEventListener("Change", function (item) {
            annotationManager.setLineColor(item.color);
            defaultColor = item.color;
            var style = {
                backgroundColor: "#" + defaultColor.getHEX()
            };
            fineLineButton.setCss({
                height: fineLine.lineWidth + "px",
                backgroundColor: "#" + defaultColor.getHEX(),
                margin: (32 - fineLine.lineWidth) / 2 + "px 4px"
            });
            middleLineButton.setCss({
                height: middleLine.lineWidth + "px",
                backgroundColor: "#" + defaultColor.getHEX(),
                margin: (32 - middleLine.lineWidth) / 2 + "px 4px"
            });
            wideLineButton.setCss({
                height: wideLine.lineWidth + "px",
                backgroundColor: "#" + defaultColor.getHEX(),
                margin: (32 - wideLine.lineWidth) / 2 + "px 4px"
            });
            var currentLine = line.getCurrentControl();
            line.setSelectedControlById(currentLine.getId());
        });

        line.addEventListener("Change", function (item) {
            annotationManager.setLineWidth(item.lineWidth);
        });

        annotationToolbar.addControl(line);

        var fontConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        fontConfig.className = "bf-button bf-font-button";
        fontConfig.title = "字号";
        var font = new Glodon.Bimface.UI.Button.ComboBox(fontConfig);

        var sizeConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        sizeConfig.className = "bf-button bf-size";
        sizeConfig.title = "14";

        var size14 = new Glodon.Bimface.UI.Button.ComboBoxOptionButton(sizeConfig);
        size14.fontSize = 14;
        size14.setHtml("14");
        font.addControl(size14);

        sizeConfig.title = "18";
        var size18 = new Glodon.Bimface.UI.Button.ComboBoxOptionButton(sizeConfig);
        size18.fontSize = 18;
        size18.setHtml("18");
        font.addControl(size18);

        sizeConfig.title = "24";
        var size24 = new Glodon.Bimface.UI.Button.ComboBoxOptionButton(sizeConfig);
        size24.fontSize = 24;
        size24.setHtml("24");
        font.addControl(size24);

        font.addEventListener("Change", function (item) {
            annotationManager.setFontSize(item.fontSize);
        });
        font.hide();
        annotationToolbar.addControl(font);

        var saveButtonConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        saveButtonConfig.className = "bf-save";
        saveButtonConfig.title = "保存";
        var saveButton = new Glodon.Bimface.UI.Button.SingleButton(saveButtonConfig);
        saveButton.setHtml("保存");
        saveButton.addEventListener("Click", function () {
            annotationManager.endDrawing();
            annotationContainer.addClass("bf-hide");
            eventManager.fireEvent(AnnotationEvent.Saved, {
                annotationList: annotationManager.getAnnotationList(),
                state: annotationManager.getCurrentState()
            });
        });
        controlToolbar.addControl(saveButton);

        var cancelButtonConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        cancelButtonConfig.className = "bf-cancel";
        cancelButtonConfig.title = "取消";
        var cancelButton = new Glodon.Bimface.UI.Button.SingleButton(cancelButtonConfig);
        cancelButton.setHtml("取消");
        cancelButton.addEventListener("Click", function () {
            annotationManager.endDrawing();
            annotationContainer.addClass("bf-hide");
            eventManager.fireEvent(AnnotationEvent.Cancelled);
        });
        controlToolbar.addControl(cancelButton);

        this.getEventManager = function () {
            return eventManager;
        };
    };

    AnnotationToolbar.prototype = {

        getEventManager: function getEventManager() {
            return this._eventManager;
        },

        addEventListener: function addEventListener(eventName, handler) {
            this.getEventManager().addEvent(eventName, handler);
        },

        removeEventListener: function removeEventListener(eventName, handler) {
            this.getEventManager().removeEvent(eventName, handler);
        },

        show: function show(eventName, handler) {
            this._annotationManager.clear();
            this._annotationManager.startDrawing();
            this.domElement.removeClass("bf-hide");
        },

        getAnnotationManager: function getAnnotationManager() {
            return this._annotationManager;
        }
    };

    AnnotationNS.AnnotationToolbar = AnnotationToolbar;
})();

(function () {
    var PluginsNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins");
    var TagConfig = function TagConfig() {
        return {
            viewer: null
        };
    };

    PluginsNS.TagConfig = TagConfig;
})();

(function () {
    var PluginsNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var $ = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.HttpRequest");

    var Tag = function Tag(options) {
        var self = this;
        var viewer = this._viewer = options.viewer.getViewer();
        this._opt = options;
        this._renderCallback = function () {
            self.resize();
        };
        this._tagHelper = new CLOUD.Extensions.MarkerEditor(viewer);
        this.init();
        viewer.addCallbacks("render", this._renderCallback);
    };

    Tag.prototype = {

        init: function init() {
            if (!this._tagHelper.isInitialized()) {
                this._tagHelper.init();
            }
        },

        addTag: function addTag(data, tagInfo) {
            if (!data) return false;
            var isAddTag = false;
            var tags = this.getTags();
            data.userId = data.objectId;
            data.worldBoundingBox = data.boundingBox;
            if (!data.worldPosition) {
                data.worldPosition = {
                    x: (data.worldBoundingBox.min.x + data.worldBoundingBox.max.x) / 2,
                    y: (data.worldBoundingBox.min.y + data.worldBoundingBox.max.y) / 2,
                    z: (data.worldBoundingBox.min.z + data.worldBoundingBox.max.z) / 2
                };
            }
            for (var i = 0, len = tags.length; i < len; i++) {
                var tag = tags[i];
                if (tag.userId == data.userId) {
                    isAddTag = true;
                    return false;
                }
            }
            if (!isAddTag) {
                this._tagHelper.createMarkerByIntersect(data, tagInfo.shape, tagInfo.type, tagInfo.image);
            }
        },

        deleteTag: function deleteTag(objectId) {
            var self = this;
            var tags = this.getTags();
            for (var i = 0, len = tags.length; i < len; i++) {
                var tag = tags[i];
                if (tag.userId == objectId) {
                    self._tagHelper.deleteMarker(tag);
                    return false;
                }
            }
        },

        destroy: function destroy() {
            this._viewer.removeCallbacks("render", this._renderCallback);
            this._tagHelper.markerClickCallback = null;
            this.unLoadTags();
            this._tagHelper = null;
        },

        loadTags: function loadTags(tagList) {
            this._tagHelper.loadMarkers(tagList);
        },

        unLoadTags: function unLoadTags() {
            this._tagHelper.unloadMarkers();
        },

        getTags: function getTags() {
            return this._tagHelper.getMarkerInfoList();
        },

        zoomToSelectedTag: function zoomToSelectedTag() {
            this._tagHelper.zoomToSelectedMarkers();
        },

        resize: function resize() {
            this._tagHelper.onResize();
        },

        onSelected: function onSelected(callback) {
            this._tagHelper.setMarkerClickCallback(callback);
        }
    };
    PluginsNS.Tag = Tag;
})();

(function () {
    var DrawableNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Drawable");
    var DrawableContainerConfig = function DrawableContainerConfig() {
        return {
            viewer: null
        };
    };

    DrawableNS.DrawableContainerConfig = DrawableContainerConfig;
})();

(function () {
    var DrawableNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Drawable");
    var DrawableItemConfig = function DrawableItemConfig() {
        return {
            id: null,
            tooltip: '',
            tooltipStyle: {},
            draggable: false,
            worldPosition: new Glodon.Web.Geometry.Point3d(0, 0, 0),
            angle: 0
        };
    };

    DrawableNS.DrawableItemConfig = DrawableItemConfig;
})();

(function () {
    var DrawableNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Drawable");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var MouseButton = Glodon.Web.Common.MouseButton;
    var DrawableItem = function DrawableItem(drawableItemConfig) {
        this.id = drawableItemConfig.id || Glodon.Web.Lang.Utility.UUID.createUUID();
        this.worldPosition = drawableItemConfig.worldPosition;
        this.angle = drawableItemConfig.angle;
    };

    DrawableItem.prototype = {

        draw: function draw(context) {},

        onClick: function onClick(callback) {
            this._onclick = callback;
        },

        onRightClick: function onRightClick(callback) {
            this._onrightclick = callback;
        },

        onEndDrag: function onEndDrag(callback) {
            this._onenddrag = callback;
        },

        setTooltip: function setTooltip(tip) {
            this.tipElement.querySelector('span').innerText = tip;
        },

        setTooltipStyle: function setTooltipStyle(CSS) {
            for (var i in CSS) {
                this.tipElement.style[i] = CSS[i];
            }
        },

        getTooltip: function getTooltip() {
            return this.tipElement.querySelector('span').innerText;
        },

        getTooltipStyle: function getTooltipStyle() {
            return this.tipElement.style;
        },

        getWorldPosition: function getWorldPosition() {
            return this.worldPosition;
        },

        setWorldPosition: function setWorldPosition(position) {
            this.worldPosition = position;
        }

    };

    DrawableNS.DrawableItem = DrawableItem;
})();

(function () {
    var DrawableNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Drawable");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");

    var DrawableContext = function DrawableContext() {
        this.rootDomElement = DomNS.create('div', 'bf-drawable-context');
        this.clientPosition = null;
    };

    DrawableNS.DrawableContext = DrawableContext;
})();

(function () {
    var DrawableNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Drawable");
    var DrawableItemConfig = new Glodon.Bimface.Plugins.Drawable.DrawableItemConfig();
    var ImageConfig = function ImageConfig() {
        var config = {
            width: 32,
            height: 32,
            opacity: 0.75,
            src: null,
            offsetX: 0,
            offsetY: 0
        };
        return Object.assign({}, DrawableItemConfig, config);
    };

    DrawableNS.ImageConfig = ImageConfig;
})();

(function () {
    var DrawableNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Drawable");
    var DrawableItem = Glodon.Bimface.Plugins.Drawable.DrawableItem;
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var UtilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");

    var Image = function Image(imageConfig) {
        DrawableItem.call(this, imageConfig);
        var self = this;
        var isDragging = false;
        var domElement = DomNS.create("img", "bf-drawable-image");
        domElement.draggable = false;
        domElement.src = imageConfig.src;
        domElement.style.width = imageConfig.width + "px";
        domElement.style.height = imageConfig.height + "px";
        domElement.style.opacity = "" + imageConfig.opacity;
        domElement.style.transform = "rotate(" + imageConfig.angle + "deg)";
        this._config = imageConfig;
        this._domElement = domElement;
        this.clientPosition = {};
        var startPosition;
        var end = function end(endClientPosition) {
            var worldPosition = self.viewer.clientToWorld({
                x: endClientPosition.x - startPosition.x + self.clientPosition.x,
                y: endClientPosition.y - startPosition.y + self.clientPosition.y
            });

            if (worldPosition) {
                self.worldPosition = worldPosition;
                self.update();
                self._onenddrag && self._onenddrag(self);
                isDragging = false;
            } else {
                self.update();
            }
        };
        var start = function start(startposition) {
            startPosition = startposition;
            isDragging = true;
        };
        if (imageConfig.draggable) {
            DomNS.drag({ element: domElement, cursor: 'pointer', end: end, start: start });
        }
        domElement.addEventListener("mouseup", function (event) {
            var e = event || window.event;
            if (e.button == '0' && self._onclick) {
                if (!isDragging || startPosition.x == e.clientX && startPosition.y == e.clientY) {
                    self._onclick(self);
                }
            }
        });

        domElement.addEventListener("mousedown", function (event) {
            var e = event || window.event;
            e.stopPropagation();
            if (e.button == '2' && self._onrightclick) {
                self._onrightclick(self);
            } else if (e.button == '1' && self._onmiddleclick) {
                self._onmiddleclick(self);
            }
        });
        //domElement.addEventListener("click",function(event){
        //  self._domElement.toggleClass("bf-drawable-selected");
        //  if(self._onclick){
        //    self._onclick(self);
        //  };
        //});
    };

    UtilityNS.Type.inheritPrototype(Image, DrawableItem);
    var mapAndSetPrototype = function mapAndSetPrototype(prototypeObject, object) {
        var prototype = object.prototype;
        for (var i in prototypeObject) {
            prototype[i] = prototypeObject[i];
        }
    };
    var prototype = {

        draw: function draw(context) {
            var domElement = this._domElement,
                config = this._config;
            this.clientPosition = context.clientPosition;
            domElement.style.left = context.clientPosition.x + config.offsetX - config.width / 2 + "px";
            domElement.style.top = context.clientPosition.y + config.offsetY - config.height / 2 + "px";
            context.rootDomElement.appendChild(domElement);
        },

        getWidth: function getWidth() {
            return this._config.width;
        },

        setWidth: function setWidth(width) {
            var curWidth = this._config.width,
                domElement = this._domElement,
                revise = (curWidth - width) / 2,
                left = parseInt(domElement.style.left);
            this._config.width = width;
            domElement.style.width = width + "px";
            domElement.style.left = left + revise + "px";
        },

        getHeight: function getHeight() {
            return this._config.height;
        },

        setHeight: function setHeight(height) {
            var curHeight = this._config.height,
                domElement = this._domElement,
                revise = (curHeight - height) / 2,
                top = parseInt(domElement.style.top);
            this._config.height = height;
            domElement.style.height = height + "px";
            domElement.style.top = top + revise + "px";
        },

        getOpacity: function getOpacity() {
            return this._config.opacity;
        },

        setOpacity: function setOpacity(opacity) {
            this._config.opacity = opacity;
            this._domElement.style.opacity = opacity;
        },

        getSrc: function getSrc() {
            return this._config.src;
        },

        setSrc: function setSrc(src) {
            this._config.src = src;
            this._domElement.src = src;
        },

        getOffsetX: function getOffsetX() {
            return this._config.offsetX;
        },

        setOffsetX: function setOffsetX(offsetX) {
            var curOffsetX = this._config.offsetX,
                domElement = this._domElement,
                revise = offsetX - curOffsetX,
                left = parseInt(domElement.style.left);
            this._config.offsetX = offsetX;
            domElement.style.left = left + revise + "px";
        },

        getOffsetY: function getOffsetY() {
            return this._config.offsetY;
        },

        setOffsetY: function setOffsetY(offsetY) {
            var curOffsetY = this._config.offsetY,
                domElement = this._domElement,
                revise = offsetY - curOffsetY,
                top = parseInt(domElement.style.top);
            this._config.offsetY = offsetY;
            domElement.style.top = top + revise + "px";
        },

        getAngle: function getAngle() {
            return this.angle;
        },

        setAngle: function setAngle(angle) {
            this.angle = angle;
            this._domElement.style.transform = "rotate(" + angle + "deg)";
        }

    };
    mapAndSetPrototype(prototype, Image);
    DrawableNS.Image = Image;
})();

(function () {
    var DrawableNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Drawable");
    var DrawableItemConfig = new Glodon.Bimface.Plugins.Drawable.DrawableItemConfig();
    var CustomItemConfig = function CustomItemConfig() {
        var config = {
            width: 0,
            height: 0,
            opacity: 0.75,
            content: '',
            offsetX: 0,
            offsetY: 0
        };
        return Object.assign({}, DrawableItemConfig, config);
    };

    DrawableNS.CustomItemConfig = CustomItemConfig;
})();

(function () {
    var DrawableNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Drawable");
    var DrawableItem = Glodon.Bimface.Plugins.Drawable.DrawableItem;
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var UtilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");

    var CustomItem = function CustomItem(boxConfig) {
        DrawableItem.call(this, boxConfig);
        var isDragging = false;
        var self = this;
        var domElement = DomNS.create("div", "bf-drawable-text");
        domElement.style.width = 0;
        domElement.style.height = 0;

        var viewer = boxConfig.viewer,
            startPosition;
        this.clientPosition = {};
        //clientPosition:标签的中心点的浏览器坐标  startPosition：开始拖拽时鼠标的起始浏览器坐标
        if (boxConfig.content instanceof HTMLElement) {
            boxConfig.content.draggable = false;
            boxConfig.content.style.marginLeft = "-" + (parseInt(boxConfig.content.style.width) / 2 - parseInt(domElement.style.width) / 2) + "px";
            boxConfig.content.style.marginTop = "-" + (parseInt(boxConfig.content.style.height) / 2 - parseInt(domElement.style.height) / 2) + "px";
            this.content = boxConfig.content;
            domElement.appendChild(boxConfig.content);
            //兼容IE11
            this.dom = boxConfig.content;
        } else {
            domElement.innerHTML = boxConfig.content;
            //兼容IE11
            this.text = boxConfig.content;
        }

        var tipElement = DomNS.create("div", "bf-tooltip");

        tipElement.style.display = 'none';

        tipElement.innerHTML = "<div class=\"bf-tooltip-content\"><div class=\"bf-tooltip-arrow\"></div><div class=\"bf-tooltip-inner\"><span>" + boxConfig.tooltip + "</span></div></div>";
        tipElement.style.left = boxConfig.width + "px";
        tipElement.style.top = "-" + boxConfig.height + "px";
        var css = boxConfig.tipCSS;
        for (var i in css) {
            tipElement.style[i] = css[i];
        }
        this.tipElement = tipElement;
        domElement.appendChild(tipElement);

        var end = function end(endClientPosition) {

            var worldPosition = viewer.clientToWorld({
                x: endClientPosition.x - startPosition.x + self.clientPosition.x,
                y: endClientPosition.y - startPosition.y + self.clientPosition.y
            });

            if (worldPosition) {
                self.worldPosition = worldPosition;
                self.update();
                self._onenddrag(self);
                isDragging = false;
            } else {
                //alert('不能拖拽到空白的地方')
                self.update();
            }
            //viewer.getViewer().pickByPointWithNormal({
            //  x: (endClientPosition.x - startPosition.x + self.clientPosition.x),
            //  y: (endClientPosition.y - startPosition.y + self.clientPosition.y)
            //}, function (arr) {
            //  if(arr){
            //    self.worldPosition = arr[0].worldPosition;
            //    boxConfig.endDrag(self.worldPosition)
            //  }else{
            //    alert('不能拖拽到空白的地方')
            //    self.update()
            //  }
            //});
        };
        var start = function start(startposition) {

            startPosition = startposition;
            isDragging = true;
        };
        if (boxConfig.draggable) {
            DomNS.drag({ element: domElement, cursor: 'pointer', end: end, start: start });
        }

        domElement.style.width = boxConfig.width + "px";
        domElement.style.height = boxConfig.height + "px";
        domElement.style.opacity = "" + boxConfig.opacity;
        this._config = boxConfig;
        this._domElement = domElement;

        domElement.addEventListener("mouseover", function (event) {

            if (self.tipElement && self.tipElement.querySelector('span').innerText.length > 0) {
                self.tipElement.style.display = 'block';
            }
        });
        domElement.addEventListener("mouseout", function (event) {
            if (self.tipElement) {
                self.tipElement.style.display = 'none';
            }
        });

        domElement.addEventListener("keydown", function (event) {
            event.stopPropagation();
        });
        domElement.addEventListener("mouseup", function (event) {
            var e = event || window.event;

            if (e.button == '0' && self._onclick) {
                if (!isDragging || startPosition.x == e.clientX && startPosition.y == e.clientY) {
                    self._onclick(self);
                }
            }
        });

        domElement.addEventListener("mousedown", function (event) {
            var e = event || window.event;
            e.stopPropagation();
            if (e.button == '2' && self._onrightclick) {

                self._onrightclick(self);
            } else if (e.button == '1' && self._onmiddleclick) {

                self._onmiddleclick(self);
            }
        });
    };

    UtilityNS.Type.inheritPrototype(CustomItem, DrawableItem);

    var mapAndSetPrototype = function mapAndSetPrototype(prototypeObject, object) {
        var prototype = object.prototype;
        for (var i in prototypeObject) {
            prototype[i] = prototypeObject[i];
        }
    };
    var prototype = {

        draw: function draw(context) {
            var domElement = this._domElement,
                config = this._config;
            this.clientPosition = context.clientPosition;
            domElement.style.left = context.clientPosition.x + config.offsetX - config.width / 2 + "px";
            domElement.style.top = context.clientPosition.y + config.offsetY - config.height / 2 + "px";
            if (domElement.innerHTML == '') {
                //兼容IE11
                if (this.dom) {
                    domElement.appendChild(this.dom);
                } else if (this.text) {
                    domElement.innerText = this.text;
                }
            }
            context.rootDomElement.appendChild(domElement);
        },

        getWidth: function getWidth() {
            return this._config.width;
        },

        setWidth: function setWidth(width) {
            var curWidth = this._config.width,
                domElement = this._domElement,
                revise = (curWidth - width) / 2,
                left = parseInt(domElement.style.left);
            this._config.width = width;
            domElement.style.width = width + "px";
            domElement.style.left = left + revise + "px";

            this.content.style.marginLeft = "-" + (parseInt(this.content.style.width) / 2 - parseInt(domElement.style.width) / 2) + "px";
            this.content.style.marginTop = "-" + (parseInt(this.content.style.height) / 2 - parseInt(domElement.style.height) / 2) + "px";
        },

        getHeight: function getHeight() {
            return this._config.height;
        },

        setHeight: function setHeight(height) {
            var curHeight = this._config.height,
                domElement = this._domElement,
                revise = (curHeight - height) / 2,
                top = parseInt(domElement.style.top);
            this._config.height = height;
            domElement.style.height = height + "px";
            domElement.style.top = top + revise + "px";

            this.content.style.marginLeft = "-" + (parseInt(this.content.style.width) / 2 - parseInt(domElement.style.width) / 2) + "px";
            this.content.style.marginTop = "-" + (parseInt(this.content.style.height) / 2 - parseInt(domElement.style.height) / 2) + "px";
        },

        getOpacity: function getOpacity() {
            return this._config.opacity;
        },

        setOpacity: function setOpacity(opacity) {
            this._config.opacity = opacity;
            this._domElement.style.opacity = opacity;
        },

        getContent: function getContent() {
            return this._config.content;
        },

        setContent: function setContent(content) {
            this._config.content = content;
            this._domElement.content = content;
        },

        getOffsetX: function getOffsetX() {
            return this._config.offsetX;
        },

        setOffsetX: function setOffsetX(offsetX) {
            var curOffsetX = this._config.offsetX,
                domElement = this._domElement,
                revise = offsetX - curOffsetX,
                left = parseInt(domElement.style.left);
            this._config.offsetX = offsetX;
            domElement.style.left = left + revise + "px";
        },

        getOffsetY: function getOffsetY() {
            return this._config.offsetY;
        },

        setOffsetY: function setOffsetY(offsetY) {
            var curOffsetY = this._config.offsetY,
                domElement = this._domElement,
                revise = offsetY - curOffsetY,
                top = parseInt(domElement.style.top);
            this._config.offsetY = offsetY;
            domElement.style.top = top + revise + "px";
        }

    };

    mapAndSetPrototype(prototype, CustomItem);
    DrawableNS.CustomItem = CustomItem;
})();

// import './Label';
// import './RichLabel';

(function () {
    var DrawableNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Drawable");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");

    var DrawableContainer = function DrawableContainer(drawableContainerConfig) {
        var self = this;
        var viewer = drawableContainerConfig.viewer;
        var eventManager = new Glodon.Web.Lang.EventManager();
        var context = new Glodon.Bimface.Plugins.Drawable.DrawableContext();
        viewer.getDomElement().appendChild(context.rootDomElement);
        viewer.addEventListener("Rendered", function () {
            self.update();
        });
        self._items = [];
        self._viewer = viewer;
        self._context = context;
        self.getEventManager = function () {
            return eventManager;
        };
    };

    DrawableContainer.prototype = {

        // addEventListener: function(eventName, handler) {
        //   this.getEventManager().addEvent(eventName, handler);
        // },
        //
        // removeEventListener: function(eventName, handler) {
        //   this.getEventManager().removeEvent(eventName, handler);
        // },

        addItem: function addItem(drawable) {
            var items = this._items,
                viewer = this._viewer;
            drawable.viewer = viewer;
            drawable.update = this.update.bind(this);
            items.push(drawable);
            this.update();
        },

        removeItemById: function removeItemById(id) {
            var items = this._items;
            var item = items.removeObjectByAttribute("id", id);
            if (item) {
                this.update();
            }
        },

        getItemById: function getItemById(id) {
            return this._items.getObjectByAttribute("id", id);
        },

        getAllItems: function getAllItems() {
            return this._items;
        },

        addItems: function addItems(items) {
            if (items.length) {
                for (var i = 0; i < items.length; i++) {
                    items[i].update = this.update.bind(this);
                }
            }
            this._items = items;
            this.update();
        },

        clear: function clear() {
            this._items = [];
            this.update();
        },

        update: function update() {
            var items = this._items,
                viewer = this._viewer,
                context = this._context;
            context.rootDomElement.innerHTML = "";
            context.domContainer = null;
            context.svgContainer = null;
            for (var i = 0, len = items.length; i < len; i++) {
                var worldPosition = items[i].worldPosition;
                if (viewer.isInViewFrustum(worldPosition)) {
                    context.clientPosition = viewer.worldToClient(worldPosition);
                    items[i].draw(context);
                }
            }
        }

    };

    DrawableNS.DrawableContainer = DrawableContainer;
})();

(function () {
    var measureNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Measure");
    var MeasureRayConfig = function MeasureRayConfig() {
        return {
            viewer: null,
            targetsHintColor: new Glodon.Web.Graphics.Color(245, 127, 35, 0.6)
        };
    };

    measureNS.MeasureRayConfig = MeasureRayConfig;
})();

(function () {
    var measureNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Measure");
    var MeasureRayItemConfig = function MeasureRayItemConfig() {
        return {
            id: null,
            color: new Glodon.Web.Graphics.Color(245, 127, 35, 1),
            width: 2,
            startPoint: new Glodon.Web.Geometry.Point3d(0, 0, 0),
            endPoint: new Glodon.Web.Geometry.Point3d(0, 0, 0),
            startObjectId: null,
            endObjectId: null
        };
    };

    measureNS.MeasureRayItemConfig = MeasureRayItemConfig;
})();

(function () {
    var measureNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Measure");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");

    var MeasureRayItem = function MeasureRayItem(measureItemConfig) {
        this.id = measureItemConfig.id || Glodon.Web.Lang.Utility.UUID.createUUID();
        var startPoint = this.startPoint = measureItemConfig.startPoint;
        var endPoint = this.endPoint = measureItemConfig.endPoint;
        this.startComponentId = measureItemConfig.startComponentId;
        this.endComponentId = measureItemConfig.endComponentId;
        var defs = DomNS.createNS("defs", "bf-defs");
        defs.innerHTML = "\n      <marker id=\"end\" markerWidth=\"6\" markerHeight=\"6\" refx=\"5\" refy=\"3\" orient=\"auto\" markerUnits=\"strokeWidth\">\n        <path d=\"M0,0 L0,6 L6,3 z\" fill=\"" + measureItemConfig.color.getRGBA() + "\" />\n      </marker>";

        var circle = DomNS.create("i", "bf-measure-handle");
        circle.style.width = measureItemConfig.width * 12 + "px";
        circle.style.height = measureItemConfig.width * 12 + "px";
        circle.style.backgroundColor = measureItemConfig.color.getRGBA();
        circle.style.lineHeight = measureItemConfig.width * 12 + "px";

        var line = DomNS.createNS("line", 'bf-measure-line');
        line.style.stroke = measureItemConfig.color.getRGBA();
        line.setAttribute("stroke-width", measureItemConfig.width);

        var text = DomNS.create("span", "bf-measure-number");
        text.style.backgroundColor = measureItemConfig.color.getRGBA();

        this.domElement = defs;
        this.line = line;
        this.circle = circle;
        this.text = text;
    };

    MeasureRayItem.prototype = {

        draw: function draw(context) {
            var domElement = this.domElement;
            var line = this.line;
            var circle = this.circle;
            var text = this.text;
            var dx = Math.abs(context.endPoint.x - context.startPoint.x);
            var dy = Math.abs(context.endPoint.y - context.startPoint.y);
            var dz = Math.abs(context.endPoint.z - context.startPoint.z);
            var distance = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2) + Math.pow(dz, 2));

            line.setAttribute("x1", context.startPoint.x);
            line.setAttribute("y1", context.startPoint.y);
            line.setAttribute("x2", context.endPoint.x);
            line.setAttribute("y2", context.endPoint.y);

            circle.style.left = context.startPoint.x + "px";
            circle.style.top = context.startPoint.y + "px";
            if (context.isMove) {
                circle.style.border = "2px solid #fff";
            }
            if (distance < 15) {
                line.removeAttribute("marker-end");
            } else {
                line.setAttribute("marker-end", "url(#end)");
            }
            text.innerText = context.distance;
            context.svg.appendChild(domElement);
            context.svg.appendChild(line);
            context.text.appendChild(circle);
            if (context.distance == 0) {
                circle.innerText = "0";
            } else {
                text.style.left = (context.startPoint.x + context.endPoint.x) / 2 + "px";
                text.style.top = (context.startPoint.y + context.endPoint.y) / 2 + "px";
                text.style.transform = "translate(-50%, 0)";
                text.style.marginTop = "2px";
                context.text.appendChild(text);
            }
        }
    };

    measureNS.MeasureRayItem = MeasureRayItem;
})();

(function () {
    var measureNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Measure");
    var MeasureRayEvent = Object.freeze({
        "Measured": "Measured"
    });

    measureNS.MeasureRayEvent = MeasureRayEvent;
})();

(function () {
    var measureNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Measure");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var singleMeasure = null;

    var MeasureRay = function MeasureRay(options) {
        if (singleMeasure) {
            return singleMeasure;
        }
        var viewer = options.viewer;
        if (!viewer) {
            return;
        }
        var isView3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        if (!isView3D) {
            console.log("Viewer2D is not supported.");
            return;
        }
        var self = this;
        var eventManager = new Glodon.Web.Lang.EventManager();
        var domElement = DomNS.create('div', 'bf-measure-conext');
        viewer.addEventListener("Rendered", function () {
            if (self.measureItem) {
                self.update();
            }
        });
        this.context = {
            rootDomElement: domElement
        };
        this._opt = options;
        this._enableMove = false;
        this._events = {
            mousedown: function mousedown() {
                this._startTime = new Date().getTime();
            },
            mouseup: function mouseup(event) {
                if (event.button == 0 || event.button == 1) {
                    if (self._enableMove) {
                        self._enableMove = false;
                        self.measureByPoint(event);
                    } else {
                        var startTime = this._startTime,
                            endTime = new Date().getTime();
                        if (endTime - startTime < 300) {
                            self.measureByPoint(event);
                        }
                    }
                }
            },
            mousemove: function mousemove(event) {
                if (self._enableMove) {
                    event.stopPropagation();
                    self.measureByPoint(event);
                }
            }
        };
        this.getEventManager = function () {
            return eventManager;
        };
    };

    MeasureRay.prototype = {
        addEventListener: function addEventListener(eventName, handler) {
            this.getEventManager().addEvent(eventName, handler);
        },
        removeEventListener: function removeEventListener(eventName, handler) {
            this.getEventManager().removeEvent(eventName, handler);
        },
        switchOn: function switchOn(callback) {
            var context = this.context,
                self = this;
            self._opt.viewer.getDomElement().appendChild(context.rootDomElement);
            self._opt.viewer.getViewer().setPickDisabled(true);
            if (callback) {
                self._callback = callback;
            }
            self._opt.viewer.setSelectedComponentsById();
            var svg = DomNS.createNS("svg", "bf-measure-svg");
            var text = DomNS.create("div", "bf-measure-text");
            context.rootDomElement.appendChild(svg);
            context.rootDomElement.appendChild(text);
            context.svg = svg;
            context.text = text;
            context.rootDomElement.addEventListener("mousedown", self._events.mousedown);
            context.rootDomElement.addEventListener("mouseup", self._events.mouseup);
            context.rootDomElement.addEventListener("mousemove", self._events.mousemove);
        },
        switchOff: function switchOff() {
            var domElement = this.context.rootDomElement,
                self = this,
                viewer3D = self._opt.viewer;
            viewer3D.getViewer().setPickDisabled(false);
            if (self.measureItem) {
                viewer3D.restoreComponentsColorById([self.measureItem.startComponentId, self.measureItem.endComponentId]);
                viewer3D.render();
            }
            domElement.removeEventListener("mousedown", self._events.mousedown);
            domElement.removeEventListener("mouseup", self._events.mouseup);
            domElement.removeEventListener("mousemove", self._events.mousemove);
            domElement.innerHTML = "";
            domElement.remove();
            self.measureItem = null;
        },
        reset: function reset() {
            var context = this.context,
                self = this,
                viewer3D = self._opt.viewer;
            if (self.measureItem) {
                viewer3D.restoreComponentsColorById([self.measureItem.startComponentId, self.measureItem.endComponentId]);
                viewer3D.render();
            }
            context.svg.innerHTML = "";
            context.text.innerHTML = "";
            self.measureItem = null;
        },
        measureByPoint: function measureByPoint(point2d) {
            var self = this;
            var viewer3D = self._opt.viewer;
            var cloudViewer = viewer3D.getViewer();

            cloudViewer.pickByPointWithNormal(point2d, function (intersects) {
                if (intersects) {
                    if (self.measureItem) {
                        viewer3D.restoreComponentsColorById([self.measureItem.startComponentId, self.measureItem.endComponentId]);
                    }
                    var viewer3DEvent = Glodon.Bimface.Viewer.Viewer3DEvent;
                    var data = self._getContextData(intersects);
                    var config = new Glodon.Bimface.Plugins.Measure.MeasureRayItemConfig();
                    config.startComponentId = data.startComponentId;
                    config.endComponentId = data.endComponentId;
                    config.startPoint = data.startPoint;
                    config.endPoint = data.endPoint;
                    var measureItem = new Glodon.Bimface.Plugins.Measure.MeasureRayItem(config);
                    measureItem.circle.addEventListener("mousedown", function (event) {
                        if (event.button != 2) {
                            self._enableMove = true;
                        }
                    });
                    self.context.distance = data.distance;
                    viewer3D.overrideComponentsColorById([data.startComponentId, data.endComponentId], self._opt.targetsHintColor);
                    setTimeout(function () {
                        self.update();
                        viewer3D.render();
                    }, 100);
                    self.measureItem = measureItem;
                    self.getEventManager().fireEvent(Glodon.Bimface.Plugins.Measure.MeasureRayEvent.Measured, data);
                }
            });
        },
        update: function update() {
            var measureItem = this.measureItem;
            var context = this.context;
            var viewer = this._opt.viewer;
            context.svg.innerHTML = "";
            context.text.innerHTML = "";
            context.isMove = this._enableMove;
            var startClientPoint = viewer.worldToClient(measureItem.startPoint);
            var endClientPoint = viewer.worldToClient(measureItem.endPoint);

            if (startClientPoint && endClientPoint) {
                context.startPoint = new Glodon.Web.Geometry.Point3d(startClientPoint.x, startClientPoint.y, startClientPoint.z);
                context.endPoint = new Glodon.Web.Geometry.Point3d(endClientPoint.x, endClientPoint.y, endClientPoint.z);
                measureItem.draw(context);
            }
        },
        _getContextData: function _getContextData(intersects) {
            var intersectStart,
                intersectEnd,
                data = {};
            intersectStart = intersectEnd = intersects[0];
            if (intersects.length > 1) {
                intersectEnd = intersects[1];
            }
            data.startComponentId = intersectStart.userId;
            data.startPoint = intersectStart.worldPosition;
            data.endComponentId = intersectEnd.userId;
            data.endPoint = intersectEnd.worldPosition;
            data.distanceX = Math.round(Math.abs(data.endPoint.x - data.startPoint.x));
            data.distanceY = Math.round(Math.abs(data.endPoint.y - data.startPoint.y));
            data.distanceZ = Math.round(Math.abs(data.endPoint.z - data.startPoint.z));
            data.distance = Math.round(Math.sqrt(Math.pow(data.distanceX, 2) + Math.pow(data.distanceY, 2) + Math.pow(data.distanceZ, 2)));
            return data;
        }
    };

    measureNS.MeasureRay = MeasureRay;
})();

(function () {
    var Marker3DNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Marker3D");
    var Marker3DContainerConfig = function Marker3DContainerConfig() {
        return {
            viewer: null
        };
    };

    Marker3DNS.Marker3DContainerConfig = Marker3DContainerConfig;
})();

(function () {
    var Marker3DNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Marker3D");
    var Marker3DConfig = function Marker3DConfig() {
        return {
            id: null,
            size: 30,
            tooltip: '',
            src: null,
            worldPosition: new Glodon.Web.Geometry.Point3d(0, 0, 0)
        };
    };

    Marker3DNS.Marker3DConfig = Marker3DConfig;
})();

(function () {
    var Marker3DNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Marker3D");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var Marker3D = function Marker3D(config) {
        this.id = config.id || Glodon.Web.Lang.Utility.UUID.createUUID();
        this.size = config.size;
        this.iconUrl = config.src;
        this.tooltip = config.tooltip;
        this.position = config.worldPosition;
    };

    Marker3D.prototype = {

        getId: function getId() {
            return this.id;
        },

        getWorldPosition: function getWorldPosition() {
            return this.position;
        },

        setWorldPosition: function setWorldPosition(position) {
            this.position = position;
            this.update();
        },

        getSize: function getSize() {
            return this.size;
        },

        setSize: function setSize(size) {
            this.size = size;
            this.update();
        },

        getSrc: function getSrc() {
            return this.iconUrl;
        },

        setSrc: function setSrc(src) {
            this.iconUrl = src;
            this.update();
        },

        getTooltip: function getTooltip() {
            return this.tooltip;
        },

        setTooltip: function setTooltip(text) {
            this.tooltip = text;
        },

        onClick: function onClick(callback) {
            if (callback) {
                this._callback = callback;
            }
        },

        onRightClick: function onRightClick(callback) {},

        update: function update() {
            if (this.container) {
                this.container.update();
            }
        }

    };

    Marker3DNS.Marker3D = Marker3D;
})();

(function () {
    var Marker3DNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Plugins.Marker3D");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");

    var Marker3DContainer = function Marker3DContainer(config) {
        if (!config.viewer) {
            console.log("viewer must not be empty.");
            return;
        }
        var isViewer3d = config.viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var viewer = config.viewer.getViewer();
        if (!isViewer3d) {
            console.log("Viewer2D is not supported.");
            return;
        }
        var helper = new CLOUD.Marker3D(viewer, true);
        var self = this;
        this._helper = helper;
        this._viewer = config.viewer;
        this._items = [];

        viewer.registerEventListener(CLOUD.EVENTS.ON_CLICK_PICK, function (res) {
            var intersect = res.intersectInfo;
            if (intersect && intersect.tag === "Marker3D") {
                var data = helper.getItemByPick(intersect);
                var item = self.getItemById(data.id);
                if (item._callback) {
                    item._callback(data);
                }
            }
        });
    };

    Marker3DContainer.prototype = {

        // createMarker3D:function(){
        //
        // },

        addItem: function addItem(item) {
            item.container = this;
            this._items.push(item);
            this.update();
        },

        addItems: function addItems(items) {
            this._items = this._items.concat(items);
            this.update();
        },

        removeItemById: function removeItemById(id) {
            this._items.removeObjectByAttribute("id", id);
            this.update();
        },

        getItemById: function getItemById(id) {
            return this._items.getObjectByAttribute("id", id);
        },

        getAllItems: function getAllItems() {
            return this._items;
        },

        clear: function clear() {
            this._items = [];
            this.update();
        },

        update: function update() {
            this._helper.clear();
            this._helper.add(this._items);
            this._helper.update();
            this._viewer.render();
        }
    };

    Marker3DNS.Marker3DContainer = Marker3DContainer;
})();

(function () {
    var appNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application");
    var WebApplication3DConfig = function WebApplication3DConfig() {
        var defaults = {
            Toolbars: ["MainToolbar", "ModelTree"],
            Buttons: ["Home", "Walk", /* "OrbitButton",*/"RectangleSelect", "Measure", "Section", "Property", "Information", "Setting", "FullScreen"]
        };
        var viewer3DConfig = Glodon.Bimface.Viewer.Viewer3DConfig();
        var Config = Object.assign({}, defaults, viewer3DConfig);
        return Config;
    };

    appNS.WebApplication3DConfig = WebApplication3DConfig;
})();

(function () {
    var AppNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application");
    var WebApplication3DEvent = Object.freeze({
        "ViewAdded": "ViewAdded",
        "ViewLoading": "ViewLoading",
        "ComponentsSelectionChanged": "ComponentsSelectionChanged",
        "Error": "Error"
    });

    AppNS.WebApplication3DEvent = WebApplication3DEvent;
})();

(function () {
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");

    var Home = function Home(viewer) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;

        var config = new Glodon.Bimface.UI.Button.ButtonConfig();
        config.id = "Home";
        config.title = "主视图";
        config.className = "bf-button gld-bf-home";
        var home = new Glodon.Bimface.UI.Button.Button(config);
        home.addEventListener(controlEvent.Click, function () {
            if (isViewer3D) {
                viewer.setView(Glodon.Bimface.Viewer.ViewOption.Home);
            } else {
                viewer.home();
            }
        });
        return home;
    };

    buttonNS.Home = Home;
})();

(function () {
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");

    var OrbitButton = function OrbitButton(viewer, rootElement, toolbar) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;
        if (!isViewer3D) {
            console.log('The API is not supported on this viewer.');
            return;
        }
        var NavigationMode = Glodon.Bimface.Viewer.NavigationMode3D;
        var handles = {
            OrbitPoint: NavigationMode.PickWithRect,
            OrbitCamera: NavigationMode.Fly
        };
        var config = new Glodon.Bimface.UI.Button.ButtonConfig();
        config.id = "OrbitButton";
        config.title = "导航";
        config.inheritTitle = true;
        var orbitButton = new Glodon.Bimface.UI.Button.ComboBox(config);

        var pointConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        pointConfig.id = "OrbitPoint";
        pointConfig.title = "绕构件旋转";
        pointConfig.className = "bf-button gld-bf-orbitpoint";
        var orbitPoint = new Glodon.Bimface.UI.Button.ComboBoxOptionButton(pointConfig);

        var cameraConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        cameraConfig.id = "OrbitCamera";
        cameraConfig.title = "绕相机旋转";
        cameraConfig.className = "bf-button gld-bf-orbitcamera";
        var orbitCamera = new Glodon.Bimface.UI.Button.ComboBoxOptionButton(cameraConfig);

        orbitButton.addControl(orbitPoint);
        orbitButton.addControl(orbitCamera);

        orbitButton.addEventListener(controlEvent.Change, function (arg) {
            var sectionButton = toolbar.getControl("Section");
            sectionButton.setCheckedState(false);
            viewer.setNavigationMode(handles[arg.id]);
        });

        return orbitButton;
    };

    buttonNS.OrbitButton = OrbitButton;
})();

(function () {
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");

    var RectangleSelect = function RectangleSelect(viewer, rootElement, toolbar) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;
        var viewerEvent = Glodon.Bimface.Viewer.Viewer3DEvent;
        if (!isViewer3D) {
            console.log('The API is not supported on this viewer.');
            return;
        }
        var config = new Glodon.Bimface.UI.Button.ButtonConfig();
        config.id = "RectangleSelect";
        config.title = "框选放大";
        config.className = "bf-button gld-bf-zoomrect";
        var button = new Glodon.Bimface.UI.Button.ToggleButton(config);
        var RectangleSelectAction = function RectangleSelectAction() {
            button.setCheckedState(false);
            toolbar.resetState();
        };
        button.addEventListener(controlEvent.StateChange, function (isChecked) {
            if (isChecked) {
                var sectionButton = toolbar.getControl("Section");
                sectionButton.setCheckedState(false);
                var walkButton = toolbar.getControl("Walk");
                walkButton.setCheckedState(false);
                viewer.setNavigationMode(Glodon.Bimface.Viewer.NavigationMode3D.ZoomWithRect);
                viewer.addEventListener(viewerEvent.RectSelection, RectangleSelectAction);
            } else {
                viewer.removeEventListener(viewerEvent.RectSelection, RectangleSelectAction);
            }
        });
        return button;
    };

    buttonNS.RectangleSelect = RectangleSelect;
})();

(function () {
    var panelNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Panel");
    var propertyPanel;

    var PropertyPanel = function PropertyPanel(viewer) {
        var viewerEvent = Glodon.Bimface.Viewer.Viewer3DEvent;
        var showProperty = function showProperty(res) {
            if (res.objectId) {
                viewer.getComponentProperty(res.objectId, function (data) {
                    propertyPanel.setData(data.properties);
                });
            } else {
                propertyPanel.setData("");
            }
        };
        if (propertyPanel) {
            propertyPanel.show();
            viewer.addEventListener(viewerEvent.ComponentsSelectionChanged, showProperty);
            return propertyPanel;
        }
        var config = new Glodon.Bimface.UI.Panel.PanelConfig();
        config.title = "属性";
        config.css = {
            right: "10px",
            top: "10px",
            width: "300px",
            height: "416px"
        };
        var propertyPanel = new Glodon.Bimface.UI.Panel.Panel(config);
        var selectedComponents = viewer.getSelectedComponents();
        for (var key in selectedComponents) {
            viewer.getComponentProperty(key, function (data) {
                propertyPanel.setData(data.properties);
            });
            break;
        }
        viewer.addEventListener(viewerEvent.ComponentsSelectionChanged, showProperty);
        propertyPanel.addEventListener("Hide", function () {
            viewer.removeEventListener(viewerEvent.ComponentsSelectionChanged, showProperty);
        });
        return propertyPanel;
    };
    panelNS.PropertyPanel = PropertyPanel;
})();

(function () {
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");

    var Property = function Property(viewer, rootElement) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;
        if (!isViewer3D) {
            console.log('The API is not supported on this viewer.');
            return;
        }
        var config = new Glodon.Bimface.UI.Button.ButtonConfig();
        config.id = "Property";
        config.title = "属性";
        config.className = "bf-button gld-bf-properties";
        var button = new Glodon.Bimface.UI.Button.ToggleButton(config);
        var propertyPanel;
        button.addEventListener(controlEvent.Click, function () {
            if (button.isChecked()) {
                propertyPanel = new Glodon.Bimface.Application.UI.Panel.PropertyPanel(viewer);
                propertyPanel.addEventListener("Hide", function () {
                    rootElement.removeChild(propertyPanel.element);
                    button.setCheckedState(false);
                });
                rootElement.appendChild(propertyPanel.element);
            } else {
                rootElement.removeChild(propertyPanel.element);
            }
        });
        return button;
    };

    buttonNS.Property = Property;
})();

(function () {
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");

    var Measure = function Measure(viewer, rootElement, toolbar) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;
        if (!isViewer3D) {
            console.log('The API is not supported on this viewer.');
            return;
        }
        var config = new Glodon.Bimface.UI.Button.ButtonConfig();
        config.id = "Measure";
        config.title = "测量";
        config.className = "bf-button gld-bf-measure";
        var button = new Glodon.Bimface.UI.Button.ToggleButton(config);
        var measurePanel, measure;

        var createMeasurePanel = function createMeasurePanel() {
            var panel = DomNS.create("div", "bf-panel bf-measure-panel");
            var text = DomNS.create("span", "bf-measure-text");
            text.innerText = "请选择测量起点";
            var close = DomNS.create("span", "bf-close bf-measure-close");
            close.addEventListener("click", function () {
                button.setCheckedState(false);
            });
            var reset = DomNS.create("button", "bf-measure-reset");
            reset.innerText = "重置";
            reset.addEventListener("click", function () {
                text.innerHTML = "请选择测量起点";
                measure.reset();
            });
            panel.appendChild(text);
            panel.appendChild(close);
            return {
                panel: panel,
                text: text,
                reset: reset
            };
        };

        button.addEventListener(controlEvent.StateChange, function (isChecked) {
            var walkButton = toolbar.getControl("Walk");

            if (isChecked) {
                var measureRayConfig = new Glodon.Bimface.Plugins.Measure.MeasureRayConfig();
                measureRayConfig.viewer = viewer;
                measure = new Glodon.Bimface.Plugins.Measure.MeasureRay(measureRayConfig);
                measurePanel = createMeasurePanel();
                measure.addEventListener(Glodon.Bimface.Plugins.Measure.MeasureRayEvent.Measured, function (data) {
                    measurePanel.text.innerHTML = "\u76F4\u7EBF\u8DDD\u79BB\uFF1A<span class=\"bf-measure-distance\">" + data.distance + "</span>mm";
                    measurePanel.text.appendChild(measurePanel.reset);
                });
                rootElement.appendChild(measurePanel.panel);
                measure.switchOn();

                //判断漫游状态
                if (walkButton.isChecked()) {
                    var measurepanel = document.querySelector('.bf-measure-panel');
                    measurepanel.style.bottom = '130px';
                }
            } else {
                rootElement.removeChild(measurePanel.panel);
                measurePanel = null;
                measure.switchOff();
            }
        });
        return button;
    };

    buttonNS.Measure = Measure;
})();

(function () {
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");

    var Annotation = function Annotation(viewer, rootElement, toolbar) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;

        var config = new Glodon.Bimface.UI.Button.ButtonConfig();
        config.id = "Annotation";
        config.title = "批注";
        config.className = "bf-button gld-bf-notes";
        var annotation = new Glodon.Bimface.UI.Button.Button(config);
        annotation.addEventListener(controlEvent.Click, function () {
            toolbar.hide();
            var measureButton = toolbar.getControl("Measure");
            measureButton.setCheckedState(false);
            var annotationConfig = new Glodon.Bimface.Plugins.Annotation.AnnotationToolbarConfig();
            annotationConfig.viewer = viewer;
            var annotationToolbar = self._annotation = new Glodon.Bimface.Plugins.Annotation.AnnotationToolbar(annotationConfig);
            var annotationToolbarEvent = Glodon.Bimface.Plugins.Annotation.AnnotationToolbarEvent;
            annotationToolbar.show();
            annotationToolbar.addEventListener(annotationToolbarEvent.Saved, function () {
                toolbar.show();
            });
            annotationToolbar.addEventListener(annotationToolbarEvent.Cancelled, function () {
                toolbar.show();
            });
            annotation._annotationManager = annotationToolbar.getAnnotationManager();
            annotation._annotationToolbar = annotationToolbar;
        });

        return annotation;
    };

    buttonNS.Annotation = Annotation;
})();

(function () {
    var panelNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Panel");
    var SectionPanel = function SectionPanel(viewer) {
        var config = new Glodon.Bimface.UI.Panel.PanelConfig();
        config.title = "剖面";
        config.css = {
            right: "10px",
            bottom: "10px",
            width: "300px",
            height: "92px",
            minHeight: "92px"
        };
        config.enableSizable = false;
        var sectionPanel = new Glodon.Bimface.UI.Panel.Panel(config);
        var toolbarConfig = Glodon.Bimface.Application.UI.Toolbar.SectionToolbarConfig();
        toolbarConfig.viewer = viewer;
        var sectionToolbar = Glodon.Bimface.Application.UI.Toolbar.Toolbar(toolbarConfig);
        var resetButton = sectionToolbar.getControl("SectionReset");
        var visibleButton = sectionToolbar.getControl("SectionVisiable");
        var rotateButton = sectionToolbar.getControl("SectionRotate");
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;
        resetButton.addEventListener(controlEvent.Click, function () {
            visibleButton.setCheckedState(false);
            rotateButton.setCheckedState(false);
        });
        sectionPanel.addControl(sectionToolbar);
        return sectionPanel;
    };
    panelNS.SectionPanel = SectionPanel;
})();

(function () {
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");

    var Section = function Section(viewer, rootElement, toolbar) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;
        if (!isViewer3D) {
            console.log('The API is not supported on this viewer.');
            return;
        }
        var config = new Glodon.Bimface.UI.Button.ButtonConfig();
        config.id = "Section";
        config.title = "剖切";
        config.className = "bf-button gld-bf-sectionbox";
        var button = new Glodon.Bimface.UI.Button.ToggleButton(config);
        var sectionPanel;
        button.addEventListener(controlEvent.StateChange, function (isChecked) {
            if (isChecked) {
                var measureButton = toolbar.getControl("Measure");
                measureButton.setCheckedState(false);
                var rectangleSelect = toolbar.getControl("RectangleSelect");
                rectangleSelect.setCheckedState(false);
                var walkButton = toolbar.getControl("Walk");
                walkButton.setCheckedState(false);
                sectionPanel = new Glodon.Bimface.Application.UI.Panel.SectionPanel(viewer);
                sectionPanel.addEventListener("Hide", function () {
                    rootElement.removeChild(sectionPanel.element);
                    button.setCheckedState(false);
                });
                viewer.enableSectionBox();
                viewer.render();
                rootElement.appendChild(sectionPanel.element);
            } else {
                viewer.resetSectionBox();
                viewer.disableSectionBox();
                viewer.render();
                // rootElement.removeChild(sectionPanel.element);
                sectionPanel.close();
                sectionPanel = null;
                toolbar.resetState();
            }
        });
        return button;
    };

    buttonNS.Section = Section;
})();

(function () {
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");

    var SectionVisiable = function SectionVisiable(viewer) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;
        if (!isViewer3D) {
            console.log('The API is not supported on this viewer.');
            return;
        }
        var config = new Glodon.Bimface.UI.Button.ButtonConfig();
        config.id = "SectionVisiable";
        config.title = "隐藏";
        var button = new Glodon.Bimface.UI.Button.ToggleButton(config);
        button.setHtml('<span class="gld-bf-box-hide"></span><span class="bf-button-name">隐藏</span>');
        button.addEventListener(controlEvent.Click, function () {
            if (button.isChecked()) {
                viewer.hideSectionBox();
            } else {
                viewer.showSectionBox();
            }
            viewer.render();
        });
        return button;
    };

    buttonNS.SectionVisiable = SectionVisiable;
})();

(function () {
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");

    var SectionRotate = function SectionRotate(viewer) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;
        if (!isViewer3D) {
            console.log('The API is not supported on this viewer.');
            return;
        }
        var config = new Glodon.Bimface.UI.Button.ButtonConfig();
        config.id = "SectionRotate";
        config.title = "旋转";
        var button = new Glodon.Bimface.UI.Button.ToggleButton(config);
        button.setHtml('<span class="gld-bf-rotate-box"></span><span class="bf-button-name">旋转</span>');
        button.addEventListener(controlEvent.Click, function () {
            var sectionBoxMode = Glodon.Bimface.Viewer.SectionBoxMode;
            if (button.isChecked()) {
                viewer.setSectionBoxMode(sectionBoxMode.Rotate);
            } else {
                viewer.setSectionBoxMode(sectionBoxMode.Default);
            }
        });
        return button;
    };

    buttonNS.SectionRotate = SectionRotate;
})();

(function () {
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");

    var SectionReset = function SectionReset(viewer) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;
        if (!isViewer3D) {
            console.log('The API is not supported on this viewer.');
            return;
        }
        var config = new Glodon.Bimface.UI.Button.ButtonConfig();
        config.id = "SectionReset";
        config.title = "重置";
        var button = new Glodon.Bimface.UI.Button.Button(config);
        button.setHtml('<span class="gld-bf-reset-box"></span><span class="bf-button-name">重置</span>');
        button.addEventListener(controlEvent.Click, function () {
            viewer.resetSectionBox();
            viewer.render();
        });
        return button;
    };

    buttonNS.SectionReset = SectionReset;
})();

(function () {
    var panelNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Panel");
    var informationPanel;
    var InformationPanel = function InformationPanel(viewer) {
        if (informationPanel) {
            informationPanel.show();
            return informationPanel;
        }
        var config = new Glodon.Bimface.UI.Panel.PanelConfig();
        config.title = "基本信息";
        config.css = {
            left: "50%",
            top: "50%",
            width: "300px",
            height: "210px",
            transform: "translate(-50%,-50%)"
        };
        config.enableSizable = false;
        var information = viewer.getInformation();
        informationPanel = new Glodon.Bimface.UI.Panel.Panel(config);
        var html = "<div class=\"bf-info\">\n                  <ul class=\"bf-info-list\">\n                    <li>\u6784\u4EF6\u6570\u91CF\uFF1A<span class=\"bf-info-value\">" + information.elements + "</span></li>\n                    <li>\u4E09\u89D2\u9762\u6570\u91CF\uFF1A<span class=\"bf-info-value\">" + information.triangles + "</span></li>\n                    <li>\u9876\u70B9\u6570\u91CF\uFF1A<span class=\"bf-info-value\">" + information.triangles * 3 + "</span></li>\n                  </ul>\n                  <div class=\"bf-info-power\">Powered by <a target=\"_blank\" href=\"http://bimface.com/\">bimface.com</a></div>\n                </div>";
        informationPanel.setHtml(html);
        return informationPanel;
    };
    panelNS.InformationPanel = InformationPanel;
})();

(function () {
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");

    var Information = function Information(viewer, rootElement) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;
        if (!isViewer3D) {
            console.log('The API is not supported on this viewer.');
            return;
        }
        var config = new Glodon.Bimface.UI.Button.ButtonConfig();
        config.id = "Information";
        config.title = "基本信息";
        config.className = "bf-button gld-bf-information";
        var button = new Glodon.Bimface.UI.Button.ToggleButton(config);
        var informationPanel;
        button.addEventListener(controlEvent.Click, function () {
            if (button.isChecked()) {
                informationPanel = new Glodon.Bimface.Application.UI.Panel.InformationPanel(viewer);
                informationPanel.addEventListener("Hide", function () {
                    rootElement.removeChild(informationPanel.element);
                    button.setCheckedState(false);
                });
                rootElement.appendChild(informationPanel.element);
            } else {
                rootElement.removeChild(informationPanel.element);
            }
        });
        return button;
    };

    buttonNS.Information = Information;
})();

(function () {
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");

    var FullScreen = function FullScreen(viewer) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;

        var config = new Glodon.Bimface.UI.Button.ButtonConfig();
        config.id = "FullScreen";
        config.title = "全屏";
        config.className = "bf-button gld-bf-maximize";
        var fullScreen = new Glodon.Bimface.UI.Button.ChangeButton(config);
        fullScreen.addEventListener(controlEvent.Click, function () {
            var enable = this.hasClass("gld-bf-maximize");
            viewer.enableFullScreen(enable);
        });
        Glodon.Web.Lang.Utility.FullScreen.onFullScreenChanged(function () {
            var title = fullScreen.getTitle();
            fullScreen.toggleClassName("gld-bf-maximize");
            fullScreen.toggleClassName("gld-bf-minimize");
            if (title == "取消全屏") {
                fullScreen.setTitle("全屏");
            } else {
                fullScreen.setTitle("取消全屏");
            }
        });
        return fullScreen;
    };

    buttonNS.FullScreen = FullScreen;
})();

(function () {
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");

    var FamilyList = function FamilyList(viewer) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;

        var config = new Glodon.Bimface.UI.Button.ButtonConfig();
        config.id = "FamilyList";
        config.title = "FamilyList";
        config.className = "bf-button gld-bf-maximize";
        var familyList = new Glodon.Bimface.UI.Button.ComboBox(config);
        var familyTypes = viewer.getFamilyTypes();

        for (var i = 0, len = familyTypes.length; i < len; i++) {
            var item = familyTypes[i];
            var config = new Glodon.Bimface.UI.Button.ButtonConfig();
            config.id = item.id;
            config.title = item.name;
            var itemButton = new Glodon.Bimface.UI.Button.ComboBoxOptionButton(config);
            itemButton.setHtml("<span class=\"bf-button-name\">" + item.name + "</span>");
            familyList.addControl(itemButton);
        }

        familyList.addEventListener(controlEvent.Change, function (arg) {
            viewer.showFamilyTypeById(arg.id);
            viewer.render();
        });

        return familyList;
    };

    buttonNS.FamilyList = FamilyList;
})();

(function () {
    var panelNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Panel");
    var modelTreePanel;
    var createTreeNode = function createTreeNode(data) {
        if (!data) {
            return;
        }
        var config = new Glodon.Bimface.UI.Tree.TreeNodeConfig();
        switch (data.type) {
            case "floor":
                data.type = "levelName";
                config.isChecked = true;
                config.hasCheckbox = true;
                config.selection = true;
                break;
            case "category":
                data.type = "categoryId";
                config.isChecked = true;
                config.hasCheckbox = true;
                config.selection = true;
                break;
            case "specialty":
                config.isChecked = true;
                config.hasCheckbox = true;
                config.selection = true;
                break;
            case "family":
            case "familyType":
            default:
                config.isChecked = false;
                config.hasCheckbox = false;
                config.selection = false;
                break;
        }
        var node = new Glodon.Bimface.UI.Tree.TreeNode(config);
        node.element.setAttribute("data-filter", data.type);
        if (data.type == "categoryId") {
            node.setData(data.id, data.name);
        } else {
            if (data.name == "未设专业") {
                node.setData("", data.name);
            } else {
                node.setData(data.name, data.name);
            }
        }

        if (data.items && data.items.length > 0) {
            for (var i = 0, len = data.items.length; i < len; i++) {
                node.addChildNode(createTreeNode(data.items[i]));
            }
        }
        return node;
    };
    var ModelTreePanel = function ModelTreePanel(viewer, rootElement, toolbar) {
        if (modelTreePanel) {
            modelTreePanel.show();
            return modelTreePanel;
        }
        var config = new Glodon.Bimface.UI.Panel.PanelConfig();
        config.title = "构件树";
        config.css = {
            left: "10px",
            top: "10px",
            width: "300px",
            height: "416px"
        };
        modelTreePanel = new Glodon.Bimface.UI.Panel.Panel(config);
        viewer.getModeTree(function (data, modelType) {
            if (!data || data.length == 0) {
                return;
            }
            var config = new Glodon.Bimface.UI.Tree.TreeNodeConfig();
            config.isChecked = true;
            config.hasCheckbox = true;
            config.selection = true;
            var rootNode = new Glodon.Bimface.UI.Tree.TreeNode(config);
            rootNode.element.setAttribute("data-filter", "root");
            rootNode.setData("all", "全部分类");
            rootNode.expand();
            var tree = new Glodon.Bimface.UI.Tree.Tree(rootNode);
            if (modelType == "singleModel") {
                for (var i = 0, len = data.length; i < len; i++) {
                    if (len == 1 && data[i].type == "floor") {
                        var items = data[i].items;
                        for (var j = 0; j < items.length; j++) {
                            rootNode.addChildNode(createTreeNode(items[j]));
                        }
                    } else {
                        rootNode.addChildNode(createTreeNode(data[i]));
                    }
                }
            } else {
                for (var i = 0, len = data.items.length; i < len; i++) {
                    rootNode.addChildNode(createTreeNode(data.items[i]));
                }
            }
            tree.addEventListener('CheckedChanged', function () {
                var conditions = tree.getChecked();
                if (conditions == "all") {
                    conditions = null;
                }
                viewer.showExclusiveComponentsByObjectData(conditions);
                viewer.render();
            });
            tree.addEventListener('SelectionChanged', function () {
                var IsolateOption = Glodon.Bimface.Viewer.IsolateOption;
                var selection = tree.getSelection();
                if (selection) {
                    viewer.isolateComponentsByObjectData([selection], IsolateOption.MakeOthersTranslucent);
                } else {
                    viewer.isolateComponentsByObjectData();
                }
                viewer.render();
            });
            toolbar.modelTree = tree;
            modelTreePanel.addControl(tree);
        });

        modelTreePanel.addEventListener('Hide', function () {
            toolbar.show();
        });

        return modelTreePanel;
    };
    panelNS.ModelTreePanel = ModelTreePanel;
})();

(function () {
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");

    var ModelTree = function ModelTree(viewer, rootElement, toolbar) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;

        var config = new Glodon.Bimface.UI.Button.ButtonConfig();
        config.id = "ModelTree";
        config.title = "构件树";
        config.className = "bf-button gld-bf-tree";
        var tree = new Glodon.Bimface.UI.Button.Button(config);
        tree.addEventListener(controlEvent.Click, function () {
            toolbar.hide();
            var modelTreePanel = new Glodon.Bimface.Application.UI.Panel.ModelTreePanel(viewer, rootElement, toolbar);
            rootElement.appendChild(modelTreePanel.element);
        });
        return tree;
    };

    buttonNS.ModelTree = ModelTree;
})();

(function () {
    var panelNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Panel");

    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");

    var status = {
        menu: false,
        hobby: false,
        hover: false,
        scroll: false,
        color: 0,
        cur: 15
    };
    var SettingPanel = function SettingPanel(viewer) {
        var config = new Glodon.Bimface.UI.Panel.PanelConfig(),
            self = this;
        this.viewer = viewer;

        config.title = "设置";
        config.css = {
            left: "50%",
            top: "50%",
            transform: "translate(-50%,-200px)",
            width: "330px",
            height: "auto"
        };
        config.enableSizable = false;

        var colors = {
            1: new Glodon.Web.Graphics.Color(255, 255, 255, 1),
            2: new Glodon.Web.Graphics.Color(214, 214, 213, 1),
            3: new Glodon.Web.Graphics.Color(92, 92, 92, 1),
            4: new Glodon.Web.Graphics.Color(0, 0, 0, 1),
            5: new Glodon.Web.Graphics.Color(134, 157, 180, 1),
            6: new Glodon.Web.Graphics.Color(50, 71, 91, 1)
        };

        var settingPanel = new Glodon.Bimface.UI.Panel.Panel(config);
        var settingTabHtml = DomNS.create('div', 'bf-setting-tabs');
        var settingInnerHtml = DomNS.create('form', 'bf-setting');
        var navHtml = "\n      <span data-tab=\"tab1\" class=\"tab-left selected\">\u4EA4\u4E92\u8BBE\u7F6E</span><span data-tab=\"tab2\" class=\"tab-right\">\u6548\u679C\u8BBE\u7F6E</span>\n    ";
        var html = "<ul class=\"tab1 show\">\n        <li class=\"bf-setting-li radio\">\n        <span class=\"bf-setting-name\">\u53F3\u952E\u83DC\u5355\uFF1A</span>\n         <div class=\"bf-setting-value bf-small contextmenu\">\n        <label class=\"bf-label bf-checked\">\n        <span class=" + (status.menu ? "icon-nochecked" : "icon-checked") + "></span>\n        <input type=\"radio\" class=\"bf-orbit\" name=\"orbit\" value=\"Left\" " + (!status.menu ? "" : 'checked="true"') + ">\n        <span class=\"bf-radio\">\u5F00\u542F</span>\n        </label>\n        <label class=\"bf-label\">\n        <span class=" + (!status.menu ? "icon-nochecked" : "icon-checked") + "></span>\n        <input type=\"radio\" class=\"bf-orbit\" name=\"orbit\" value=\"Right\"" + (status.menu ? "" : 'checked="true"') + ">\n        <span class=\"bf-radio\">\u5173\u95ED</span>\n        </label>\n        </div>\n        </li>\n\n        <li class=\"bf-setting-li radio\">\n        <span class=\"bf-setting-name\">\u9F20\u6807\u4E60\u60EF\uFF1A</span>\n    <div class=\"bf-setting-value bf-small hobby\">\n        <label class=\"bf-label bf-checked\">\n        <span class=" + (status.hobby ? "icon-nochecked" : "icon-checked") + "></span>\n        <input type=\"radio\" class=\"bf-orbit\" name=\"orbit\" value=\"Left\" " + (!status.hobby && 'checked="true"') + ">\n        <span class=\"bf-radio\">\u5DE6\u952E\u65CB\u8F6C</span>\n        </label>\n        <label class=\"bf-label\">\n        <span class=" + (!status.hobby ? "icon-nochecked" : "icon-checked") + "></span>\n        <input type=\"radio\" class=\"bf-orbit\" name=\"orbit\" value=\"Right\"" + (status.hobby && 'checked="true"') + ">\n        <span class=\"bf-radio\">\u53F3\u952E\u65CB\u8F6C</span>\n        </label>\n        </div>\n        </li>\n\n        <li class=\"bf-setting-li checkbox\">\n        <span class=\"bf-setting-name\">\u9F20\u6807\u60AC\u505C\uFF1A</span>\n    <label class=\" bf-checkbox\">\n        <span class=\"radioBox gld-bf-selected " + (status.hover ? 'checked' : '') + "\"></span>\n        <input type=\"checkbox\" class=\"bf-orbit hover\" name=\"orbit\" value=\"Left\" checked=\"true\">\n        <span class=\"bf-radio\">\u6784\u4EF6\u9F20\u6807\u60AC\u505C\u6548\u679C</span>\n        </label>\n        </li>\n        <li class=\"bf-setting-li checkbox\">\n        <span class=\"bf-setting-name\">\u9F20\u6807\u6EDA\u52A8\uFF1A</span>\n    <label class=\" bf-checkbox\">\n        <span class=\"radioBox gld-bf-selected " + (status.scroll ? 'checked' : '') + "\"></span>\n        <input type=\"checkbox\" class=\"bf-orbit scroll\" name=\"orbit\" value=\"Left\" checked=\"true\">\n        <span class=\"bf-radio\">\u53CD\u8F6C\u9F20\u6807\u7F29\u653E\u65B9\u5411</span>\n        </label>\n        </li>\n        </ul>\n\n        <ul class=\"tab2 \">\n        <li class=\"bf-setting-li\">\n        <span class=\"bf-setting-name\">\u6E32\u67D3\u5E27\u7387\uFF1A</span>\n    <div class=\"bf-setting-value bf-FPS\" ></div>\n        </li>\n\n        <li class=\"bf-setting-li\">\n        <span class=\"bf-setting-name\">\u80CC\u666F\u8272\uFF1A</span>\n    <div class=\"bf-color\">\n        <label class=\"bf-color-item\">\n        <input type=\"radio\" name=\"color\" class=\"bf-color-input\" value=\"1\" " + (status.color == 0 && 'checked="checked"') + " />\n        <span class=\"bf-radio\"  style=\"background:#fff;\"></span>\n        </label>\n        <label class=\"bf-color-item\" value=\"2\">\n        <input type=\"radio\" name=\"color\" class=\"bf-color-input\" value=\"2\" " + (status.color == 1 && 'checked="checked"') + " />\n        <span class=\"bf-radio\" style=\"background:#d6d6d5;\"></span>\n        </label>\n        <label class=\"bf-color-item\">\n        <input type=\"radio\" name=\"color\" class=\"bf-color-input\" value=\"3\" " + (status.color == 2 && 'checked="checked"') + " />\n        <span class=\"bf-radio\" style=\"background:#5c5c5c;\"></span>\n        </label>\n        <label class=\"bf-color-item\">\n        <input type=\"radio\" name=\"color\" class=\"bf-color-input\" value=\"4\"  " + (status.color == 3 && 'checked="checked"') + "/>\n        <span class=\"bf-radio\" style=\"background:#000000;\"></span>\n        </label>\n        <label class=\"bf-color-item\">\n        <input type=\"radio\" name=\"color\" class=\"bf-color-input\" value=\"5\"  " + (status.color == 4 && 'checked="checked"') + "/>\n        <span class=\"bf-radio\" style=\"background:#869db4;\"></span>\n        </label>\n        <label class=\"bf-color-item\">\n        <input type=\"radio\" name=\"color\" class=\"bf-color-input\" value=\"6\" " + (status.color == 5 && 'checked="checked"') + " />\n        <span class=\"bf-radio\" style=\"background:#32475b;\"></span>\n        </label>\n        </div>\n        </li>\n        </ul>\n        <div class=\"bf-reset\">\n        <span class=\"reset\">\u6062\u590D\u9ED8\u8BA4\u8BBE\u7F6E</span>\n        </div>";
        settingInnerHtml.innerHTML = html;
        settingTabHtml.innerHTML = navHtml;
        settingTabHtml.onclick = function (event) {
            var target = event.target,
                tabName = target.getAttribute('data-tab'),
                sibling = target.previousElementSibling || target.nextElementSibling,
                isSelected = target.hasClass('selected');
            if (!isSelected) {
                target.toggleClass('selected');
                sibling.toggleClass('selected');
                document.querySelector('.tab1').toggleClass('show');
                document.querySelector('.tab2').toggleClass('show');
            }
        };
        //右键菜单
        var radios = settingInnerHtml.querySelectorAll('.contextmenu input');
        for (var i = 0, len = radios.length; i < len; i++) {
            radios[i].addEventListener('change', function () {
                var sibling = this.previousElementSibling,
                    checked = sibling.hasClass('icon-checked');

                if (!checked) {
                    self.viewer.toggleContextMenuDisplay();
                } else {}
                var radio = settingInnerHtml.querySelector('.contextmenu .icon-checked');
                radio.removeClass('icon-checked');
                radio.addClass('icon-nochecked');
                sibling.toggleClass('icon-checked');
                sibling.toggleClass('icon-nochecked');
                status.menu = !status.menu;
            });
        }
        //鼠标习惯
        var radios = settingInnerHtml.querySelectorAll('.hobby input');
        for (var _i = 0, _len = radios.length; _i < _len; _i++) {
            radios[_i].addEventListener('change', function () {
                var sibling = this.previousElementSibling,
                    checked = sibling.hasClass('icon-checked');
                if (!checked) {
                    viewer.setUseLeftHandedInput(this.value == 'Left' && true || false);
                }
                var radio = settingInnerHtml.querySelector('.hobby .icon-checked');
                radio.removeClass('icon-checked');
                radio.addClass('icon-nochecked');
                sibling.toggleClass('icon-checked');
                sibling.toggleClass('icon-nochecked');
                status.hobby = !status.hobby;
            });
        }
        //鼠标悬停
        var hover = settingInnerHtml.querySelector('.hover');
        hover.addEventListener('change', function () {
            var sibling = this.previousElementSibling,
                checked = sibling.hasClass('checked');
            viewer.enableHover(!checked);

            sibling.toggleClass('checked');
            status.hover = !status.hover;
        });

        //鼠标滚动
        var scroll = settingInnerHtml.querySelector('.scroll');
        scroll.addEventListener('change', function () {
            var sibling = this.previousElementSibling,
                checked = sibling.hasClass('checked');
            viewer.setReverseWheelDirection(!checked);
            sibling.toggleClass('checked');
            status.scroll = !status.scroll;
        });
        //背景颜色选择
        var colorPan = settingInnerHtml.querySelectorAll('.bf-color input');

        var _loop = function _loop(_i2, _len2) {
            colorPan[_i2].addEventListener('change', function () {
                var color = colors[this.value];
                viewer.setBackgroundColor(color);
                status.color = _i2;
            });
        };

        for (var _i2 = 0, _len2 = colorPan.length; _i2 < _len2; _i2++) {
            _loop(_i2, _len2);
        }
        //重置
        var reset = settingInnerHtml.querySelector('.reset');
        reset.addEventListener('click', function () {
            settingInnerHtml.querySelector('.bf-color input').click();
            if (status.scroll) {
                settingInnerHtml.querySelector('.scroll').click();
            }
            if (status.hover) {
                settingInnerHtml.querySelector('.hover').click();
            }
            settingInnerHtml.querySelector('.hobby input').click();
            settingInnerHtml.querySelector('.contextmenu input').click();

            settingInnerHtml.querySelector('.bf-input-range').value = 15;
            FPS.reset();
            status.cur = 15;
            viewer.setMinimumFPS(15);
        });
        var FPS = new Glodon.Web.Lang.Utility.Dom.range({
            element: settingInnerHtml.getElementsByClassName('bf-FPS')[0],
            min: 4,
            max: 60,
            cur: status.cur,
            change: function change(value) {
                viewer.setMinimumFPS(parseInt(value));
                status.cur = value;
            }
        });

        settingPanel.cantainer.appendChild(settingTabHtml);
        settingPanel.cantainer.appendChild(settingInnerHtml);

        return settingPanel;
    };
    panelNS.SettingPanel = SettingPanel;
})();

(function () {
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");

    var Setting = function Setting(viewer, rootElement) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;
        if (!isViewer3D) {
            console.log('The API is not supported on this viewer.');
            return;
        }
        var config = new Glodon.Bimface.UI.Button.ButtonConfig();
        config.id = "Setting";
        config.title = "设置";
        config.className = "bf-button gld-bf-settings";
        var button = new Glodon.Bimface.UI.Button.ToggleButton(config);
        var SettingPanel;
        button.addEventListener(controlEvent.Click, function () {
            if (button.isChecked()) {
                if (SettingPanel) {
                    return SettingPanel.show();
                }
                SettingPanel = new Glodon.Bimface.Application.UI.Panel.SettingPanel(viewer);
                SettingPanel.addEventListener("Hide", function () {
                    button.setCheckedState(false);
                    SettingPanel.toggle();
                });
                viewer.render();
                rootElement.appendChild(SettingPanel.element);
            } else {

                SettingPanel.toggle();
            }
        });
        return button;
    };

    buttonNS.Setting = Setting;
})();

(function () {
    var panelNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Panel");

    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");

    var status = {
        lock: false,
        click: true
    };
    var WalkPanel = function WalkPanel(viewer, rootElement) {
        var self = this,
            Panel = {
            WalkMenu: {
                element: rootElement,
                speedIndex: 2,
                className: 'bf-panel bf-walk-panel',
                css: {
                    left: "50%",
                    bottom: "46px",
                    borderRadius: "3px",
                    background: "rgba(0, 0, 0, 0.6)",
                    transform: "translate(-50%,-50%)",
                    width: "390px",
                    minWidth: 0,
                    minHeight: 0,
                    height: "50px"
                },
                title: '',
                easyMode: true,
                enableSizable: false
            },
            WalkSetting: {
                element: rootElement,
                title: "漫游设置",
                className: 'bf-panel bf-walksetting-panel',
                css: {
                    left: "50%",
                    top: "50%",
                    transform: "translate(-50%,-50%)",
                    width: "330px",
                    height: '207px'
                },
                enableSizable: true
            }
        };

        var speedArr = ['0.50', '0.75', '1.00', '1.50', '2.00'],
            view = document.getElementById('cloud-main-canvas'),
            originalViewer = viewer.getViewer();

        if (!self.WalkMenuPanel) {
            var setText = function setText() {
                var specialNum = speedArr[Panel.WalkMenu.speedIndex];
                speedNum[0].innerText = specialNum + 'X';
                speedNum[1] && (speedNum[1].innerText = specialNum + 'X');
                originalViewer.setMovementSpeedRate((specialNum - 0) / 2);
            };

            var plus = function plus() {

                if (2 - speedArr[Panel.WalkMenu.speedIndex] > 0) {

                    ++Panel.WalkMenu.speedIndex;
                    setText();
                }
            };

            var minus = function minus() {
                if (speedArr[Panel.WalkMenu.speedIndex] - 0.5 > 0) {
                    --Panel.WalkMenu.speedIndex;
                    setText();
                }
            };

            var WalkMenuPanel = new Glodon.Bimface.Application.Panel(Panel.WalkMenu);
            var WalkInnerHtml = DomNS.create('div', 'bf-person');
            var html = "<span class=\"person-text\">\u8BF7\u4F7F\u7528<em class=\"orange\">WSAD</em>\u548C<em class=\"orange\">QE</em>\u79FB\u52A8</span>\n                  <div class=\"person-btns\"><span class=\" gld-bf-minus  speedBtn\"></span><span class=\"speedNum\">" + speedArr[Panel.WalkMenu.speedIndex] + "X</span><span class=\" gld-bf-add speedBtn\"></span><span class=\"setting\">\u8BBE\u7F6E</span></div>";
            WalkInnerHtml.innerHTML = html;
            WalkInnerHtml.querySelector('.gld-bf-add').addEventListener('click', plus);
            WalkInnerHtml.querySelector('.gld-bf-minus').addEventListener('click', minus);

            var settingBtn = WalkInnerHtml.getElementsByClassName('setting')[0];
            settingBtn.onclick = function () {
                if (!self.WalkSettingPanel) {
                    var SettingPanel = new Glodon.Bimface.Application.Panel(Panel.WalkSetting);
                    var settingInnerHtml = DomNS.create('form', 'bf-setting');
                    var html = "<ul class='person-setting'>\n                          <li class=\"bf-setting-li\">\n                          <span class=\"bf-setting-name\">\u79FB\u52A8\u901F\u7387\uFF1A</span>\n                      <div class=\"person-btns\"><span  class=\"speedBtn  gld-bf-minus\"></span><span class=\"speedNum\">" + speedArr[Panel.WalkMenu.speedIndex] + "X</span><span class=\"speedBtn  gld-bf-add\"></span></div>\n                          </li>\n                          <li class=\"bf-setting-li lock\">\n                          <span class=\"bf-setting-name\">\u9501\u5B9A\u6807\u9AD8\uFF1A</span>\n\n                      <label class=\" bf-checkbox\">\n                          <span class=\"radioBox gld-bf-selected " + (status.lock ? 'checked' : '') + "\"></span>\n                          <input type=\"checkbox\" class=\"bf-orbit scroll\" name=\"orbit\" value=\"Left\" checked=\"true\">\n                          <span class=\"bf-radio\">\u9501\u5B9A</span>\n                          </label>\n\n\n\n                          </li>\n                          <li class=\"bf-setting-li\">\n                          <span class=\"bf-setting-name\">\u5207\u6362\u89C6\u89D2\uFF1A</span>\n                      <div class=\"bf-setting-value bf-small viewpoint\">\n\n                          <label class=\"bf-label bf-checked\">\n                          <span class=" + (!status.click ? "icon-nochecked" : "icon-checked") + "></span>\n                      <input type=\"radio\" class=\"bf-orbit\" name=\"orbit\" value=\"Left\" " + (!status.click ? "" : 'checked="true"') + ">\n                          <span class=\"bf-radio\">\u9F20\u6807\u6309\u4F4F\u6ED1\u52A8</span>\n                          </label>\n                          <label class=\"bf-label\">\n                          <span class=" + (status.click ? "icon-nochecked" : "icon-checked") + "></span>\n                      <input type=\"radio\" class=\"bf-orbit\" name=\"orbit\" value=\"Right\"" + (status.click ? "" : 'checked="true"') + ">\n                          <span class=\"bf-radio\">\u9F20\u6807\u6ED1\u52A8</span>\n                          </label>\n\n\n                          </div>\n                          </li>\n\n                          </ul>\n                          <div class=\"bf-reset-wrap\">\n                          <span class=\"person-reset \">\u6062\u590D\u9ED8\u8BA4\u8BBE\u7F6E</span>\n                          </div>";
                    settingInnerHtml.innerHTML = html;

                    //切换视角
                    var radios = settingInnerHtml.querySelectorAll('.viewpoint input');
                    for (var i = 0, len = radios.length; i < len; i++) {
                        radios[i].addEventListener('change', function () {
                            var sibling = this.previousElementSibling,
                                checked = sibling.hasClass('icon-checked');

                            originalViewer.setWalkLookMousePressed(!status.click);
                            var radio = settingInnerHtml.querySelector('.viewpoint .icon-checked');
                            radio.removeClass('icon-checked');
                            radio.addClass('icon-nochecked');
                            sibling.toggleClass('icon-checked');
                            sibling.toggleClass('icon-nochecked');
                            status.click = !status.click;
                        });
                    }
                    //锁定标高
                    var lock = settingInnerHtml.querySelector('.lock input');
                    lock.addEventListener('change', function () {
                        var sibling = this.previousElementSibling,
                            checked = sibling.hasClass('checked');

                        originalViewer.setWalkHeightLocked(!checked);
                        sibling.toggleClass('checked');
                        status.lock = !status.lock;
                    });

                    var checkbox = settingInnerHtml.querySelector('.gld-bf-selected');
                    var mode = settingInnerHtml.querySelector('.viewpoint input');

                    settingInnerHtml.querySelector('.gld-bf-add').addEventListener('click', plus);
                    settingInnerHtml.querySelector('.gld-bf-minus').addEventListener('click', minus);
                    checkbox.addEventListener('click', function () {
                        if (this.checked) {} else {}
                    });
                    settingInnerHtml.querySelector('.person-reset').addEventListener('click', function () {

                        if (status.lock) {
                            checkbox.click();
                        }
                        if (!status.click) {
                            mode.click();
                        }

                        Panel.WalkMenu.speedIndex = 2;
                        setText();
                    });

                    SettingPanel.cantainer.appendChild(settingInnerHtml);

                    self.WalkSettingPanel = SettingPanel;
                    WalkMenuPanel.WalkSettingPanel = SettingPanel;

                    setText();
                } else {
                    self.WalkSettingPanel.toggle();
                }
            };
            WalkMenuPanel.cantainer.appendChild(WalkInnerHtml);
            self.WalkMenuPanel = WalkMenuPanel;
            var speedNum = document.getElementsByClassName('speedNum');
        } else {
            self.WalkMenuPanel.show();
        }

        self.WalkMenuPanel = WalkMenuPanel;

        WalkMenuPanel.hideSettingPanel = function () {
            if (this.WalkSettingPanel) {
                this.WalkSettingPanel.hide();
            }
        };
        return WalkMenuPanel;
    };

    panelNS.WalkPanel = WalkPanel;
})();

(function () {
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");

    var Walk = function Walk(viewer, rootElement, toolbar) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;
        if (!isViewer3D) {
            console.log('The API is not supported on this viewer.');
            return;
        }
        var config = new Glodon.Bimface.UI.Button.ButtonConfig();
        config.id = "Walk";
        config.title = "漫游模式";
        config.className = "bf-button gld-bf-firstperson";
        var button = new Glodon.Bimface.UI.Button.ToggleButton(config);
        var WalkPanel,
            mode,
            originalViewer = viewer.getViewer();
        button.addEventListener(controlEvent.StateChange, function () {
            var measureButton = toolbar.getControl("Measure");
            if (button.isChecked()) {
                var rectangleSelectButton = toolbar.getControl("RectangleSelect");
                rectangleSelectButton.setCheckedState(false);
                viewer.setNavigationMode(Glodon.Bimface.Viewer.NavigationMode3D.PickWithRect);

                mode = originalViewer.getCurrentEditorName();

                //判断测量状态
                if (measureButton.isChecked()) {
                    var measurePanel = document.querySelector('.bf-measure-panel');
                    measurePanel.style.bottom = '130px';
                }

                //判断剖切状态
                var sectionButton = toolbar.getControl("Section");
                if (sectionButton.isChecked()) {
                    sectionButton.setCheckedState(false);
                }

                originalViewer.setEditorMode('walk');
                if (WalkPanel) {
                    return WalkPanel.show();
                }

                WalkPanel = new Glodon.Bimface.Application.UI.Panel.WalkPanel(viewer, rootElement);
                WalkPanel.addEventListener("Hide", function () {
                    button.setCheckedState(false);
                    WalkPanel.toggle();
                    originalViewer.setEditorMode(mode);
                });
                viewer.render();
                rootElement.appendChild(WalkPanel.element);
            } else {
                originalViewer.setEditorMode(mode);
                WalkPanel.toggle();
                WalkPanel.hideSettingPanel();
                //判断测量状态

                if (measureButton.isChecked()) {
                    var measurePanel = document.querySelector('.bf-measure-panel');
                    measurePanel.style.bottom = '70px';
                }
            }
        });
        return button;
    };

    buttonNS.Walk = Walk;
})();

(function () {
    var toolbarNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Toolbar");
    var MainToolbarConfig = function MainToolbarConfig() {
        var defaults = {
            id: "MainToolbar",
            title: "主菜单",
            className: "bf-toolbar bf-toolbar-bottom",
            buttons: ["Home", "Person", "OrbitButton", "RectangleSelect", "Measure", "Section", "Annotation", "Property", "Information", "Setting", "FullScreen"]
        };
        var toolbarConfig = new Glodon.Bimface.UI.Toolbar.ToolbarConfig();
        var config = Object.assign({}, toolbarConfig, defaults);
        return config;
    };

    toolbarNS.MainToolbarConfig = MainToolbarConfig;
})();

(function () {
    var toolbarNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Toolbar");
    var SectionToolbarConfig = function SectionToolbarConfig() {
        var defaults = {
            id: "SectionToolbar",
            title: "剖切",
            buttons: ["SectionVisiable", "SectionRotate", "SectionReset"]
        };
        var toolbarConfig = new Glodon.Bimface.UI.Toolbar.ToolbarConfig();
        var config = Object.assign({}, toolbarConfig, defaults);
        return config;
    };

    toolbarNS.SectionToolbarConfig = SectionToolbarConfig;
})();

(function () {
    var toolbarNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Toolbar");
    var FamilyListConfig = function FamilyListConfig() {
        var defaults = {
            id: "FamilyTypes",
            title: "FamilyTypes",
            className: "bf-toolbar bf-toolbar bf-toolbar-select",
            buttons: ["FamilyList"]
        };
        var toolbarConfig = new Glodon.Bimface.UI.Toolbar.ToolbarConfig();
        var config = Object.assign({}, toolbarConfig, defaults);
        return config;
    };

    toolbarNS.FamilyListConfig = FamilyListConfig;
})();

(function () {
    var toolbarNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Toolbar");
    var ModelTree = function ModelTree() {
        var defaults = {
            id: "ModelTree",
            title: "ModelTree",
            className: "bf-toolbar bf-toolbar bf-tree-toolbar",
            buttons: ["ModelTree"]
        };
        var toolbarConfig = new Glodon.Bimface.UI.Toolbar.ToolbarConfig();
        var config = Object.assign({}, toolbarConfig, defaults);
        return config;
    };

    toolbarNS.ModelTree = ModelTree;
})();

(function () {
    var toolbarNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Toolbar");
    var buttonNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Button");
    var Toolbar = function Toolbar(config) {
        var toolbar = new Glodon.Bimface.UI.Toolbar.Toolbar(config);
        for (var i = 0, len = config.buttons.length; i < len; i++) {
            if (buttonNS[config.buttons[i]]) {
                var button = buttonNS[config.buttons[i]](config.viewer, config.element, toolbar);
                toolbar.addControl(button);
            }
        }
        return toolbar;
    };
    toolbarNS.Toolbar = Toolbar;
})();

(function () {
    var menuNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application.UI.Menu");

    var ContextMenu = function ContextMenu(viewer, rootElement, selectedComponents, modelTree) {
        var isViewer3D = viewer instanceof Glodon.Bimface.Viewer.Viewer3D;
        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;

        var controlEvent = Glodon.Bimface.UI.Control.ControlEvent;
        var menuConfig = new Glodon.Bimface.UI.Menu.MenuConfig();
        menuConfig.element = rootElement;
        var contextMenu = new Glodon.Bimface.UI.Menu.Menu(menuConfig);
        var hideContextMenu = function hideContextMenu() {
            if (contextMenu) {
                contextMenu.destroy();
                contextMenu = null;
            }
        };
        self._contextMenu = contextMenu;

        var hideComponentsConfig = new Glodon.Bimface.UI.Menu.MenuItemConfig();
        hideComponentsConfig.id = "HideComponents";
        var hideComponents = new Glodon.Bimface.UI.Menu.MenuItem(hideComponentsConfig);
        hideComponents.setText("隐藏选中构件");
        hideComponents.addEventListener(controlEvent.Click, function () {
            viewer.hideComponents(selectedComponents);
            viewer.setSelectedComponentsById();
            viewer.render();
            hideContextMenu();
        });

        var setComponentsOpacityConfig = new Glodon.Bimface.UI.Menu.MenuItemConfig();
        setComponentsOpacityConfig.id = "SetComponentsOpacityssddd";
        var setComponentsOpacity = new Glodon.Bimface.UI.Menu.MenuItem(setComponentsOpacityConfig);
        setComponentsOpacity.setText("半透明选中构件");
        setComponentsOpacity.addEventListener(controlEvent.Click, function () {
            viewer.setComponentsOpacity(selectedComponents, Glodon.Bimface.Viewer.OpacityOption.Translucent);
            viewer.setSelectedComponentsById();
            viewer.render();
            hideContextMenu();
        });

        var isolateMenuConfig = new Glodon.Bimface.UI.Menu.MenuConfig();
        isolateMenuConfig.id = "IsolateMenu";
        isolateMenuConfig.isSubMenu = true;
        isolateMenuConfig.text = "隔离选中构件";
        isolateMenuConfig.className = "bf-sub-menu";
        var isolateMenu = new Glodon.Bimface.UI.Menu.Menu(isolateMenuConfig);

        var hideOthersConfig = new Glodon.Bimface.UI.Menu.MenuItemConfig();
        hideOthersConfig.id = "HideOthers";
        var hideOthers = new Glodon.Bimface.UI.Menu.MenuItem(hideOthersConfig);
        hideOthers.setText("其他构件隐藏");
        hideOthers.addEventListener(controlEvent.Click, function () {
            viewer.isolateComponentsById(selectedComponents, Glodon.Bimface.Viewer.IsolateOption.HideOthers);
            viewer.setSelectedComponentsById();
            viewer.render();
            hideContextMenu();
        });

        var makeOthersTranslucentConfig = new Glodon.Bimface.UI.Menu.MenuItemConfig();
        makeOthersTranslucentConfig.id = "MakeOthersTranslucent";
        var makeOthersTranslucent = new Glodon.Bimface.UI.Menu.MenuItem(makeOthersTranslucentConfig);
        makeOthersTranslucent.setText("其他构件半透明");
        makeOthersTranslucent.addEventListener(controlEvent.Click, function () {
            viewer.isolateComponentsById(selectedComponents, Glodon.Bimface.Viewer.IsolateOption.MakeOthersTranslucent);
            viewer.setSelectedComponentsById();
            viewer.render();
            hideContextMenu();
        });
        isolateMenu.addControl(hideOthers);
        isolateMenu.addControl(makeOthersTranslucent);

        var spacer = new Glodon.Bimface.UI.Menu.Spacer();

        var showAllConfig = new Glodon.Bimface.UI.Menu.MenuItemConfig();
        showAllConfig.id = "ShowAll";
        var showAll = new Glodon.Bimface.UI.Menu.MenuItem(showAllConfig);
        showAll.setText("显示所有");
        showAll.addEventListener(controlEvent.Click, function () {
            if (modelTree) {
                modelTree._root.setCheckedState(true);
            }
            viewer.showAllComponents();
            viewer.render();
            hideContextMenu();
        });

        contextMenu.addControl(hideComponents);
        contextMenu.addControl(setComponentsOpacity);
        contextMenu.addControl(isolateMenu);
        contextMenu.addControl(spacer);
        contextMenu.addControl(showAll);

        if (selectedComponents && selectedComponents.length == 0) {
            hideComponents.disabled();
            setComponentsOpacity.disabled();
            isolateMenu.disabled();
            hideOthers.disabled();
            makeOthersTranslucent.disabled();
        }

        rootElement.addEventListener("mousedown", function (target) {
            hideContextMenu();
        });
        var viewerDom = viewer.getDomElement();
        viewerDom.addEventListener("mousedown", function (target) {
            hideContextMenu();
        });

        return contextMenu;
    };

    menuNS.ContextMenu = ContextMenu;
})();

(function () {
    var appNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application");
    var viewNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    var utilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var WebApplication3D = function WebApplication3D(options) {
        var self = this;
        var toolbars = [];
        var viewConfig = options;
        var rootElement = DomNS.create('div', 'bf-container');
        options.domElement.appendChild(rootElement);
        viewConfig.domElement = rootElement;

        this.getViewer = function () {
            return viewer3D;
        };
        this.getEventManager = function () {
            return eventManager;
        };
        this.getToolbars = function () {
            return toolbars;
        };
        this.getToolbar = function (id) {
            if (id == "LeftToolbar") {
                id = "ModelTree";
            }
            return toolbars.getObjectByAttribute('id', id);
        };
        this.render = function () {
            this.getViewer().render();
        };
        this.addView = function (viewToken) {
            viewer3D.addView(viewToken);
        };
        this.getAnnotationManager = function () {
            return mainToolbar.getControl("Annotation")._annotationManager;
        };
        this.addEventListener = Glodon.Bimface.Viewer.Viewer3D.prototype.addEventListener;
        this.removeEventListener = Glodon.Bimface.Viewer.Viewer3D.prototype.removeEventListener;
        var mainToolbar;
        var viewer3D = new Glodon.Bimface.Viewer.Viewer3D(viewConfig);
        var events = Glodon.Bimface.Viewer.Viewer3DEvent;
        var eventManager = viewer3D.getEventManager();
        viewer3D.addEventListener(events.ViewAdded, function (viewer) {
            var metaData = viewer._data;
            if (viewConfig.Toolbars.indexOf("MainToolbar") != -1) {
                var mainToolbarConfig = Glodon.Bimface.Application.UI.Toolbar.MainToolbarConfig();
                mainToolbarConfig.element = rootElement;
                mainToolbarConfig.viewer = viewer3D;
                mainToolbarConfig.buttons = viewConfig.Buttons;
                if (!metaData.isSupportComponentProperty) {
                    mainToolbarConfig.buttons.removeByValue("Property");
                }
                mainToolbar = Glodon.Bimface.Application.UI.Toolbar.Toolbar(mainToolbarConfig);
                toolbars.push(mainToolbar);
                mainToolbar.resetState = function () {
                    var orbitButton = mainToolbar.getControl("OrbitButton"),
                        NavigationMode = Glodon.Bimface.Viewer.NavigationMode3D;
                    if (!orbitButton) {
                        viewer3D.setNavigationMode(NavigationMode.Select);
                        return;
                    }
                    var type = orbitButton.getCurrentControl().id,
                        events = {
                        OrbitPoint: NavigationMode.Select,
                        OrbitCamera: NavigationMode.Fly
                    };
                    viewer3D.setNavigationMode(events[type]);

                    var walkButton = this.getControl("Walk");
                    if (walkButton && walkButton._checked) {
                        var originalViewer = viewer3D.getViewer();
                        originalViewer.setEditorMode('walk');
                    }
                };
            }
            if (metaData.isSupportModelTree && viewConfig.Toolbars.indexOf("ModelTree") != -1) {
                var modelTreeConfig = Glodon.Bimface.Application.UI.Toolbar.ModelTree();
                modelTreeConfig.element = rootElement;
                modelTreeConfig.viewer = viewer3D;
                var modelTree = Glodon.Bimface.Application.UI.Toolbar.Toolbar(modelTreeConfig);
                self._modelTree = modelTree;
                toolbars.push(modelTree);
            }
            if (metaData.isSupportFamilyTypeList) {
                var familyListConfig = Glodon.Bimface.Application.UI.Toolbar.FamilyListConfig();
                familyListConfig.element = rootElement;
                familyListConfig.viewer = viewer3D;
                var familyList = Glodon.Bimface.Application.UI.Toolbar.Toolbar(familyListConfig);
                toolbars.push(familyList);
            }
        });

        viewer3D.addEventListener(events.ContextMenu, function (viewer, position) {
            var arr = [],
                selections = viewer.getSelectedComponents();
            for (var key in selections) {
                if (key) {
                    arr.push(key);
                }
            }
            if (!self.disableContextMenu) {
                var contextMenu = new Glodon.Bimface.Application.UI.Menu.ContextMenu(viewer3D, rootElement, arr, self._modelTree.modelTree);
                self._contextMenu = contextMenu;
                contextMenu.setPosition({
                    x: position.x,
                    y: position.y
                });
            }
        });

        //模型聚焦
        rootElement.onclick = function () {

            var activeElement = document.activeElement,
                canvas = document.getElementById('cloud-main-canvas');
            if (activeElement != canvas && activeElement.tagName != 'INPUT') {
                canvas.focus();
            }
        };
    };
    appNS.WebApplication3D = WebApplication3D;
})();

(function () {
    var appNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application");
    var WebApplicationRfaConfig = function WebApplicationRfaConfig() {
        var defaults = {
            Toolbars: ["MainToolbar", "FamilyList"],
            Buttons: ["Home", "Setting", "Information", "FullScreen"]
        };
        var viewer3DConfig = Glodon.Bimface.Viewer.Viewer3DConfig();
        var Config = Object.assign({}, defaults, viewer3DConfig);
        return Config;
    };

    appNS.WebApplicationRfaConfig = WebApplicationRfaConfig;
})();

(function () {
    var AppNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application");
    var WebApplicationRfaEvent = Object.freeze({
        "ViewAdded": "ViewAdded",
        "ViewLoading": "ViewLoading",
        "ComponentsSelectionChanged": "ComponentsSelectionChanged",
        "Error": "Error"
    });

    AppNS.WebApplicationRfaEvent = WebApplicationRfaEvent;
})();

(function () {
    var appNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application");
    var viewNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    var utilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var WebApplicationRfa = function WebApplicationRfa(options) {
        var self = this;
        var toolbars = [];
        var viewConfig = options;
        var rootElement = DomNS.create('div', 'bf-container');
        options.domElement.appendChild(rootElement);
        viewConfig.domElement = rootElement;

        this.getViewer = function () {
            return viewer3D;
        };
        this.getEventManager = function () {
            return eventManager;
        };
        this.getToolbars = function () {
            return toolbars;
        };
        this.getToolbar = function (id) {
            if (id == "LeftToolbar") {
                id = "FamilyList";
            }
            return toolbars.getObjectByAttribute('id', id);
        };
        this.render = function () {
            this.getViewer().render();
        };
        this.addView = function (viewToken) {
            viewer3D.addView(viewToken);
        };
        this.getAnnotationManager = function () {
            return mainToolbar.getControl("Annotation")._annotationManager;
        };
        this.addEventListener = Glodon.Bimface.Viewer.Viewer3D.prototype.addEventListener;
        this.removeEventListener = Glodon.Bimface.Viewer.Viewer3D.prototype.removeEventListener;
        var mainToolbar;
        var viewer3D = new Glodon.Bimface.Viewer.Viewer3D(viewConfig);
        var events = Glodon.Bimface.Viewer.Viewer3DEvent;
        var eventManager = viewer3D.getEventManager();
        viewer3D.addEventListener(events.ViewAdded, function (viewer) {
            var metaData = viewer._data;
            if (viewConfig.Toolbars.indexOf("MainToolbar") != -1) {
                var mainToolbarConfig = Glodon.Bimface.Application.UI.Toolbar.MainToolbarConfig();
                mainToolbarConfig.element = rootElement;
                mainToolbarConfig.viewer = viewer3D;
                mainToolbarConfig.buttons = viewConfig.Buttons;
                if (!metaData.isSupportComponentProperty) {
                    mainToolbarConfig.buttons.removeByValue("Property");
                }
                mainToolbar = Glodon.Bimface.Application.UI.Toolbar.Toolbar(mainToolbarConfig);
                toolbars.push(mainToolbar);
                mainToolbar.resetState = function () {
                    var orbitButton = mainToolbar.getControl("OrbitButton"),
                        NavigationMode = Glodon.Bimface.Viewer.NavigationMode3D;
                    if (!orbitButton) {
                        viewer3D.setNavigationMode(NavigationMode.Select);
                        return;
                    }
                    var type = orbitButton.getCurrentControl().id,
                        events = {
                        OrbitPoint: NavigationMode.Select,
                        OrbitCamera: NavigationMode.Fly
                    };
                    viewer3D.setNavigationMode(events[type]);
                };
            }
            if (metaData.isSupportModelTree && viewConfig.Toolbars.indexOf("ModelTree") != -1) {
                var modelTreeConfig = Glodon.Bimface.Application.UI.Toolbar.ModelTree();
                modelTreeConfig.element = rootElement;
                modelTreeConfig.viewer = viewer3D;
                var modelTree = Glodon.Bimface.Application.UI.Toolbar.Toolbar(modelTreeConfig);
                self._modelTree = modelTree;
                toolbars.push(modelTree);
            }
            if (metaData.isSupportFamilyTypeList) {
                var familyListConfig = Glodon.Bimface.Application.UI.Toolbar.FamilyListConfig();
                familyListConfig.element = rootElement;
                familyListConfig.viewer = viewer3D;
                var familyToolbar = Glodon.Bimface.Application.UI.Toolbar.Toolbar(familyListConfig);
                var familyList = familyToolbar.getControl("FamilyList");
                var currentFamily = familyList.getCurrentControl();
                viewer3D.showFamilyTypeById(currentFamily.getId());
                toolbars.push(familyToolbar);
            }
        });

        viewer3D.addEventListener(events.ContextMenu, function (viewer, position) {
            var arr = [],
                selections = viewer.getSelectedComponents();
            for (var key in selections) {
                if (key) {
                    arr.push(key);
                }
            }
            if (!self.disableContextMenu) {
                var contextMenu = new Glodon.Bimface.Application.UI.Menu.ContextMenu(viewer3D, rootElement, arr, self._modelTree.modelTree);
                self._contextMenu = contextMenu;
                contextMenu.setPosition({
                    x: position.x,
                    y: position.y
                });
            }
        });
    };
    appNS.WebApplicationRfa = WebApplicationRfa;
})();

(function () {
    var appNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application");
    var WebApplication2DConfig = function WebApplication2DConfig() {
        var defaults = {
            Toolbars: ["MainToolbar", "LeftSubToolbar"],
            Buttons: ["Home", "RectZoom", "FullScreen"]
        };
        var viewer2DConfig = Glodon.Bimface.Viewer.Viewer2DConfig();
        var Config = Object.assign({}, defaults, viewer2DConfig);
        return Config;
    };

    appNS.WebApplication2DConfig = WebApplication2DConfig;
})();

(function () {
    var AppNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application");
    var WebApplication2DEvent = Object.freeze({
        "Loaded": "Loaded",
        "Error": "Error"
    });

    AppNS.WebApplication2DEvent = WebApplication2DEvent;
})();

(function () {
    var appNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application");
    var Toolbar = function Toolbar(options) {
        var ToolbarConfig = new Glodon.Bimface.UI.Toolbar.ToolbarConfig();
        var config = Object.assign({}, ToolbarConfig, options);
        var Toolbar = new Glodon.Bimface.UI.Toolbar.Toolbar(config);
        return Toolbar;
    };
    var Toolbars = function Toolbars(arr) {
        var Toolbars = [];
        for (var i = 0, len = arr.length; i < len; i++) {
            Toolbars.push(Toolbar(arr[i]));
        }
        this._Toolbars = Toolbars;
    };

    Toolbars.prototype.getToolbar = function (id) {
        return this._Toolbars.getObjectByAttribute('id', id);
    };
    appNS.Toolbar = Toolbar;
    appNS.Toolbars = Toolbars;
})();

(function () {
    var appNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application");
    var Button = function Button(options) {
        var ButtonConfig = new Glodon.Bimface.UI.Button.ButtonConfig();
        var config = Object.assign({
            type: 'Button'
        }, ButtonConfig, options);
        var buttonEvent = Glodon.Bimface.UI.Control.ControlEvent;
        var Button = new Glodon.Bimface.UI.Button[config.type](config);
        for (var key in config.handles) {
            Button.addEventListener(key, config.handles[key]);
        }
        config.html && Button.setHtml(config.html);
        return Button;
    };
    var Buttons = function Buttons(arr) {
        var Buttons = [];
        for (var i = 0, len = arr.length; i < len; i++) {
            var button = Button(arr[i]);
            if (arr[i].type == "ComboBox") {
                var options = arr[i].options;
                for (var j in options) {
                    button.addControl(Button(options[j]));
                }
            }
            Buttons.push(button);
        }
        this._Buttons = Buttons;
    };
    Buttons.prototype.getButtons = function (id) {
        return this._Buttons;
    };
    Buttons.prototype.getButton = function (id) {
        return this._Buttons.getObjectByAttribute("id", id);
    };
    appNS.Button = Button;
    appNS.Buttons = Buttons;
})();

(function () {
    var appNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application");
    var Panel = function Panel(options) {
        var PanelConfig = new Glodon.Bimface.UI.Panel.PanelConfig();
        var css = Object.assign({}, PanelConfig.css, options.css);
        var config = Object.assign({}, PanelConfig, options);
        config.css = css;
        var Panel = new Glodon.Bimface.UI.Panel.Panel(config);
        return Panel;
    };

    appNS.Panel = Panel;
})();

(function () {
    var appNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application");
    var Tree = function Tree(id, name, filter, hasCheckbox, selection) {
        var TreeNodeConfig = new Glodon.Bimface.UI.Tree.TreeNodeConfig();
        TreeNodeConfig.hasCheckbox = hasCheckbox;
        TreeNodeConfig.isChecked = true;
        TreeNodeConfig.selection = selection;
        var TreeNode = new Glodon.Bimface.UI.Tree.TreeNode(TreeNodeConfig);
        TreeNode.element.setAttribute("data-filter", filter);
        TreeNode.setTitle("");
        TreeNode.setData(id, name);
        return TreeNode;
    };

    appNS.Tree = Tree;
})();

(function () {
    var appNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application");
    var viewNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Viewer");
    var utilityNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility");
    var DomNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Web.Lang.Utility.Dom");
    var WebApplication2D = function WebApplication2D(options) {
        var self = this;
        var viewConfig = options;
        var rootElement = DomNS.create('div', 'bf-container');
        var NavigationMode = Glodon.Bimface.Viewer.NavigationMode2D;
        var ViewerEvent = Glodon.Bimface.Viewer.Viewer2DEvent;
        options.domElement.appendChild(rootElement);
        viewConfig.domElement = rootElement;
        var viewer2D = new Glodon.Bimface.Viewer.Viewer2D(viewConfig);
        this.load = function (viewToken) {
            viewer2D.load(viewToken);
        };
        this.getViewer = function () {
            return viewer2D;
        };
        this.getToolbars = function () {
            return toolbars;
        };
        this.getToolbar = function (id) {
            return toolbars.getToolbar(id);
        };

        this._panels = {};
        var Toolbars = {
            MainToolbar: {
                id: "MainToolbar",
                title: "MainToolbar",
                element: rootElement,
                className: "bf-toolbar bf-toolbar-bottom"
            },
            LeftSubToolbar: {
                id: "LeftSubToolbar",
                title: "LeftSubToolbar",
                element: rootElement,
                className: "bf-toolbar bf-toolbar-select"
            }
        };
        var Buttons = {
            Home: {
                id: "Home",
                title: "适应屏幕",
                className: "bf-button gld-bf-home",
                handles: {
                    Click: function Click() {
                        viewer2D.home();
                    }
                }
            },
            RectZoom: {
                id: "RectZoom",
                title: "框选",
                type: "ToggleButton",
                className: "bf-button gld-bf-zoomrect",
                handles: {
                    Click: function Click() {
                        viewer2D.rectZoom(function () {
                            var RectButton = MainToolbarButtons.getButton("RectZoom");
                            RectButton.setCheckedState(false);
                            viewer2D.setNavigationMode(NavigationMode.Pan);
                        });
                    }
                }
            },
            Information: {
                id: "Information",
                title: "关于BIMFACE",
                className: "bf-button gld-bf-information",
                type: "ToggleButton",
                handles: {
                    Click: function Click() {
                        var eanble = this.hasClass("bf-checked");
                        if (eanble) {
                            if (!self._panels.InformationPanel) {
                                var InformationPanel = new Glodon.Bimface.Application.Panel(Panel.Information);
                                var imgSrc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANEAAAAfCAYAAAB52CgrAAAABGdBTUEAALGPC/xhBQAAFJlJREFUeAHlXAt8VcWZn5lzbyAQIIRAoSISEnyBVq1u17oqspqg5WeLq65WixV8oNQVpGopdqtWVizUoi1QFJDCyq9VKau7KyGAPBStRayPtVLzIKBSH0A0JCHJvWdm/9+5Z86dc+85ed5AKPPLZGa++WbmO+fMf75vvjPn8q/s3jDCbrJPZUaQ3KpiPD5MSB7RZNtSasSI/LLdHx4YyBrVWZrupIL9jSnZhymR46P3772lV4OKNDQ1nGfSbcFraoqKt5m0oHywbGrXgZHj3tP8A6pK/4HH+SBdTk1VlFXsLyjZmUrv6rJSiudVrb/UspUIG6tntnr1o+PHHQir13T01Qf50xDzNK2DaRztXuWc17a3PWSguZCNWI/2sr3t28KPMU4AXwGifx61pXGS5zPI96dkMT2Hceg6oog8vbZdlCaM1RhpaoqN54z/C2PqAt2cMzWfSTXZZs7Dc8jgmV5dsS9PgoaGYyEI2iQCV+w55E5VTCbBaIk5/Iu6wXWcC8XV6UypqQb/H/PKS5eeXtRj+WZ+ET3YwODIxtkVTLELNQNX4nHk76RyfnnpWZLxYYrLXynFBmsenXLODnEmLur/QelDB0aW/ARyK13XlWl+1dqT8ipLL2eKD8M9/EHgWJwtbGgSX0XdE4H1IOIe90IyB/EWxB6ImQi0AI1uT0eQoxD8OxD7Ib6O8nm4l3Z7+gjjRV80ka9HvBdxVBhfe+jo83bItyi1DehTQLsP8bjUug6WbfQ5TGCw+Yqp1QDl1rCOuMWnK8m+jRk4Blc8E9e9E+3QJiQQgKQagWlwFTTUjWiTzThf4OdWV71T0fT0GLXJ03b+ekjE2aMA739hvdiSWueUOeunbLWEWeIO8H6SygM571cxiYejZg0oL1vkPrBUtoyW88o3nCptthnAnyO5XIOL2JM2AACEe9KDFqq0OpcAWYci+zbiHYiZAhD1PgJ90yrcnjALzAQgCt9AvNLJdfIf5CCNQPNoBWJGAOSKdJKbOgk9d0Qag4CVKQBR3xZibgTLHfAAICk1DRMWtKRGIi4NIPCNwYSoIhpjcpZSYjYm7mq08zSSU+UCCPSrUV9GNOQnYYxlGGkBCp5GIh4AiQFI14VoJLr4X6LtdNwGdJTUSM5Yic4BJLaEW+ImbhsaibM/o8FeaKgJDhuTtw6oKI3cr9Qt93eROdK/cv1pTMY3YEzHvLQYXwSL+E6uYms8eV0AgWcy7nZLZscStCny2jH2LvIViJ3RpjG0fxr3k9I2Bdx/AvP1Kcw/Qvn3KbSOFJejkfN83MYNSN9C/NQtByWtXf9naDQ7peGdKH/PoH2E/JuIcYPWkez7aPTXhBZIAxKqYNNxkdBADoDShkgCyXuuBoBS2X1AYurrur4NQCIQmkDSTZOpUilA4vlCRO6RdhwPOnnPaeI+VrEuCiDdmGkgDdxVdkY8Fl+P0fK1YBjvRMHi52PxWIWL+C7uqaOBSA7NE5Tiemlilbh1jUgnYOKXBvEeBtoMjJGquc6AjOM6IxPaX45+rzbk/zXy96JPAlLGAsYR6Ow+o0PaDszAOJ0FkNclDZAIGkhk2in2CuORH5IJFwwg3YiAxHcirmGCzyMTDkKbN0YzOinqJmH1zcYFkFr1ArVpzbQDzy9d0+5lr6GZcYDkmnaCz5QyDjNIpW/ElZoIIK28SilSxRkJ+RXrvh6PyY3ozAOQ7him8jSmrFXQ4v9BJlxrAHLbjdftkc7rzGQ1+ml3Fvd8ABrdbDTcbORnGvmOZKcbjZbhGmGSZxZAbv/9kdJ1UChHnI5xMgYg6jTCo9Y0yuggbJsNLyx5ofqjlwbxJlmJh/8zXQcLcK+0xTLBlc9Gz+7R9zVpNfVuamjeDQEXa35LqP0S9gy2jtqedqr6WFlv1kbtch6TL2peSt/dE7sQCU1GJ0AT3sVEEufcthVke167s6K9+lTJpnq//DGZlcsLf7VfVDVwIV7SfaWmGz57eRSA9N6zndwgF5WX96hhVaN5VDyYOoYuSyUOwhpdzISaACB58oq42qd5UtJhRnmLkT/cWdqP9XYHfR3ptYi7EHsiXgCQnYvn/Rry7Qpol40G5xuNOgtIo6u0LI2lwzbIK3UhU2lExez5vs7gRKiuXD9+f1Ex2fEf++paLhxCdeikNZvuRwEeswKYNyOh6bw9Esp/QZW3wVRSPcpsO4kiy5pBsoHH2WPEGg6OAI8nP/ZgtTISnVyjdsMbyHapuL0GqQ/wWg5Re2jmxtp1swCk73YUSAMqN5xToyqvxKSYqGLp3kFnLM439eqd92RT/YErlC3PgGb6vpYBnkXaEz2ty0aaZeTrjfxhy+KaCDwEIh0exgT8BPSnQLjNJdLkJ7OsvYG8ktoSqEa/tI/pqoB1ywtt3gt6LdqQSU5QMGsnglLygja07RQLvM034OoCvHbB3XIAiEn7WwDNmCAOAhCzopNZPP4Yl/bgmqKStYyLCQBmUxA/0TAhrt5YsW5VR0w7AhBMxjLIkxvWP7T4puze+eP3fvXsBrj/bwOADsIkXR7K370qyK2uzWHaQL/gijcPqe3mx+MeeoueS2tL0stg0oaFQTq6sh6INIBa3gNl9uLwAJw9EiZbivvbP44HIMXG+msSJRNAmKi0yjmhq4CkAYR71SYAaXmQ3nE0AAnPhTThXYbcj0BbwGeChTbhoX3GraNVnjx1x3RwQHQkAKTveitAUh0FkO4/00BqI4A2aw2k5TDSowFI10Peoa7Me5CuMuSnLL0A1uEaPMMTdOFYTMWRBJC+4RpIOF3g00hwLPzQMeFCNBDWRc+EMzWQ7lenmQJSOwD0LTLh9PgBqQMkuL6XB9QdURKeBS2s9xhC/ALax7eXQPkd1GunEL0mudvgP+ayES6yXmPCMXGf11dv25JuUmDAcZ1RVkT43hv0ZtGdYO5Zz2LDzUY8bh2UQllcSNMGZiqnV2Xsy/pH0M9ak59Jvt0sk2wKssFm+G9Nt6V6V+f3FZXsyKvaUMCi1lxz99hs9yYb3hcISP0r1uH9C04RhDgbMIFoj8SCnA2dBRCcjAukiDxrCgWvnZ6IJvlI53GP2EmuEOQ9XBIi0MOgX+bWTcK9ewDg+jyE9++aHGF280mYVJNxE0brK7VwggH5EE+bKo3HbK3qyUj+dR1rXC+taBazJfUzTvcD73EZk6wvThT8Y5LGV/PaQ6uwfGFfbp+JfcVEp47zL4QQl2g+J1XxE5VtT4J8p2m6xZyzcxupTIB29rhx+QDev/TVPFn8YCXyFbqsUx+QNDElDQJSZwFEQ0jJpio7/k09HBwMfxCW/SHKuzWtm6TmHudxACNQo4L+Cu7VNsh8HiK5kachzkI85kIED3cJVsmbgIa7TSC16U4AQNAAvSQdqbBjpyohVpIX3gSS2Q9uPI4J8Z04GkPqvxbl9xXjK5C/3AKA9hUWv2HyS9t+UkTErTIuZ5hA0jyCs0Gom88iYjKO/Cw1gaR5UlMNJLy7OtnzMaUwmUB6qWrjWeSFa9GJoOCFy8m/qRUTzhuFAIR3Rn9hNiezabVXEZy5F/J8FlzVbiqZajtw3xcFtcQ4F4N+tltXh5ROEbQUSBv9j8twO9rPQd8HW2pwhOvOh4xPZFAGsnjmQyGoKF6Ith9ILoAgFM7FOae4oRTkw8oSM4OA5AEI5+4w8B/pQuAevhP7nsfwwuCczwuL0zQHWKIypp4UUXFzGJDgMjqOdwBIo9R7Gz+u3IOXUI4nisRJCYqtr15/muDyDLyfm002ZVAQFts+enjPbZv52fGg+lSaBhBOg9yHLv+UWh9Q/nYArTOka/HMluB5+PY5bofmS8/F4KlpZSAyR8m8JkuBPJX0/ujniN01nAzBKGYyvAgQUfADKUFr4b8BoDQuA0jol1Y+cosmNFACQL4mBCR8X0Q0MgcCAmSLMRNIaTypQEpjCCC8x0c1968srYSp+QdUmy83E9wwL62I3Koa2VBoz38P6AIkvtXK4YtCDs+mNTEBlFZ5+AhknqUBHsA6B/SxrhjNSB9186EJniuaqTlg0C+Mp6H8GOih7+ZCOzt6Kw65IKIrSAIJk8ag+69OwYOGs6kjcbMm+WuMUhJIjUBQBKsuVilHAxlMySwBKa+ilB0oGtcqkFScBcpmAglmUm2y9/BcTeG4/wWQrmC2SgcSVz9SjXwpi/L5vJnB7FSn+HviW7P68ss+HVxS76eHlDjAylUuaaAQjjDyQ6igPV4mAjmE6KM83K60YGqhFeDZm8qhVuScwifWpTptfg8+krEAcQji9xEXI3bHsAVCLc+gYO/jPu2JWBG4kY2gJM8tKCpedMCgmVmYbk9Db1yExiSQE/Ch3G7Ycv2U4KTSEwEbFJ6bs6ZnY130UBMbj1X7Bl2F4y6f41O9PjDjyjSN0n6fbCn4cvCFuzTNEtbdjEsMlwgSpwMKikoWatniIloVETGf/LZkkX0jiz3ZdNuwNBBIOGkAk3QQgDOaNcM8sayJ2Me9gH2Zo1lJA7ULQBic94j+jsdi16AHT944E23Z67yIe/1amPyZoGNBJBPnO25f2NWmm2RqRf9hsVjsd6j7msvnJJCNPkybh8ICl057azIXHZevydsN8h9AruWZliNix50bkOzX4nN2V677JxA2JYnJ3IGiEvIorUhS2pRL488rX7vOVqw42ZpvFQfrP0DZA5Et7bnJiYuJKMTc6sqy88HzErWLyNgIuLzpAerQLLiYTN/11BRe4rnCdWVYagIJi4TNIuoRaLznMTaCysMxoolYEhYi/4OOAIh6kQ3217hg/4wJdimVKQgmaU+00ikc2X/3Yni9WK3GRCtPFac53jwFtNNjy3IujE6qS12klqHup4iDEAsRr0IkwB0TwV1Z3Wt1vweSqkOHCjtxw/hWrPqr8bKVvD2BgQAEP/HxzucZgRwMALLgYpezLCmHB7OEUwlIzOJXYC79GDuGnwBAPTQ3Jj4+MOT4PIT9Z3s1kO4D78pmQZG9gn7Walp3SHFtx0OO6wxZ5hh5J6ueGZWF/dxNVICamppaj2tqBG2+QSdQHjMhCaIWPqjr2rvhAsh5N+V8b582nAcgxq5Jq0wQPAABjCeH8LRKJiDxCD5+4/wN8hqaEY2Prxl56ffavAcKGk3Zs7shkGZAVNorUSgDIN5MZJP/mxuq8f5ZDSQKXAkT1Mp82vukBmhqHAJOBPpoz9O4qYx/b+WIc0HdAUDwZngGhXGXDxeA9JDuLwOFODg0VydSAhK3ZjmftSjvY7FOdNjxppjoA9Da0TBuL2laiOjc5lOxODks+B+JxxtvQeEBh+D+A/i+RH+LUNRaiF7adiuta8qbybzAj3w4PyqCG3B1JjturS/8CFDChCMNRAAKDOLnjgkXooHgoGjSJlxnNFDg0F1JdDUSNN6LXTlMG/r+N/D0dvleBxA2pbZp/m3umbi355p0OHhuUZvGJBZgsyJh0pFpR4E+2vtmIpv2n1zoOujxdfmoSyPY/zwXEexiqAFPjcOLvCPsSoZ+WJonrR5JMxCMJw5hX1RXs0hzD//vhTXWZzf3jRwSoPtueP8hg2p3fVjzVHZz3fXQPjP1nhZOjk/McWVUPRux+SVA2FuaDrh5csLJ8eqAirKvYMO+3FRjPAunIrpZwMmQ38AT+kJSLCwBVq+nkuXDm8MEz8GIcJR4IVgLsXguvK4/87h0Ztc7ZNKRk8kLACF9tLcchCkukbTR5W7eTP5mFOh1SQ7a1hm0rsr65m2mBolYgo/Az05NxYXQBtMJFo/TJnGDW/QlDY3qbaUah2oiLn71W7v448IW2fgg7iF4ts9O1jWW1cZxdi6WPDsHwGytr/r4wZ7SvgcA9rxzAMr23KyexV/oxkgtyUdg1bsdmmqYJgMsjyO/nsoDK0qLpJI54HkQxSyiUeCNOFKT+J7eKXeHfzhaNUXavpX5FckaaLEyJ9ThFJVMsjx3wPeRegeQTSGiN9SRdkrTUCZPSn4uyjcjWoj00d5ozJH/M3lQrgX9z6CdiUgTm/ZlPvMQ5UyFJqOj0418xrL4MRq5DCYd/fqJb1VpywgEIFhiO4UtcbQ/Plco8SRcxG+Et004EeA9861sBKC+0Z7F1QUXmRiiY0RLIxaO2Qf9dhsGUdjsA7QzBXc8R6aJEC5Ct6jhL+Msx7OWVL77cLhEwwSmBecuYzzvozuD1qEs5kQVGj7jNsaj9fZIqf0tNgj4wRtFoO6KcACdahPznK4YJwJ7Nwdnz5bhEOckHOL8BQbxNFJLV6QB5J5EeA53y7K5XGQpcRt+tBDKI6mREv34vHCv675DAQQGgCTHjrOlkQibHLc53hklNZJuD/lPwY97OUCSeMkHuqeRNE/3SglA6jmuaC/Ith8h2f4V4x7njr0H6aoMy0Gm4bVun/TR3lTMl9qUMZaifCPiNxDJO7gYfGRevorYGe1ML7Dp14McDYQ0jn7pRTBpOwo0zpVI6R1djAidCHRi4Rlnr5IKpNY6RcPgs3Dw3zpA4nwKYGR0YwDI8MK1BCDdmGSz49wAkq5JpgFASlZ2q5wJIHKm4O/IBDK3dEj76E5XdDTF/HgHE5WcJpch0hyjA6rbEL3gTu7vgLAOUZtZxEexs2EwOvip0cl9yJOT41yXdglSip0OuM4d3kaLJqs27fBwaXUKDmEA0twEJKV+AxPrCeBlO25WoBeO6gJNON2PkSaABI1Epp1QgbIRkLRpJ5nsdqYd4GJooDBvpHHRXZvV94dWfNLeXRFmo1O9ktpBA2BukCPpPMR5iIeCeDpIwzvhZMA4ZM5djLgIMZ6syUhO8QHlpT/2dYXvQcYWFi8M+xmpIVUbT2i2Y9f52wg6oDkQL+LyNR1XYVu5OQuds3ON6lYAM7nscv7x/qKS32resHRA+dqZ/naqbmzhuAVatjBZ3J/7Cuv2iNDJq3ko7T6ovfuLLl2eKhBWN/r8YYhLX4NJ8GkqT2fK6D8H7U9BrETftGfokoBxCtBxP8S3MY4GVOBY4CVX91hEakPydTTQvVqJ8fRC4evHvfbhIPZB9JSIj6nthX0Y56//Dy5GPw14sZShAAAAAElFTkSuQmCC";
                                var html = "<div class=\"bf-info\"><img src=\"" + imgSrc + "\" /><p>Powered by BIMFACE</p><a target=\"_blank\" href=\"https://bimface.com\">https://bimface.com</a></div>";
                                InformationPanel.setHtml(html);
                                self._panels.InformationPanel = InformationPanel;
                                InformationPanel.addEventListener('Hide', function () {
                                    MainToolbarButtons.getButton("Information").setCheckedState(false);
                                });
                            } else {
                                self._panels.InformationPanel.show();
                            }
                        } else {
                            self._panels.InformationPanel.hide();
                        }
                    }
                }
            },
            FullScreen: {
                id: "FullScreen",
                title: "全屏",
                className: "bf-button gld-bf-maximize",
                handles: {
                    Click: function Click() {
                        var enable = this.hasClass("gld-bf-maximize");
                        viewer2D.enableFullScreen(enable);
                        Glodon.Web.Lang.Utility.FullScreen.onFullScreenChanged(function () {
                            var FullScreenButton = MainToolbar.getControl("FullScreen");
                            var title = FullScreenButton.getTitle();
                            FullScreenButton.toggleClassName("gld-bf-maximize");
                            FullScreenButton.toggleClassName("gld-bf-minimize");
                            if (enable) {
                                FullScreenButton.setTitle("全屏");
                            } else {
                                FullScreenButton.setTitle("取消全屏");
                            }
                        });
                    }
                }
            }
        };
        var Panel = {
            Information: {
                element: rootElement,
                title: "BIMFACE",
                css: {
                    left: "50%",
                    top: "50%",
                    width: "330px",
                    height: "278px",
                    transform: "translate(-50%,-50%)",
                    zIndex: 999
                },
                enableSizable: false
            }
        };
        if (!options.Toolbars || options.Toolbars.length == 0) {
            return false;
        }
        var userToolbars = [];
        for (var i = 0, len = options.Toolbars.length; i < len; i++) {
            userToolbars.push(Toolbars[options.Toolbars[i]]);
        }
        var toolbars = new Glodon.Bimface.Application.Toolbars(userToolbars);

        var MainToolbar = toolbars.getToolbar('MainToolbar');
        if (MainToolbar) {
            var usetButtons = [];
            for (var i = 0, len = options.Buttons.length; i < len; i++) {
                usetButtons.push(Buttons[options.Buttons[i]]);
            }
            var MainToolbarButtons = new Glodon.Bimface.Application.Buttons(usetButtons);
            MainToolbar.addControls(MainToolbarButtons.getButtons());
        }
        var LeftSubToolbar = toolbars.getToolbar('LeftSubToolbar');
        if (LeftSubToolbar) {
            viewer2D.addEventListener(ViewerEvent.Loaded, function (viewer) {
                var viewList = viewer.getViews();
                var viewsButton = {
                    type: "ComboBox",
                    id: "Views",
                    inheritTitle: true,
                    options: {},
                    handles: {
                        Change: function Change(arg) {
                            viewer2D.showViewById(arg.id);
                        }
                    }
                };
                for (var i = 0, len = viewList.length; i < len; i++) {
                    var item = viewList[i];
                    viewsButton.options[item.name] = {
                        type: "ComboBoxOptionButton",
                        title: item.name,
                        id: item.id,
                        className: "bf-button",
                        html: "<span class=\"bf-button-name\">" + item.name + "</span>"
                    };
                }
                var viewsButton = new Glodon.Bimface.Application.Buttons([viewsButton]);
                var button = viewsButton.getButtons()[0];
                viewer2D.addEventListener(ViewerEvent.ViewChanged, function (id) {
                    button.setSelectedControlById(id);
                });
                LeftSubToolbar.addControls(viewsButton.getButtons());
            });
        }
    };
    appNS.WebApplication2D = WebApplication2D;
})();

(function () {
    var appNS = Glodon.Web.Lang.Utility.Namespace.ensureNamespace(Glodon, "Bimface.Application");
    var WebApplicationDemo = function WebApplicationDemo(viewMetaData, domElement) {
        var app;
        if (viewMetaData.viewType == "dwgView") {
            var WebAppConfig = new Glodon.Bimface.Application.WebApplication2DConfig();
            WebAppConfig.domElement = domElement;
            var appEvents = Glodon.Bimface.Application.ApplicationEvent;
            app = new Glodon.Bimface.Application.WebApplication2D(WebAppConfig);
            app.load(viewMetaData.viewToken);
        } else if (viewMetaData.viewType == "rfaView") {
            var WebAppConfig = new Glodon.Bimface.Application.WebApplicationRfaConfig();
            WebAppConfig.domElement = domElement;
            var appEvents = Glodon.Bimface.Application.WebApplicationRfaEvent;
            app = new Glodon.Bimface.Application.WebApplicationRfa(WebAppConfig);
            app.addView(viewMetaData.viewToken);
            app.addEventListener(appEvents.ViewAdded, function () {
                app.render();
            });
        } else {
            var WebAppConfig = new Glodon.Bimface.Application.WebApplication3DConfig();
            WebAppConfig.domElement = domElement;
            var appEvents = Glodon.Bimface.Application.WebApplication3DEvent;
            app = new Glodon.Bimface.Application.WebApplication3D(WebAppConfig);
            app.addView(viewMetaData.viewToken);
            app.addEventListener(appEvents.ViewAdded, function () {
                app.render();
            });
        }
        this._application = app;
    };
    WebApplicationDemo.prototype = {
        hideBimfaceInfo: function hideBimfaceInfo() {
            var mainToolbar = this._application.getToolbar("MainToolbar"),
                bimfaceInfo = mainToolbar.getControl("Information");
            bimfaceInfo.hide();
        }
    };

    appNS.WebApplicationDemo = WebApplicationDemo;
})();

window.Glodon = Glodon;